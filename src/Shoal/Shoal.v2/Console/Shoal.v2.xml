<?xml version="1.0"?>
<doc>
<assembly>
<name>
Shoal.v2
</name>
</assembly>
<members>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Config.InitDir">
 <summary>
 应用程序启动的时候的初始工作目录，默认为应用程序所在的文件夹
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Config.SPMRegistry">
 <summary>
 脚本引擎的类型注册表的文件位置，为空的话会使用默认的文件位置
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Config.GetRegistryFile">
 <summary>
 Get shoal shell registry file path.(获取注册表的文件路径)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.DocRenderer">
 <summary>
 命名空间的html帮助页面的生成工具
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.DocRenderer.RequestHtml(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace)">
 <summary>
 值返回路径
 </summary>
 <param name="[Namespace]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.IWikiHandle">
 <summary>
 Internal wiki system queriable object.(这个对象是可以接受wiki查询操作的)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.IWikiHandle.Match(System.String)">
 <summary>
 模糊匹配并返回匹配结果，当返回空字符串的时候，则说明没有被匹配上
 </summary>
 <param name="keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter.ParseFile(System.String)">
 <summary>
 
 </summary>
 <param name="File">文件路径</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls">
 <summary>
 所输入的参数是可能没有顺序的，但是函数的参数定义是有顺序的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderReferenceAlignment(System.Reflection.ParameterInfo[],System.Object[])">
 <summary>
 一一对应比较
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
 <remarks>一一对应比较和参数名无关</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.__boolsEquals(System.Reflection.ParameterInfo,System.Object)">
 <summary>
 处理逻辑开关标记的
 </summary>
 <param name="FuncDef"></param>
 <param name="inputParam"></param>
 <returns>函数不会计算拓展函数的调用参数</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OverloadsAlignment(System.Reflection.MethodInfo,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
 <summary>
 使用这个函数来进行判断
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OverloadsAlignment(System.Reflection.MethodInfo,System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.MultipleAlignment(System.Reflection.ParameterInfo[],System.Collections.Generic.Dictionary{System.String,System.Object}@)">
 <summary>
 
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderAlignment(System.Reflection.ParameterInfo[],System.Collections.Generic.Dictionary{System.String,System.Object}@)">
 <summary>
 输入的参数里面是没有任何的特殊的名称的，会使用字典查询，不会像<see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderReferenceAlignment(System.Reflection.ParameterInfo[],System.Object[])"/>
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals">
 <summary>
 这个模块只是用来判断函数如何重载的，数据类型的转换有系统自动完成
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.TypeEquals(System.Type,System.Type)">
 <summary>
 判断两种类型是否相等
 </summary>
 <param name="FuncDef">当前的这个重载方法的参数定义的类型</param>
 <param name="InputParam">从脚本传递进来的函数参数的类型</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.IsInheritsFrom(System.Type,System.Type)">
 <summary>
 Is a inherits from b
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="b">基本类型</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.IsInterfaceInheritsFrom(System.Type,System.Type)">
 <summary>
 Is a inherits from b
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="b">基本类型</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint">
 <summary>
 命令执行的入口点，使用这个对象进行函数重载的处理
 </summary>
 <remarks>
 重载函数的签名冲突的条件：
 1. 具有完全一样的参数列表，即参数名和参数类型完全一致，参数的顺序对签名冲突没有影响
 2. 除了满足上面的条件，两个函数之间的返回值完全一样的时候，即可认为两个函数的签名完全一样
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint._OverloadAPIEntryPoints">
 <summary>
 Shoal脚本命令的函数重载
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.Name">
 <summary>
 Shoal API命令的名称
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.IsOverloaded">
 <summary>
 当前的这个执行入口点是否有重载的命令
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.#ctor(System.String,System.Reflection.MethodInfo)">
 <summary>
 共享方法
 </summary>
 <param name="Name"></param>
 <param name="InitMethod">如果不知道该怎么处理这个参数，请使用Nothing</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.#ctor(System.String,Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.CommandEntryPointInfo)">
 <summary>
 共享方法和实例方法
 </summary>
 <param name="Name"></param>
 <param name="InitEntryPoint">如果不知道该怎么处理这个参数，请使用Nothing</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.OverloadsAPIEntryPoint(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.CommandEntryPointInfo)">
 <summary>
 向当前的执行入口点添加一个重载函数，当当前的执行入口点之中具备有两个完全相同的函数签名的入口点的时候，新的入口点会替换掉旧的入口点
 </summary>
 <param name="EntryPoint"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.__getTypeSignatureHandles(System.Reflection.MethodInfo)">
 <summary>
 获取用于支持函授重载所需要的数字签名信息
 </summary>
 <param name="EntryInfo"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.OverloadsEntryPointNumbers">
 <summary>
 当前的这个执行入口点之中的重载的函数的反射入口点的数目
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint">
 <summary>
 用于表示一个已经被签名的函数
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint._InternalParameterSignature">
 <summary>
 参数列表按照从小到大排序之后计算MD5哈希值作为参数列表的数字签名
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.TypeSignature">
 <summary>
 返回值的数字签名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.FakeSingleParameter">
 <summary>
 当参数有多个的时候，出了第一个之外，其他的参数都是可选的或者类型为逻辑值，则该函数被定义为伪单参数函数
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.ParameterSignature">
 <summary>
 参数列表按照从小到大排序之后计算MD5哈希值作为参数列表的数字签名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint._InternalNonOptionalCounts">
 <summary>
 非可选参数的数目
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.CreateObject(System.Reflection.MethodInfo,Microsoft.VisualBasic.Scripting.EntryPointMetaData.OverloadsSignatureHandle[])">
 <summary>
 创建共享方法的签名实例
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.Equals(System.Object)">
 <summary>
 判断两个函数入口点对象是否具有完全一样的数字签名
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.Linker.GetAddress(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable)">
 <summary>
 得到内存之中的实际引用位置
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.CollectionOpr">
 <summary>
 Dim array &lt;= {expression} as type 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.DynamicsCast">
 <summary>
 var &lt; (typeID) {expression}
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.DynamicsCast.TypeID">
 <summary>
 去掉了外层的括号了的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.FileIO.Value">
 <summary>
 左端的将要写入文件的表达式
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.OutDeviceRef">
 <summary>
 解析出来的表达式之中只含有一个词元，并且不是注释，则默认认为是变量查看操作，值默认赋值给系统变量$
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression">
 <summary>
 在解释器阶段由于缺少信息还无法判断表达式的类型，则这些语句都被设定为动态的类型
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Die">
 <summary>
 Throw Exception
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Die.When">
 <summary>
 Boolean Expression
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Comments.CommentFLAGLen(System.String)">
 <summary>
 -1表示不是注释
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.GOTO">
 <summary>
 Goto语句
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.GOTO.ExprWhen">
 <summary>
 When后面的逻辑条件表达式
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.LineLabel">
 <summary>
 Goto的标签
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.HybridScript.HybridsScript.ExternalScript">
 <summary>
 计算得到脚本值，再由引擎计算值之后赋值给本脚本之中的变量
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.OnErrorResumeNext">
 <summary>
 On Error Resume Next.(脚本程序在遇到错误之后忽略掉错误尝试继续执行下去)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Imports">
 <summary>
 Imports Namespace1, Namespace2, Namespace3
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Imports.Namespaces">
 <summary>
 字符串常量或者内部表达式
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.SyntaxError.IsBlankLineSyntax">
 <summary>
 对于空白行，是无法被解析出来的，但是空白行不是语法错误
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Include">
 <summary>
 Include file1, file2, file3, file4, ...
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Include.ExternalScripts">
 <summary>
 The file path list of the external script
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Library">
 <summary>
 Dynamics install a external module in the runtime.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.VariableDeclaration.Name">
 <summary>
 The name of the variable.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.VariableDeclaration.Type">
 <summary>
 变量的类型约束
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.ExprTypeID">
 <summary>
 表达式的类型编号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.LineNumber">
 <summary>
 本句代码在脚本之中的原始的行数
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.Comments">
 <summary>
 语句后面所出现的注释信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.PrimaryExpression">
 <summary>
 原始的表达式字符串
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.SyntaxError">
 <summary>
 语法错误
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.BlankLine">
 <summary>
 空白行
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.Comments">
 <summary>
 注释行
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.DynamicsExpression">
 <summary>
 在解释器阶段由于缺少类型信息无法判断目标类型，所以被设置为动态类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.FunctionCalls">
 <summary>
 函数调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.OutDeviceRef">
 <summary>
 单独执行输出设备的调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.FileIO">
 <summary>
 >
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.DynamicsCast">
 <summary>
 &lt;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.HybridsScript">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.HybirdsScriptPush">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.GoTo">
 <summary>
 Goto跳转语句
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.LineLable">
 <summary>
 Goto的跳转的行标
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.OnErrorResumeNext">
 <summary>
 On Error Resume Next语句
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls">
 <summary>
 只是调用方法，函数的返回值直接返回给系统变量$
 方法返回Nothing
 函数返回函数值
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.EntryPoint">
 <summary>
 对于<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.PrimaryExpression"/>类型而言，其不仅仅调用一个方法，而且还将方法的返回值赋值给一个指定的左端变量，
 由于变量之间赋值传递的情况也可能存在，故而这个属性也可能是引用一个内存地址，当找不到方法的时候，就会通过这个参数来查找内存变量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.Parameters">
 <summary>
 解析得到的顺序应该和原始的脚本语句是一致的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.IsVariable">
 <summary>
 只有左端引用表达式不为空，其他的元素都为空
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel">
 <summary>
 只有解析出来的词元模型，，没有包含有函数指针的句柄信息，还不能够直接运行
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.GotoJumpsLabel">
 <summary>
 Value是指向<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.Expressions"/>列表之中的元素的位置下表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.ScriptParser(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="ScriptText"></param>
 <param name="File">脚本文件的文件路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.ThrowSyntaxException(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.SyntaxError[],System.String)">
 <summary>
 at Shoal.Testing.Debugger.Main() in G:\Shoal\Shoal.Testing\Debugger.vb:line 21
 </summary>
 <param name="Tokens"></param>
 <param name="File"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.FullTokenliser">
 <summary>
 将表达式之中的所有词元进行完全展开
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.FullTokenliser.#ctor(System.String)">
 <summary>
 将表达式解析为词元，每一个词元都不含有前导或者后置的空白符号
 断词元的条件是Stack必须为空
 </summary>
 <param name="Expression"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.Tokenliser">
 <summary>
 保留有内部表达式，只展开一级表达式
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.Tokenliser.IsCommentLine">
 <summary>
 当前的整行代码是否为注释行
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.Tokenliser.IsBlank">
 <summary>
 空白行
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.Tokenliser.#ctor(System.String)">
 <summary>
 将表达式解析为词元，每一个词元都不含有前导或者后置的空白符号
 断词元的条件是Stack必须为空
 </summary>
 <param name="Expression">在调用之前请先试用Trim函数进行处理</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName">
 <summary>
 开关参数：只适用于逻辑值参数，有表示True，没有则表示False，开关参数使用-或者--或者\或者/开头
 例如有如下的函数定义
 Function(a As Object, b as Boolean) 
 则调用的时候可以有下面的形式
 Function a $a b T/F/True/False/1/0/yesy/no
 或者开关形式
 Function a $a -b 或者 --b 或者 /b 或者 \b
 当然也可以
 Call $a -> Function True/False/yes/No/1/0/T/F
 Call $a -> Function /a 或者 \a 或者 -a 或者 --a
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType">
 <summary>
 参数名出了普通类型的参数名需要填充参数名之外，其他类型的参数名都可以留空
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.ExtensionMethodCaller">
 <summary>
 拓展函数的调用参数，即函数定义之中的第一个参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.EXtensionSingleParameter">
 <summary>
 当函数有两个参数的时候，使用拓展函数的形式调用，则第二个参数会可以看作为伪单参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.SingleParameter">
 <summary>
 函数只有一个参数，则可以忽略参数名直接调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.BooleanSwitch">
 <summary>
 逻辑值类型的开关参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.OrderReference">
 <summary>
 函数的参数之间是按照函数的定义顺序引用的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.#ctor(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType,System.String)">
 <summary>
 
 </summary>
 <param name="Type">普通类型还是特殊类型</param>
 <param name="Expression">获得参数名称的一个表达式字符串</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable">
 <summary>
 可能会存在指针引用的情况，这个对象类型的主要实现的功能是设置内存变量
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.RefEntry">
 <summary>
 该变量在内存之中的引用地址
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.IsInnerReference">
 <summary>
 是内部表达式 <see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="Ref">
 1. Name 普通变量引用
 2. $var 变量地址引用 -> 值是实际的地址
 3. {expr} 内部表达式引用 -> 值是实际的地址
 4. [int] 位置引用
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.InternalGetPointer(System.Object)">
 <summary>
 会判断是否为有效的指针
 </summary>
 <param name="Ref"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator">
 <summary>
 该表达式之中的操作符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.ValueAssign">
 <summary>
 &lt;- Assign value to variable;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.ExtCall">
 <summary>
 -> Extension method calling;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.CollectionOpr">
 <summary>
 &lt;= Collection and hash table operations;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.SelfCast">
 <summary>
 = Self type cast;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybridsScript">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybirdsScriptPush">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.Delegate">
 <summary>
 => 函数指针
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.DynamicsCast">
 <summary>
 &lt;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.IODevice">
 <summary>
 >
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="opr">
 [&lt;- Assign value to variable;]
 
 
 [-> Extension method calling;]
 
 
 [&lt;= Collection and hash table operations;]
 
 
 [= Self type cast;]
 
 
 [&lt;&lt; Hybrids scripting;]
 
 
 [>> Setup variable of hybrids scripting;]
 
 </param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.EntryPoint">
 <summary>
 包含有函数句柄以及调用的接口的描述信息
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression">
 <summary>
 这个是参数引用之中的内部表达式，只有单行的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token">
 <summary>
 一个表达式对象之中的某一个单词元素
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.OprTag">
 <summary>
 产生<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.DepthLevel"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.GetTokenValue">
 <summary>
 获取得到原始的词元数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.GetTrimExpr">
 <summary>
 假若是内部表达式的话，则可以使用这个方法来修建掉两边的括号
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser">
 <summary>
 语法解析器
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.Parsing(System.String)">
 <summary>
 从这里开始解析表达式
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseCollectionOpr(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.CollectionOpr"/>
 </summary>
 <param name="Expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Compiler.CodeDOM.Expression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHybridsScript(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybridsScript"/>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHybirdsScriptPush(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybirdsScriptPush"/>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseDieException(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 单独的抛出错误的语句
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHashTable(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 var = $args => --ssl
 或者
 $args => /name
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseInclude(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 Include file1, file2, file3
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseGoto(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 Goto Label When BooleanExpression
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseDynamicsCast(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 var &lt; (typeID) {expression}
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseOutputHandle(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 开头的第一个字符必须是$或者&amp;
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseImports(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseFunctionCalls(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.__createParameters(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[],System.Int32)">
 <summary>
 
 </summary>
 <param name="Tokens"></param>
 <param name="Index">
 3:  没有进行拓展方法的调用的
 5:  进行了拓展方法的调用的
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension">
 <summary>
 内部的一些简单的常用命令
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.gpl">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.license">
<summary>
  Looks up a localized string similar to This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.sdk_doc">
<summary>
  Looks up a localized string similar to &lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot;&gt;

	&lt;head&gt;
		
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;%Namespace%&lt;/title&gt;
		
		&lt;style&gt;::-moz-selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      ::selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      html {
        padding: 30px 10px;
        font-size: 16px;
        line-height: 1.4;
        color: #737373;
        background: #f0f0f0;
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
      }

  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DynamicsCast">
 <summary>
 字典之中的Key属性分别为所需要转换的目标类型的简称和输入的第一个参数的类型,目标方法只能够有一个参数
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DynamicsCast.TypeCastDynamics(System.Object,System.String)">
 <summary>
 
 </summary>
 <param name="obj">目标函数的第一个参数，本方法会根据这个参数以及<paramref name="typeId"></paramref>参数查找最合适的句柄来处理本参数的输入</param>
 <param name="typeId">类型标记信息的简写</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.OutputDeviceHandle">
 <summary>
 将目标变量在终端进行输出
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.InputDeviceHandle">
 <summary>
 <see cref="P:System.Attribute.TypeId"></see>参数指的是目标函数所返回的值的类型，驱动程序会自动根据函数的参数的类型来决定函数方法的调用
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.InputDeviceHandle.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="TypeId">
 The brief name of the type information, usage syntax of this input type casting driver in the shoal scripting is:  var &lt; (TypeId) $variable
 (类型简称，在脚本之中的使用语法为：  var &lt; (TypeId) $variable)
 </param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.IO_DeviceHandle">
 <summary>
 Target delegate must compatible with delegate Func(Of T, String, Boolean), the first parameter in the delegate is the 
 data type and the data to write to the file, the second parameter is the file path of the IO operation and the last bool 
 return value indicated that the io operation success or not. please notices that, for the considerations of the data 
 type compatible, the collection data type is recommended implement as generic enumeration interface.
 (目标接口委托对象必须要符合以下接口类型Func(Of T, String, Boolean)，其中第一个将要写文件的数据类型，第二个参数为
 文件路径，最后一个参数是文件是否写入成功，请注意，对于任意的集合类型推荐使用<see cref="T:System.Collections.Generic.IEnumerable`1"></see>泛型集合)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.IO_DeviceHandle.#ctor(System.Type)">
 <summary>
 
 </summary>
 <param name="DataType">目标数据类型，脚本引擎会自动根据函数的数据类型自动选择文件系统的写入方式的驱动程序</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.IODeviceDriver.ImportsHandler(System.Type)">
 <summary>
 返回成功导入的IO方法
 </summary>
 <param name="Module"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.IODeviceDriver.WriteData(System.Object,System.String)">
 <summary>
 This function will trying to save the data in a properly method from the data type:
 Function will trying save the string as a text file;
 Basic data type collection will be save as a csv data table;
 All of the other data type will be saved based on the registry data;
 If the method is not found in the registry for the data type, then function will throw a method missing exception!
 (函数会尝试根据文件的类型来选择合适的保存格式:
 字符串类型会保存为文本文件
 数组会保存为Csv
 其他的复杂类型会尝试根据注册的句柄来执行相应的数据保存操作)
 </summary>
 <param name="value"></param>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.OutputDeviceDriver">
 <summary>
 Output support module for that data type.(各种数据类型的输出模块)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.OutputDeviceDriver.HandleOutput(System.String)">
 <summary>
 
 </summary>
 <param name="variable">Variable Name.(变量名)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Strings">
 <summary>
 字符串服务
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Strings.Format(System.String)">
 <summary>
 常量是区分大小写的
 </summary>
 <param name="Expr"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice">
 <summary>
 Memory Management Unit Device.(大小写不敏感的，直接使用即可)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.MMU_CHUNKS">
 <summary>
 内存设备
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.MTRR">
 <summary>
 寄存器
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.SystemReserved">
 <summary>
 内存之中的地址总是 0
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.__importsConstantsInit">
 <summary>
 导入系统初始的默认常量
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.__addInternal(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable)">
 <summary>
 
 </summary>
 <param name="keyFind">必须为小写的</param>
 <param name="var"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.ImportConstant(System.String,System.Object,System.String)">
 <summary>
 常量是大小写敏感的，但是变量大小写不敏感
 </summary>
 <param name="Name">不需要加前导符号</param>
 <param name="value"></param>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.Item(System.String)">
 <summary>
 请不要删除前面的前导符号
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.AddrHwnd">
 <summary>
 内存之中的位置指针，使用 *p 来表示
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.#ctor(System.String,System.String,System.Object,System.Boolean)">
 <summary>
 
 </summary>
 <param name="Name"></param>
 <param name="Type"></param>
 <param name="[ReadOnly]">是否为常量</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.SCOM.RuntimeComponent">
 <summary>
 This type of the class object consist of the shoal shell scripting engine.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.SCOM.RuntimeComponent.ScriptEngine">
 <summary>
 Script engine.(脚本引擎)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.FSMMachine">
 <summary>
 执行整个脚本的模块
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.Strings">
 <summary>
 字符串服务
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel">
 <summary>
 执行依据脚本语句
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.DynamicsExpression(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 在解释器阶段由于缺少类型信息无法判断目标类型，所以被设置为动态类型
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.__fillBool(System.Reflection.ParameterInfo[])">
 <summary>
 逻辑值默认为False
 </summary>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.FunctionCalls(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 函数调用
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.OutDeviceRef(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 单独执行输出设备的调用，在终端输出或者打开绘图窗口
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.HybridsScript(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.HybirdsScriptPush(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.FileIO(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 > 操作符将数据写入文件
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.GoTo(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 Goto跳转语句
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly">
 <summary>
 用于引用的程序的定位的，用来处理相对路径以及网络路径
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly.TypeId">
 <summary>
 这个属性使用于记录重复的命名空间模块之间的相互比较的
 路径可以不一样，但是这个必须要一样
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly.LoadAssembly">
 <summary>
 出错的时候会返回空值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule.Copy(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule)">
 <summary>
 从文件之中解析出来的新的数据更新当前的模块
 </summary>
 <param name="ns"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.EntryPointMeta">
 <summary>
 一个方法的元数据
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.AssemblyParser.Imports(System.Type)">
 <summary>
 直接导入静态方法
 </summary>
 <param name="[module]"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.PartialModules">
 <summary>
 命名空间是可以被分隔为多个模块分别开发于不同的程序模块之中的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.Description">
 <summary>
 A brief description text about the function of this namespace.(关于本模块之中的描述性的摘要文本)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.Namespace">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.PackageModuleDb">
 <summary>
 包管理器的数据库文件
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.PackageModuleDb.DefaultFile">
 <summary>
 默认的注册表配置文件，该文件是在与本程序同一个文件夹之下的以程序名开始的XML文件.在该文件之中包含有所有的类型注册信息
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager">
 <summary>
 Shoal模块管理器
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager.MergeNamespace(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule[])">
 <summary>
 将所得到的模块合并到现有的模块之中
 </summary>
 <param name="NsCollection"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager.Item(System.String)">
 <summary>
 大小写不敏感
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
</members>
</doc>
