'************************************************************************
'ALGLIB 3.9.0 (source code generated 2014-12-11)
'Copyright (c) Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the 
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'>>> END OF LICENSE >>>
'************************************************************************

'#Pragma warning disable 162
'#Pragma warning disable 219

Public Partial Class alglib


	'************************************************************************
'    Cache-oblivous complex "copy-and-transpose"
'
'    Input parameters:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   source matrix, MxN submatrix is copied and transposed
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        B   -   destination matrix, must be large enough to store result
'        IB  -   submatrix offset (row index)
'        JB  -   submatrix offset (column index)
'    ************************************************************************

	Public Shared Sub cmatrixtranspose(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, ByRef b As complex(,), _
		ib As Integer, jb As Integer)

		ablas.cmatrixtranspose(m, n, a, ia, ja, b, _
			ib, jb)
		Return
	End Sub

	'************************************************************************
'    Cache-oblivous real "copy-and-transpose"
'
'    Input parameters:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   source matrix, MxN submatrix is copied and transposed
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        B   -   destination matrix, must be large enough to store result
'        IB  -   submatrix offset (row index)
'        JB  -   submatrix offset (column index)
'    ************************************************************************

	Public Shared Sub rmatrixtranspose(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, ByRef b As Double(,), _
		ib As Integer, jb As Integer)

		ablas.rmatrixtranspose(m, n, a, ia, ja, b, _
			ib, jb)
		Return
	End Sub

	'************************************************************************
'    This code enforces symmetricy of the matrix by copying Upper part to lower
'    one (or vice versa).
'
'    INPUT PARAMETERS:
'        A   -   matrix
'        N   -   number of rows/columns
'        IsUpper - whether we want to copy upper triangle to lower one (True)
'                or vice versa (False).
'    ************************************************************************

	Public Shared Sub rmatrixenforcesymmetricity(ByRef a As Double(,), n As Integer, isupper As Boolean)

		ablas.rmatrixenforcesymmetricity(a, n, isupper)
		Return
	End Sub

	'************************************************************************
'    Copy
'
'    Input parameters:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   source matrix, MxN submatrix is copied and transposed
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        B   -   destination matrix, must be large enough to store result
'        IB  -   submatrix offset (row index)
'        JB  -   submatrix offset (column index)
'    ************************************************************************

	Public Shared Sub cmatrixcopy(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, ByRef b As complex(,), _
		ib As Integer, jb As Integer)

		ablas.cmatrixcopy(m, n, a, ia, ja, b, _
			ib, jb)
		Return
	End Sub

	'************************************************************************
'    Copy
'
'    Input parameters:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   source matrix, MxN submatrix is copied and transposed
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        B   -   destination matrix, must be large enough to store result
'        IB  -   submatrix offset (row index)
'        JB  -   submatrix offset (column index)
'    ************************************************************************

	Public Shared Sub rmatrixcopy(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, ByRef b As Double(,), _
		ib As Integer, jb As Integer)

		ablas.rmatrixcopy(m, n, a, ia, ja, b, _
			ib, jb)
		Return
	End Sub

	'************************************************************************
'    Rank-1 correction: A := A + u*v'
'
'    INPUT PARAMETERS:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   target matrix, MxN submatrix is updated
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        U   -   vector #1
'        IU  -   subvector offset
'        V   -   vector #2
'        IV  -   subvector offset
'    ************************************************************************

	Public Shared Sub cmatrixrank1(m As Integer, n As Integer, ByRef a As complex(,), ia As Integer, ja As Integer, ByRef u As complex(), _
		iu As Integer, ByRef v As complex(), iv As Integer)

		ablas.cmatrixrank1(m, n, a, ia, ja, u, _
			iu, v, iv)
		Return
	End Sub

	'************************************************************************
'    Rank-1 correction: A := A + u*v'
'
'    INPUT PARAMETERS:
'        M   -   number of rows
'        N   -   number of columns
'        A   -   target matrix, MxN submatrix is updated
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        U   -   vector #1
'        IU  -   subvector offset
'        V   -   vector #2
'        IV  -   subvector offset
'    ************************************************************************

	Public Shared Sub rmatrixrank1(m As Integer, n As Integer, ByRef a As Double(,), ia As Integer, ja As Integer, ByRef u As Double(), _
		iu As Integer, ByRef v As Double(), iv As Integer)

		ablas.rmatrixrank1(m, n, a, ia, ja, u, _
			iu, v, iv)
		Return
	End Sub

	'************************************************************************
'    Matrix-vector product: y := op(A)*x
'
'    INPUT PARAMETERS:
'        M   -   number of rows of op(A)
'                M>=0
'        N   -   number of columns of op(A)
'                N>=0
'        A   -   target matrix
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        OpA -   operation type:
'                * OpA=0     =>  op(A) = A
'                * OpA=1     =>  op(A) = A^T
'                * OpA=2     =>  op(A) = A^H
'        X   -   input vector
'        IX  -   subvector offset
'        IY  -   subvector offset
'        Y   -   preallocated matrix, must be large enough to store result
'
'    OUTPUT PARAMETERS:
'        Y   -   vector which stores result
'
'    if M=0, then subroutine does nothing.
'    if N=0, Y is filled by zeros.
'
'
'      -- ALGLIB routine --
'
'         28.01.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixmv(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, opa As Integer, _
		x As complex(), ix As Integer, ByRef y As complex(), iy As Integer)

		ablas.cmatrixmv(m, n, a, ia, ja, opa, _
			x, ix, y, iy)
		Return
	End Sub

	'************************************************************************
'    Matrix-vector product: y := op(A)*x
'
'    INPUT PARAMETERS:
'        M   -   number of rows of op(A)
'        N   -   number of columns of op(A)
'        A   -   target matrix
'        IA  -   submatrix offset (row index)
'        JA  -   submatrix offset (column index)
'        OpA -   operation type:
'                * OpA=0     =>  op(A) = A
'                * OpA=1     =>  op(A) = A^T
'        X   -   input vector
'        IX  -   subvector offset
'        IY  -   subvector offset
'        Y   -   preallocated matrix, must be large enough to store result
'
'    OUTPUT PARAMETERS:
'        Y   -   vector which stores result
'
'    if M=0, then subroutine does nothing.
'    if N=0, Y is filled by zeros.
'
'
'      -- ALGLIB routine --
'
'         28.01.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixmv(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, opa As Integer, _
		x As Double(), ix As Integer, ByRef y As Double(), iy As Integer)

		ablas.rmatrixmv(m, n, a, ia, ja, opa, _
			x, ix, y, iy)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates X*op(A^-1) where:
'    * X is MxN general matrix
'    * A is NxN upper/lower triangular/unitriangular matrix
'    * "op" may be identity transformation, transposition, conjugate transposition
'
'    Multiplication result replaces X.
'    Cache-oblivious algorithm is used.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N   -   matrix size, N>=0
'        M   -   matrix size, N>=0
'        A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'        I1      -   submatrix offset
'        J1      -   submatrix offset
'        IsUpper -   whether matrix is upper triangular
'        IsUnit  -   whether matrix is unitriangular
'        OpType  -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'                    * 2 - conjugate transposition
'        X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'        I2  -   submatrix offset
'        J2  -   submatrix offset
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixrighttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As complex(,), i2 As Integer, j2 As Integer)

		ablas.cmatrixrighttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub


	Public Shared Sub smp_cmatrixrighttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As complex(,), i2 As Integer, j2 As Integer)

		ablas._pexec_cmatrixrighttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates op(A^-1)*X where:
'    * X is MxN general matrix
'    * A is MxM upper/lower triangular/unitriangular matrix
'    * "op" may be identity transformation, transposition, conjugate transposition
'
'    Multiplication result replaces X.
'    Cache-oblivious algorithm is used.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N   -   matrix size, N>=0
'        M   -   matrix size, N>=0
'        A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'        I1      -   submatrix offset
'        J1      -   submatrix offset
'        IsUpper -   whether matrix is upper triangular
'        IsUnit  -   whether matrix is unitriangular
'        OpType  -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'                    * 2 - conjugate transposition
'        X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'        I2  -   submatrix offset
'        J2  -   submatrix offset
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixlefttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As complex(,), i2 As Integer, j2 As Integer)

		ablas.cmatrixlefttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub


	Public Shared Sub smp_cmatrixlefttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As complex(,), i2 As Integer, j2 As Integer)

		ablas._pexec_cmatrixlefttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates X*op(A^-1) where:
'    * X is MxN general matrix
'    * A is NxN upper/lower triangular/unitriangular matrix
'    * "op" may be identity transformation, transposition
'
'    Multiplication result replaces X.
'    Cache-oblivious algorithm is used.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N   -   matrix size, N>=0
'        M   -   matrix size, N>=0
'        A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'        I1      -   submatrix offset
'        J1      -   submatrix offset
'        IsUpper -   whether matrix is upper triangular
'        IsUnit  -   whether matrix is unitriangular
'        OpType  -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'        X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'        I2  -   submatrix offset
'        J2  -   submatrix offset
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixrighttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As Double(,), i2 As Integer, j2 As Integer)

		ablas.rmatrixrighttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub


	Public Shared Sub smp_rmatrixrighttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As Double(,), i2 As Integer, j2 As Integer)

		ablas._pexec_rmatrixrighttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates op(A^-1)*X where:
'    * X is MxN general matrix
'    * A is MxM upper/lower triangular/unitriangular matrix
'    * "op" may be identity transformation, transposition
'
'    Multiplication result replaces X.
'    Cache-oblivious algorithm is used.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N   -   matrix size, N>=0
'        M   -   matrix size, N>=0
'        A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'        I1      -   submatrix offset
'        J1      -   submatrix offset
'        IsUpper -   whether matrix is upper triangular
'        IsUnit  -   whether matrix is unitriangular
'        OpType  -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'        X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'        I2  -   submatrix offset
'        J2  -   submatrix offset
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixlefttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As Double(,), i2 As Integer, j2 As Integer)

		ablas.rmatrixlefttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub


	Public Shared Sub smp_rmatrixlefttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
		isunit As Boolean, optype As Integer, ByRef x As Double(,), i2 As Integer, j2 As Integer)

		ablas._pexec_rmatrixlefttrsm(m, n, a, i1, j1, isupper, _
			isunit, optype, x, i2, j2)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
'    where:
'    * C is NxN Hermitian matrix given by its upper/lower triangle
'    * A is NxK matrix when A*A^H is calculated, KxN matrix otherwise
'
'    Additional info:
'    * cache-oblivious algorithm is used.
'    * multiplication result replaces C. If Beta=0, C elements are not used in
'      calculations (not multiplied by zero - just not referenced)
'    * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'    * if both Beta and Alpha are zero, C is filled by zeros.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N       -   matrix size, N>=0
'        K       -   matrix size, K>=0
'        Alpha   -   coefficient
'        A       -   matrix
'        IA      -   submatrix offset (row index)
'        JA      -   submatrix offset (column index)
'        OpTypeA -   multiplication type:
'                    * 0 - A*A^H is calculated
'                    * 2 - A^H*A is calculated
'        Beta    -   coefficient
'        C       -   preallocated input/output matrix
'        IC      -   submatrix offset (row index)
'        JC      -   submatrix offset (column index)
'        IsUpper -   whether upper or lower triangle of C is updated;
'                    this function updates only one half of C, leaving
'                    other half unchanged (not referenced at all).
'
'      -- ALGLIB routine --
'         16.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixherk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas.cmatrixherk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub


	Public Shared Sub smp_cmatrixherk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas._pexec_cmatrixherk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates  C=alpha*A*A^T+beta*C  or  C=alpha*A^T*A+beta*C
'    where:
'    * C is NxN symmetric matrix given by its upper/lower triangle
'    * A is NxK matrix when A*A^T is calculated, KxN matrix otherwise
'
'    Additional info:
'    * cache-oblivious algorithm is used.
'    * multiplication result replaces C. If Beta=0, C elements are not used in
'      calculations (not multiplied by zero - just not referenced)
'    * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'    * if both Beta and Alpha are zero, C is filled by zeros.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS
'        N       -   matrix size, N>=0
'        K       -   matrix size, K>=0
'        Alpha   -   coefficient
'        A       -   matrix
'        IA      -   submatrix offset (row index)
'        JA      -   submatrix offset (column index)
'        OpTypeA -   multiplication type:
'                    * 0 - A*A^T is calculated
'                    * 2 - A^T*A is calculated
'        Beta    -   coefficient
'        C       -   preallocated input/output matrix
'        IC      -   submatrix offset (row index)
'        JC      -   submatrix offset (column index)
'        IsUpper -   whether C is upper triangular or lower triangular
'
'      -- ALGLIB routine --
'         16.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As Double(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas.rmatrixsyrk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub


	Public Shared Sub smp_rmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As Double(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas._pexec_rmatrixsyrk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'    * C is MxN general matrix
'    * op1(A) is MxK matrix
'    * op2(B) is KxN matrix
'    * "op" may be identity transformation, transposition, conjugate transposition
'
'    Additional info:
'    * cache-oblivious algorithm is used.
'    * multiplication result replaces C. If Beta=0, C elements are not used in
'      calculations (not multiplied by zero - just not referenced)
'    * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'    * if both Beta and Alpha are zero, C is filled by zeros.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    IMPORTANT:
'
'    This function does NOT preallocate output matrix C, it MUST be preallocated
'    by caller prior to calling this function. In case C does not have  enough
'    space to store result, exception will be generated.
'
'    INPUT PARAMETERS
'        M       -   matrix size, M>0
'        N       -   matrix size, N>0
'        K       -   matrix size, K>0
'        Alpha   -   coefficient
'        A       -   matrix
'        IA      -   submatrix offset
'        JA      -   submatrix offset
'        OpTypeA -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'                    * 2 - conjugate transposition
'        B       -   matrix
'        IB      -   submatrix offset
'        JB      -   submatrix offset
'        OpTypeB -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'                    * 2 - conjugate transposition
'        Beta    -   coefficient
'        C       -   matrix (PREALLOCATED, large enough to store result)
'        IC      -   submatrix offset
'        JC      -   submatrix offset
'
'      -- ALGLIB routine --
'         16.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As complex, a As complex(,), ia As Integer, _
		ja As Integer, optypea As Integer, b As complex(,), ib As Integer, jb As Integer, optypeb As Integer, _
		beta As complex, ByRef c As complex(,), ic As Integer, jc As Integer)

		ablas.cmatrixgemm(m, n, k, alpha, a, ia, _
			ja, optypea, b, ib, jb, optypeb, _
			beta, c, ic, jc)
		Return
	End Sub


	Public Shared Sub smp_cmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As complex, a As complex(,), ia As Integer, _
		ja As Integer, optypea As Integer, b As complex(,), ib As Integer, jb As Integer, optypeb As Integer, _
		beta As complex, ByRef c As complex(,), ic As Integer, jc As Integer)

		ablas._pexec_cmatrixgemm(m, n, k, alpha, a, ia, _
			ja, optypea, b, ib, jb, optypeb, _
			beta, c, ic, jc)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'    * C is MxN general matrix
'    * op1(A) is MxK matrix
'    * op2(B) is KxN matrix
'    * "op" may be identity transformation, transposition
'
'    Additional info:
'    * cache-oblivious algorithm is used.
'    * multiplication result replaces C. If Beta=0, C elements are not used in
'      calculations (not multiplied by zero - just not referenced)
'    * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'    * if both Beta and Alpha are zero, C is filled by zeros.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  Because  starting/stopping  worker  thread always
'      ! involves some overhead, parallelism starts to be  profitable  for  N's
'      ! larger than 128.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    IMPORTANT:
'
'    This function does NOT preallocate output matrix C, it MUST be preallocated
'    by caller prior to calling this function. In case C does not have  enough
'    space to store result, exception will be generated.
'
'    INPUT PARAMETERS
'        M       -   matrix size, M>0
'        N       -   matrix size, N>0
'        K       -   matrix size, K>0
'        Alpha   -   coefficient
'        A       -   matrix
'        IA      -   submatrix offset
'        JA      -   submatrix offset
'        OpTypeA -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'        B       -   matrix
'        IB      -   submatrix offset
'        JB      -   submatrix offset
'        OpTypeB -   transformation type:
'                    * 0 - no transformation
'                    * 1 - transposition
'        Beta    -   coefficient
'        C       -   PREALLOCATED output matrix, large enough to store result
'        IC      -   submatrix offset
'        JC      -   submatrix offset
'
'      -- ALGLIB routine --
'         2009-2013
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, _
		ja As Integer, optypea As Integer, b As Double(,), ib As Integer, jb As Integer, optypeb As Integer, _
		beta As Double, ByRef c As Double(,), ic As Integer, jc As Integer)

		ablas.rmatrixgemm(m, n, k, alpha, a, ia, _
			ja, optypea, b, ib, jb, optypeb, _
			beta, c, ic, jc)
		Return
	End Sub


	Public Shared Sub smp_rmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, _
		ja As Integer, optypea As Integer, b As Double(,), ib As Integer, jb As Integer, optypeb As Integer, _
		beta As Double, ByRef c As Double(,), ic As Integer, jc As Integer)

		ablas._pexec_rmatrixgemm(m, n, k, alpha, a, ia, _
			ja, optypea, b, ib, jb, optypeb, _
			beta, c, ic, jc)
		Return
	End Sub

	'************************************************************************
'    This subroutine is an older version of CMatrixHERK(), one with wrong  name
'    (it is HErmitian update, not SYmmetric). It  is  left  here  for  backward
'    compatibility.
'
'      -- ALGLIB routine --
'         16.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas.cmatrixsyrk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub


	Public Shared Sub smp_cmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
		optypea As Integer, beta As Double, ByRef c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)

		ablas._pexec_cmatrixsyrk(n, k, alpha, a, ia, ja, _
			optypea, beta, c, ic, jc, isupper)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    QR decomposition of a rectangular matrix of size MxN
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'        M   -   number of rows in matrix A.
'        N   -   number of columns in matrix A.
'
'    Output parameters:
'        A   -   matrices Q and R in compact form (see below).
'        Tau -   array of scalar factors which are used to form
'                matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
'
'    Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'    MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
'
'    The elements of matrix R are located on and above the main diagonal of
'    matrix A. The elements which are located in Tau array and below the main
'    diagonal of matrix A are used to form matrix Q as follows:
'
'    Matrix Q is represented as a product of elementary reflections
'
'    Q = H(0)*H(2)*...*H(k-1),
'
'    where k = min(m,n), and each H(i) is in the form
'
'    H(i) = 1 - tau * v * (v^T)
'
'    where tau is a scalar stored in Tau[I]; v - real vector,
'    so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixqr(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
		tau = New Double(-1) {}
		ortfac.rmatrixqr(a, m, n, tau)
		Return
	End Sub


	Public Shared Sub smp_rmatrixqr(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
		tau = New Double(-1) {}
		ortfac._pexec_rmatrixqr(a, m, n, tau)
		Return
	End Sub

	'************************************************************************
'    LQ decomposition of a rectangular matrix of size MxN
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'        M   -   number of rows in matrix A.
'        N   -   number of columns in matrix A.
'
'    Output parameters:
'        A   -   matrices L and Q in compact form (see below)
'        Tau -   array of scalar factors which are used to form
'                matrix Q. Array whose index ranges within [0..Min(M,N)-1].
'
'    Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'    MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
'
'    The elements of matrix L are located on and below  the  main  diagonal  of
'    matrix A. The elements which are located in Tau array and above  the  main
'    diagonal of matrix A are used to form matrix Q as follows:
'
'    Matrix Q is represented as a product of elementary reflections
'
'    Q = H(k-1)*H(k-2)*...*H(1)*H(0),
'
'    where k = min(m,n), and each H(i) is of the form
'
'    H(i) = 1 - tau * v * (v^T)
'
'    where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
'    v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixlq(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
		tau = New Double(-1) {}
		ortfac.rmatrixlq(a, m, n, tau)
		Return
	End Sub


	Public Shared Sub smp_rmatrixlq(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
		tau = New Double(-1) {}
		ortfac._pexec_rmatrixlq(a, m, n, tau)
		Return
	End Sub

	'************************************************************************
'    QR decomposition of a rectangular complex matrix of size MxN
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'        M   -   number of rows in matrix A.
'        N   -   number of columns in matrix A.
'
'    Output parameters:
'        A   -   matrices Q and R in compact form
'        Tau -   array of scalar factors which are used to form matrix Q. Array
'                whose indexes range within [0.. Min(M,N)-1]
'
'    Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'    MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         September 30, 1994
'    ************************************************************************

	Public Shared Sub cmatrixqr(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
		tau = New complex(-1) {}
		ortfac.cmatrixqr(a, m, n, tau)
		Return
	End Sub


	Public Shared Sub smp_cmatrixqr(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
		tau = New complex(-1) {}
		ortfac._pexec_cmatrixqr(a, m, n, tau)
		Return
	End Sub

	'************************************************************************
'    LQ decomposition of a rectangular complex matrix of size MxN
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'        M   -   number of rows in matrix A.
'        N   -   number of columns in matrix A.
'
'    Output parameters:
'        A   -   matrices Q and L in compact form
'        Tau -   array of scalar factors which are used to form matrix Q. Array
'                whose indexes range within [0.. Min(M,N)-1]
'
'    Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'    MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         September 30, 1994
'    ************************************************************************

	Public Shared Sub cmatrixlq(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
		tau = New complex(-1) {}
		ortfac.cmatrixlq(a, m, n, tau)
		Return
	End Sub


	Public Shared Sub smp_cmatrixlq(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
		tau = New complex(-1) {}
		ortfac._pexec_cmatrixlq(a, m, n, tau)
		Return
	End Sub

	'************************************************************************
'    Partial unpacking of matrix Q from the QR decomposition of a matrix A
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrices Q and R in compact form.
'                    Output of RMatrixQR subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'        Tau     -   scalar factors which are used to form Q.
'                    Output of the RMatrixQR subroutine.
'        QColumns -  required number of columns of matrix Q. M>=QColumns>=0.
'
'    Output parameters:
'        Q       -   first QColumns columns of matrix Q.
'                    Array whose indexes range within [0..M-1, 0..QColumns-1].
'                    If QColumns=0, the array remains unchanged.
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixqrunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qcolumns As Integer, ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac.rmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		Return
	End Sub


	Public Shared Sub smp_rmatrixqrunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qcolumns As Integer, ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac._pexec_rmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		Return
	End Sub

	'************************************************************************
'    Unpacking of matrix R from the QR decomposition of a matrix A
'
'    Input parameters:
'        A       -   matrices Q and R in compact form.
'                    Output of RMatrixQR subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'
'    Output parameters:
'        R       -   matrix R, array[0..M-1, 0..N-1].
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixqrunpackr(a As Double(,), m As Integer, n As Integer, ByRef r As Double(,))
		r = New Double(-1, -1) {}
		ortfac.rmatrixqrunpackr(a, m, n, r)
		Return
	End Sub

	'************************************************************************
'    Partial unpacking of matrix Q from the LQ decomposition of a matrix A
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrices L and Q in compact form.
'                    Output of RMatrixLQ subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'        Tau     -   scalar factors which are used to form Q.
'                    Output of the RMatrixLQ subroutine.
'        QRows   -   required number of rows in matrix Q. N>=QRows>=0.
'
'    Output parameters:
'        Q       -   first QRows rows of matrix Q. Array whose indexes range
'                    within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
'                    unchanged.
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixlqunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qrows As Integer, ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac.rmatrixlqunpackq(a, m, n, tau, qrows, q)
		Return
	End Sub


	Public Shared Sub smp_rmatrixlqunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qrows As Integer, ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac._pexec_rmatrixlqunpackq(a, m, n, tau, qrows, q)
		Return
	End Sub

	'************************************************************************
'    Unpacking of matrix L from the LQ decomposition of a matrix A
'
'    Input parameters:
'        A       -   matrices Q and L in compact form.
'                    Output of RMatrixLQ subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'
'    Output parameters:
'        L       -   matrix L, array[0..M-1, 0..N-1].
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixlqunpackl(a As Double(,), m As Integer, n As Integer, ByRef l As Double(,))
		l = New Double(-1, -1) {}
		ortfac.rmatrixlqunpackl(a, m, n, l)
		Return
	End Sub

	'************************************************************************
'    Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A           -   matrices Q and R in compact form.
'                        Output of CMatrixQR subroutine .
'        M           -   number of rows in matrix A. M>=0.
'        N           -   number of columns in matrix A. N>=0.
'        Tau         -   scalar factors which are used to form Q.
'                        Output of CMatrixQR subroutine .
'        QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.
'
'    Output parameters:
'        Q           -   first QColumns columns of matrix Q.
'                        Array whose index ranges within [0..M-1, 0..QColumns-1].
'                        If QColumns=0, array isn't changed.
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixqrunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qcolumns As Integer, ByRef q As complex(,))
		q = New complex(-1, -1) {}
		ortfac.cmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		Return
	End Sub


	Public Shared Sub smp_cmatrixqrunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qcolumns As Integer, ByRef q As complex(,))
		q = New complex(-1, -1) {}
		ortfac._pexec_cmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		Return
	End Sub

	'************************************************************************
'    Unpacking of matrix R from the QR decomposition of a matrix A
'
'    Input parameters:
'        A       -   matrices Q and R in compact form.
'                    Output of CMatrixQR subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'
'    Output parameters:
'        R       -   matrix R, array[0..M-1, 0..N-1].
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixqrunpackr(a As complex(,), m As Integer, n As Integer, ByRef r As complex(,))
		r = New complex(-1, -1) {}
		ortfac.cmatrixqrunpackr(a, m, n, r)
		Return
	End Sub

	'************************************************************************
'    Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that QP decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=512,   achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A           -   matrices Q and R in compact form.
'                        Output of CMatrixLQ subroutine .
'        M           -   number of rows in matrix A. M>=0.
'        N           -   number of columns in matrix A. N>=0.
'        Tau         -   scalar factors which are used to form Q.
'                        Output of CMatrixLQ subroutine .
'        QRows       -   required number of rows in matrix Q. N>=QColumns>=0.
'
'    Output parameters:
'        Q           -   first QRows rows of matrix Q.
'                        Array whose index ranges within [0..QRows-1, 0..N-1].
'                        If QRows=0, array isn't changed.
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixlqunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qrows As Integer, ByRef q As complex(,))
		q = New complex(-1, -1) {}
		ortfac.cmatrixlqunpackq(a, m, n, tau, qrows, q)
		Return
	End Sub


	Public Shared Sub smp_cmatrixlqunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qrows As Integer, ByRef q As complex(,))
		q = New complex(-1, -1) {}
		ortfac._pexec_cmatrixlqunpackq(a, m, n, tau, qrows, q)
		Return
	End Sub

	'************************************************************************
'    Unpacking of matrix L from the LQ decomposition of a matrix A
'
'    Input parameters:
'        A       -   matrices Q and L in compact form.
'                    Output of CMatrixLQ subroutine.
'        M       -   number of rows in given matrix A. M>=0.
'        N       -   number of columns in given matrix A. N>=0.
'
'    Output parameters:
'        L       -   matrix L, array[0..M-1, 0..N-1].
'
'      -- ALGLIB routine --
'         17.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixlqunpackl(a As complex(,), m As Integer, n As Integer, ByRef l As complex(,))
		l = New complex(-1, -1) {}
		ortfac.cmatrixlqunpackl(a, m, n, l)
		Return
	End Sub

	'************************************************************************
'    Reduction of a rectangular matrix to  bidiagonal form
'
'    The algorithm reduces the rectangular matrix A to  bidiagonal form by
'    orthogonal transformations P and Q: A = Q*B*(P^T).
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Multithreaded acceleration is NOT supported for this function  because
'      ! bidiagonal decompostion is inherently sequential in nature.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   source matrix. array[0..M-1, 0..N-1]
'        M       -   number of rows in matrix A.
'        N       -   number of columns in matrix A.
'
'    Output parameters:
'        A       -   matrices Q, B, P in compact form (see below).
'        TauQ    -   scalar factors which are used to form matrix Q.
'        TauP    -   scalar factors which are used to form matrix P.
'
'    The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
'    replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
'    reflections which form MxM matrix Q and NxN matrix P, respectively.
'
'    If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
'    corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
'    product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
'    H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
'    vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
'    stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
'    G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
'    u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
'
'    If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
'    corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
'    H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
'    is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
'    G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
'    is stored in A(i,i+1:n-1).
'
'    EXAMPLE:
'
'    m=6, n=5 (m > n):               m=5, n=6 (m < n):
'
'    (  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
'    (  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
'    (  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
'    (  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
'    (  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
'    (  v1  v2  v3  v4  v5 )
'
'    Here vi and ui are vectors which form H(i) and G(i), and d and e -
'    are the diagonal and off-diagonal elements of matrix B.
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         September 30, 1994.
'         Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'         pseudocode, 2007-2010.
'    ************************************************************************

	Public Shared Sub rmatrixbd(ByRef a As Double(,), m As Integer, n As Integer, ByRef tauq As Double(), ByRef taup As Double())
		tauq = New Double(-1) {}
		taup = New Double(-1) {}
		ortfac.rmatrixbd(a, m, n, tauq, taup)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix Q which reduces a matrix to bidiagonal form.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        QP          -   matrices Q and P in compact form.
'                        Output of ToBidiagonal subroutine.
'        M           -   number of rows in matrix A.
'        N           -   number of columns in matrix A.
'        TAUQ        -   scalar factors which are used to form Q.
'                        Output of ToBidiagonal subroutine.
'        QColumns    -   required number of columns in matrix Q.
'                        M>=QColumns>=0.
'
'    Output parameters:
'        Q           -   first QColumns columns of matrix Q.
'                        Array[0..M-1, 0..QColumns-1]
'                        If QColumns=0, the array is not modified.
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixbdunpackq(qp As Double(,), m As Integer, n As Integer, tauq As Double(), qcolumns As Integer, ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac.rmatrixbdunpackq(qp, m, n, tauq, qcolumns, q)
		Return
	End Sub

	'************************************************************************
'    Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
'
'    The algorithm allows pre- or post-multiply by Q or Q'.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        QP          -   matrices Q and P in compact form.
'                        Output of ToBidiagonal subroutine.
'        M           -   number of rows in matrix A.
'        N           -   number of columns in matrix A.
'        TAUQ        -   scalar factors which are used to form Q.
'                        Output of ToBidiagonal subroutine.
'        Z           -   multiplied matrix.
'                        array[0..ZRows-1,0..ZColumns-1]
'        ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                        ZRows=M, otherwise ZRows can be arbitrary.
'        ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                        ZColumns=M, otherwise ZColumns can be arbitrary.
'        FromTheRight -  pre- or post-multiply.
'        DoTranspose -   multiply by Q or Q'.
'
'    Output parameters:
'        Z           -   product of Z and Q.
'                        Array[0..ZRows-1,0..ZColumns-1]
'                        If ZRows=0 or ZColumns=0, the array is not modified.
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixbdmultiplybyq(qp As Double(,), m As Integer, n As Integer, tauq As Double(), ByRef z As Double(,), zrows As Integer, _
		zcolumns As Integer, fromtheright As Boolean, dotranspose As Boolean)

		ortfac.rmatrixbdmultiplybyq(qp, m, n, tauq, z, zrows, _
			zcolumns, fromtheright, dotranspose)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix P which reduces matrix A to bidiagonal form.
'    The subroutine returns transposed matrix P.
'
'    Input parameters:
'        QP      -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'        M       -   number of rows in matrix A.
'        N       -   number of columns in matrix A.
'        TAUP    -   scalar factors which are used to form P.
'                    Output of ToBidiagonal subroutine.
'        PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.
'
'    Output parameters:
'        PT      -   first PTRows columns of matrix P^T
'                    Array[0..PTRows-1, 0..N-1]
'                    If PTRows=0, the array is not modified.
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixbdunpackpt(qp As Double(,), m As Integer, n As Integer, taup As Double(), ptrows As Integer, ByRef pt As Double(,))
		pt = New Double(-1, -1) {}
		ortfac.rmatrixbdunpackpt(qp, m, n, taup, ptrows, pt)
		Return
	End Sub

	'************************************************************************
'    Multiplication by matrix P which reduces matrix A to  bidiagonal form.
'
'    The algorithm allows pre- or post-multiply by P or P'.
'
'    Input parameters:
'        QP          -   matrices Q and P in compact form.
'                        Output of RMatrixBD subroutine.
'        M           -   number of rows in matrix A.
'        N           -   number of columns in matrix A.
'        TAUP        -   scalar factors which are used to form P.
'                        Output of RMatrixBD subroutine.
'        Z           -   multiplied matrix.
'                        Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'        ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                        ZRows=N, otherwise ZRows can be arbitrary.
'        ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                        ZColumns=N, otherwise ZColumns can be arbitrary.
'        FromTheRight -  pre- or post-multiply.
'        DoTranspose -   multiply by P or P'.
'
'    Output parameters:
'        Z - product of Z and P.
'                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'                    If ZRows=0 or ZColumns=0, the array is not modified.
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixbdmultiplybyp(qp As Double(,), m As Integer, n As Integer, taup As Double(), ByRef z As Double(,), zrows As Integer, _
		zcolumns As Integer, fromtheright As Boolean, dotranspose As Boolean)

		ortfac.rmatrixbdmultiplybyp(qp, m, n, taup, z, zrows, _
			zcolumns, fromtheright, dotranspose)
		Return
	End Sub

	'************************************************************************
'    Unpacking of the main and secondary diagonals of bidiagonal decomposition
'    of matrix A.
'
'    Input parameters:
'        B   -   output of RMatrixBD subroutine.
'        M   -   number of rows in matrix B.
'        N   -   number of columns in matrix B.
'
'    Output parameters:
'        IsUpper -   True, if the matrix is upper bidiagonal.
'                    otherwise IsUpper is False.
'        D       -   the main diagonal.
'                    Array whose index ranges within [0..Min(M,N)-1].
'        E       -   the secondary diagonal (upper or lower, depending on
'                    the value of IsUpper).
'                    Array index ranges within [0..Min(M,N)-1], the last
'                    element is not used.
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixbdunpackdiagonals(b As Double(,), m As Integer, n As Integer, ByRef isupper As Boolean, ByRef d As Double(), ByRef e As Double())
		isupper = False
		d = New Double(-1) {}
		e = New Double(-1) {}
		ortfac.rmatrixbdunpackdiagonals(b, m, n, isupper, d, e)
		Return
	End Sub

	'************************************************************************
'    Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
'    where Q is an orthogonal matrix, H - Hessenberg matrix.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix A with elements [0..N-1, 0..N-1]
'        N       -   size of matrix A.
'
'    Output parameters:
'        A       -   matrices Q and P in  compact form (see below).
'        Tau     -   array of scalar factors which are used to form matrix Q.
'                    Array whose index ranges within [0..N-2]
'
'    Matrix H is located on the main diagonal, on the lower secondary  diagonal
'    and above the main diagonal of matrix A. The elements which are used to
'    form matrix Q are situated in array Tau and below the lower secondary
'    diagonal of matrix A as follows:
'
'    Matrix Q is represented as a product of elementary reflections
'
'    Q = H(0)*H(2)*...*H(n-2),
'
'    where each H(i) is given by
'
'    H(i) = 1 - tau * v * (v^T)
'
'    where tau is a scalar stored in Tau[I]; v - is a real vector,
'    so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         October 31, 1992
'    ************************************************************************

	Public Shared Sub rmatrixhessenberg(ByRef a As Double(,), n As Integer, ByRef tau As Double())
		tau = New Double(-1) {}
		ortfac.rmatrixhessenberg(a, n, tau)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix Q which reduces matrix A to upper Hessenberg form
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A   -   output of RMatrixHessenberg subroutine.
'        N   -   size of matrix A.
'        Tau -   scalar factors which are used to form Q.
'                Output of RMatrixHessenberg subroutine.
'
'    Output parameters:
'        Q   -   matrix Q.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixhessenbergunpackq(a As Double(,), n As Integer, tau As Double(), ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac.rmatrixhessenbergunpackq(a, n, tau, q)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
'
'    Input parameters:
'        A   -   output of RMatrixHessenberg subroutine.
'        N   -   size of matrix A.
'
'    Output parameters:
'        H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
'
'      -- ALGLIB --
'         2005-2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixhessenbergunpackh(a As Double(,), n As Integer, ByRef h As Double(,))
		h = New Double(-1, -1) {}
		ortfac.rmatrixhessenbergunpackh(a, n, h)
		Return
	End Sub

	'************************************************************************
'    Reduction of a symmetric matrix which is given by its higher or lower
'    triangular part to a tridiagonal matrix using orthogonal similarity
'    transformation: Q'*A*Q=T.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix to be transformed
'                    array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   storage format. If IsUpper = True, then matrix A is given
'                    by its upper triangle, and the lower triangle is not used
'                    and not modified by the algorithm, and vice versa
'                    if IsUpper = False.
'
'    Output parameters:
'        A       -   matrices T and Q in  compact form (see lower)
'        Tau     -   array of factors which are forming matrices H(i)
'                    array with elements [0..N-2].
'        D       -   main diagonal of symmetric matrix T.
'                    array with elements [0..N-1].
'        E       -   secondary diagonal of symmetric matrix T.
'                    array with elements [0..N-2].
'
'
'      If IsUpper=True, the matrix Q is represented as a product of elementary
'      reflectors
'
'         Q = H(n-2) . . . H(2) H(0).
'
'      Each H(i) has the form
'
'         H(i) = I - tau * v * v'
'
'      where tau is a real scalar, and v is a real vector with
'      v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'      A(0:i-1,i+1), and tau in TAU(i).
'
'      If IsUpper=False, the matrix Q is represented as a product of elementary
'      reflectors
'
'         Q = H(0) H(2) . . . H(n-2).
'
'      Each H(i) has the form
'
'         H(i) = I - tau * v * v'
'
'      where tau is a real scalar, and v is a real vector with
'      v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'      and tau in TAU(i).
'
'      The contents of A on exit are illustrated by the following examples
'      with n = 5:
'
'      if UPLO = 'U':                       if UPLO = 'L':
'
'        (  d   e   v1  v2  v3 )              (  d                  )
'        (      d   e   v2  v3 )              (  e   d              )
'        (          d   e   v3 )              (  v0  e   d          )
'        (              d   e  )              (  v0  v1  e   d      )
'        (                  d  )              (  v0  v1  v2  e   d  )
'
'      where d and e denote diagonal and off-diagonal elements of T, and vi
'      denotes an element of the vector defining H(i).
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         October 31, 1992
'    ************************************************************************

	Public Shared Sub smatrixtd(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef tau As Double(), ByRef d As Double(), ByRef e As Double())
		tau = New Double(-1) {}
		d = New Double(-1) {}
		e = New Double(-1) {}
		ortfac.smatrixtd(a, n, isupper, tau, d, e)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
'    form.
'
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   the result of a SMatrixTD subroutine
'        N       -   size of matrix A.
'        IsUpper -   storage format (a parameter of SMatrixTD subroutine)
'        Tau     -   the result of a SMatrixTD subroutine
'
'    Output parameters:
'        Q       -   transformation matrix.
'                    array with elements [0..N-1, 0..N-1].
'
'      -- ALGLIB --
'         Copyright 2005-2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub smatrixtdunpackq(a As Double(,), n As Integer, isupper As Boolean, tau As Double(), ByRef q As Double(,))
		q = New Double(-1, -1) {}
		ortfac.smatrixtdunpackq(a, n, isupper, tau, q)
		Return
	End Sub

	'************************************************************************
'    Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
'    triangular part to a real  tridiagonal  matrix  using  unitary  similarity
'    transformation: Q'*A*Q = T.
'
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix to be transformed
'                    array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   storage format. If IsUpper = True, then matrix A is  given
'                    by its upper triangle, and the lower triangle is not  used
'                    and not modified by the algorithm, and vice versa
'                    if IsUpper = False.
'
'    Output parameters:
'        A       -   matrices T and Q in  compact form (see lower)
'        Tau     -   array of factors which are forming matrices H(i)
'                    array with elements [0..N-2].
'        D       -   main diagonal of real symmetric matrix T.
'                    array with elements [0..N-1].
'        E       -   secondary diagonal of real symmetric matrix T.
'                    array with elements [0..N-2].
'
'
'      If IsUpper=True, the matrix Q is represented as a product of elementary
'      reflectors
'
'         Q = H(n-2) . . . H(2) H(0).
'
'      Each H(i) has the form
'
'         H(i) = I - tau * v * v'
'
'      where tau is a complex scalar, and v is a complex vector with
'      v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'      A(0:i-1,i+1), and tau in TAU(i).
'
'      If IsUpper=False, the matrix Q is represented as a product of elementary
'      reflectors
'
'         Q = H(0) H(2) . . . H(n-2).
'
'      Each H(i) has the form
'
'         H(i) = I - tau * v * v'
'
'      where tau is a complex scalar, and v is a complex vector with
'      v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'      and tau in TAU(i).
'
'      The contents of A on exit are illustrated by the following examples
'      with n = 5:
'
'      if UPLO = 'U':                       if UPLO = 'L':
'
'        (  d   e   v1  v2  v3 )              (  d                  )
'        (      d   e   v2  v3 )              (  e   d              )
'        (          d   e   v3 )              (  v0  e   d          )
'        (              d   e  )              (  v0  v1  e   d      )
'        (                  d  )              (  v0  v1  v2  e   d  )
'
'    where d and e denote diagonal and off-diagonal elements of T, and vi
'    denotes an element of the vector defining H(i).
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         October 31, 1992
'    ************************************************************************

	Public Shared Sub hmatrixtd(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef tau As complex(), ByRef d As Double(), ByRef e As Double())
		tau = New complex(-1) {}
		d = New Double(-1) {}
		e = New Double(-1) {}
		ortfac.hmatrixtd(a, n, isupper, tau, d, e)
		Return
	End Sub

	'************************************************************************
'    Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
'    form.
'
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   the result of a HMatrixTD subroutine
'        N       -   size of matrix A.
'        IsUpper -   storage format (a parameter of HMatrixTD subroutine)
'        Tau     -   the result of a HMatrixTD subroutine
'
'    Output parameters:
'        Q       -   transformation matrix.
'                    array with elements [0..N-1, 0..N-1].
'
'      -- ALGLIB --
'         Copyright 2005-2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hmatrixtdunpackq(a As complex(,), n As Integer, isupper As Boolean, tau As complex(), ByRef q As complex(,))
		q = New complex(-1, -1) {}
		ortfac.hmatrixtdunpackq(a, n, isupper, tau, q)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Singular value decomposition of a bidiagonal matrix (extended algorithm)
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    The algorithm performs the singular value decomposition  of  a  bidiagonal
'    matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
'    orthogonal matrices, S - diagonal matrix with non-negative elements on the
'    main diagonal, in descending order.
'
'    The  algorithm  finds  singular  values.  In  addition,  the algorithm can
'    calculate  matrices  Q  and P (more precisely, not the matrices, but their
'    product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
'    matrices U and VT can be of any type, including identity. Furthermore, the
'    algorithm can calculate Q'*C (this product is calculated more  effectively
'    than U*Q,  because  this calculation operates with rows instead  of matrix
'    columns).
'
'    The feature of the algorithm is its ability to find  all  singular  values
'    including those which are arbitrarily close to 0  with  relative  accuracy
'    close to  machine precision. If the parameter IsFractionalAccuracyRequired
'    is set to True, all singular values will have high relative accuracy close
'    to machine precision. If the parameter is set to False, only  the  biggest
'    singular value will have relative accuracy  close  to  machine  precision.
'    The absolute error of other singular values is equal to the absolute error
'    of the biggest singular value.
'
'    Input parameters:
'        D       -   main diagonal of matrix B.
'                    Array whose index ranges within [0..N-1].
'        E       -   superdiagonal (or subdiagonal) of matrix B.
'                    Array whose index ranges within [0..N-2].
'        N       -   size of matrix B.
'        IsUpper -   True, if the matrix is upper bidiagonal.
'        IsFractionalAccuracyRequired -
'                    THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0
'                    SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.
'        U       -   matrix to be multiplied by Q.
'                    Array whose indexes range within [0..NRU-1, 0..N-1].
'                    The matrix can be bigger, in that case only the  submatrix
'                    [0..NRU-1, 0..N-1] will be multiplied by Q.
'        NRU     -   number of rows in matrix U.
'        C       -   matrix to be multiplied by Q'.
'                    Array whose indexes range within [0..N-1, 0..NCC-1].
'                    The matrix can be bigger, in that case only the  submatrix
'                    [0..N-1, 0..NCC-1] will be multiplied by Q'.
'        NCC     -   number of columns in matrix C.
'        VT      -   matrix to be multiplied by P^T.
'                    Array whose indexes range within [0..N-1, 0..NCVT-1].
'                    The matrix can be bigger, in that case only the  submatrix
'                    [0..N-1, 0..NCVT-1] will be multiplied by P^T.
'        NCVT    -   number of columns in matrix VT.
'
'    Output parameters:
'        D       -   singular values of matrix B in descending order.
'        U       -   if NRU>0, contains matrix U*Q.
'        VT      -   if NCVT>0, contains matrix (P^T)*VT.
'        C       -   if NCC>0, contains matrix Q'*C.
'
'    Result:
'        True, if the algorithm has converged.
'        False, if the algorithm hasn't converged (rare case).
'
'    NOTE: multiplication U*Q is performed by means of transposition to internal
'          buffer, multiplication and backward transposition. It helps to avoid
'          costly columnwise operations and speed-up algorithm.
'
'    Additional information:
'        The type of convergence is controlled by the internal  parameter  TOL.
'        If the parameter is greater than 0, the singular values will have
'        relative accuracy TOL. If TOL<0, the singular values will have
'        absolute accuracy ABS(TOL)*norm(B).
'        By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
'        where Epsilon is the machine precision. It is not  recommended  to  use
'        TOL less than 10*Epsilon since this will  considerably  slow  down  the
'        algorithm and may not lead to error decreasing.
'
'    History:
'        * 31 March, 2007.
'            changed MAXITR from 6 to 12.
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         October 31, 1999.
'    ************************************************************************

	Public Shared Function rmatrixbdsvd(ByRef d As Double(), e As Double(), n As Integer, isupper As Boolean, isfractionalaccuracyrequired As Boolean, ByRef u As Double(,), _
		nru As Integer, ByRef c As Double(,), ncc As Integer, ByRef vt As Double(,), ncvt As Integer) As Boolean

		Dim result As Boolean = bdsvd.rmatrixbdsvd(d, e, n, isupper, isfractionalaccuracyrequired, u, _
			nru, c, ncc, vt, ncvt)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Singular value decomposition of a rectangular matrix.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is only partially supported (some parts are
'      ! optimized, but most - are not).
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    The algorithm calculates the singular value decomposition of a matrix of
'    size MxN: A = U * S * V^T
'
'    The algorithm finds the singular values and, optionally, matrices U and V^T.
'    The algorithm can find both first min(M,N) columns of matrix U and rows of
'    matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
'    and NxN respectively).
'
'    Take into account that the subroutine does not return matrix V but V^T.
'
'    Input parameters:
'        A           -   matrix to be decomposed.
'                        Array whose indexes range within [0..M-1, 0..N-1].
'        M           -   number of rows in matrix A.
'        N           -   number of columns in matrix A.
'        UNeeded     -   0, 1 or 2. See the description of the parameter U.
'        VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
'        AdditionalMemory -
'                        If the parameter:
'                         * equals 0, the algorithm doesn use additional
'                           memory (lower requirements, lower performance).
'                         * equals 1, the algorithm uses additional
'                           memory of size min(M,N)*min(M,N) of real numbers.
'                           It often speeds up the algorithm.
'                         * equals 2, the algorithm uses additional
'                           memory of size M*min(M,N) of real numbers.
'                           It allows to get a maximum performance.
'                        The recommended value of the parameter is 2.
'
'    Output parameters:
'        W           -   contains singular values in descending order.
'        U           -   if UNeeded=0, U isn't changed, the left singular vectors
'                        are not calculated.
'                        if Uneeded=1, U contains left singular vectors (first
'                        min(M,N) columns of matrix U). Array whose indexes range
'                        within [0..M-1, 0..Min(M,N)-1].
'                        if UNeeded=2, U contains matrix U wholly. Array whose
'                        indexes range within [0..M-1, 0..M-1].
'        VT          -   if VTNeeded=0, VT isn changed, the right singular vectors
'                        are not calculated.
'                        if VTNeeded=1, VT contains right singular vectors (first
'                        min(M,N) rows of matrix V^T). Array whose indexes range
'                        within [0..min(M,N)-1, 0..N-1].
'                        if VTNeeded=2, VT contains matrix V^T wholly. Array whose
'                        indexes range within [0..N-1, 0..N-1].
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function rmatrixsvd(a As Double(,), m As Integer, n As Integer, uneeded As Integer, vtneeded As Integer, additionalmemory As Integer, _
		ByRef w As Double(), ByRef u As Double(,), ByRef vt As Double(,)) As Boolean
		w = New Double(-1) {}
		u = New Double(-1, -1) {}
		vt = New Double(-1, -1) {}
		Dim result As Boolean = svd.rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory, _
			w, u, vt)
		Return result
	End Function


	Public Shared Function smp_rmatrixsvd(a As Double(,), m As Integer, n As Integer, uneeded As Integer, vtneeded As Integer, additionalmemory As Integer, _
		ByRef w As Double(), ByRef u As Double(,), ByRef vt As Double(,)) As Boolean
		w = New Double(-1) {}
		u = New Double(-1, -1) {}
		vt = New Double(-1, -1) {}
		Dim result As Boolean = svd._pexec_rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory, _
			w, u, vt)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Finding the eigenvalues and eigenvectors of a symmetric matrix
'
'    The algorithm finds eigen pairs of a symmetric matrix by reducing it to
'    tridiagonal form and using the QL/QR algorithm.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   symmetric matrix which is given by its upper or lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'        IsUpper -   storage format.
'
'    Output parameters:
'        D       -   eigenvalues in ascending order.
'                    Array whose index ranges within [0..N-1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains the eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'                    The eigenvectors are stored in the matrix columns.
'
'    Result:
'        True, if the algorithm has converged.
'        False, if the algorithm hasn't converged (rare case).
'
'      -- ALGLIB --
'         Copyright 2005-2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixevd(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, ByRef d As Double(), ByRef z As Double(,)) As Boolean
		d = New Double(-1) {}
		z = New Double(-1, -1) {}
		Dim result As Boolean = evd.smatrixevd(a, n, zneeded, isupper, d, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
'    matrix  in  a  given half open interval (A, B] by using  a  bisection  and
'    inverse iteration
'
'    Input parameters:
'        A       -   symmetric matrix which is given by its upper or lower
'                    triangular part. Array [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'        IsUpperA -  storage format of matrix A.
'        B1, B2 -    half open interval (B1, B2] to search eigenvalues in.
'
'    Output parameters:
'        M       -   number of eigenvalues found in a given half-interval (M>=0).
'        W       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..M-1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..M-1].
'                    The eigenvectors are stored in the matrix columns.
'
'    Result:
'        True, if successful. M contains the number of eigenvalues in the given
'        half-interval (could be equal to 0), W contains the eigenvalues,
'        Z contains the eigenvectors (if needed).
'
'        False, if the bisection method subroutine wasn't able to find the
'        eigenvalues in the given interval or if the inverse iteration subroutine
'        wasn't able to find all the corresponding eigenvectors.
'        In that case, the eigenvalues and eigenvectors are not returned,
'        M is equal to 0.
'
'      -- ALGLIB --
'         Copyright 07.01.2006 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixevdr(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, b1 As Double, b2 As Double, _
		ByRef m As Integer, ByRef w As Double(), ByRef z As Double(,)) As Boolean
		m = 0
		w = New Double(-1) {}
		z = New Double(-1, -1) {}
		Dim result As Boolean = evd.smatrixevdr(a, n, zneeded, isupper, b1, b2, _
			m, w, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
'    matrix with given indexes by using bisection and inverse iteration methods.
'
'    Input parameters:
'        A       -   symmetric matrix which is given by its upper or lower
'                    triangular part. Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'        IsUpperA -  storage format of matrix A.
'        I1, I2 -    index interval for searching (from I1 to I2).
'                    0 <= I1 <= I2 <= N-1.
'
'    Output parameters:
'        W       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..I2-I1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..I2-I1].
'                    In that case, the eigenvectors are stored in the matrix columns.
'
'    Result:
'        True, if successful. W contains the eigenvalues, Z contains the
'        eigenvectors (if needed).
'
'        False, if the bisection method subroutine wasn't able to find the
'        eigenvalues in the given interval or if the inverse iteration subroutine
'        wasn't able to find all the corresponding eigenvectors.
'        In that case, the eigenvalues and eigenvectors are not returned.
'
'      -- ALGLIB --
'         Copyright 07.01.2006 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixevdi(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, i1 As Integer, i2 As Integer, _
		ByRef w As Double(), ByRef z As Double(,)) As Boolean
		w = New Double(-1) {}
		z = New Double(-1, -1) {}
		Dim result As Boolean = evd.smatrixevdi(a, n, zneeded, isupper, i1, i2, _
			w, z)
		Return result
	End Function

	'************************************************************************
'    Finding the eigenvalues and eigenvectors of a Hermitian matrix
'
'    The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
'    real tridiagonal form and using the QL/QR algorithm.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   storage format.
'        ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                    not. If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'
'    Output parameters:
'        D       -   eigenvalues in ascending order.
'                    Array whose index ranges within [0..N-1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains the eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'                    The eigenvectors are stored in the matrix columns.
'
'    Result:
'        True, if the algorithm has converged.
'        False, if the algorithm hasn't converged (rare case).
'
'    Note:
'        eigenvectors of Hermitian matrix are defined up to  multiplication  by
'        a complex number L, such that |L|=1.
'
'      -- ALGLIB --
'         Copyright 2005, 23 March 2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function hmatrixevd(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, ByRef d As Double(), ByRef z As complex(,)) As Boolean
		d = New Double(-1) {}
		z = New complex(-1, -1) {}
		Dim result As Boolean = evd.hmatrixevd(a, n, zneeded, isupper, d, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
'    matrix  in  a  given half-interval (A, B] by using a bisection and inverse
'    iteration
'
'    Input parameters:
'        A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                    triangular  part.  Array  whose   indexes   range   within
'                    [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                    not. If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'        IsUpperA -  storage format of matrix A.
'        B1, B2 -    half-interval (B1, B2] to search eigenvalues in.
'
'    Output parameters:
'        M       -   number of eigenvalues found in a given half-interval, M>=0
'        W       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..M-1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..M-1].
'                    The eigenvectors are stored in the matrix columns.
'
'    Result:
'        True, if successful. M contains the number of eigenvalues in the given
'        half-interval (could be equal to 0), W contains the eigenvalues,
'        Z contains the eigenvectors (if needed).
'
'        False, if the bisection method subroutine  wasn't  able  to  find  the
'        eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'        subroutine  wasn't  able  to  find all the corresponding eigenvectors.
'        In that case, the eigenvalues and eigenvectors are not returned, M  is
'        equal to 0.
'
'    Note:
'        eigen vectors of Hermitian matrix are defined up to multiplication  by
'        a complex number L, such as |L|=1.
'
'      -- ALGLIB --
'         Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'    ************************************************************************

	Public Shared Function hmatrixevdr(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, b1 As Double, b2 As Double, _
		ByRef m As Integer, ByRef w As Double(), ByRef z As complex(,)) As Boolean
		m = 0
		w = New Double(-1) {}
		z = New complex(-1, -1) {}
		Dim result As Boolean = evd.hmatrixevdr(a, n, zneeded, isupper, b1, b2, _
			m, w, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
'    matrix with given indexes by using bisection and inverse iteration methods
'
'    Input parameters:
'        A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                    triangular part.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                    not. If ZNeeded is equal to:
'                     * 0, the eigenvectors are not returned;
'                     * 1, the eigenvectors are returned.
'        IsUpperA -  storage format of matrix A.
'        I1, I2 -    index interval for searching (from I1 to I2).
'                    0 <= I1 <= I2 <= N-1.
'
'    Output parameters:
'        W       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..I2-I1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains eigenvectors.
'                    Array whose indexes range within [0..N-1, 0..I2-I1].
'                    In  that  case,  the eigenvectors are stored in the matrix
'                    columns.
'
'    Result:
'        True, if successful. W contains the eigenvalues, Z contains the
'        eigenvectors (if needed).
'
'        False, if the bisection method subroutine  wasn't  able  to  find  the
'        eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'        subroutine wasn't able to find  all  the  corresponding  eigenvectors.
'        In that case, the eigenvalues and eigenvectors are not returned.
'
'    Note:
'        eigen vectors of Hermitian matrix are defined up to multiplication  by
'        a complex number L, such as |L|=1.
'
'      -- ALGLIB --
'         Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'    ************************************************************************

	Public Shared Function hmatrixevdi(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, i1 As Integer, i2 As Integer, _
		ByRef w As Double(), ByRef z As complex(,)) As Boolean
		w = New Double(-1) {}
		z = New complex(-1, -1) {}
		Dim result As Boolean = evd.hmatrixevdi(a, n, zneeded, isupper, i1, i2, _
			w, z)
		Return result
	End Function

	'************************************************************************
'    Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix
'
'    The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
'    using an QL/QR algorithm with implicit shifts.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        D       -   the main diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-1].
'        E       -   the secondary diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-2].
'        N       -   size of matrix A.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not needed;
'                     * 1, the eigenvectors of a tridiagonal matrix
'                       are multiplied by the square matrix Z. It is used if the
'                       tridiagonal matrix is obtained by the similarity
'                       transformation of a symmetric matrix;
'                     * 2, the eigenvectors of a tridiagonal matrix replace the
'                       square matrix Z;
'                     * 3, matrix Z contains the first row of the eigenvectors
'                       matrix.
'        Z       -   if ZNeeded=1, Z contains the square matrix by which the
'                    eigenvectors are multiplied.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'
'    Output parameters:
'        D       -   eigenvalues in ascending order.
'                    Array whose index ranges within [0..N-1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z hasn changed;
'                     * 1, Z contains the product of a given matrix (from the left)
'                       and the eigenvectors matrix (from the right);
'                     * 2, Z contains the eigenvectors.
'                     * 3, Z contains the first row of the eigenvectors matrix.
'                    If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
'                    In that case, the eigenvectors are stored in the matrix columns.
'                    If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].
'
'    Result:
'        True, if the algorithm has converged.
'        False, if the algorithm hasn't converged.
'
'      -- LAPACK routine (version 3.0) --
'         Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'         Courant Institute, Argonne National Lab, and Rice University
'         September 30, 1994
'    ************************************************************************

	Public Shared Function smatrixtdevd(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, ByRef z As Double(,)) As Boolean

		Dim result As Boolean = evd.smatrixtdevd(d, e, n, zneeded, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
'    given half-interval (A, B] by using bisection and inverse iteration.
'
'    Input parameters:
'        D       -   the main diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-1].
'        E       -   the secondary diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-2].
'        N       -   size of matrix, N>=0.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not needed;
'                     * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                       by the square matrix Z. It is used if the tridiagonal
'                       matrix is obtained by the similarity transformation
'                       of a symmetric matrix.
'                     * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
'        A, B    -   half-interval (A, B] to search eigenvalues in.
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z isn't used and remains unchanged;
'                     * 1, Z contains the square matrix (array whose indexes range
'                       within [0..N-1, 0..N-1]) which reduces the given symmetric
'                       matrix to tridiagonal form;
'                     * 2, Z isn't used (but changed on the exit).
'
'    Output parameters:
'        D       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..M-1].
'        M       -   number of eigenvalues found in the given half-interval (M>=0).
'        Z       -   if ZNeeded is equal to:
'                     * 0, doesn't contain any information;
'                     * 1, contains the product of a given NxN matrix Z (from the
'                       left) and NxM matrix of the eigenvectors found (from the
'                       right). Array whose indexes range within [0..N-1, 0..M-1].
'                     * 2, contains the matrix of the eigenvectors found.
'                       Array whose indexes range within [0..N-1, 0..M-1].
'
'    Result:
'
'        True, if successful. In that case, M contains the number of eigenvalues
'        in the given half-interval (could be equal to 0), D contains the eigenvalues,
'        Z contains the eigenvectors (if needed).
'        It should be noted that the subroutine changes the size of arrays D and Z.
'
'        False, if the bisection method subroutine wasn't able to find the
'        eigenvalues in the given interval or if the inverse iteration subroutine
'        wasn't able to find all the corresponding eigenvectors. In that case,
'        the eigenvalues and eigenvectors are not returned, M is equal to 0.
'
'      -- ALGLIB --
'         Copyright 31.03.2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixtdevdr(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, a As Double, b As Double, _
		ByRef m As Integer, ByRef z As Double(,)) As Boolean
		m = 0
		Dim result As Boolean = evd.smatrixtdevdr(d, e, n, zneeded, a, b, _
			m, z)
		Return result
	End Function

	'************************************************************************
'    Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
'    indexes (in ascending order) by using the bisection and inverse iteraion.
'
'    Input parameters:
'        D       -   the main diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-1].
'        E       -   the secondary diagonal of a tridiagonal matrix.
'                    Array whose index ranges within [0..N-2].
'        N       -   size of matrix. N>=0.
'        ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                    If ZNeeded is equal to:
'                     * 0, the eigenvectors are not needed;
'                     * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                       by the square matrix Z. It is used if the
'                       tridiagonal matrix is obtained by the similarity transformation
'                       of a symmetric matrix.
'                     * 2, the eigenvectors of a tridiagonal matrix replace
'                       matrix Z.
'        I1, I2  -   index interval for searching (from I1 to I2).
'                    0 <= I1 <= I2 <= N-1.
'        Z       -   if ZNeeded is equal to:
'                     * 0, Z isn't used and remains unchanged;
'                     * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
'                       which reduces the given symmetric matrix to  tridiagonal form;
'                     * 2, Z isn't used (but changed on the exit).
'
'    Output parameters:
'        D       -   array of the eigenvalues found.
'                    Array whose index ranges within [0..I2-I1].
'        Z       -   if ZNeeded is equal to:
'                     * 0, doesn't contain any information;
'                     * 1, contains the product of a given NxN matrix Z (from the left) and
'                       Nx(I2-I1) matrix of the eigenvectors found (from the right).
'                       Array whose indexes range within [0..N-1, 0..I2-I1].
'                     * 2, contains the matrix of the eigenvalues found.
'                       Array whose indexes range within [0..N-1, 0..I2-I1].
'
'
'    Result:
'
'        True, if successful. In that case, D contains the eigenvalues,
'        Z contains the eigenvectors (if needed).
'        It should be noted that the subroutine changes the size of arrays D and Z.
'
'        False, if the bisection method subroutine wasn't able to find the eigenvalues
'        in the given interval or if the inverse iteration subroutine wasn't able
'        to find all the corresponding eigenvectors. In that case, the eigenvalues
'        and eigenvectors are not returned.
'
'      -- ALGLIB --
'         Copyright 25.12.2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixtdevdi(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, i1 As Integer, i2 As Integer, _
		ByRef z As Double(,)) As Boolean

		Dim result As Boolean = evd.smatrixtdevdi(d, e, n, zneeded, i1, i2, _
			z)
		Return result
	End Function

	'************************************************************************
'    Finding eigenvalues and eigenvectors of a general (unsymmetric) matrix
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison. Speed-up provided by MKL for this particular problem (EVD)
'      ! is really high, because  MKL  uses combination of (a) better low-level
'      ! optimizations, and (b) better EVD algorithms.
'      !
'      ! On one particular SSE-capable  machine  for  N=1024,  commercial  MKL-
'      ! -capable ALGLIB was:
'      ! * 7-10 times faster than open source "generic C" version
'      ! * 15-18 times faster than "pure C#" version
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    The algorithm finds eigenvalues and eigenvectors of a general matrix by
'    using the QR algorithm with multiple shifts. The algorithm can find
'    eigenvalues and both left and right eigenvectors.
'
'    The right eigenvector is a vector x such that A*x = w*x, and the left
'    eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
'    conjugate transposition of vector y).
'
'    Input parameters:
'        A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        VNeeded -   flag controlling whether eigenvectors are needed or not.
'                    If VNeeded is equal to:
'                     * 0, eigenvectors are not returned;
'                     * 1, right eigenvectors are returned;
'                     * 2, left eigenvectors are returned;
'                     * 3, both left and right eigenvectors are returned.
'
'    Output parameters:
'        WR      -   real parts of eigenvalues.
'                    Array whose index ranges within [0..N-1].
'        WR      -   imaginary parts of eigenvalues.
'                    Array whose index ranges within [0..N-1].
'        VL, VR  -   arrays of left and right eigenvectors (if they are needed).
'                    If WI[i]=0, the respective eigenvalue is a real number,
'                    and it corresponds to the column number I of matrices VL/VR.
'                    If WI[i]>0, we have a pair of complex conjugate numbers with
'                    positive and negative imaginary parts:
'                        the first eigenvalue WR[i] + sqrt(-1)*WI[i];
'                        the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
'                        WI[i]>0
'                        WI[i+1] = -WI[i] < 0
'                    In that case, the eigenvector  corresponding to the first
'                    eigenvalue is located in i and i+1 columns of matrices
'                    VL/VR (the column number i contains the real part, and the
'                    column number i+1 contains the imaginary part), and the vector
'                    corresponding to the second eigenvalue is a complex conjugate to
'                    the first vector.
'                    Arrays whose indexes range within [0..N-1, 0..N-1].
'
'    Result:
'        True, if the algorithm has converged.
'        False, if the algorithm has not converged.
'
'    Note 1:
'        Some users may ask the following question: what if WI[N-1]>0?
'        WI[N] must contain an eigenvalue which is complex conjugate to the
'        N-th eigenvalue, but the array has only size N?
'        The answer is as follows: such a situation cannot occur because the
'        algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
'        strictly less than N-1.
'
'    Note 2:
'        The algorithm performance depends on the value of the internal parameter
'        NS of the InternalSchurDecomposition subroutine which defines the number
'        of shifts in the QR algorithm (similarly to the block width in block-matrix
'        algorithms of linear algebra). If you require maximum performance
'        on your machine, it is recommended to adjust this parameter manually.
'
'
'    See also the InternalTREVC subroutine.
'
'    The algorithm is based on the LAPACK 3.0 library.
'    ************************************************************************

	Public Shared Function rmatrixevd(a As Double(,), n As Integer, vneeded As Integer, ByRef wr As Double(), ByRef wi As Double(), ByRef vl As Double(,), _
		ByRef vr As Double(,)) As Boolean
		wr = New Double(-1) {}
		wi = New Double(-1) {}
		vl = New Double(-1, -1) {}
		vr = New Double(-1, -1) {}
		Dim result As Boolean = evd.rmatrixevd(a, n, vneeded, wr, wi, vl, _
			vr)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Generation of a random uniformly distributed (Haar) orthogonal matrix
'
'    INPUT PARAMETERS:
'        N   -   matrix size, N>=1
'
'    OUTPUT PARAMETERS:
'        A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'    NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
'          "The Efficient Generation of  Random  Orthogonal  Matrices  with  an
'          Application to Condition Estimators".
'
'          Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
'          * takes an NxN one
'          * takes uniformly distributed unit vector of dimension N+1.
'          * constructs a Householder reflection from the vector, then applies
'            it to the smaller matrix (embedded in the larger size with a 1 at
'            the bottom right corner).
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixrndorthogonal(n As Integer, ByRef a As Double(,))
		a = New Double(-1, -1) {}
		matgen.rmatrixrndorthogonal(n, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN matrix with given condition number and norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
		a = New Double(-1, -1) {}
		matgen.rmatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Generation of a random Haar distributed orthogonal complex matrix
'
'    INPUT PARAMETERS:
'        N   -   matrix size, N>=1
'
'    OUTPUT PARAMETERS:
'        A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'    NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
'          "The Efficient Generation of  Random  Orthogonal  Matrices  with  an
'          Application to Condition Estimators".
'
'          Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
'          * takes an NxN one
'          * takes uniformly distributed unit vector of dimension N+1.
'          * constructs a Householder reflection from the vector, then applies
'            it to the smaller matrix (embedded in the larger size with a 1 at
'            the bottom right corner).
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixrndorthogonal(n As Integer, ByRef a As complex(,))
		a = New complex(-1, -1) {}
		matgen.cmatrixrndorthogonal(n, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN complex matrix with given condition number C and
'    norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
		a = New complex(-1, -1) {}
		matgen.cmatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN symmetric matrix with given condition number  and
'    norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub smatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
		a = New Double(-1, -1) {}
		matgen.smatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN symmetric positive definite matrix with given
'    condition number and norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random SPD matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spdmatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
		a = New Double(-1, -1) {}
		matgen.spdmatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN Hermitian matrix with given condition number  and
'    norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
		a = New complex(-1, -1) {}
		matgen.hmatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Generation of random NxN Hermitian positive definite matrix with given
'    condition number and norm2(A)=1
'
'    INPUT PARAMETERS:
'        N   -   matrix size
'        C   -   condition number (in 2-norm)
'
'    OUTPUT PARAMETERS:
'        A   -   random HPD matrix with norm2(A)=1 and cond(A)=C
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hpdmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
		a = New complex(-1, -1) {}
		matgen.hpdmatrixrndcond(n, c, a)
		Return
	End Sub

	'************************************************************************
'    Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..M-1, 0..N-1]
'        M, N-   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   A*Q, where Q is random NxN orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixrndorthogonalfromtheright(ByRef a As Double(,), m As Integer, n As Integer)

		matgen.rmatrixrndorthogonalfromtheright(a, m, n)
		Return
	End Sub

	'************************************************************************
'    Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..M-1, 0..N-1]
'        M, N-   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   Q*A, where Q is random MxM orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixrndorthogonalfromtheleft(ByRef a As Double(,), m As Integer, n As Integer)

		matgen.rmatrixrndorthogonalfromtheleft(a, m, n)
		Return
	End Sub

	'************************************************************************
'    Multiplication of MxN complex matrix by NxN random Haar distributed
'    complex orthogonal matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..M-1, 0..N-1]
'        M, N-   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   A*Q, where Q is random NxN orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixrndorthogonalfromtheright(ByRef a As complex(,), m As Integer, n As Integer)

		matgen.cmatrixrndorthogonalfromtheright(a, m, n)
		Return
	End Sub

	'************************************************************************
'    Multiplication of MxN complex matrix by MxM random Haar distributed
'    complex orthogonal matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..M-1, 0..N-1]
'        M, N-   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   Q*A, where Q is random MxM orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixrndorthogonalfromtheleft(ByRef a As complex(,), m As Integer, n As Integer)

		matgen.cmatrixrndorthogonalfromtheleft(a, m, n)
		Return
	End Sub

	'************************************************************************
'    Symmetric multiplication of NxN matrix by random Haar distributed
'    orthogonal  matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..N-1, 0..N-1]
'        N   -   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   Q'*A*Q, where Q is random NxN orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub smatrixrndmultiply(ByRef a As Double(,), n As Integer)

		matgen.smatrixrndmultiply(a, n)
		Return
	End Sub

	'************************************************************************
'    Hermitian multiplication of NxN matrix by random Haar distributed
'    complex orthogonal matrix
'
'    INPUT PARAMETERS:
'        A   -   matrix, array[0..N-1, 0..N-1]
'        N   -   matrix size
'
'    OUTPUT PARAMETERS:
'        A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix
'
'      -- ALGLIB routine --
'         04.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hmatrixrndmultiply(ByRef a As complex(,), n As Integer)

		matgen.hmatrixrndmultiply(a, n)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Sparse matrix structure.
'
'    You should use ALGLIB functions to work with sparse matrix. Never  try  to
'    access its fields directly!
'
'    NOTES ON THE SPARSE STORAGE FORMATS
'
'    Sparse matrices can be stored using several formats:
'    * Hash-Table representation
'    * Compressed Row Storage (CRS)
'    * Skyline matrix storage (SKS)
'
'    Each of the formats has benefits and drawbacks:
'    * Hash-table is good for dynamic operations (insertion of new elements),
'      but does not support linear algebra operations
'    * CRS is good for operations like matrix-vector or matrix-matrix products,
'      but its initialization is less convenient - you have to tell row   sizes
'      at the initialization, and you have to fill  matrix  only  row  by  row,
'      from left to right.
'    * SKS is a special format which is used to store triangular  factors  from
'      Cholesky factorization. It does not support  dynamic  modification,  and
'      support for linear algebra operations is very limited.
'
'    Tables below outline information about these two formats:
'
'        OPERATIONS WITH MATRIX      HASH        CRS         SKS
'        creation                    +           +           +
'        SparseGet                   +           +           +
'        SparseRewriteExisting       +           +           +
'        SparseSet                   +
'        SparseAdd                   +
'        SparseGetRow                            +           +
'        SparseGetCompressedRow                  +           +
'        sparse-dense linear algebra             +           +
'    ************************************************************************

	Public Class sparsematrix
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New sparse.sparsematrix()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New sparsematrix(DirectCast(_innerobj.make_copy(), sparse.sparsematrix))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As sparse.sparsematrix
		Public ReadOnly Property innerobj() As sparse.sparsematrix
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As sparse.sparsematrix)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Temporary buffers for sparse matrix operations.
'
'    You should pass an instance of this structure to factorization  functions.
'    It allows to reuse memory during repeated sparse  factorizations.  You  do
'    not have to call some initialization function - simply passing an instance
'    to factorization function is enough.
'    ************************************************************************

	Public Class sparsebuffers
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New sparse.sparsebuffers()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New sparsebuffers(DirectCast(_innerobj.make_copy(), sparse.sparsebuffers))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As sparse.sparsebuffers
		Public ReadOnly Property innerobj() As sparse.sparsebuffers
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As sparse.sparsebuffers)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This function creates sparse matrix in a Hash-Table format.
'
'    This function creates Hast-Table matrix, which can be  converted  to  CRS
'    format after its initialization is over. Typical  usage  scenario  for  a
'    sparse matrix is:
'    1. creation in a Hash-Table format
'    2. insertion of the matrix elements
'    3. conversion to the CRS representation
'    4. matrix is passed to some linear algebra algorithm
'
'    Some  information  about  different matrix formats can be found below, in
'    the "NOTES" section.
'
'    INPUT PARAMETERS
'        M           -   number of rows in a matrix, M>=1
'        N           -   number of columns in a matrix, N>=1
'        K           -   K>=0, expected number of non-zero elements in a matrix.
'                        K can be inexact approximation, can be less than actual
'                        number  of  elements  (table will grow when needed) or
'                        even zero).
'                        It is important to understand that although hash-table
'                        may grow automatically, it is better to  provide  good
'                        estimate of data size.
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table representation.
'                        All elements of the matrix are zero.
'
'    NOTE 1
'
'    Hash-tables use memory inefficiently, and they have to keep  some  amount
'    of the "spare memory" in order to have good performance. Hash  table  for
'    matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
'    where C is a small constant, about 1.5-2 in magnitude.
'
'    CRS storage, from the other side, is  more  memory-efficient,  and  needs
'    just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
'    in a matrix.
'
'    When you convert from the Hash-Table to CRS  representation, all unneeded
'    memory will be freed.
'
'    NOTE 2
'
'    Comments of SparseMatrix structure outline  information  about  different
'    sparse storage formats. We recommend you to read them before starting  to
'    use ALGLIB sparse matrices.
'
'    NOTE 3
'
'    This function completely  overwrites S with new sparse matrix. Previously
'    allocated storage is NOT reused. If you  want  to reuse already allocated
'    memory, call SparseCreateBuf function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreate(m As Integer, n As Integer, k As Integer, ByRef s As sparsematrix)
		s = New sparsematrix()
		sparse.sparsecreate(m, n, k, s.innerobj)
		Return
	End Sub
	Public Shared Sub sparsecreate(m As Integer, n As Integer, ByRef s As sparsematrix)
		Dim k As Integer

		s = New sparsematrix()
		k = 0
		sparse.sparsecreate(m, n, k, s.innerobj)

		Return
	End Sub

	'************************************************************************
'    This version of SparseCreate function creates sparse matrix in Hash-Table
'    format, reusing previously allocated storage as much  as  possible.  Read
'    comments for SparseCreate() for more information.
'
'    INPUT PARAMETERS
'        M           -   number of rows in a matrix, M>=1
'        N           -   number of columns in a matrix, N>=1
'        K           -   K>=0, expected number of non-zero elements in a matrix.
'                        K can be inexact approximation, can be less than actual
'                        number  of  elements  (table will grow when needed) or
'                        even zero).
'                        It is important to understand that although hash-table
'                        may grow automatically, it is better to  provide  good
'                        estimate of data size.
'        S           -   SparseMatrix structure which MAY contain some  already
'                        allocated storage.
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table representation.
'                        All elements of the matrix are zero.
'                        Previously allocated storage is reused, if  its  size
'                        is compatible with expected number of non-zeros K.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreatebuf(m As Integer, n As Integer, k As Integer, s As sparsematrix)

		sparse.sparsecreatebuf(m, n, k, s.innerobj)
		Return
	End Sub
	Public Shared Sub sparsecreatebuf(m As Integer, n As Integer, s As sparsematrix)
		Dim k As Integer


		k = 0
		sparse.sparsecreatebuf(m, n, k, s.innerobj)

		Return
	End Sub

	'************************************************************************
'    This function creates sparse matrix in a CRS format (expert function for
'    situations when you are running out of memory).
'
'    This function creates CRS matrix. Typical usage scenario for a CRS matrix
'    is:
'    1. creation (you have to tell number of non-zero elements at each row  at
'       this moment)
'    2. insertion of the matrix elements (row by row, from left to right)
'    3. matrix is passed to some linear algebra algorithm
'
'    This function is a memory-efficient alternative to SparseCreate(), but it
'    is more complex because it requires you to know in advance how large your
'    matrix is. Some  information about  different matrix formats can be found
'    in comments on SparseMatrix structure.  We recommend  you  to  read  them
'    before starting to use ALGLIB sparse matrices..
'
'    INPUT PARAMETERS
'        M           -   number of rows in a matrix, M>=1
'        N           -   number of columns in a matrix, N>=1
'        NER         -   number of elements at each row, array[M], NER[I]>=0
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS representation.
'                        You have to fill ALL non-zero elements by calling
'                        SparseSet() BEFORE you try to use this matrix.
'
'    NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
'          Previously allocated storage is NOT reused. If you  want  to  reuse
'          already allocated memory, call SparseCreateCRSBuf function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreatecrs(m As Integer, n As Integer, ner As Integer(), ByRef s As sparsematrix)
		s = New sparsematrix()
		sparse.sparsecreatecrs(m, n, ner, s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function creates sparse matrix in a CRS format (expert function  for
'    situations when you are running out  of  memory).  This  version  of  CRS
'    matrix creation function may reuse memory already allocated in S.
'
'    This function creates CRS matrix. Typical usage scenario for a CRS matrix
'    is:
'    1. creation (you have to tell number of non-zero elements at each row  at
'       this moment)
'    2. insertion of the matrix elements (row by row, from left to right)
'    3. matrix is passed to some linear algebra algorithm
'
'    This function is a memory-efficient alternative to SparseCreate(), but it
'    is more complex because it requires you to know in advance how large your
'    matrix is. Some  information about  different matrix formats can be found
'    in comments on SparseMatrix structure.  We recommend  you  to  read  them
'    before starting to use ALGLIB sparse matrices..
'
'    INPUT PARAMETERS
'        M           -   number of rows in a matrix, M>=1
'        N           -   number of columns in a matrix, N>=1
'        NER         -   number of elements at each row, array[M], NER[I]>=0
'        S           -   sparse matrix structure with possibly preallocated
'                        memory.
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS representation.
'                        You have to fill ALL non-zero elements by calling
'                        SparseSet() BEFORE you try to use this matrix.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreatecrsbuf(m As Integer, n As Integer, ner As Integer(), s As sparsematrix)

		sparse.sparsecreatecrsbuf(m, n, ner, s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function creates sparse matrix in  a  SKS  format  (skyline  storage
'    format). In most cases you do not need this function - CRS format  better
'    suits most use cases.
'
'    INPUT PARAMETERS
'        M, N        -   number of rows(M) and columns (N) in a matrix:
'                        * M=N (as for now, ALGLIB supports only square SKS)
'                        * N>=1
'                        * M>=1
'        D           -   "bottom" bandwidths, array[M], D[I]>=0.
'                        I-th element stores number of non-zeros at I-th  row,
'                        below the diagonal (diagonal itself is not  included)
'        U           -   "top" bandwidths, array[N], U[I]>=0.
'                        I-th element stores number of non-zeros  at I-th row,
'                        above the diagonal (diagonal itself  is not included)
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in SKS representation.
'                        All elements are filled by zeros.
'                        You may use SparseRewriteExisting() to  change  their
'                        values.
'
'    NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
'          Previously allocated storage is NOT reused. If you  want  to  reuse
'          already allocated memory, call SparseCreateSKSBuf function.
'
'      -- ALGLIB PROJECT --
'         Copyright 13.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreatesks(m As Integer, n As Integer, d As Integer(), u As Integer(), ByRef s As sparsematrix)
		s = New sparsematrix()
		sparse.sparsecreatesks(m, n, d, u, s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This is "buffered"  version  of  SparseCreateSKS()  which  reuses  memory
'    previously allocated in S (of course, memory is reallocated if needed).
'
'    This function creates sparse matrix in  a  SKS  format  (skyline  storage
'    format). In most cases you do not need this function - CRS format  better
'    suits most use cases.
'
'    INPUT PARAMETERS
'        M, N        -   number of rows(M) and columns (N) in a matrix:
'                        * M=N (as for now, ALGLIB supports only square SKS)
'                        * N>=1
'                        * M>=1
'        D           -   "bottom" bandwidths, array[M], 0<=D[I]<=I.
'                        I-th element stores number of non-zeros at I-th row,
'                        below the diagonal (diagonal itself is not included)
'        U           -   "top" bandwidths, array[N], 0<=U[I]<=I.
'                        I-th element stores number of non-zeros at I-th row,
'                        above the diagonal (diagonal itself is not included)
'
'    OUTPUT PARAMETERS
'        S           -   sparse M*N matrix in SKS representation.
'                        All elements are filled by zeros.
'                        You may use SparseSet()/SparseAdd() to change their
'                        values.
'
'      -- ALGLIB PROJECT --
'         Copyright 13.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecreatesksbuf(m As Integer, n As Integer, d As Integer(), u As Integer(), s As sparsematrix)

		sparse.sparsecreatesksbuf(m, n, d, u, s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function copies S0 to S1.
'    This function completely deallocates memory owned by S1 before creating a
'    copy of S0. If you want to reuse memory, use SparseCopyBuf.
'
'    NOTE:  this  function  does  not verify its arguments, it just copies all
'    fields of the structure.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopy(s0 As sparsematrix, ByRef s1 As sparsematrix)
		s1 = New sparsematrix()
		sparse.sparsecopy(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function copies S0 to S1.
'    Memory already allocated in S1 is reused as much as possible.
'
'    NOTE:  this  function  does  not verify its arguments, it just copies all
'    fields of the structure.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopybuf(s0 As sparsematrix, s1 As sparsematrix)

		sparse.sparsecopybuf(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function efficiently swaps contents of S0 and S1.
'
'      -- ALGLIB PROJECT --
'         Copyright 16.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseswap(s0 As sparsematrix, s1 As sparsematrix)

		sparse.sparseswap(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function adds value to S[i,j] - element of the sparse matrix. Matrix
'    must be in a Hash-Table mode.
'
'    In case S[i,j] already exists in the table, V i added to  its  value.  In
'    case  S[i,j]  is  non-existent,  it  is  inserted  in  the  table.  Table
'    automatically grows when necessary.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table representation.
'                        Exception will be thrown for CRS matrix.
'        I           -   row index of the element to modify, 0<=I<M
'        J           -   column index of the element to modify, 0<=J<N
'        V           -   value to add, must be finite number
'
'    OUTPUT PARAMETERS
'        S           -   modified matrix
'
'    NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted
'    from the table.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseadd(s As sparsematrix, i As Integer, j As Integer, v As Double)

		sparse.sparseadd(s.innerobj, i, j, v)
		Return
	End Sub

	'************************************************************************
'    This function modifies S[i,j] - element of the sparse matrix.
'
'    For Hash-based storage format:
'    * this function can be called at any moment - during matrix initialization
'      or later
'    * new value can be zero or non-zero.  In case new value of S[i,j] is zero,
'      this element is deleted from the table.
'    * this  function  has  no  effect when called with zero V for non-existent
'      element.
'
'    For CRS-bases storage format:
'    * this function can be called ONLY DURING MATRIX INITIALIZATION
'    * new value MUST be non-zero. Exception will be thrown for zero V.
'    * elements must be initialized in correct order -  from top row to bottom,
'      within row - from left to right.
'
'    For SKS storage: NOT SUPPORTED! Use SparseRewriteExisting() to  work  with
'    SKS matrices.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table or CRS representation.
'        I           -   row index of the element to modify, 0<=I<M
'        J           -   column index of the element to modify, 0<=J<N
'        V           -   value to set, must be finite number, can be zero
'
'    OUTPUT PARAMETERS
'        S           -   modified matrix
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseset(s As sparsematrix, i As Integer, j As Integer, v As Double)

		sparse.sparseset(s.innerobj, i, j, v)
		Return
	End Sub

	'************************************************************************
'    This function returns S[i,j] - element of the sparse matrix.  Matrix  can
'    be in any mode (Hash-Table, CRS, SKS), but this function is less efficient
'    for CRS matrices. Hash-Table and SKS matrices can find  element  in  O(1)
'    time, while  CRS  matrices need O(log(RS)) time, where RS is an number of
'    non-zero elements in a row.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table representation.
'                        Exception will be thrown for CRS matrix.
'        I           -   row index of the element to modify, 0<=I<M
'        J           -   column index of the element to modify, 0<=J<N
'
'    RESULT
'        value of S[I,J] or zero (in case no element with such index is found)
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparseget(s As sparsematrix, i As Integer, j As Integer) As Double

		Dim result As Double = sparse.sparseget(s.innerobj, i, j)
		Return result
	End Function

	'************************************************************************
'    This function returns I-th diagonal element of the sparse matrix.
'
'    Matrix can be in any mode (Hash-Table or CRS storage), but this  function
'    is most efficient for CRS matrices - it requires less than 50 CPU  cycles
'    to extract diagonal element. For Hash-Table matrices we still  have  O(1)
'    query time, but function is many times slower.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table representation.
'                        Exception will be thrown for CRS matrix.
'        I           -   index of the element to modify, 0<=I<min(M,N)
'
'    RESULT
'        value of S[I,I] or zero (in case no element with such index is found)
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetdiagonal(s As sparsematrix, i As Integer) As Double

		Dim result As Double = sparse.sparsegetdiagonal(s.innerobj, i)
		Return result
	End Function

	'************************************************************************
'    This function calculates matrix-vector product  S*x.  Matrix  S  must  be
'    stored in CRS or SKS format (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS or SKS format.
'        X           -   array[N], input vector. For  performance  reasons  we
'                        make only quick checks - we check that array size  is
'                        at least N, but we do not check for NAN's or INF's.
'        Y           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        Y           -   array[M], S*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemv(s As sparsematrix, x As Double(), ByRef y As Double())

		sparse.sparsemv(s.innerobj, x, y)
		Return
	End Sub

	'************************************************************************
'    This function calculates matrix-vector product  S^T*x. Matrix S  must  be
'    stored in CRS or SKS format (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS or SKS format.
'        X           -   array[M], input vector. For  performance  reasons  we
'                        make only quick checks - we check that array size  is
'                        at least M, but we do not check for NAN's or INF's.
'        Y           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        Y           -   array[N], S^T*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemtv(s As sparsematrix, x As Double(), ByRef y As Double())

		sparse.sparsemtv(s.innerobj, x, y)
		Return
	End Sub

	'************************************************************************
'    This function simultaneously calculates two matrix-vector products:
'        S*x and S^T*x.
'    S must be square (non-rectangular) matrix stored in  CRS  or  SKS  format
'    (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse N*N matrix in CRS or SKS format.
'        X           -   array[N], input vector. For  performance  reasons  we
'                        make only quick checks - we check that array size  is
'                        at least N, but we do not check for NAN's or INF's.
'        Y0          -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'        Y1          -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        Y0          -   array[N], S*x
'        Y1          -   array[N], S^T*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemv2(s As sparsematrix, x As Double(), ByRef y0 As Double(), ByRef y1 As Double())

		sparse.sparsemv2(s.innerobj, x, y0, y1)
		Return
	End Sub

	'************************************************************************
'    This function calculates matrix-vector product  S*x, when S is  symmetric
'    matrix. Matrix S  must be stored in CRS or SKS format  (exception will be
'    thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*M matrix in CRS or SKS format.
'        IsUpper     -   whether upper or lower triangle of S is given:
'                        * if upper triangle is given,  only   S[i,j] for j>=i
'                          are used, and lower triangle is ignored (it can  be
'                          empty - these elements are not referenced at all).
'                        * if lower triangle is given,  only   S[i,j] for j<=i
'                          are used, and upper triangle is ignored.
'        X           -   array[N], input vector. For  performance  reasons  we
'                        make only quick checks - we check that array size  is
'                        at least N, but we do not check for NAN's or INF's.
'        Y           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        Y           -   array[M], S*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsesmv(s As sparsematrix, isupper As Boolean, x As Double(), ByRef y As Double())

		sparse.sparsesmv(s.innerobj, isupper, x, y)
		Return
	End Sub

	'************************************************************************
'    This function calculates vector-matrix-vector product x'*S*x, where  S is
'    symmetric matrix. Matrix S must be stored in CRS or SKS format (exception
'    will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*M matrix in CRS or SKS format.
'        IsUpper     -   whether upper or lower triangle of S is given:
'                        * if upper triangle is given,  only   S[i,j] for j>=i
'                          are used, and lower triangle is ignored (it can  be
'                          empty - these elements are not referenced at all).
'                        * if lower triangle is given,  only   S[i,j] for j<=i
'                          are used, and upper triangle is ignored.
'        X           -   array[N], input vector. For  performance  reasons  we
'                        make only quick checks - we check that array size  is
'                        at least N, but we do not check for NAN's or INF's.
'
'    RESULT
'        x'*S*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 27.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsevsmv(s As sparsematrix, isupper As Boolean, x As Double()) As Double

		Dim result As Double = sparse.sparsevsmv(s.innerobj, isupper, x)
		Return result
	End Function

	'************************************************************************
'    This function calculates matrix-matrix product  S*A.  Matrix  S  must  be
'    stored in CRS or SKS format (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS or SKS format.
'        A           -   array[N][K], input dense matrix. For  performance reasons
'                        we make only quick checks - we check that array size
'                        is at least N, but we do not check for NAN's or INF's.
'        K           -   number of columns of matrix (A).
'        B           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        B           -   array[M][K], S*A
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemm(s As sparsematrix, a As Double(,), k As Integer, ByRef b As Double(,))

		sparse.sparsemm(s.innerobj, a, k, b)
		Return
	End Sub

	'************************************************************************
'    This function calculates matrix-matrix product  S^T*A. Matrix S  must  be
'    stored in CRS or SKS format (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in CRS or SKS format.
'        A           -   array[M][K], input dense matrix. For performance reasons
'                        we make only quick checks - we check that array size  is
'                        at least M, but we do not check for NAN's or INF's.
'        K           -   number of columns of matrix (A).
'        B           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        B           -   array[N][K], S^T*A
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemtm(s As sparsematrix, a As Double(,), k As Integer, ByRef b As Double(,))

		sparse.sparsemtm(s.innerobj, a, k, b)
		Return
	End Sub

	'************************************************************************
'    This function simultaneously calculates two matrix-matrix products:
'        S*A and S^T*A.
'    S  must  be  square (non-rectangular) matrix stored in CRS or  SKS  format
'    (exception will be thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse N*N matrix in CRS or SKS format.
'        A           -   array[N][K], input dense matrix. For performance reasons
'                        we make only quick checks - we check that array size  is
'                        at least N, but we do not check for NAN's or INF's.
'        K           -   number of columns of matrix (A).
'        B0          -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'        B1          -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        B0          -   array[N][K], S*A
'        B1          -   array[N][K], S^T*A
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsemm2(s As sparsematrix, a As Double(,), k As Integer, ByRef b0 As Double(,), ByRef b1 As Double(,))

		sparse.sparsemm2(s.innerobj, a, k, b0, b1)
		Return
	End Sub

	'************************************************************************
'    This function calculates matrix-matrix product  S*A, when S  is  symmetric
'    matrix. Matrix S must be stored in CRS or SKS format  (exception  will  be
'    thrown otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse M*M matrix in CRS or SKS format.
'        IsUpper     -   whether upper or lower triangle of S is given:
'                        * if upper triangle is given,  only   S[i,j] for j>=i
'                          are used, and lower triangle is ignored (it can  be
'                          empty - these elements are not referenced at all).
'                        * if lower triangle is given,  only   S[i,j] for j<=i
'                          are used, and upper triangle is ignored.
'        A           -   array[N][K], input dense matrix. For performance reasons
'                        we make only quick checks - we check that array size is
'                        at least N, but we do not check for NAN's or INF's.
'        K           -   number of columns of matrix (A).
'        B           -   output buffer, possibly preallocated. In case  buffer
'                        size is too small to store  result,  this  buffer  is
'                        automatically resized.
'
'    OUTPUT PARAMETERS
'        B           -   array[M][K], S*A
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsesmm(s As sparsematrix, isupper As Boolean, a As Double(,), k As Integer, ByRef b As Double(,))

		sparse.sparsesmm(s.innerobj, isupper, a, k, b)
		Return
	End Sub

	'************************************************************************
'    This function calculates matrix-vector product op(S)*x, when x is  vector,
'    S is symmetric triangular matrix, op(S) is transposition or no  operation.
'    Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
'    otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse square matrix in CRS or SKS format.
'        IsUpper     -   whether upper or lower triangle of S is used:
'                        * if upper triangle is given,  only   S[i,j] for  j>=i
'                          are used, and lower triangle is  ignored (it can  be
'                          empty - these elements are not referenced at all).
'                        * if lower triangle is given,  only   S[i,j] for  j<=i
'                          are used, and upper triangle is ignored.
'        IsUnit      -   unit or non-unit diagonal:
'                        * if True, diagonal elements of triangular matrix  are
'                          considered equal to 1.0. Actual elements  stored  in
'                          S are not referenced at all.
'                        * if False, diagonal stored in S is used
'        OpType      -   operation type:
'                        * if 0, S*x is calculated
'                        * if 1, (S^T)*x is calculated (transposition)
'        X           -   array[N] which stores input  vector.  For  performance
'                        reasons we make only quick  checks  -  we  check  that
'                        array  size  is  at  least  N, but we do not check for
'                        NAN's or INF's.
'        Y           -   possibly  preallocated  input   buffer.  Automatically
'                        resized if its size is too small.
'
'    OUTPUT PARAMETERS
'        Y           -   array[N], op(S)*x
'
'    NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'    You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'    this function.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsetrmv(s As sparsematrix, isupper As Boolean, isunit As Boolean, optype As Integer, ByRef x As Double(), ByRef y As Double())

		sparse.sparsetrmv(s.innerobj, isupper, isunit, optype, x, y)
		Return
	End Sub

	'************************************************************************
'    This function solves linear system op(S)*y=x  where  x  is  vector,  S  is
'    symmetric  triangular  matrix,  op(S)  is  transposition  or no operation.
'    Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
'    otherwise).
'
'    INPUT PARAMETERS
'        S           -   sparse square matrix in CRS or SKS format.
'        IsUpper     -   whether upper or lower triangle of S is used:
'                        * if upper triangle is given,  only   S[i,j] for  j>=i
'                          are used, and lower triangle is  ignored (it can  be
'                          empty - these elements are not referenced at all).
'                        * if lower triangle is given,  only   S[i,j] for  j<=i
'                          are used, and upper triangle is ignored.
'        IsUnit      -   unit or non-unit diagonal:
'                        * if True, diagonal elements of triangular matrix  are
'                          considered equal to 1.0. Actual elements  stored  in
'                          S are not referenced at all.
'                        * if False, diagonal stored in S is used. It  is  your
'                          responsibility  to  make  sure  that   diagonal   is
'                          non-zero.
'        OpType      -   operation type:
'                        * if 0, S*x is calculated
'                        * if 1, (S^T)*x is calculated (transposition)
'        X           -   array[N] which stores input  vector.  For  performance
'                        reasons we make only quick  checks  -  we  check  that
'                        array  size  is  at  least  N, but we do not check for
'                        NAN's or INF's.
'
'    OUTPUT PARAMETERS
'        X           -   array[N], inv(op(S))*x
'
'    NOTE: this function throws exception when called for  non-CRS/SKS  matrix.
'          You must convert your matrix  with  SparseConvertToCRS/SKS()  before
'          using this function.
'
'    NOTE: no assertion or tests are done during algorithm  operation.   It  is
'          your responsibility to provide invertible matrix to algorithm.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsetrsv(s As sparsematrix, isupper As Boolean, isunit As Boolean, optype As Integer, ByRef x As Double())

		sparse.sparsetrsv(s.innerobj, isupper, isunit, optype, x)
		Return
	End Sub

	'************************************************************************
'    This procedure resizes Hash-Table matrix. It can be called when you  have
'    deleted too many elements from the matrix, and you want to  free unneeded
'    memory.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseresizematrix(s As sparsematrix)

		sparse.sparseresizematrix(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  is  used  to enumerate all elements of the sparse matrix.
'    Before  first  call  user  initializes  T0 and T1 counters by zero. These
'    counters are used to remember current position in a  matrix;  after  each
'    call they are updated by the function.
'
'    Subsequent calls to this function return non-zero elements of the  sparse
'    matrix, one by one. If you enumerate CRS matrix, matrix is traversed from
'    left to right, from top to bottom. In case you enumerate matrix stored as
'    Hash table, elements are returned in random order.
'
'    EXAMPLE
'        > T0=0
'        > T1=0
'        > while SparseEnumerate(S,T0,T1,I,J,V) do
'        >     ....do something with I,J,V
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in Hash-Table or CRS representation.
'        T0          -   internal counter
'        T1          -   internal counter
'
'    OUTPUT PARAMETERS
'        T0          -   new value of the internal counter
'        T1          -   new value of the internal counter
'        I           -   row index of non-zero element, 0<=I<M.
'        J           -   column index of non-zero element, 0<=J<N
'        V           -   value of the T-th element
'
'    RESULT
'        True in case of success (next non-zero element was retrieved)
'        False in case all non-zero elements were enumerated
'
'    NOTE: you may call SparseRewriteExisting() during enumeration, but it  is
'          THE  ONLY  matrix  modification  function  you  can  call!!!  Other
'          matrix modification functions should not be called during enumeration!
'
'      -- ALGLIB PROJECT --
'         Copyright 14.03.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparseenumerate(s As sparsematrix, ByRef t0 As Integer, ByRef t1 As Integer, ByRef i As Integer, ByRef j As Integer, ByRef v As Double) As Boolean
		i = 0
		j = 0
		v = 0
		Dim result As Boolean = sparse.sparseenumerate(s.innerobj, t0, t1, i, j, v)
		Return result
	End Function

	'************************************************************************
'    This function rewrites existing (non-zero) element. It  returns  True   if
'    element  exists  or  False,  when  it  is  called for non-existing  (zero)
'    element.
'
'    This function works with any kind of the matrix.
'
'    The purpose of this function is to provide convenient thread-safe  way  to
'    modify  sparse  matrix.  Such  modification  (already  existing element is
'    rewritten) is guaranteed to be thread-safe without any synchronization, as
'    long as different threads modify different elements.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in any kind of representation
'                        (Hash, SKS, CRS).
'        I           -   row index of non-zero element to modify, 0<=I<M
'        J           -   column index of non-zero element to modify, 0<=J<N
'        V           -   value to rewrite, must be finite number
'
'    OUTPUT PARAMETERS
'        S           -   modified matrix
'    RESULT
'        True in case when element exists
'        False in case when element doesn't exist or it is zero
'
'      -- ALGLIB PROJECT --
'         Copyright 14.03.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparserewriteexisting(s As sparsematrix, i As Integer, j As Integer, v As Double) As Boolean

		Dim result As Boolean = sparse.sparserewriteexisting(s.innerobj, i, j, v)
		Return result
	End Function

	'************************************************************************
'    This function returns I-th row of the sparse matrix. Matrix must be stored
'    in CRS or SKS format.
'
'    INPUT PARAMETERS:
'        S           -   sparse M*N matrix in CRS format
'        I           -   row index, 0<=I<M
'        IRow        -   output buffer, can be  preallocated.  In  case  buffer
'                        size  is  too  small  to  store  I-th   row,   it   is
'                        automatically reallocated.
'
'    OUTPUT PARAMETERS:
'        IRow        -   array[M], I-th row.
'
'    NOTE: this function has O(N) running time, where N is a  column  count. It
'          allocates and fills N-element  array,  even  although  most  of  its
'          elemets are zero.
'
'    NOTE: If you have O(non-zeros-per-row) time and memory  requirements,  use
'          SparseGetCompressedRow() function. It  returns  data  in  compressed
'          format.
'
'    NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
'          is passed, this function throws exception.
'
'      -- ALGLIB PROJECT --
'         Copyright 10.12.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsegetrow(s As sparsematrix, i As Integer, ByRef irow As Double())

		sparse.sparsegetrow(s.innerobj, i, irow)
		Return
	End Sub

	'************************************************************************
'    This function returns I-th row of the sparse matrix IN COMPRESSED FORMAT -
'    only non-zero elements are returned (with their indexes). Matrix  must  be
'    stored in CRS or SKS format.
'
'    INPUT PARAMETERS:
'        S           -   sparse M*N matrix in CRS format
'        I           -   row index, 0<=I<M
'        ColIdx      -   output buffer for column indexes, can be preallocated.
'                        In case buffer size is too small to store I-th row, it
'                        is automatically reallocated.
'        Vals        -   output buffer for values, can be preallocated. In case
'                        buffer size is too small to  store  I-th  row,  it  is
'                        automatically reallocated.
'
'    OUTPUT PARAMETERS:
'        ColIdx      -   column   indexes   of  non-zero  elements,  sorted  by
'                        ascending. Symbolically non-zero elements are  counted
'                        (i.e. if you allocated place for element, but  it  has
'                        zero numerical value - it is counted).
'        Vals        -   values. Vals[K] stores value of  matrix  element  with
'                        indexes (I,ColIdx[K]). Symbolically non-zero  elements
'                        are counted (i.e. if you allocated place for  element,
'                        but it has zero numerical value - it is counted).
'        NZCnt       -   number of symbolically non-zero elements per row.
'
'    NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
'          is passed, this function throws exception.
'
'    NOTE: this function may allocate additional, unnecessary place for  ColIdx
'          and Vals arrays. It is dictated by  performance  reasons  -  on  SKS
'          matrices it is faster  to  allocate  space  at  the  beginning  with
'          some "extra"-space, than performing two passes over matrix  -  first
'          time to calculate exact space required for data, second  time  -  to
'          store data itself.
'
'      -- ALGLIB PROJECT --
'         Copyright 10.12.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsegetcompressedrow(s As sparsematrix, i As Integer, ByRef colidx As Integer(), ByRef vals As Double(), ByRef nzcnt As Integer)
		nzcnt = 0
		sparse.sparsegetcompressedrow(s.innerobj, i, colidx, vals, nzcnt)
		Return
	End Sub

	'************************************************************************
'    This function performs efficient in-place  transpose  of  SKS  matrix.  No
'    additional memory is allocated during transposition.
'
'    This function supports only skyline storage format (SKS).
'
'    INPUT PARAMETERS
'        S       -   sparse matrix in SKS format.
'
'    OUTPUT PARAMETERS
'        S           -   sparse matrix, transposed.
'
'      -- ALGLIB PROJECT --
'         Copyright 16.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsetransposesks(s As sparsematrix)

		sparse.sparsetransposesks(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  in-place  conversion  to  desired sparse storage
'    format.
'
'    INPUT PARAMETERS
'        S0      -   sparse matrix in any format.
'        Fmt     -   desired storage format  of  the  output,  as  returned  by
'                    SparseGetMatrixType() function:
'                    * 0 for hash-based storage
'                    * 1 for CRS
'                    * 2 for SKS
'
'    OUTPUT PARAMETERS
'        S0          -   sparse matrix in requested format.
'
'    NOTE: in-place conversion wastes a lot of memory which is  used  to  store
'          temporaries.  If  you  perform  a  lot  of  repeated conversions, we
'          recommend to use out-of-place buffered  conversion  functions,  like
'          SparseCopyToBuf(), which can reuse already allocated memory.
'
'      -- ALGLIB PROJECT --
'         Copyright 16.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseconvertto(s0 As sparsematrix, fmt As Integer)

		sparse.sparseconvertto(s0.innerobj, fmt)
		Return
	End Sub

	'************************************************************************
'    This  function  performs out-of-place conversion to desired sparse storage
'    format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
'    S1 is reused to maximum extent possible.
'
'    INPUT PARAMETERS
'        S0      -   sparse matrix in any format.
'        Fmt     -   desired storage format  of  the  output,  as  returned  by
'                    SparseGetMatrixType() function:
'                    * 0 for hash-based storage
'                    * 1 for CRS
'                    * 2 for SKS
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in requested format.
'
'      -- ALGLIB PROJECT --
'         Copyright 16.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytobuf(s0 As sparsematrix, fmt As Integer, s1 As sparsematrix)

		sparse.sparsecopytobuf(s0.innerobj, fmt, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function performs in-place conversion to Hash table storage.
'
'    INPUT PARAMETERS
'        S           -   sparse matrix in CRS format.
'
'    OUTPUT PARAMETERS
'        S           -   sparse matrix in Hash table format.
'
'    NOTE: this  function  has   no  effect  when  called with matrix which  is
'          already in Hash table mode.
'
'    NOTE: in-place conversion involves allocation of temporary arrays. If  you
'          perform a lot of repeated in- place  conversions,  it  may  lead  to
'          memory fragmentation. Consider using out-of-place SparseCopyToHashBuf()
'          function in this case.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseconverttohash(s As sparsematrix)

		sparse.sparseconverttohash(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to  Hash table storage
'    format. S0 is copied to S1 and converted on-the-fly.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in Hash table format.
'
'    NOTE: if S0 is stored as Hash-table, it is just copied without conversion.
'
'    NOTE: this function de-allocates memory  occupied  by  S1 before  starting
'          conversion. If you perform a  lot  of  repeated  conversions, it may
'          lead to memory fragmentation. In this case we recommend you  to  use
'          SparseCopyToHashBuf() function which re-uses memory in S1 as much as
'          possible.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytohash(s0 As sparsematrix, ByRef s1 As sparsematrix)
		s1 = New sparsematrix()
		sparse.sparsecopytohash(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to  Hash table storage
'    format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
'    S1 is reused to maximum extent possible.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in Hash table format.
'
'    NOTE: if S0 is stored as Hash-table, it is just copied without conversion.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytohashbuf(s0 As sparsematrix, s1 As sparsematrix)

		sparse.sparsecopytohashbuf(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function converts matrix to CRS format.
'
'    Some  algorithms  (linear  algebra ones, for example) require matrices in
'    CRS format. This function allows to perform in-place conversion.
'
'    INPUT PARAMETERS
'        S           -   sparse M*N matrix in any format
'
'    OUTPUT PARAMETERS
'        S           -   matrix in CRS format
'
'    NOTE: this   function  has  no  effect  when  called with matrix which is
'          already in CRS mode.
'
'    NOTE: this function allocates temporary memory to store a   copy  of  the
'          matrix. If you perform a lot of repeated conversions, we  recommend
'          you  to  use  SparseCopyToCRSBuf()  function,   which   can   reuse
'          previously allocated memory.
'
'      -- ALGLIB PROJECT --
'         Copyright 14.10.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseconverttocrs(s As sparsematrix)

		sparse.sparseconverttocrs(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
'    copied to S1 and converted on-the-fly.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in CRS format.
'
'    NOTE: if S0 is stored as CRS, it is just copied without conversion.
'
'    NOTE: this function de-allocates memory occupied by S1 before starting CRS
'          conversion. If you perform a lot of repeated CRS conversions, it may
'          lead to memory fragmentation. In this case we recommend you  to  use
'          SparseCopyToCRSBuf() function which re-uses memory in S1 as much  as
'          possible.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytocrs(s0 As sparsematrix, ByRef s1 As sparsematrix)
		s1 = New sparsematrix()
		sparse.sparsecopytocrs(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
'    copied to S1 and converted on-the-fly. Memory allocated in S1 is reused to
'    maximum extent possible.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'        S1          -   matrix which may contain some pre-allocated memory, or
'                        can be just uninitialized structure.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in CRS format.
'
'    NOTE: if S0 is stored as CRS, it is just copied without conversion.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytocrsbuf(s0 As sparsematrix, s1 As sparsematrix)

		sparse.sparsecopytocrsbuf(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function performs in-place conversion to SKS format.
'
'    INPUT PARAMETERS
'        S           -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S           -   sparse matrix in SKS format.
'
'    NOTE: this  function  has   no  effect  when  called with matrix which  is
'          already in SKS mode.
'
'    NOTE: in-place conversion involves allocation of temporary arrays. If  you
'          perform a lot of repeated in- place  conversions,  it  may  lead  to
'          memory fragmentation. Consider using out-of-place SparseCopyToSKSBuf()
'          function in this case.
'
'      -- ALGLIB PROJECT --
'         Copyright 15.01.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparseconverttosks(s As sparsematrix)

		sparse.sparseconverttosks(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to SKS storage format.
'    S0 is copied to S1 and converted on-the-fly.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in SKS format.
'
'    NOTE: if S0 is stored as SKS, it is just copied without conversion.
'
'    NOTE: this function de-allocates memory  occupied  by  S1 before  starting
'          conversion. If you perform a  lot  of  repeated  conversions, it may
'          lead to memory fragmentation. In this case we recommend you  to  use
'          SparseCopyToSKSBuf() function which re-uses memory in S1 as much  as
'          possible.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytosks(s0 As sparsematrix, ByRef s1 As sparsematrix)
		s1 = New sparsematrix()
		sparse.sparsecopytosks(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  performs  out-of-place  conversion  to SKS format.  S0  is
'    copied to S1 and converted on-the-fly. Memory  allocated  in S1 is  reused
'    to maximum extent possible.
'
'    INPUT PARAMETERS
'        S0          -   sparse matrix in any format.
'
'    OUTPUT PARAMETERS
'        S1          -   sparse matrix in SKS format.
'
'    NOTE: if S0 is stored as SKS, it is just copied without conversion.
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsecopytosksbuf(s0 As sparsematrix, s1 As sparsematrix)

		sparse.sparsecopytosksbuf(s0.innerobj, s1.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function returns type of the matrix storage format.
'
'    INPUT PARAMETERS:
'        S           -   sparse matrix.
'
'    RESULT:
'        sparse storage format used by matrix:
'            0   -   Hash-table
'            1   -   CRS (compressed row storage)
'            2   -   SKS (skyline)
'
'    NOTE: future  versions  of  ALGLIB  may  include additional sparse storage
'          formats.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetmatrixtype(s As sparsematrix) As Integer

		Dim result As Integer = sparse.sparsegetmatrixtype(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    This function checks matrix storage format and returns True when matrix is
'    stored using Hash table representation.
'
'    INPUT PARAMETERS:
'        S   -   sparse matrix.
'
'    RESULT:
'        True if matrix type is Hash table
'        False if matrix type is not Hash table
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparseishash(s As sparsematrix) As Boolean

		Dim result As Boolean = sparse.sparseishash(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    This function checks matrix storage format and returns True when matrix is
'    stored using CRS representation.
'
'    INPUT PARAMETERS:
'        S   -   sparse matrix.
'
'    RESULT:
'        True if matrix type is CRS
'        False if matrix type is not CRS
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparseiscrs(s As sparsematrix) As Boolean

		Dim result As Boolean = sparse.sparseiscrs(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    This function checks matrix storage format and returns True when matrix is
'    stored using SKS representation.
'
'    INPUT PARAMETERS:
'        S   -   sparse matrix.
'
'    RESULT:
'        True if matrix type is SKS
'        False if matrix type is not SKS
'
'      -- ALGLIB PROJECT --
'         Copyright 20.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparseissks(s As sparsematrix) As Boolean

		Dim result As Boolean = sparse.sparseissks(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    The function frees all memory occupied by  sparse  matrix.  Sparse  matrix
'    structure becomes unusable after this call.
'
'    OUTPUT PARAMETERS
'        S   -   sparse matrix to delete
'
'      -- ALGLIB PROJECT --
'         Copyright 24.07.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub sparsefree(ByRef s As sparsematrix)
		s = New sparsematrix()
		sparse.sparsefree(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    The function returns number of rows of a sparse matrix.
'
'    RESULT: number of rows of a sparse matrix.
'
'      -- ALGLIB PROJECT --
'         Copyright 23.08.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetnrows(s As sparsematrix) As Integer

		Dim result As Integer = sparse.sparsegetnrows(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    The function returns number of columns of a sparse matrix.
'
'    RESULT: number of columns of a sparse matrix.
'
'      -- ALGLIB PROJECT --
'         Copyright 23.08.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetncols(s As sparsematrix) As Integer

		Dim result As Integer = sparse.sparsegetncols(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    The function returns number of strictly upper triangular non-zero elements
'    in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
'    in the sparse matrix data structure. If some element  has  zero  numerical
'    value, it is still counted.
'
'    This function has different cost for different types of matrices:
'    * for hash-based matrices it involves complete pass over entire hash-table
'      with O(NNZ) cost, where NNZ is number of non-zero elements
'    * for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).
'
'    RESULT: number of non-zero elements strictly above main diagonal
'
'      -- ALGLIB PROJECT --
'         Copyright 12.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetuppercount(s As sparsematrix) As Integer

		Dim result As Integer = sparse.sparsegetuppercount(s.innerobj)
		Return result
	End Function

	'************************************************************************
'    The function returns number of strictly lower triangular non-zero elements
'    in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
'    in the sparse matrix data structure. If some element  has  zero  numerical
'    value, it is still counted.
'
'    This function has different cost for different types of matrices:
'    * for hash-based matrices it involves complete pass over entire hash-table
'      with O(NNZ) cost, where NNZ is number of non-zero elements
'    * for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).
'
'    RESULT: number of non-zero elements strictly below main diagonal
'
'      -- ALGLIB PROJECT --
'         Copyright 12.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsegetlowercount(s As sparsematrix) As Integer

		Dim result As Integer = sparse.sparsegetlowercount(s.innerobj)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    LU decomposition of a general real matrix with row pivoting
'
'    A is represented as A = P*L*U, where:
'    * L is lower unitriangular matrix
'    * U is upper triangular matrix
'    * P = P0*P1*...*PK, K=min(M,N)-1,
'      Pi - permutation matrix for I and Pivots[I]
'
'    This is cache-oblivous implementation of LU decomposition.
'    It is optimized for square matrices. As for rectangular matrices:
'    * best case - M>>N
'    * worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that LU decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   array[0..M-1, 0..N-1].
'        M       -   number of rows in matrix A.
'        N       -   number of columns in matrix A.
'
'
'    OUTPUT PARAMETERS:
'        A       -   matrices L and U in compact form:
'                    * L is stored under main diagonal
'                    * U is stored on and above main diagonal
'        Pivots  -   permutation matrix in compact form.
'                    array[0..Min(M-1,N-1)].
'
'      -- ALGLIB routine --
'         10.01.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixlu(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
		pivots = New Integer(-1) {}
		trfac.rmatrixlu(a, m, n, pivots)
		Return
	End Sub


	Public Shared Sub smp_rmatrixlu(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
		pivots = New Integer(-1) {}
		trfac._pexec_rmatrixlu(a, m, n, pivots)
		Return
	End Sub

	'************************************************************************
'    LU decomposition of a general complex matrix with row pivoting
'
'    A is represented as A = P*L*U, where:
'    * L is lower unitriangular matrix
'    * U is upper triangular matrix
'    * P = P0*P1*...*PK, K=min(M,N)-1,
'      Pi - permutation matrix for I and Pivots[I]
'
'    This is cache-oblivous implementation of LU decomposition. It is optimized
'    for square matrices. As for rectangular matrices:
'    * best case - M>>N
'    * worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that LU decomposition  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   array[0..M-1, 0..N-1].
'        M       -   number of rows in matrix A.
'        N       -   number of columns in matrix A.
'
'
'    OUTPUT PARAMETERS:
'        A       -   matrices L and U in compact form:
'                    * L is stored under main diagonal
'                    * U is stored on and above main diagonal
'        Pivots  -   permutation matrix in compact form.
'                    array[0..Min(M-1,N-1)].
'
'      -- ALGLIB routine --
'         10.01.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixlu(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
		pivots = New Integer(-1) {}
		trfac.cmatrixlu(a, m, n, pivots)
		Return
	End Sub


	Public Shared Sub smp_cmatrixlu(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
		pivots = New Integer(-1) {}
		trfac._pexec_cmatrixlu(a, m, n, pivots)
		Return
	End Sub

	'************************************************************************
'    Cache-oblivious Cholesky decomposition
'
'    The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
'    definite matrix. The result of an algorithm is a representation  of  A  as
'    A=U'*U  or A=L*L' (here X' detones conj(X^T)).
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that Cholesky decomposition is harder
'      ! to parallelize than, say, matrix-matrix product - this  algorithm  has
'      ! several synchronization points which  can  not  be  avoided.  However,
'      ! parallelism starts to be profitable starting from N=500.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   upper or lower triangle of a factorized matrix.
'                    array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                    a symmetric matrix, otherwise A contains a lower one.
'
'    OUTPUT PARAMETERS:
'        A       -   the result of factorization. If IsUpper=True, then
'                    the upper triangle contains matrix U, so that A = U'*U,
'                    and the elements below the main diagonal are not modified.
'                    Similarly, if IsUpper = False.
'
'    RESULT:
'        If  the  matrix  is  positive-definite,  the  function  returns  True.
'        Otherwise, the function returns False. Contents of A is not determined
'        in such case.
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Function hpdmatrixcholesky(ByRef a As complex(,), n As Integer, isupper As Boolean) As Boolean

		Dim result As Boolean = trfac.hpdmatrixcholesky(a, n, isupper)
		Return result
	End Function


	Public Shared Function smp_hpdmatrixcholesky(ByRef a As complex(,), n As Integer, isupper As Boolean) As Boolean

		Dim result As Boolean = trfac._pexec_hpdmatrixcholesky(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Cache-oblivious Cholesky decomposition
'
'    The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'    definite matrix. The result of an algorithm is a representation  of  A  as
'    A=U^T*U  or A=L*L^T
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that Cholesky decomposition is harder
'      ! to parallelize than, say, matrix-matrix product - this  algorithm  has
'      ! several synchronization points which  can  not  be  avoided.  However,
'      ! parallelism starts to be profitable starting from N=500.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   upper or lower triangle of a factorized matrix.
'                    array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                    a symmetric matrix, otherwise A contains a lower one.
'
'    OUTPUT PARAMETERS:
'        A       -   the result of factorization. If IsUpper=True, then
'                    the upper triangle contains matrix U, so that A = U^T*U,
'                    and the elements below the main diagonal are not modified.
'                    Similarly, if IsUpper = False.
'
'    RESULT:
'        If  the  matrix  is  positive-definite,  the  function  returns  True.
'        Otherwise, the function returns False. Contents of A is not determined
'        in such case.
'
'      -- ALGLIB routine --
'         15.12.2009
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spdmatrixcholesky(ByRef a As Double(,), n As Integer, isupper As Boolean) As Boolean

		Dim result As Boolean = trfac.spdmatrixcholesky(a, n, isupper)
		Return result
	End Function


	Public Shared Function smp_spdmatrixcholesky(ByRef a As Double(,), n As Integer, isupper As Boolean) As Boolean

		Dim result As Boolean = trfac._pexec_spdmatrixcholesky(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Update of Cholesky decomposition: rank-1 update to original A.  "Buffered"
'    version which uses preallocated buffer which is saved  between  subsequent
'    function calls.
'
'    This function uses internally allocated buffer which is not saved  between
'    subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
'    we  recommend   you   to   use   "buffered"   version   of  this function:
'    SPDMatrixCholeskyUpdateAdd1Buf().
'
'    INPUT PARAMETERS:
'        A       -   upper or lower Cholesky factor.
'                    array with elements [0..N-1, 0..N-1].
'                    Exception is thrown if array size is too small.
'        N       -   size of matrix A, N>0
'        IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                    otherwise A contains a lower one.
'        U       -   array[N], rank-1 update to A: A_mod = A + u*u'
'                    Exception is thrown if array size is too small.
'        BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                    needed. It is recommended to  reuse  this  buffer  if  you
'                    perform a lot of subsequent decompositions.
'
'    OUTPUT PARAMETERS:
'        A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                    triangle contains matrix U, and the elements below the main
'                    diagonal are not modified. Similarly, if IsUpper = False.
'
'    NOTE: this function always succeeds, so it does not return completion code
'
'    NOTE: this function checks sizes of input arrays, but it does  NOT  checks
'          for presence of infinities or NAN's.
'
'      -- ALGLIB --
'         03.02.2014
'         Sergey Bochkanov
'    ************************************************************************

	Public Shared Sub spdmatrixcholeskyupdateadd1(ByRef a As Double(,), n As Integer, isupper As Boolean, u As Double())

		trfac.spdmatrixcholeskyupdateadd1(a, n, isupper, u)
		Return
	End Sub

	'************************************************************************
'    Update of Cholesky decomposition: "fixing" some variables.
'
'    This function uses internally allocated buffer which is not saved  between
'    subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
'    we  recommend   you   to   use   "buffered"   version   of  this function:
'    SPDMatrixCholeskyUpdateFixBuf().
'
'    "FIXING" EXPLAINED:
'
'        Suppose we have N*N positive definite matrix A. "Fixing" some variable
'        means filling corresponding row/column of  A  by  zeros,  and  setting
'        diagonal element to 1.
'
'        For example, if we fix 2nd variable in 4*4 matrix A, it becomes Af:
'
'            ( A00  A01  A02  A03 )      ( Af00  0   Af02 Af03 )
'            ( A10  A11  A12  A13 )      (  0    1    0    0   )
'            ( A20  A21  A22  A23 )  =>  ( Af20  0   Af22 Af23 )
'            ( A30  A31  A32  A33 )      ( Af30  0   Af32 Af33 )
'
'        If we have Cholesky decomposition of A, it must be recalculated  after
'        variables were  fixed.  However,  it  is  possible  to  use  efficient
'        algorithm, which needs O(K*N^2)  time  to  "fix"  K  variables,  given
'        Cholesky decomposition of original, "unfixed" A.
'
'    INPUT PARAMETERS:
'        A       -   upper or lower Cholesky factor.
'                    array with elements [0..N-1, 0..N-1].
'                    Exception is thrown if array size is too small.
'        N       -   size of matrix A, N>0
'        IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                    otherwise A contains a lower one.
'        Fix     -   array[N], I-th element is True if I-th  variable  must  be
'                    fixed. Exception is thrown if array size is too small.
'        BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                    needed. It is recommended to  reuse  this  buffer  if  you
'                    perform a lot of subsequent decompositions.
'
'    OUTPUT PARAMETERS:
'        A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                    triangle contains matrix U, and the elements below the main
'                    diagonal are not modified. Similarly, if IsUpper = False.
'
'    NOTE: this function always succeeds, so it does not return completion code
'
'    NOTE: this function checks sizes of input arrays, but it does  NOT  checks
'          for presence of infinities or NAN's.
'
'    NOTE: this  function  is  efficient  only  for  moderate amount of updated
'          variables - say, 0.1*N or 0.3*N. For larger amount of  variables  it
'          will  still  work,  but  you  may  get   better   performance   with
'          straightforward Cholesky.
'
'      -- ALGLIB --
'         03.02.2014
'         Sergey Bochkanov
'    ************************************************************************

	Public Shared Sub spdmatrixcholeskyupdatefix(ByRef a As Double(,), n As Integer, isupper As Boolean, fix As Boolean())

		trfac.spdmatrixcholeskyupdatefix(a, n, isupper, fix)
		Return
	End Sub

	'************************************************************************
'    Update of Cholesky decomposition: rank-1 update to original A.  "Buffered"
'    version which uses preallocated buffer which is saved  between  subsequent
'    function calls.
'
'    See comments for SPDMatrixCholeskyUpdateAdd1() for more information.
'
'    INPUT PARAMETERS:
'        A       -   upper or lower Cholesky factor.
'                    array with elements [0..N-1, 0..N-1].
'                    Exception is thrown if array size is too small.
'        N       -   size of matrix A, N>0
'        IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                    otherwise A contains a lower one.
'        U       -   array[N], rank-1 update to A: A_mod = A + u*u'
'                    Exception is thrown if array size is too small.
'        BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                    needed. It is recommended to  reuse  this  buffer  if  you
'                    perform a lot of subsequent decompositions.
'
'    OUTPUT PARAMETERS:
'        A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                    triangle contains matrix U, and the elements below the main
'                    diagonal are not modified. Similarly, if IsUpper = False.
'
'      -- ALGLIB --
'         03.02.2014
'         Sergey Bochkanov
'    ************************************************************************

	Public Shared Sub spdmatrixcholeskyupdateadd1buf(ByRef a As Double(,), n As Integer, isupper As Boolean, u As Double(), ByRef bufr As Double())

		trfac.spdmatrixcholeskyupdateadd1buf(a, n, isupper, u, bufr)
		Return
	End Sub

	'************************************************************************
'    Update of Cholesky  decomposition:  "fixing"  some  variables.  "Buffered"
'    version which uses preallocated buffer which is saved  between  subsequent
'    function calls.
'
'    See comments for SPDMatrixCholeskyUpdateFix() for more information.
'
'    INPUT PARAMETERS:
'        A       -   upper or lower Cholesky factor.
'                    array with elements [0..N-1, 0..N-1].
'                    Exception is thrown if array size is too small.
'        N       -   size of matrix A, N>0
'        IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                    otherwise A contains a lower one.
'        Fix     -   array[N], I-th element is True if I-th  variable  must  be
'                    fixed. Exception is thrown if array size is too small.
'        BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                    needed. It is recommended to  reuse  this  buffer  if  you
'                    perform a lot of subsequent decompositions.
'
'    OUTPUT PARAMETERS:
'        A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                    triangle contains matrix U, and the elements below the main
'                    diagonal are not modified. Similarly, if IsUpper = False.
'
'      -- ALGLIB --
'         03.02.2014
'         Sergey Bochkanov
'    ************************************************************************

	Public Shared Sub spdmatrixcholeskyupdatefixbuf(ByRef a As Double(,), n As Integer, isupper As Boolean, fix As Boolean(), ByRef bufr As Double())

		trfac.spdmatrixcholeskyupdatefixbuf(a, n, isupper, fix, bufr)
		Return
	End Sub

	'************************************************************************
'    Sparse Cholesky decomposition for skyline matrixm using in-place algorithm
'    without allocating additional storage.
'
'    The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'    definite sparse matrix. The result of an algorithm is a representation  of
'    A as A=U^T*U or A=L*L^T
'
'    This  function  is  a  more  efficient alternative to general, but  slower
'    SparseCholeskyX(), because it does not  create  temporary  copies  of  the
'    target. It performs factorization in-place, which gives  best  performance
'    on low-profile matrices. Its drawback, however, is that it can not perform
'    profile-reducing permutation of input matrix.
'
'    INPUT PARAMETERS:
'        A       -   sparse matrix in skyline storage (SKS) format.
'        N       -   size of matrix A (can be smaller than actual size of A)
'        IsUpper -   if IsUpper=True, then factorization is performed on  upper
'                    triangle. Another triangle is ignored (it may contant some
'                    data, but it is not changed).
'
'
'    OUTPUT PARAMETERS:
'        A       -   the result of factorization, stored in SKS. If IsUpper=True,
'                    then the upper  triangle  contains  matrix  U,  such  that
'                    A = U^T*U. Lower triangle is not changed.
'                    Similarly, if IsUpper = False. In this case L is returned,
'                    and we have A = L*(L^T).
'                    Note that THIS function does not  perform  permutation  of
'                    rows to reduce bandwidth.
'
'    RESULT:
'        If  the  matrix  is  positive-definite,  the  function  returns  True.
'        Otherwise, the function returns False. Contents of A is not determined
'        in such case.
'
'    NOTE: for  performance  reasons  this  function  does NOT check that input
'          matrix  includes  only  finite  values. It is your responsibility to
'          make sure that there are no infinite or NAN values in the matrix.
'
'      -- ALGLIB routine --
'         16.01.2014
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Function sparsecholeskyskyline(a As sparsematrix, n As Integer, isupper As Boolean) As Boolean

		Dim result As Boolean = trfac.sparsecholeskyskyline(a.innerobj, n, isupper)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Estimate of a matrix condition number (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixrcond1(a As Double(,), n As Integer) As Double

		Dim result As Double = rcond.rmatrixrcond1(a, n)
		Return result
	End Function

	'************************************************************************
'    Estimate of a matrix condition number (infinity-norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixrcondinf(a As Double(,), n As Integer) As Double

		Dim result As Double = rcond.rmatrixrcondinf(a, n)
		Return result
	End Function

	'************************************************************************
'    Condition number estimate of a symmetric positive definite matrix.
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'    matrices are equal, so the algorithm doesn't take into account the
'    differences between these types of norms.
'
'    Input parameters:
'        A       -   symmetric positive definite matrix which is given by its
'                    upper or lower triangle depending on the value of
'                    IsUpper. Array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   storage format.
'
'    Result:
'        1/LowerBound(cond(A)), if matrix A is positive definite,
'       -1, if matrix A is not positive definite, and its condition number
'        could not be found by this algorithm.
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function spdmatrixrcond(a As Double(,), n As Integer, isupper As Boolean) As Double

		Dim result As Double = rcond.spdmatrixrcond(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Triangular matrix: estimate of a condition number (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A       -   matrix. Array[0..N-1, 0..N-1].
'        N       -   size of A.
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   True, if the matrix has a unit diagonal.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixtrrcond1(a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double

		Dim result As Double = rcond.rmatrixtrrcond1(a, n, isupper, isunit)
		Return result
	End Function

	'************************************************************************
'    Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   True, if the matrix has a unit diagonal.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixtrrcondinf(a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double

		Dim result As Double = rcond.rmatrixtrrcondinf(a, n, isupper, isunit)
		Return result
	End Function

	'************************************************************************
'    Condition number estimate of a Hermitian positive definite matrix.
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    It should be noted that 1-norm and inf-norm of condition numbers of symmetric
'    matrices are equal, so the algorithm doesn't take into account the
'    differences between these types of norms.
'
'    Input parameters:
'        A       -   Hermitian positive definite matrix which is given by its
'                    upper or lower triangle depending on the value of
'                    IsUpper. Array with elements [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        IsUpper -   storage format.
'
'    Result:
'        1/LowerBound(cond(A)), if matrix A is positive definite,
'       -1, if matrix A is not positive definite, and its condition number
'        could not be found by this algorithm.
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function hpdmatrixrcond(a As complex(,), n As Integer, isupper As Boolean) As Double

		Dim result As Double = rcond.hpdmatrixrcond(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Estimate of a matrix condition number (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixrcond1(a As complex(,), n As Integer) As Double

		Dim result As Double = rcond.cmatrixrcond1(a, n)
		Return result
	End Function

	'************************************************************************
'    Estimate of a matrix condition number (infinity-norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixrcondinf(a As complex(,), n As Integer) As Double

		Dim result As Double = rcond.cmatrixrcondinf(a, n)
		Return result
	End Function

	'************************************************************************
'    Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        LUA         -   LU decomposition of a matrix in compact form. Output of
'                        the RMatrixLU subroutine.
'        N           -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixlurcond1(lua As Double(,), n As Integer) As Double

		Dim result As Double = rcond.rmatrixlurcond1(lua, n)
		Return result
	End Function

	'************************************************************************
'    Estimate of the condition number of a matrix given by its LU decomposition
'    (infinity norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        LUA     -   LU decomposition of a matrix in compact form. Output of
'                    the RMatrixLU subroutine.
'        N       -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function rmatrixlurcondinf(lua As Double(,), n As Integer) As Double

		Dim result As Double = rcond.rmatrixlurcondinf(lua, n)
		Return result
	End Function

	'************************************************************************
'    Condition number estimate of a symmetric positive definite matrix given by
'    Cholesky decomposition.
'
'    The algorithm calculates a lower bound of the condition number. In this
'    case, the algorithm does not return a lower bound of the condition number,
'    but an inverse number (to avoid an overflow in case of a singular matrix).
'
'    It should be noted that 1-norm and inf-norm condition numbers of symmetric
'    matrices are equal, so the algorithm doesn't take into account the
'    differences between these types of norms.
'
'    Input parameters:
'        CD  - Cholesky decomposition of matrix A,
'              output of SMatrixCholesky subroutine.
'        N   - size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function spdmatrixcholeskyrcond(a As Double(,), n As Integer, isupper As Boolean) As Double

		Dim result As Double = rcond.spdmatrixcholeskyrcond(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Condition number estimate of a Hermitian positive definite matrix given by
'    Cholesky decomposition.
'
'    The algorithm calculates a lower bound of the condition number. In this
'    case, the algorithm does not return a lower bound of the condition number,
'    but an inverse number (to avoid an overflow in case of a singular matrix).
'
'    It should be noted that 1-norm and inf-norm condition numbers of symmetric
'    matrices are equal, so the algorithm doesn't take into account the
'    differences between these types of norms.
'
'    Input parameters:
'        CD  - Cholesky decomposition of matrix A,
'              output of SMatrixCholesky subroutine.
'        N   - size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function hpdmatrixcholeskyrcond(a As complex(,), n As Integer, isupper As Boolean) As Double

		Dim result As Double = rcond.hpdmatrixcholeskyrcond(a, n, isupper)
		Return result
	End Function

	'************************************************************************
'    Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        LUA         -   LU decomposition of a matrix in compact form. Output of
'                        the CMatrixLU subroutine.
'        N           -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixlurcond1(lua As complex(,), n As Integer) As Double

		Dim result As Double = rcond.cmatrixlurcond1(lua, n)
		Return result
	End Function

	'************************************************************************
'    Estimate of the condition number of a matrix given by its LU decomposition
'    (infinity norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        LUA     -   LU decomposition of a matrix in compact form. Output of
'                    the CMatrixLU subroutine.
'        N       -   size of matrix A.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixlurcondinf(lua As complex(,), n As Integer) As Double

		Dim result As Double = rcond.cmatrixlurcondinf(lua, n)
		Return result
	End Function

	'************************************************************************
'    Triangular matrix: estimate of a condition number (1-norm)
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A       -   matrix. Array[0..N-1, 0..N-1].
'        N       -   size of A.
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   True, if the matrix has a unit diagonal.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixtrrcond1(a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double

		Dim result As Double = rcond.cmatrixtrrcond1(a, n, isupper, isunit)
		Return result
	End Function

	'************************************************************************
'    Triangular matrix: estimate of a matrix condition number (infinity-norm).
'
'    The algorithm calculates a lower bound of the condition number. In this case,
'    the algorithm does not return a lower bound of the condition number, but an
'    inverse number (to avoid an overflow in case of a singular matrix).
'
'    Input parameters:
'        A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of matrix A.
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   True, if the matrix has a unit diagonal.
'
'    Result: 1/LowerBound(cond(A))
'
'    NOTE:
'        if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
'        0.0 is returned in such cases.
'    ************************************************************************

	Public Shared Function cmatrixtrrcondinf(a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double

		Dim result As Double = rcond.cmatrixtrrcondinf(a, n, isupper, isunit)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Matrix inverse report:
'    * R1    reciprocal of condition number in 1-norm
'    * RInf  reciprocal of condition number in inf-norm
'    ************************************************************************

	Public Class matinvreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property r1() As Double
			Get
				Return _innerobj.r1
			End Get
			Set
				_innerobj.r1 = value
			End Set
		End Property
		Public Property rinf() As Double
			Get
				Return _innerobj.rinf
			End Get
			Set
				_innerobj.rinf = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New matinv.matinvreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New matinvreport(DirectCast(_innerobj.make_copy(), matinv.matinvreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As matinv.matinvreport
		Public ReadOnly Property innerobj() As matinv.matinvreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As matinv.matinvreport)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    Inversion of a matrix given by its LU decomposition.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that matrix inversion  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   LU decomposition of the matrix
'                    (output of RMatrixLU subroutine).
'        Pivots  -   table of permutations
'                    (the output of RMatrixLU subroutine).
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'
'    OUTPUT PARAMETERS:
'        Info    -   return code:
'                    * -3    A is singular, or VERY close to singular.
'                            it is filled by zeros in such cases.
'                    *  1    task is solved (but matrix A may be ill-conditioned,
'                            check R1/RInf parameters for condition numbers).
'        Rep     -   solver report, see below for more info
'        A       -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'
'    SOLVER REPORT
'
'    Subroutine sets following fields of the Rep structure:
'    * R1        reciprocal of condition number: 1/cond(A), 1-norm.
'    * RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'      -- ALGLIB routine --
'         05.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.rmatrixluinverse(a, pivots, n, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_rmatrixluinverse(a, pivots, n, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) OrElse (ap.cols(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv.rmatrixluinverse(a, pivots, n, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) OrElse (ap.cols(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv._pexec_rmatrixluinverse(a, pivots, n, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a general matrix.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that matrix inversion  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix.
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'    Result:
'        True, if the matrix is not singular.
'        False, if the matrix is singular.
'
'      -- ALGLIB --
'         Copyright 2005-2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixinverse(ByRef a As Double(,), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.rmatrixinverse(a, n, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_rmatrixinverse(ByRef a As Double(,), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_rmatrixinverse(a, n, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub rmatrixinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv.rmatrixinverse(a, n, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_rmatrixinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv._pexec_rmatrixinverse(a, n, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a matrix given by its LU decomposition.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that matrix inversion  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        A       -   LU decomposition of the matrix
'                    (output of CMatrixLU subroutine).
'        Pivots  -   table of permutations
'                    (the output of CMatrixLU subroutine).
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'
'    OUTPUT PARAMETERS:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB routine --
'         05.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.cmatrixluinverse(a, pivots, n, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_cmatrixluinverse(a, pivots, n, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) OrElse (ap.cols(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv.cmatrixluinverse(a, pivots, n, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) OrElse (ap.cols(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv._pexec_cmatrixluinverse(a, pivots, n, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a general matrix.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that matrix inversion  is  harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixinverse(ByRef a As complex(,), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.cmatrixinverse(a, n, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_cmatrixinverse(ByRef a As complex(,), n As Integer, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_cmatrixinverse(a, n, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub cmatrixinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv.cmatrixinverse(a, n, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_cmatrixinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		matinv._pexec_cmatrixinverse(a, n, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a symmetric positive definite matrix which is given
'    by Cholesky decomposition.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'      ! algorithm  -  it  has  lots  of  internal synchronization points which
'      ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'      ! problems (N=thousands) can be efficiently parallelized.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   Cholesky decomposition of the matrix to be inverted:
'                    A=U?U or A = L*L'.
'                    Output of  SPDMatrixCholesky subroutine.
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   storage type (optional):
'                    * if True, symmetric  matrix  A  is  given  by  its  upper
'                      triangle, and the lower triangle isn  used/changed  by
'                      function
'                    * if False,  symmetric matrix  A  is  given  by  its lower
'                      triangle, and the  upper triangle isn used/changed  by
'                      function
'                    * if not given, lower half is used.
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB routine --
'         10.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spdmatrixcholeskyinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.spdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spdmatrixcholeskyinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_spdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spdmatrixcholeskyinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv.spdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spdmatrixcholeskyinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv._pexec_spdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a symmetric positive definite matrix.
'
'    Given an upper or lower triangle of a symmetric positive definite matrix,
'    the algorithm generates matrix A^-1 and saves the upper or lower triangle
'    depending on the input.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'      ! algorithm  -  it  has  lots  of  internal synchronization points which
'      ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'      ! problems (N=thousands) can be efficiently parallelized.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix to be inverted (upper or lower triangle).
'                    Array with elements [0..N-1,0..N-1].
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   storage type (optional):
'                    * if True, symmetric  matrix  A  is  given  by  its  upper
'                      triangle, and the lower triangle isn  used/changed  by
'                      function
'                    * if False,  symmetric matrix  A  is  given  by  its lower
'                      triangle, and the  upper triangle isn used/changed  by
'                      function
'                    * if not given,  both lower and upper  triangles  must  be
'                      filled.
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB routine --
'         10.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spdmatrixinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.spdmatrixinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spdmatrixinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_spdmatrixinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spdmatrixinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size")
		End If
		If Not alglib.ap.issymmetric(a) Then
			Throw New alglibexception("'a' parameter is not symmetric matrix")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv.spdmatrixinverse(a, n, isupper, info, rep.innerobj)
		If Not alglib.ap.forcesymmetric(a) Then
			Throw New alglibexception("Internal error while forcing symmetricity of 'a' parameter")
		End If
		Return
	End Sub


	Public Shared Sub smp_spdmatrixinverse(ByRef a As Double(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size")
		End If
		If Not alglib.ap.issymmetric(a) Then
			Throw New alglibexception("'a' parameter is not symmetric matrix")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv._pexec_spdmatrixinverse(a, n, isupper, info, rep.innerobj)
		If Not alglib.ap.forcesymmetric(a) Then
			Throw New alglibexception("Internal error while forcing symmetricity of 'a' parameter")
		End If
		Return
	End Sub

	'************************************************************************
'    Inversion of a Hermitian positive definite matrix which is given
'    by Cholesky decomposition.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'      ! algorithm  -  it  has  lots  of  internal synchronization points which
'      ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'      ! problems (N=thousands) can be efficiently parallelized.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   Cholesky decomposition of the matrix to be inverted:
'                    A=U?U or A = L*L'.
'                    Output of  HPDMatrixCholesky subroutine.
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   storage type (optional):
'                    * if True, symmetric  matrix  A  is  given  by  its  upper
'                      triangle, and the lower triangle isn  used/changed  by
'                      function
'                    * if False,  symmetric matrix  A  is  given  by  its lower
'                      triangle, and the  upper triangle isn used/changed  by
'                      function
'                    * if not given, lower half is used.
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB routine --
'         10.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hpdmatrixcholeskyinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.hpdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_hpdmatrixcholeskyinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_hpdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub hpdmatrixcholeskyinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv.hpdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_hpdmatrixcholeskyinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv._pexec_hpdmatrixcholeskyinverse(a, n, isupper, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Inversion of a Hermitian positive definite matrix.
'
'    Given an upper or lower triangle of a Hermitian positive definite matrix,
'    the algorithm generates matrix A^-1 and saves the upper or lower triangle
'    depending on the input.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'      ! algorithm  -  it  has  lots  of  internal synchronization points which
'      ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'      ! problems (N=thousands) can be efficiently parallelized.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix to be inverted (upper or lower triangle).
'                    Array with elements [0..N-1,0..N-1].
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   storage type (optional):
'                    * if True, symmetric  matrix  A  is  given  by  its  upper
'                      triangle, and the lower triangle isn  used/changed  by
'                      function
'                    * if False,  symmetric matrix  A  is  given  by  its lower
'                      triangle, and the  upper triangle isn used/changed  by
'                      function
'                    * if not given,  both lower and upper  triangles  must  be
'                      filled.
'
'    Output parameters:
'        Info    -   return code, same as in RMatrixLUInverse
'        Rep     -   solver report, same as in RMatrixLUInverse
'        A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'      -- ALGLIB routine --
'         10.02.2010
'         Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub hpdmatrixinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.hpdmatrixinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_hpdmatrixinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_hpdmatrixinverse(a, n, isupper, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub hpdmatrixinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size")
		End If
		If Not alglib.ap.ishermitian(a) Then
			Throw New alglibexception("'a' parameter is not Hermitian matrix")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv.hpdmatrixinverse(a, n, isupper, info, rep.innerobj)
		If Not alglib.ap.forcehermitian(a) Then
			Throw New alglibexception("Internal error while forcing Hermitian properties of 'a' parameter")
		End If
		Return
	End Sub


	Public Shared Sub smp_hpdmatrixinverse(ByRef a As complex(,), ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size")
		End If
		If Not alglib.ap.ishermitian(a) Then
			Throw New alglibexception("'a' parameter is not Hermitian matrix")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isupper = False
		matinv._pexec_hpdmatrixinverse(a, n, isupper, info, rep.innerobj)
		If Not alglib.ap.forcehermitian(a) Then
			Throw New alglibexception("Internal error while forcing Hermitian properties of 'a' parameter")
		End If
		Return
	End Sub

	'************************************************************************
'    Triangular matrix inverse (real)
'
'    The subroutine inverts the following types of matrices:
'        * upper triangular
'        * upper triangular with unit diagonal
'        * lower triangular
'        * lower triangular with unit diagonal
'
'    In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'    also be upper (lower) triangular, and after the end of the algorithm,  the
'    inverse matrix replaces the source matrix. The elements  below (above) the
'    main diagonal are not changed by the algorithm.
'
'    If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'    diagonal, and the diagonal elements are not passed to the algorithm.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that triangular inverse is harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix, array[0..N-1, 0..N-1].
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   diagonal type (optional):
'                    * if True, matrix has unit diagonal (a[i,i] are NOT used)
'                    * if False, matrix diagonal is arbitrary
'                    * if not given, False is assumed
'
'    Output parameters:
'        Info    -   same as for RMatrixLUInverse
'        Rep     -   same as for RMatrixLUInverse
'        A       -   same as for RMatrixLUInverse.
'
'      -- ALGLIB --
'         Copyright 05.02.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixtrinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.rmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_rmatrixtrinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_rmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub rmatrixtrinverse(ByRef a As Double(,), isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isunit As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isunit = False
		matinv.rmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_rmatrixtrinverse(ByRef a As Double(,), isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isunit As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isunit = False
		matinv._pexec_rmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Triangular matrix inverse (complex)
'
'    The subroutine inverts the following types of matrices:
'        * upper triangular
'        * upper triangular with unit diagonal
'        * lower triangular
'        * lower triangular with unit diagonal
'
'    In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'    also be upper (lower) triangular, and after the end of the algorithm,  the
'    inverse matrix replaces the source matrix. The elements  below (above) the
'    main diagonal are not changed by the algorithm.
'
'    If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'    diagonal, and the diagonal elements are not passed to the algorithm.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multicore support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'      ! * about 2-3x faster than ALGLIB for C++ without MKL
'      ! * about 7-10x faster than "pure C#" edition of ALGLIB
'      ! Difference in performance will be more striking  on  newer  CPU's with
'      ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'      ! problem whose size is at least 128, with best  efficiency achieved for
'      ! N's larger than 512.
'      !
'      ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'      ! of this function. We should note that triangular inverse is harder  to
'      ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'      ! many internal synchronization points which can not be avoided. However
'      ! parallelism starts to be profitable starting  from  N=1024,  achieving
'      ! near-linear speedup for N=4096 or higher.
'      !
'      ! In order to use multicore features you have to:
'      ! * use commercial version of ALGLIB
'      ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'      !   multicore code will be used (for multicore support)
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    Input parameters:
'        A       -   matrix, array[0..N-1, 0..N-1].
'        N       -   size of matrix A (optional) :
'                    * if given, only principal NxN submatrix is processed  and
'                      overwritten. other elements are unchanged.
'                    * if not given,  size  is  automatically  determined  from
'                      matrix size (A must be square matrix)
'        IsUpper -   True, if the matrix is upper triangular.
'        IsUnit  -   diagonal type (optional):
'                    * if True, matrix has unit diagonal (a[i,i] are NOT used)
'                    * if False, matrix diagonal is arbitrary
'                    * if not given, False is assumed
'
'    Output parameters:
'        Info    -   same as for RMatrixLUInverse
'        Rep     -   same as for RMatrixLUInverse
'        A       -   same as for RMatrixLUInverse.
'
'      -- ALGLIB --
'         Copyright 05.02.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub cmatrixtrinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv.cmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_cmatrixtrinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		info = 0
		rep = New matinvreport()
		matinv._pexec_cmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)
		Return
	End Sub
	Public Shared Sub cmatrixtrinverse(ByRef a As complex(,), isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isunit As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isunit = False
		matinv.cmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_cmatrixtrinverse(ByRef a As complex(,), isupper As Boolean, ByRef info As Integer, ByRef rep As matinvreport)
		Dim n As Integer
		Dim isunit As Boolean
		If (ap.cols(a) <> ap.rows(a)) Then
			Throw New alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size")
		End If
		info = 0
		rep = New matinvreport()
		n = ap.cols(a)
		isunit = False
		matinv._pexec_cmatrixtrinverse(a, n, isupper, isunit, info, rep.innerobj)

		Return
	End Sub

End Class
Public Partial Class alglib



End Class
Public Partial Class alglib


	'************************************************************************
'    This object stores state of the iterative norm estimation algorithm.
'
'    You should use ALGLIB functions to work with this object.
'    ************************************************************************

	Public Class normestimatorstate
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New normestimator.normestimatorstate()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New normestimatorstate(DirectCast(_innerobj.make_copy(), normestimator.normestimatorstate))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As normestimator.normestimatorstate
		Public ReadOnly Property innerobj() As normestimator.normestimatorstate
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As normestimator.normestimatorstate)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This procedure initializes matrix norm estimator.
'
'    USAGE:
'    1. User initializes algorithm state with NormEstimatorCreate() call
'    2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())
'    3. User calls NormEstimatorResults() to get solution.
'
'    INPUT PARAMETERS:
'        M       -   number of rows in the matrix being estimated, M>0
'        N       -   number of columns in the matrix being estimated, N>0
'        NStart  -   number of random starting vectors
'                    recommended value - at least 5.
'        NIts    -   number of iterations to do with best starting vector
'                    recommended value - at least 5.
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'
'    NOTE: this algorithm is effectively deterministic, i.e. it always  returns
'    same result when repeatedly called for the same matrix. In fact, algorithm
'    uses randomized starting vectors, but internal  random  numbers  generator
'    always generates same sequence of the random values (it is a  feature, not
'    bug).
'
'    Algorithm can be made non-deterministic with NormEstimatorSetSeed(0) call.
'
'      -- ALGLIB --
'         Copyright 06.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub normestimatorcreate(m As Integer, n As Integer, nstart As Integer, nits As Integer, ByRef state As normestimatorstate)
		state = New normestimatorstate()
		normestimator.normestimatorcreate(m, n, nstart, nits, state.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function changes seed value used by algorithm. In some cases we  need
'    deterministic processing, i.e. subsequent calls must return equal results,
'    in other cases we need non-deterministic algorithm which returns different
'    results for the same matrix on every pass.
'
'    Setting zero seed will lead to non-deterministic algorithm, while non-zero
'    value will make our algorithm deterministic.
'
'    INPUT PARAMETERS:
'        State       -   norm estimator state, must be initialized with a  call
'                        to NormEstimatorCreate()
'        SeedVal     -   seed value, >=0. Zero value = non-deterministic algo.
'
'      -- ALGLIB --
'         Copyright 06.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub normestimatorsetseed(state As normestimatorstate, seedval As Integer)

		normestimator.normestimatorsetseed(state.innerobj, seedval)
		Return
	End Sub

	'************************************************************************
'    This function estimates norm of the sparse M*N matrix A.
'
'    INPUT PARAMETERS:
'        State       -   norm estimator state, must be initialized with a  call
'                        to NormEstimatorCreate()
'        A           -   sparse M*N matrix, must be converted to CRS format
'                        prior to calling this function.
'
'    After this function  is  over  you can call NormEstimatorResults() to get
'    estimate of the norm(A).
'
'      -- ALGLIB --
'         Copyright 06.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub normestimatorestimatesparse(state As normestimatorstate, a As sparsematrix)

		normestimator.normestimatorestimatesparse(state.innerobj, a.innerobj)
		Return
	End Sub

	'************************************************************************
'    Matrix norm estimation results
'
'    INPUT PARAMETERS:
'        State   -   algorithm state
'
'    OUTPUT PARAMETERS:
'        Nrm     -   estimate of the matrix norm, Nrm>=0
'
'      -- ALGLIB --
'         Copyright 06.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub normestimatorresults(state As normestimatorstate, ByRef nrm As Double)
		nrm = 0
		normestimator.normestimatorresults(state.innerobj, nrm)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Determinant calculation of the matrix given by its LU decomposition.
'
'    Input parameters:
'        A       -   LU decomposition of the matrix (output of
'                    RMatrixLU subroutine).
'        Pivots  -   table of permutations which were made during
'                    the LU decomposition.
'                    Output of RMatrixLU subroutine.
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'
'    Result: matrix determinant.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function rmatrixludet(a As Double(,), pivots As Integer(), n As Integer) As Double

		Dim result As Double = matdet.rmatrixludet(a, pivots, n)
		Return result
	End Function
	Public Shared Function rmatrixludet(a As Double(,), pivots As Integer()) As Double
		Dim n As Integer
		If (ap.rows(a) <> ap.cols(a)) OrElse (ap.rows(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'rmatrixludet': looks like one of arguments has wrong size")
		End If

		n = ap.rows(a)
		Dim result As Double = matdet.rmatrixludet(a, pivots, n)

		Return result
	End Function

	'************************************************************************
'    Calculation of the determinant of a general matrix
'
'    Input parameters:
'        A       -   matrix, array[0..N-1, 0..N-1]
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'
'    Result: determinant of matrix A.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function rmatrixdet(a As Double(,), n As Integer) As Double

		Dim result As Double = matdet.rmatrixdet(a, n)
		Return result
	End Function
	Public Shared Function rmatrixdet(a As Double(,)) As Double
		Dim n As Integer
		If (ap.rows(a) <> ap.cols(a)) Then
			Throw New alglibexception("Error while calling 'rmatrixdet': looks like one of arguments has wrong size")
		End If

		n = ap.rows(a)
		Dim result As Double = matdet.rmatrixdet(a, n)

		Return result
	End Function

	'************************************************************************
'    Determinant calculation of the matrix given by its LU decomposition.
'
'    Input parameters:
'        A       -   LU decomposition of the matrix (output of
'                    RMatrixLU subroutine).
'        Pivots  -   table of permutations which were made during
'                    the LU decomposition.
'                    Output of RMatrixLU subroutine.
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'
'    Result: matrix determinant.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function cmatrixludet(a As complex(,), pivots As Integer(), n As Integer) As complex

		Dim result As complex = matdet.cmatrixludet(a, pivots, n)
		Return result
	End Function
	Public Shared Function cmatrixludet(a As complex(,), pivots As Integer()) As complex
		Dim n As Integer
		If (ap.rows(a) <> ap.cols(a)) OrElse (ap.rows(a) <> ap.len(pivots)) Then
			Throw New alglibexception("Error while calling 'cmatrixludet': looks like one of arguments has wrong size")
		End If

		n = ap.rows(a)
		Dim result As complex = matdet.cmatrixludet(a, pivots, n)

		Return result
	End Function

	'************************************************************************
'    Calculation of the determinant of a general matrix
'
'    Input parameters:
'        A       -   matrix, array[0..N-1, 0..N-1]
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'
'    Result: determinant of matrix A.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function cmatrixdet(a As complex(,), n As Integer) As complex

		Dim result As complex = matdet.cmatrixdet(a, n)
		Return result
	End Function
	Public Shared Function cmatrixdet(a As complex(,)) As complex
		Dim n As Integer
		If (ap.rows(a) <> ap.cols(a)) Then
			Throw New alglibexception("Error while calling 'cmatrixdet': looks like one of arguments has wrong size")
		End If

		n = ap.rows(a)
		Dim result As complex = matdet.cmatrixdet(a, n)

		Return result
	End Function

	'************************************************************************
'    Determinant calculation of the matrix given by the Cholesky decomposition.
'
'    Input parameters:
'        A       -   Cholesky decomposition,
'                    output of SMatrixCholesky subroutine.
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'
'    As the determinant is equal to the product of squares of diagonal elements,
'    it not necessary to specify which triangle - lower or upper - the matrix
'    is stored in.
'
'    Result:
'        matrix determinant.
'
'      -- ALGLIB --
'         Copyright 2005-2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spdmatrixcholeskydet(a As Double(,), n As Integer) As Double

		Dim result As Double = matdet.spdmatrixcholeskydet(a, n)
		Return result
	End Function
	Public Shared Function spdmatrixcholeskydet(a As Double(,)) As Double
		Dim n As Integer
		If (ap.rows(a) <> ap.cols(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size")
		End If

		n = ap.rows(a)
		Dim result As Double = matdet.spdmatrixcholeskydet(a, n)

		Return result
	End Function

	'************************************************************************
'    Determinant calculation of the symmetric positive definite matrix.
'
'    Input parameters:
'        A       -   matrix. Array with elements [0..N-1, 0..N-1].
'        N       -   (optional) size of matrix A:
'                    * if given, only principal NxN submatrix is processed and
'                      overwritten. other elements are unchanged.
'                    * if not given, automatically determined from matrix size
'                      (A must be square matrix)
'        IsUpper -   (optional) storage type:
'                    * if True, symmetric matrix  A  is  given  by  its  upper
'                      triangle, and the lower triangle isn used/changed  by
'                      function
'                    * if False, symmetric matrix  A  is  given  by  its lower
'                      triangle, and the upper triangle isn used/changed  by
'                      function
'                    * if not given, both lower and upper  triangles  must  be
'                      filled.
'
'    Result:
'        determinant of matrix A.
'        If matrix A is not positive definite, exception is thrown.
'
'      -- ALGLIB --
'         Copyright 2005-2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spdmatrixdet(a As Double(,), n As Integer, isupper As Boolean) As Double

		Dim result As Double = matdet.spdmatrixdet(a, n, isupper)
		Return result
	End Function
	Public Shared Function spdmatrixdet(a As Double(,)) As Double
		Dim n As Integer
		Dim isupper As Boolean
		If (ap.rows(a) <> ap.cols(a)) Then
			Throw New alglibexception("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size")
		End If
		If Not alglib.ap.issymmetric(a) Then
			Throw New alglibexception("'a' parameter is not symmetric matrix")
		End If

		n = ap.rows(a)
		isupper = False
		Dim result As Double = matdet.spdmatrixdet(a, n, isupper)

		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Algorithm for solving the following generalized symmetric positive-definite
'    eigenproblem:
'        A*x = lambda*B*x (1) or
'        A*B*x = lambda*x (2) or
'        B*A*x = lambda*x (3).
'    where A is a symmetric matrix, B - symmetric positive-definite matrix.
'    The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
'    problem.
'
'    Input parameters:
'        A           -   symmetric matrix which is given by its upper or lower
'                        triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        N           -   size of matrices A and B.
'        IsUpperA    -   storage format of matrix A.
'        B           -   symmetric positive-definite matrix which is given by
'                        its upper or lower triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        IsUpperB    -   storage format of matrix B.
'        ZNeeded     -   if ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'        ProblemType -   if ProblemType is equal to:
'                         * 1, the following problem is solved: A*x = lambda*B*x;
'                         * 2, the following problem is solved: A*B*x = lambda*x;
'                         * 3, the following problem is solved: B*A*x = lambda*x.
'
'    Output parameters:
'        D           -   eigenvalues in ascending order.
'                        Array whose index ranges within [0..N-1].
'        Z           -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'                        The eigenvectors are stored in matrix columns. It should
'                        be noted that the eigenvectors in such problems do not
'                        form an orthogonal system.
'
'    Result:
'        True, if the problem was solved successfully.
'        False, if the error occurred during the Cholesky decomposition of matrix
'        B (the matrix isn positive-definite) or during the work of the iterative
'        algorithm for solving the symmetric eigenproblem.
'
'    See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.
'
'      -- ALGLIB --
'         Copyright 1.28.2006 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixgevd(a As Double(,), n As Integer, isuppera As Boolean, b As Double(,), isupperb As Boolean, zneeded As Integer, _
		problemtype As Integer, ByRef d As Double(), ByRef z As Double(,)) As Boolean
		d = New Double(-1) {}
		z = New Double(-1, -1) {}
		Dim result As Boolean = spdgevd.smatrixgevd(a, n, isuppera, b, isupperb, zneeded, _
			problemtype, d, z)
		Return result
	End Function

	'************************************************************************
'    Algorithm for reduction of the following generalized symmetric positive-
'    definite eigenvalue problem:
'        A*x = lambda*B*x (1) or
'        A*B*x = lambda*x (2) or
'        B*A*x = lambda*x (3)
'    to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
'    the given problems are the same, and the eigenvectors of the given problem
'    could be obtained by multiplying the obtained eigenvectors by the
'    transformation matrix x = R*y).
'
'    Here A is a symmetric matrix, B - symmetric positive-definite matrix.
'
'    Input parameters:
'        A           -   symmetric matrix which is given by its upper or lower
'                        triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        N           -   size of matrices A and B.
'        IsUpperA    -   storage format of matrix A.
'        B           -   symmetric positive-definite matrix which is given by
'                        its upper or lower triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        IsUpperB    -   storage format of matrix B.
'        ProblemType -   if ProblemType is equal to:
'                         * 1, the following problem is solved: A*x = lambda*B*x;
'                         * 2, the following problem is solved: A*B*x = lambda*x;
'                         * 3, the following problem is solved: B*A*x = lambda*x.
'
'    Output parameters:
'        A           -   symmetric matrix which is given by its upper or lower
'                        triangle depending on IsUpperA. Contains matrix C.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        R           -   upper triangular or low triangular transformation matrix
'                        which is used to obtain the eigenvectors of a given problem
'                        as the product of eigenvectors of C (from the right) and
'                        matrix R (from the left). If the matrix is upper
'                        triangular, the elements below the main diagonal
'                        are equal to 0 (and vice versa). Thus, we can perform
'                        the multiplication without taking into account the
'                        internal structure (which is an easier though less
'                        effective way).
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        IsUpperR    -   type of matrix R (upper or lower triangular).
'
'    Result:
'        True, if the problem was reduced successfully.
'        False, if the error occurred during the Cholesky decomposition of
'            matrix B (the matrix is not positive-definite).
'
'      -- ALGLIB --
'         Copyright 1.28.2006 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function smatrixgevdreduce(ByRef a As Double(,), n As Integer, isuppera As Boolean, b As Double(,), isupperb As Boolean, problemtype As Integer, _
		ByRef r As Double(,), ByRef isupperr As Boolean) As Boolean
		r = New Double(-1, -1) {}
		isupperr = False
		Dim result As Boolean = spdgevd.smatrixgevdreduce(a, n, isuppera, b, isupperb, problemtype, _
			r, isupperr)
		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    Inverse matrix update by the Sherman-Morrison formula
'
'    The algorithm updates matrix A^-1 when adding a number to an element
'    of matrix A.
'
'    Input parameters:
'        InvA    -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        UpdRow  -   row where the element to be updated is stored.
'        UpdColumn - column where the element to be updated is stored.
'        UpdVal  -   a number to be added to the element.
'
'
'    Output parameters:
'        InvA    -   inverse of modified matrix A.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixinvupdatesimple(ByRef inva As Double(,), n As Integer, updrow As Integer, updcolumn As Integer, updval As Double)

		inverseupdate.rmatrixinvupdatesimple(inva, n, updrow, updcolumn, updval)
		Return
	End Sub

	'************************************************************************
'    Inverse matrix update by the Sherman-Morrison formula
'
'    The algorithm updates matrix A^-1 when adding a vector to a row
'    of matrix A.
'
'    Input parameters:
'        InvA    -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        UpdRow  -   the row of A whose vector V was added.
'                    0 <= Row <= N-1
'        V       -   the vector to be added to a row.
'                    Array whose index ranges within [0..N-1].
'
'    Output parameters:
'        InvA    -   inverse of modified matrix A.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixinvupdaterow(ByRef inva As Double(,), n As Integer, updrow As Integer, v As Double())

		inverseupdate.rmatrixinvupdaterow(inva, n, updrow, v)
		Return
	End Sub

	'************************************************************************
'    Inverse matrix update by the Sherman-Morrison formula
'
'    The algorithm updates matrix A^-1 when adding a vector to a column
'    of matrix A.
'
'    Input parameters:
'        InvA        -   inverse of matrix A.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'        N           -   size of matrix A.
'        UpdColumn   -   the column of A whose vector U was added.
'                        0 <= UpdColumn <= N-1
'        U           -   the vector to be added to a column.
'                        Array whose index ranges within [0..N-1].
'
'    Output parameters:
'        InvA        -   inverse of modified matrix A.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixinvupdatecolumn(ByRef inva As Double(,), n As Integer, updcolumn As Integer, u As Double())

		inverseupdate.rmatrixinvupdatecolumn(inva, n, updcolumn, u)
		Return
	End Sub

	'************************************************************************
'    Inverse matrix update by the Sherman-Morrison formula
'
'    The algorithm computes the inverse of matrix A+u*v?by using the given matrix
'    A^-1 and the vectors u and v.
'
'    Input parameters:
'        InvA    -   inverse of matrix A.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'        N       -   size of matrix A.
'        U       -   the vector modifying the matrix.
'                    Array whose index ranges within [0..N-1].
'        V       -   the vector modifying the matrix.
'                    Array whose index ranges within [0..N-1].
'
'    Output parameters:
'        InvA - inverse of matrix A + u*v'.
'
'      -- ALGLIB --
'         Copyright 2005 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rmatrixinvupdateuv(ByRef inva As Double(,), n As Integer, u As Double(), v As Double())

		inverseupdate.rmatrixinvupdateuv(inva, n, u, v)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Subroutine performing the Schur decomposition of a general matrix by using
'    the QR algorithm with multiple shifts.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes one  important  improvement   of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Multithreaded acceleration is NOT supported for this function.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    The source matrix A is represented as S'*A*S = T, where S is an orthogonal
'    matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
'    sizes 1x1 and 2x2 on the main diagonal).
'
'    Input parameters:
'        A   -   matrix to be decomposed.
'                Array whose indexes range within [0..N-1, 0..N-1].
'        N   -   size of A, N>=0.
'
'
'    Output parameters:
'        A   -   contains matrix T.
'                Array whose indexes range within [0..N-1, 0..N-1].
'        S   -   contains Schur vectors.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'    Note 1:
'        The block structure of matrix T can be easily recognized: since all
'        the elements below the blocks are zeros, the elements a[i+1,i] which
'        are equal to 0 show the block border.
'
'    Note 2:
'        The algorithm performance depends on the value of the internal parameter
'        NS of the InternalSchurDecomposition subroutine which defines the number
'        of shifts in the QR algorithm (similarly to the block width in block-matrix
'        algorithms in linear algebra). If you require maximum performance on
'        your machine, it is recommended to adjust this parameter manually.
'
'    Result:
'        True,
'            if the algorithm has converged and parameters A and S contain the result.
'        False,
'            if the algorithm has not converged.
'
'    Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
'    ************************************************************************

	Public Shared Function rmatrixschur(ByRef a As Double(,), n As Integer, ByRef s As Double(,)) As Boolean
		s = New Double(-1, -1) {}
		Dim result As Boolean = schur.rmatrixschur(a, n, s)
		Return result
	End Function

End Class
Public Partial Class alglib
	Public Class ablas
		Public Const rgemmparallelsize As Integer = 64
		Public Const cgemmparallelsize As Integer = 64


		'************************************************************************
'        Splits matrix length in two parts, left part should match ABLAS block size
'
'        INPUT PARAMETERS
'            A   -   real matrix, is passed to ensure that we didn't split
'                    complex matrix using real splitting subroutine.
'                    matrix itself is not changed.
'            N   -   length, N>0
'
'        OUTPUT PARAMETERS
'            N1  -   length
'            N2  -   length
'
'        N1+N2=N, N1>=N2, N2 may be zero
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub ablassplitlength(a As Double(,), n As Integer, ByRef n1 As Integer, ByRef n2 As Integer)
			n1 = 0
			n2 = 0

			If n > ablasblocksize(a) Then
				ablasinternalsplitlength(n, ablasblocksize(a), n1, n2)
			Else
				ablasinternalsplitlength(n, ablasmicroblocksize(), n1, n2)
			End If
		End Sub


		'************************************************************************
'        Complex ABLASSplitLength
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub ablascomplexsplitlength(a As complex(,), n As Integer, ByRef n1 As Integer, ByRef n2 As Integer)
			n1 = 0
			n2 = 0

			If n > ablascomplexblocksize(a) Then
				ablasinternalsplitlength(n, ablascomplexblocksize(a), n1, n2)
			Else
				ablasinternalsplitlength(n, ablasmicroblocksize(), n1, n2)
			End If
		End Sub


		'************************************************************************
'        Returns block size - subdivision size where  cache-oblivious  soubroutines
'        switch to the optimized kernel.
'
'        INPUT PARAMETERS
'            A   -   real matrix, is passed to ensure that we didn't split
'                    complex matrix using real splitting subroutine.
'                    matrix itself is not changed.
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function ablasblocksize(a As Double(,)) As Integer
			Dim result As Integer = 0

			result = 32
			Return result
		End Function


		'************************************************************************
'        Block size for complex subroutines.
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function ablascomplexblocksize(a As complex(,)) As Integer
			Dim result As Integer = 0

			result = 24
			Return result
		End Function


		'************************************************************************
'        Microblock size
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function ablasmicroblocksize() As Integer
			Dim result As Integer = 0

			result = 8
			Return result
		End Function


		'************************************************************************
'        Cache-oblivous complex "copy-and-transpose"
'
'        Input parameters:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   source matrix, MxN submatrix is copied and transposed
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            B   -   destination matrix, must be large enough to store result
'            IB  -   submatrix offset (row index)
'            JB  -   submatrix offset (column index)
'        ************************************************************************

		Public Shared Sub cmatrixtranspose(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, ByRef b As complex(,), _
			ib As Integer, jb As Integer)
			Dim i As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m <= 2 * ablascomplexblocksize(a) AndAlso n <= 2 * ablascomplexblocksize(a) Then

				'
				' base case
				'
				For i = 0 To m - 1
					i1_ = (ja) - (ib)
					For i_ = ib To ib + n - 1
						b(i_, jb + i) = a(ia + i, i_ + i1_)
					Next
				Next
			Else

				'
				' Cache-oblivious recursion
				'
				If m > n Then
					ablascomplexsplitlength(a, m, s1, s2)
					cmatrixtranspose(s1, n, a, ia, ja, b, _
						ib, jb)
					cmatrixtranspose(s2, n, a, ia + s1, ja, b, _
						ib, jb + s1)
				Else
					ablascomplexsplitlength(a, n, s1, s2)
					cmatrixtranspose(m, s1, a, ia, ja, b, _
						ib, jb)
					cmatrixtranspose(m, s2, a, ia, ja + s1, b, _
						ib + s1, jb)
				End If
			End If
		End Sub


		'************************************************************************
'        Cache-oblivous real "copy-and-transpose"
'
'        Input parameters:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   source matrix, MxN submatrix is copied and transposed
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            B   -   destination matrix, must be large enough to store result
'            IB  -   submatrix offset (row index)
'            JB  -   submatrix offset (column index)
'        ************************************************************************

		Public Shared Sub rmatrixtranspose(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, b As Double(,), _
			ib As Integer, jb As Integer)
			Dim i As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m <= 2 * ablasblocksize(a) AndAlso n <= 2 * ablasblocksize(a) Then

				'
				' base case
				'
				For i = 0 To m - 1
					i1_ = (ja) - (ib)
					For i_ = ib To ib + n - 1
						b(i_, jb + i) = a(ia + i, i_ + i1_)
					Next
				Next
			Else

				'
				' Cache-oblivious recursion
				'
				If m > n Then
					ablassplitlength(a, m, s1, s2)
					rmatrixtranspose(s1, n, a, ia, ja, b, _
						ib, jb)
					rmatrixtranspose(s2, n, a, ia + s1, ja, b, _
						ib, jb + s1)
				Else
					ablassplitlength(a, n, s1, s2)
					rmatrixtranspose(m, s1, a, ia, ja, b, _
						ib, jb)
					rmatrixtranspose(m, s2, a, ia, ja + s1, b, _
						ib + s1, jb)
				End If
			End If
		End Sub


		'************************************************************************
'        This code enforces symmetricy of the matrix by copying Upper part to lower
'        one (or vice versa).
'
'        INPUT PARAMETERS:
'            A   -   matrix
'            N   -   number of rows/columns
'            IsUpper - whether we want to copy upper triangle to lower one (True)
'                    or vice versa (False).
'        ************************************************************************

		Public Shared Sub rmatrixenforcesymmetricity(a As Double(,), n As Integer, isupper As Boolean)
			Dim i As Integer = 0
			Dim j As Integer = 0

			If isupper Then
				For i = 0 To n - 1
					For j = i + 1 To n - 1
						a(j, i) = a(i, j)
					Next
				Next
			Else
				For i = 0 To n - 1
					For j = i + 1 To n - 1
						a(i, j) = a(j, i)
					Next
				Next
			End If
		End Sub


		'************************************************************************
'        Copy
'
'        Input parameters:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   source matrix, MxN submatrix is copied and transposed
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            B   -   destination matrix, must be large enough to store result
'            IB  -   submatrix offset (row index)
'            JB  -   submatrix offset (column index)
'        ************************************************************************

		Public Shared Sub cmatrixcopy(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, ByRef b As complex(,), _
			ib As Integer, jb As Integer)
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 OrElse n = 0 Then
				Return
			End If
			For i = 0 To m - 1
				i1_ = (ja) - (jb)
				For i_ = jb To jb + n - 1
					b(ib + i, i_) = a(ia + i, i_ + i1_)
				Next
			Next
		End Sub


		'************************************************************************
'        Copy
'
'        Input parameters:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   source matrix, MxN submatrix is copied and transposed
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            B   -   destination matrix, must be large enough to store result
'            IB  -   submatrix offset (row index)
'            JB  -   submatrix offset (column index)
'        ************************************************************************

		Public Shared Sub rmatrixcopy(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, ByRef b As Double(,), _
			ib As Integer, jb As Integer)
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 OrElse n = 0 Then
				Return
			End If
			For i = 0 To m - 1
				i1_ = (ja) - (jb)
				For i_ = jb To jb + n - 1
					b(ib + i, i_) = a(ia + i, i_ + i1_)
				Next
			Next
		End Sub


		'************************************************************************
'        Rank-1 correction: A := A + u*v'
'
'        INPUT PARAMETERS:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   target matrix, MxN submatrix is updated
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            U   -   vector #1
'            IU  -   subvector offset
'            V   -   vector #2
'            IV  -   subvector offset
'        ************************************************************************

		Public Shared Sub cmatrixrank1(m As Integer, n As Integer, ByRef a As complex(,), ia As Integer, ja As Integer, ByRef u As complex(), _
			iu As Integer, ByRef v As complex(), iv As Integer)
			Dim i As Integer = 0
			Dim s As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 OrElse n = 0 Then
				Return
			End If
			If ablasf.cmatrixrank1f(m, n, a, ia, ja, u, _
				iu, v, iv) Then
				Return
			End If
			For i = 0 To m - 1
				s = u(iu + i)
				i1_ = (iv) - (ja)
				For i_ = ja To ja + n - 1
					a(ia + i, i_) = a(ia + i, i_) + s * v(i_ + i1_)
				Next
			Next
		End Sub


		'************************************************************************
'        Rank-1 correction: A := A + u*v'
'
'        INPUT PARAMETERS:
'            M   -   number of rows
'            N   -   number of columns
'            A   -   target matrix, MxN submatrix is updated
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            U   -   vector #1
'            IU  -   subvector offset
'            V   -   vector #2
'            IV  -   subvector offset
'        ************************************************************************

		Public Shared Sub rmatrixrank1(m As Integer, n As Integer, ByRef a As Double(,), ia As Integer, ja As Integer, ByRef u As Double(), _
			iu As Integer, ByRef v As Double(), iv As Integer)
			Dim i As Integer = 0
			Dim s As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 OrElse n = 0 Then
				Return
			End If
			If ablasf.rmatrixrank1f(m, n, a, ia, ja, u, _
				iu, v, iv) Then
				Return
			End If
			For i = 0 To m - 1
				s = u(iu + i)
				i1_ = (iv) - (ja)
				For i_ = ja To ja + n - 1
					a(ia + i, i_) = a(ia + i, i_) + s * v(i_ + i1_)
				Next
			Next
		End Sub


		'************************************************************************
'        Matrix-vector product: y := op(A)*x
'
'        INPUT PARAMETERS:
'            M   -   number of rows of op(A)
'                    M>=0
'            N   -   number of columns of op(A)
'                    N>=0
'            A   -   target matrix
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            OpA -   operation type:
'                    * OpA=0     =>  op(A) = A
'                    * OpA=1     =>  op(A) = A^T
'                    * OpA=2     =>  op(A) = A^H
'            X   -   input vector
'            IX  -   subvector offset
'            IY  -   subvector offset
'            Y   -   preallocated matrix, must be large enough to store result
'
'        OUTPUT PARAMETERS:
'            Y   -   vector which stores result
'
'        if M=0, then subroutine does nothing.
'        if N=0, Y is filled by zeros.
'
'
'          -- ALGLIB routine --
'
'             28.01.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixmv(m As Integer, n As Integer, a As complex(,), ia As Integer, ja As Integer, opa As Integer, _
			x As complex(), ix As Integer, ByRef y As complex(), iy As Integer)
			Dim i As Integer = 0
			Dim v As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 Then
				Return
			End If
			If n = 0 Then
				For i = 0 To m - 1
					y(iy + i) = 0
				Next
				Return
			End If
			If ablasf.cmatrixmvf(m, n, a, ia, ja, opa, _
				x, ix, y, iy) Then
				Return
			End If
			If opa = 0 Then

				'
				' y = A*x
				'
				For i = 0 To m - 1
					i1_ = (ix) - (ja)
					v = 0.0
					For i_ = ja To ja + n - 1
						v += a(ia + i, i_) * x(i_ + i1_)
					Next
					y(iy + i) = v
				Next
				Return
			End If
			If opa = 1 Then

				'
				' y = A^T*x
				'
				For i = 0 To m - 1
					y(iy + i) = 0
				Next
				For i = 0 To n - 1
					v = x(ix + i)
					i1_ = (ja) - (iy)
					For i_ = iy To iy + m - 1
						y(i_) = y(i_) + v * a(ia + i, i_ + i1_)
					Next
				Next
				Return
			End If
			If opa = 2 Then

				'
				' y = A^H*x
				'
				For i = 0 To m - 1
					y(iy + i) = 0
				Next
				For i = 0 To n - 1
					v = x(ix + i)
					i1_ = (ja) - (iy)
					For i_ = iy To iy + m - 1
						y(i_) = y(i_) + v * Math.conj(a(ia + i, i_ + i1_))
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        Matrix-vector product: y := op(A)*x
'
'        INPUT PARAMETERS:
'            M   -   number of rows of op(A)
'            N   -   number of columns of op(A)
'            A   -   target matrix
'            IA  -   submatrix offset (row index)
'            JA  -   submatrix offset (column index)
'            OpA -   operation type:
'                    * OpA=0     =>  op(A) = A
'                    * OpA=1     =>  op(A) = A^T
'            X   -   input vector
'            IX  -   subvector offset
'            IY  -   subvector offset
'            Y   -   preallocated matrix, must be large enough to store result
'
'        OUTPUT PARAMETERS:
'            Y   -   vector which stores result
'
'        if M=0, then subroutine does nothing.
'        if N=0, Y is filled by zeros.
'
'
'          -- ALGLIB routine --
'
'             28.01.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixmv(m As Integer, n As Integer, a As Double(,), ia As Integer, ja As Integer, opa As Integer, _
			x As Double(), ix As Integer, ByRef y As Double(), iy As Integer)
			Dim i As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If m = 0 Then
				Return
			End If
			If n = 0 Then
				For i = 0 To m - 1
					y(iy + i) = 0
				Next
				Return
			End If
			If ablasf.rmatrixmvf(m, n, a, ia, ja, opa, _
				x, ix, y, iy) Then
				Return
			End If
			If opa = 0 Then

				'
				' y = A*x
				'
				For i = 0 To m - 1
					i1_ = (ix) - (ja)
					v = 0.0
					For i_ = ja To ja + n - 1
						v += a(ia + i, i_) * x(i_ + i1_)
					Next
					y(iy + i) = v
				Next
				Return
			End If
			If opa = 1 Then

				'
				' y = A^T*x
				'
				For i = 0 To m - 1
					y(iy + i) = 0
				Next
				For i = 0 To n - 1
					v = x(ix + i)
					i1_ = (ja) - (iy)
					For i_ = iy To iy + m - 1
						y(i_) = y(i_) + v * a(ia + i, i_ + i1_)
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This subroutine calculates X*op(A^-1) where:
'        * X is MxN general matrix
'        * A is NxN upper/lower triangular/unitriangular matrix
'        * "op" may be identity transformation, transposition, conjugate transposition
'
'        Multiplication result replaces X.
'        Cache-oblivious algorithm is used.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N   -   matrix size, N>=0
'            M   -   matrix size, N>=0
'            A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'            I1      -   submatrix offset
'            J1      -   submatrix offset
'            IsUpper -   whether matrix is upper triangular
'            IsUnit  -   whether matrix is unitriangular
'            OpType  -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'                        * 2 - conjugate transposition
'            X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'            I2  -   submatrix offset
'            J2  -   submatrix offset
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixrighttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablascomplexblocksize(a)

			'
			' Basecase: either MKL-supported code or ALGLIB basecase code
			'
			If ablasmkl.cmatrixrighttrsmmkl(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If
			If m <= bs AndAlso n <= bs Then
				cmatrixrighttrsm2(m, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				Return
			End If

			'
			' Recursive subdivision
			'
			If m >= n Then

				'
				' Split X: X*A = (X1 X2)^T*A
				'
				ablascomplexsplitlength(a, m, s1, s2)
				cmatrixrighttrsm(s1, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				cmatrixrighttrsm(s2, n, a, i1, j1, isupper, _
					isunit, optype, x, i2 + s1, j2)
				Return
			Else

				'
				' Split A:
				'               (A1  A12)
				' X*op(A) = X*op(       )
				'               (     A2)
				'
				' Different variants depending on
				' IsUpper/OpType combinations
				'
				ablascomplexsplitlength(a, n, s1, s2)
				If isupper AndAlso optype = 0 Then

					'
					'                  (A1  A12)-1
					' X*A^-1 = (X1 X2)*(       )
					'                  (     A2)
					'
					cmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					cmatrixgemm(m, s2, s1, -1.0, x, i2, _
						j2, 0, a, i1, j1 + s1, 0, _
						1.0, x, i2, j2 + s1)
					cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					Return
				End If
				If isupper AndAlso optype <> 0 Then

					'
					'                  (A1'     )-1
					' X*A^-1 = (X1 X2)*(        )
					'                  (A12' A2')
					'
					cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					cmatrixgemm(m, s1, s2, -1.0, x, i2, _
						j2 + s1, 0, a, i1, j1 + s1, optype, _
						1.0, x, i2, j2)
					cmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If Not isupper AndAlso optype = 0 Then

					'
					'                  (A1     )-1
					' X*A^-1 = (X1 X2)*(       )
					'                  (A21  A2)
					'
					cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					cmatrixgemm(m, s1, s2, -1.0, x, i2, _
						j2 + s1, 0, a, i1 + s1, j1, 0, _
						1.0, x, i2, j2)
					cmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If Not isupper AndAlso optype <> 0 Then

					'
					'                  (A1' A21')-1
					' X*A^-1 = (X1 X2)*(        )
					'                  (     A2')
					'
					cmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					cmatrixgemm(m, s2, s1, -1.0, x, i2, _
						j2, 0, a, i1 + s1, j1, optype, _
						1.0, x, i2, j2 + s1)
					cmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixrighttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			cmatrixrighttrsm(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2)
		End Sub


		'************************************************************************
'        This subroutine calculates op(A^-1)*X where:
'        * X is MxN general matrix
'        * A is MxM upper/lower triangular/unitriangular matrix
'        * "op" may be identity transformation, transposition, conjugate transposition
'
'        Multiplication result replaces X.
'        Cache-oblivious algorithm is used.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N   -   matrix size, N>=0
'            M   -   matrix size, N>=0
'            A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'            I1      -   submatrix offset
'            J1      -   submatrix offset
'            IsUpper -   whether matrix is upper triangular
'            IsUnit  -   whether matrix is unitriangular
'            OpType  -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'                        * 2 - conjugate transposition
'            X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'            I2  -   submatrix offset
'            J2  -   submatrix offset
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixlefttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablascomplexblocksize(a)

			'
			' Basecase: either MKL-supported code or ALGLIB basecase code
			'
			If ablasmkl.cmatrixlefttrsmmkl(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If
			If m <= bs AndAlso n <= bs Then
				cmatrixlefttrsm2(m, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				Return
			End If

			'
			' Recursive subdivision
			'
			If n >= m Then

				'
				' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
				'
				ablascomplexsplitlength(x, n, s1, s2)
				cmatrixlefttrsm(m, s1, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				cmatrixlefttrsm(m, s2, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2 + s1)
				Return
			Else

				'
				' Split A
				'
				ablascomplexsplitlength(a, m, s1, s2)
				If isupper AndAlso optype = 0 Then

					'
					'           (A1  A12)-1  ( X1 )
					' A^-1*X* = (       )   *(    )
					'           (     A2)    ( X2 )
					'
					cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					cmatrixgemm(s1, n, s2, -1.0, a, i1, _
						j1 + s1, 0, x, i2 + s1, j2, 0, _
						1.0, x, i2, j2)
					cmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If isupper AndAlso optype <> 0 Then

					'
					'          (A1'     )-1 ( X1 )
					' A^-1*X = (        )  *(    )
					'          (A12' A2')   ( X2 )
					'
					cmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					cmatrixgemm(s2, n, s1, -1.0, a, i1, _
						j1 + s1, optype, x, i2, j2, 0, _
						1.0, x, i2 + s1, j2)
					cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					Return
				End If
				If Not isupper AndAlso optype = 0 Then

					'
					'          (A1     )-1 ( X1 )
					' A^-1*X = (       )  *(    )
					'          (A21  A2)   ( X2 )
					'
					cmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					cmatrixgemm(s2, n, s1, -1.0, a, i1 + s1, _
						j1, 0, x, i2, j2, 0, _
						1.0, x, i2 + s1, j2)
					cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					Return
				End If
				If Not isupper AndAlso optype <> 0 Then

					'
					'          (A1' A21')-1 ( X1 )
					' A^-1*X = (        )  *(    )
					'          (     A2')   ( X2 )
					'
					cmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					cmatrixgemm(s1, n, s2, -1.0, a, i1 + s1, _
						j1, optype, x, i2 + s1, j2, 0, _
						1.0, x, i2, j2)
					cmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixlefttrsm(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			cmatrixlefttrsm(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2)
		End Sub


		'************************************************************************
'        This subroutine calculates X*op(A^-1) where:
'        * X is MxN general matrix
'        * A is NxN upper/lower triangular/unitriangular matrix
'        * "op" may be identity transformation, transposition
'
'        Multiplication result replaces X.
'        Cache-oblivious algorithm is used.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N   -   matrix size, N>=0
'            M   -   matrix size, N>=0
'            A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
'            I1      -   submatrix offset
'            J1      -   submatrix offset
'            IsUpper -   whether matrix is upper triangular
'            IsUnit  -   whether matrix is unitriangular
'            OpType  -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'            X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'            I2  -   submatrix offset
'            J2  -   submatrix offset
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixrighttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablasblocksize(a)

			'
			' Basecase: MKL or ALGLIB code
			'
			If ablasmkl.rmatrixrighttrsmmkl(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If
			If m <= bs AndAlso n <= bs Then
				rmatrixrighttrsm2(m, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				Return
			End If

			'
			' Recursive subdivision
			'
			If m >= n Then

				'
				' Split X: X*A = (X1 X2)^T*A
				'
				ablassplitlength(a, m, s1, s2)
				rmatrixrighttrsm(s1, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				rmatrixrighttrsm(s2, n, a, i1, j1, isupper, _
					isunit, optype, x, i2 + s1, j2)
				Return
			Else

				'
				' Split A:
				'               (A1  A12)
				' X*op(A) = X*op(       )
				'               (     A2)
				'
				' Different variants depending on
				' IsUpper/OpType combinations
				'
				ablassplitlength(a, n, s1, s2)
				If isupper AndAlso optype = 0 Then

					'
					'                  (A1  A12)-1
					' X*A^-1 = (X1 X2)*(       )
					'                  (     A2)
					'
					rmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					rmatrixgemm(m, s2, s1, -1.0, x, i2, _
						j2, 0, a, i1, j1 + s1, 0, _
						1.0, x, i2, j2 + s1)
					rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					Return
				End If
				If isupper AndAlso optype <> 0 Then

					'
					'                  (A1'     )-1
					' X*A^-1 = (X1 X2)*(        )
					'                  (A12' A2')
					'
					rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					rmatrixgemm(m, s1, s2, -1.0, x, i2, _
						j2 + s1, 0, a, i1, j1 + s1, optype, _
						1.0, x, i2, j2)
					rmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If Not isupper AndAlso optype = 0 Then

					'
					'                  (A1     )-1
					' X*A^-1 = (X1 X2)*(       )
					'                  (A21  A2)
					'
					rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					rmatrixgemm(m, s1, s2, -1.0, x, i2, _
						j2 + s1, 0, a, i1 + s1, j1, 0, _
						1.0, x, i2, j2)
					rmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If Not isupper AndAlso optype <> 0 Then

					'
					'                  (A1' A21')-1
					' X*A^-1 = (X1 X2)*(        )
					'                  (     A2')
					'
					rmatrixrighttrsm(m, s1, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					rmatrixgemm(m, s2, s1, -1.0, x, i2, _
						j2, 0, a, i1 + s1, j1, optype, _
						1.0, x, i2, j2 + s1)
					rmatrixrighttrsm(m, s2, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2, j2 + s1)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixrighttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			rmatrixrighttrsm(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2)
		End Sub


		'************************************************************************
'        This subroutine calculates op(A^-1)*X where:
'        * X is MxN general matrix
'        * A is MxM upper/lower triangular/unitriangular matrix
'        * "op" may be identity transformation, transposition
'
'        Multiplication result replaces X.
'        Cache-oblivious algorithm is used.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N   -   matrix size, N>=0
'            M   -   matrix size, N>=0
'            A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
'            I1      -   submatrix offset
'            J1      -   submatrix offset
'            IsUpper -   whether matrix is upper triangular
'            IsUnit  -   whether matrix is unitriangular
'            OpType  -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'            X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
'            I2  -   submatrix offset
'            J2  -   submatrix offset
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixlefttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablasblocksize(a)

			'
			' Basecase: MKL or ALGLIB code
			'
			If ablasmkl.rmatrixlefttrsmmkl(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If
			If m <= bs AndAlso n <= bs Then
				rmatrixlefttrsm2(m, n, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				Return
			End If

			'
			' Recursive subdivision
			'
			If n >= m Then

				'
				' Split X: op(A)^-1*X = op(A)^-1*(X1 X2)
				'
				ablassplitlength(x, n, s1, s2)
				rmatrixlefttrsm(m, s1, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2)
				rmatrixlefttrsm(m, s2, a, i1, j1, isupper, _
					isunit, optype, x, i2, j2 + s1)
			Else

				'
				' Split A
				'
				ablassplitlength(a, m, s1, s2)
				If isupper AndAlso optype = 0 Then

					'
					'           (A1  A12)-1  ( X1 )
					' A^-1*X* = (       )   *(    )
					'           (     A2)    ( X2 )
					'
					rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					rmatrixgemm(s1, n, s2, -1.0, a, i1, _
						j1 + s1, 0, x, i2 + s1, j2, 0, _
						1.0, x, i2, j2)
					rmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
				If isupper AndAlso optype <> 0 Then

					'
					'          (A1'     )-1 ( X1 )
					' A^-1*X = (        )  *(    )
					'          (A12' A2')   ( X2 )
					'
					rmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					rmatrixgemm(s2, n, s1, -1.0, a, i1, _
						j1 + s1, optype, x, i2, j2, 0, _
						1.0, x, i2 + s1, j2)
					rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					Return
				End If
				If Not isupper AndAlso optype = 0 Then

					'
					'          (A1     )-1 ( X1 )
					' A^-1*X = (       )  *(    )
					'          (A21  A2)   ( X2 )
					'
					rmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					rmatrixgemm(s2, n, s1, -1.0, a, i1 + s1, _
						j1, 0, x, i2, j2, 0, _
						1.0, x, i2 + s1, j2)
					rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					Return
				End If
				If Not isupper AndAlso optype <> 0 Then

					'
					'          (A1' A21')-1 ( X1 )
					' A^-1*X = (        )  *(    )
					'          (     A2')   ( X2 )
					'
					rmatrixlefttrsm(s2, n, a, i1 + s1, j1 + s1, isupper, _
						isunit, optype, x, i2 + s1, j2)
					rmatrixgemm(s1, n, s2, -1.0, a, i1 + s1, _
						j1, optype, x, i2 + s1, j2, 0, _
						1.0, x, i2, j2)
					rmatrixlefttrsm(s1, n, a, i1, j1, isupper, _
						isunit, optype, x, i2, j2)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixlefttrsm(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			rmatrixlefttrsm(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2)
		End Sub


		'************************************************************************
'        This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
'        where:
'        * C is NxN Hermitian matrix given by its upper/lower triangle
'        * A is NxK matrix when A*A^H is calculated, KxN matrix otherwise
'
'        Additional info:
'        * cache-oblivious algorithm is used.
'        * multiplication result replaces C. If Beta=0, C elements are not used in
'          calculations (not multiplied by zero - just not referenced)
'        * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'        * if both Beta and Alpha are zero, C is filled by zeros.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N       -   matrix size, N>=0
'            K       -   matrix size, K>=0
'            Alpha   -   coefficient
'            A       -   matrix
'            IA      -   submatrix offset (row index)
'            JA      -   submatrix offset (column index)
'            OpTypeA -   multiplication type:
'                        * 0 - A*A^H is calculated
'                        * 2 - A^H*A is calculated
'            Beta    -   coefficient
'            C       -   preallocated input/output matrix
'            IC      -   submatrix offset (row index)
'            JC      -   submatrix offset (column index)
'            IsUpper -   whether upper or lower triangle of C is updated;
'                        this function updates only one half of C, leaving
'                        other half unchanged (not referenced at all).
'
'          -- ALGLIB routine --
'             16.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixherk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablascomplexblocksize(a)

			'
			' Use MKL or ALGLIB basecase code
			'
			If ablasmkl.cmatrixherkmkl(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper) Then
				Return
			End If
			If n <= bs AndAlso k <= bs Then
				cmatrixherk2(n, k, alpha, a, ia, ja, _
					optypea, beta, c, ic, jc, isupper)
				Return
			End If

			'
			' Recursive division of the problem
			'
			If k >= n Then

				'
				' Split K
				'
				ablascomplexsplitlength(a, k, s1, s2)
				If optypea = 0 Then
					cmatrixherk(n, s1, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixherk(n, s2, alpha, a, ia, ja + s1, _
						optypea, 1.0, c, ic, jc, isupper)
				Else
					cmatrixherk(n, s1, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixherk(n, s2, alpha, a, ia + s1, ja, _
						optypea, 1.0, c, ic, jc, isupper)
				End If
			Else

				'
				' Split N
				'
				ablascomplexsplitlength(a, n, s1, s2)
				If optypea = 0 AndAlso isupper Then
					cmatrixherk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixgemm(s1, s2, k, alpha, a, ia, _
						ja, 0, a, ia + s1, ja, 2, _
						beta, c, ic, jc + s1)
					cmatrixherk(s2, k, alpha, a, ia + s1, ja, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea = 0 AndAlso Not isupper Then
					cmatrixherk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixgemm(s2, s1, k, alpha, a, ia + s1, _
						ja, 0, a, ia, ja, 2, _
						beta, c, ic + s1, jc)
					cmatrixherk(s2, k, alpha, a, ia + s1, ja, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea <> 0 AndAlso isupper Then
					cmatrixherk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixgemm(s1, s2, k, alpha, a, ia, _
						ja, 2, a, ia, ja + s1, 0, _
						beta, c, ic, jc + s1)
					cmatrixherk(s2, k, alpha, a, ia, ja + s1, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea <> 0 AndAlso Not isupper Then
					cmatrixherk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					cmatrixgemm(s2, s1, k, alpha, a, ia, _
						ja + s1, 2, a, ia, ja, 0, _
						beta, c, ic + s1, jc)
					cmatrixherk(s2, k, alpha, a, ia, ja + s1, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixherk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)
			cmatrixherk(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper)
		End Sub


		'************************************************************************
'        This subroutine calculates  C=alpha*A*A^T+beta*C  or  C=alpha*A^T*A+beta*C
'        where:
'        * C is NxN symmetric matrix given by its upper/lower triangle
'        * A is NxK matrix when A*A^T is calculated, KxN matrix otherwise
'
'        Additional info:
'        * cache-oblivious algorithm is used.
'        * multiplication result replaces C. If Beta=0, C elements are not used in
'          calculations (not multiplied by zero - just not referenced)
'        * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'        * if both Beta and Alpha are zero, C is filled by zeros.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS
'            N       -   matrix size, N>=0
'            K       -   matrix size, K>=0
'            Alpha   -   coefficient
'            A       -   matrix
'            IA      -   submatrix offset (row index)
'            JA      -   submatrix offset (column index)
'            OpTypeA -   multiplication type:
'                        * 0 - A*A^T is calculated
'                        * 2 - A^T*A is calculated
'            Beta    -   coefficient
'            C       -   preallocated input/output matrix
'            IC      -   submatrix offset (row index)
'            JC      -   submatrix offset (column index)
'            IsUpper -   whether C is upper triangular or lower triangular
'
'          -- ALGLIB routine --
'             16.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As Double(,), ic As Integer, jc As Integer, isupper As Boolean)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablasblocksize(a)

			'
			' Use MKL or generic basecase code
			'
			If ablasmkl.rmatrixsyrkmkl(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper) Then
				Return
			End If
			If n <= bs AndAlso k <= bs Then
				rmatrixsyrk2(n, k, alpha, a, ia, ja, _
					optypea, beta, c, ic, jc, isupper)
				Return
			End If

			'
			' Recursive subdivision of the problem
			'
			If k >= n Then

				'
				' Split K
				'
				ablassplitlength(a, k, s1, s2)
				If optypea = 0 Then
					rmatrixsyrk(n, s1, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixsyrk(n, s2, alpha, a, ia, ja + s1, _
						optypea, 1.0, c, ic, jc, isupper)
				Else
					rmatrixsyrk(n, s1, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixsyrk(n, s2, alpha, a, ia + s1, ja, _
						optypea, 1.0, c, ic, jc, isupper)
				End If
			Else

				'
				' Split N
				'
				ablassplitlength(a, n, s1, s2)
				If optypea = 0 AndAlso isupper Then
					rmatrixsyrk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixgemm(s1, s2, k, alpha, a, ia, _
						ja, 0, a, ia + s1, ja, 1, _
						beta, c, ic, jc + s1)
					rmatrixsyrk(s2, k, alpha, a, ia + s1, ja, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea = 0 AndAlso Not isupper Then
					rmatrixsyrk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixgemm(s2, s1, k, alpha, a, ia + s1, _
						ja, 0, a, ia, ja, 1, _
						beta, c, ic + s1, jc)
					rmatrixsyrk(s2, k, alpha, a, ia + s1, ja, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea <> 0 AndAlso isupper Then
					rmatrixsyrk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixgemm(s1, s2, k, alpha, a, ia, _
						ja, 1, a, ia, ja + s1, 0, _
						beta, c, ic, jc + s1)
					rmatrixsyrk(s2, k, alpha, a, ia, ja + s1, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
				If optypea <> 0 AndAlso Not isupper Then
					rmatrixsyrk(s1, k, alpha, a, ia, ja, _
						optypea, beta, c, ic, jc, isupper)
					rmatrixgemm(s2, s1, k, alpha, a, ia, _
						ja + s1, 1, a, ia, ja, 0, _
						beta, c, ic + s1, jc)
					rmatrixsyrk(s2, k, alpha, a, ia, ja + s1, _
						optypea, beta, c, ic + s1, jc + s1, isupper)
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As Double(,), ic As Integer, jc As Integer, isupper As Boolean)
			rmatrixsyrk(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper)
		End Sub


		'************************************************************************
'        This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'        * C is MxN general matrix
'        * op1(A) is MxK matrix
'        * op2(B) is KxN matrix
'        * "op" may be identity transformation, transposition, conjugate transposition
'
'        Additional info:
'        * cache-oblivious algorithm is used.
'        * multiplication result replaces C. If Beta=0, C elements are not used in
'          calculations (not multiplied by zero - just not referenced)
'        * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'        * if both Beta and Alpha are zero, C is filled by zeros.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        IMPORTANT:
'
'        This function does NOT preallocate output matrix C, it MUST be preallocated
'        by caller prior to calling this function. In case C does not have  enough
'        space to store result, exception will be generated.
'
'        INPUT PARAMETERS
'            M       -   matrix size, M>0
'            N       -   matrix size, N>0
'            K       -   matrix size, K>0
'            Alpha   -   coefficient
'            A       -   matrix
'            IA      -   submatrix offset
'            JA      -   submatrix offset
'            OpTypeA -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'                        * 2 - conjugate transposition
'            B       -   matrix
'            IB      -   submatrix offset
'            JB      -   submatrix offset
'            OpTypeB -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'                        * 2 - conjugate transposition
'            Beta    -   coefficient
'            C       -   matrix (PREALLOCATED, large enough to store result)
'            IC      -   submatrix offset
'            JC      -   submatrix offset
'
'          -- ALGLIB routine --
'             16.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As complex, a As complex(,), ia As Integer, _
			ja As Integer, optypea As Integer, b As complex(,), ib As Integer, jb As Integer, optypeb As Integer, _
			beta As complex, c As complex(,), ic As Integer, jc As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablascomplexblocksize(a)

			'
			' Use MKL or ALGLIB basecase code
			'
			If ablasmkl.cmatrixgemmmkl(m, n, k, alpha, a, ia, _
				ja, optypea, b, ib, jb, optypeb, _
				beta, c, ic, jc) Then
				Return
			End If
			If (m <= bs AndAlso n <= bs) AndAlso k <= bs Then
				ablasf.cmatrixgemmk(m, n, k, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				Return
			End If

			'
			' SMP support is turned on when M or N are larger than some boundary value.
			' Magnitude of K is not taken into account because splitting on K does not
			' allow us to spawn child tasks.
			'

			'
			' Recursive algorithm: parallel splitting on M/N
			'
			If m >= n AndAlso m >= k Then

				'
				' A*B = (A1 A2)^T*B
				'
				ablascomplexsplitlength(a, m, s1, s2)
				cmatrixgemm(s1, n, k, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				If optypea = 0 Then
					cmatrixgemm(s2, n, k, alpha, a, ia + s1, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic + s1, jc)
				Else
					cmatrixgemm(s2, n, k, alpha, a, ia, _
						ja + s1, optypea, b, ib, jb, optypeb, _
						beta, c, ic + s1, jc)
				End If
				Return
			End If
			If n >= m AndAlso n >= k Then

				'
				' A*B = A*(B1 B2)
				'
				ablascomplexsplitlength(a, n, s1, s2)
				If optypeb = 0 Then
					cmatrixgemm(m, s1, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					cmatrixgemm(m, s2, k, alpha, a, ia, _
						ja, optypea, b, ib, jb + s1, optypeb, _
						beta, c, ic, jc + s1)
				Else
					cmatrixgemm(m, s1, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					cmatrixgemm(m, s2, k, alpha, a, ia, _
						ja, optypea, b, ib + s1, jb, optypeb, _
						beta, c, ic, jc + s1)
				End If
				Return
			End If

			'
			' Recursive algorithm: serial splitting on K
			'

			'
			' A*B = (A1 A2)*(B1 B2)^T
			'
			ablascomplexsplitlength(a, k, s1, s2)
			If optypea = 0 AndAlso optypeb = 0 Then
				cmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				cmatrixgemm(m, n, s2, alpha, a, ia, _
					ja + s1, optypea, b, ib + s1, jb, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea = 0 AndAlso optypeb <> 0 Then
				cmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				cmatrixgemm(m, n, s2, alpha, a, ia, _
					ja + s1, optypea, b, ib, jb + s1, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea <> 0 AndAlso optypeb = 0 Then
				cmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				cmatrixgemm(m, n, s2, alpha, a, ia + s1, _
					ja, optypea, b, ib + s1, jb, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea <> 0 AndAlso optypeb <> 0 Then
				cmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				cmatrixgemm(m, n, s2, alpha, a, ia + s1, _
					ja, optypea, b, ib, jb + s1, optypeb, _
					1.0, c, ic, jc)
			End If
			Return
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As complex, a As complex(,), ia As Integer, _
			ja As Integer, optypea As Integer, b As complex(,), ib As Integer, jb As Integer, optypeb As Integer, _
			beta As complex, c As complex(,), ic As Integer, jc As Integer)
			cmatrixgemm(m, n, k, alpha, a, ia, _
				ja, optypea, b, ib, jb, optypeb, _
				beta, c, ic, jc)
		End Sub


		'************************************************************************
'        This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
'        * C is MxN general matrix
'        * op1(A) is MxK matrix
'        * op2(B) is KxN matrix
'        * "op" may be identity transformation, transposition
'
'        Additional info:
'        * cache-oblivious algorithm is used.
'        * multiplication result replaces C. If Beta=0, C elements are not used in
'          calculations (not multiplied by zero - just not referenced)
'        * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
'        * if both Beta and Alpha are zero, C is filled by zeros.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  Because  starting/stopping  worker  thread always
'          ! involves some overhead, parallelism starts to be  profitable  for  N's
'          ! larger than 128.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        IMPORTANT:
'
'        This function does NOT preallocate output matrix C, it MUST be preallocated
'        by caller prior to calling this function. In case C does not have  enough
'        space to store result, exception will be generated.
'
'        INPUT PARAMETERS
'            M       -   matrix size, M>0
'            N       -   matrix size, N>0
'            K       -   matrix size, K>0
'            Alpha   -   coefficient
'            A       -   matrix
'            IA      -   submatrix offset
'            JA      -   submatrix offset
'            OpTypeA -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'            B       -   matrix
'            IB      -   submatrix offset
'            JB      -   submatrix offset
'            OpTypeB -   transformation type:
'                        * 0 - no transformation
'                        * 1 - transposition
'            Beta    -   coefficient
'            C       -   PREALLOCATED output matrix, large enough to store result
'            IC      -   submatrix offset
'            JC      -   submatrix offset
'
'          -- ALGLIB routine --
'             2009-2013
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, _
			ja As Integer, optypea As Integer, b As Double(,), ib As Integer, jb As Integer, optypeb As Integer, _
			beta As Double, c As Double(,), ic As Integer, jc As Integer)
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim bs As Integer = 0

			bs = ablasblocksize(a)

			'
			' Check input sizes for correctness
			'
			alglib.ap.assert(optypea = 0 OrElse optypea = 1, "RMatrixGEMM: incorrect OpTypeA (must be 0 or 1)")
			alglib.ap.assert(optypeb = 0 OrElse optypeb = 1, "RMatrixGEMM: incorrect OpTypeB (must be 0 or 1)")
			alglib.ap.assert(ic + m <= alglib.ap.rows(c), "RMatrixGEMM: incorect size of output matrix C")
			alglib.ap.assert(jc + n <= alglib.ap.cols(c), "RMatrixGEMM: incorect size of output matrix C")

			'
			' Use MKL or ALGLIB basecase code
			'
			If ablasmkl.rmatrixgemmmkl(m, n, k, alpha, a, ia, _
				ja, optypea, b, ib, jb, optypeb, _
				beta, c, ic, jc) Then
				Return
			End If
			If (m <= bs AndAlso n <= bs) AndAlso k <= bs Then
				ablasf.rmatrixgemmk(m, n, k, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				Return
			End If

			'
			' SMP support is turned on when M or N are larger than some boundary value.
			' Magnitude of K is not taken into account because splitting on K does not
			' allow us to spawn child tasks.
			'

			'
			' Recursive algorithm: split on M or N
			'
			If m >= n AndAlso m >= k Then

				'
				' A*B = (A1 A2)^T*B
				'
				ablassplitlength(a, m, s1, s2)
				If optypea = 0 Then
					rmatrixgemm(s1, n, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					rmatrixgemm(s2, n, k, alpha, a, ia + s1, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic + s1, jc)
				Else
					rmatrixgemm(s1, n, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					rmatrixgemm(s2, n, k, alpha, a, ia, _
						ja + s1, optypea, b, ib, jb, optypeb, _
						beta, c, ic + s1, jc)
				End If
				Return
			End If
			If n >= m AndAlso n >= k Then

				'
				' A*B = A*(B1 B2)
				'
				ablassplitlength(a, n, s1, s2)
				If optypeb = 0 Then
					rmatrixgemm(m, s1, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					rmatrixgemm(m, s2, k, alpha, a, ia, _
						ja, optypea, b, ib, jb + s1, optypeb, _
						beta, c, ic, jc + s1)
				Else
					rmatrixgemm(m, s1, k, alpha, a, ia, _
						ja, optypea, b, ib, jb, optypeb, _
						beta, c, ic, jc)
					rmatrixgemm(m, s2, k, alpha, a, ia, _
						ja, optypea, b, ib + s1, jb, optypeb, _
						beta, c, ic, jc + s1)
				End If
				Return
			End If

			'
			' Recursive algorithm: split on K
			'

			'
			' A*B = (A1 A2)*(B1 B2)^T
			'
			ablassplitlength(a, k, s1, s2)
			If optypea = 0 AndAlso optypeb = 0 Then
				rmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				rmatrixgemm(m, n, s2, alpha, a, ia, _
					ja + s1, optypea, b, ib + s1, jb, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea = 0 AndAlso optypeb <> 0 Then
				rmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				rmatrixgemm(m, n, s2, alpha, a, ia, _
					ja + s1, optypea, b, ib, jb + s1, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea <> 0 AndAlso optypeb = 0 Then
				rmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				rmatrixgemm(m, n, s2, alpha, a, ia + s1, _
					ja, optypea, b, ib + s1, jb, optypeb, _
					1.0, c, ic, jc)
			End If
			If optypea <> 0 AndAlso optypeb <> 0 Then
				rmatrixgemm(m, n, s1, alpha, a, ia, _
					ja, optypea, b, ib, jb, optypeb, _
					beta, c, ic, jc)
				rmatrixgemm(m, n, s2, alpha, a, ia + s1, _
					ja, optypea, b, ib, jb + s1, optypeb, _
					1.0, c, ic, jc)
			End If
			Return
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixgemm(m As Integer, n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, _
			ja As Integer, optypea As Integer, b As Double(,), ib As Integer, jb As Integer, optypeb As Integer, _
			beta As Double, c As Double(,), ic As Integer, jc As Integer)
			rmatrixgemm(m, n, k, alpha, a, ia, _
				ja, optypea, b, ib, jb, optypeb, _
				beta, c, ic, jc)
		End Sub


		'************************************************************************
'        This subroutine is an older version of CMatrixHERK(), one with wrong  name
'        (it is HErmitian update, not SYmmetric). It  is  left  here  for  backward
'        compatibility.
'
'          -- ALGLIB routine --
'             16.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)
			cmatrixherk(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixsyrk(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)
			cmatrixsyrk(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper)
		End Sub


		'************************************************************************
'        Complex ABLASSplitLength
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub ablasinternalsplitlength(n As Integer, nb As Integer, ByRef n1 As Integer, ByRef n2 As Integer)
			Dim r As Integer = 0

			n1 = 0
			n2 = 0

			If n <= nb Then

				'
				' Block size, no further splitting
				'
				n1 = n
				n2 = 0
			Else

				'
				' Greater than block size
				'
				If n Mod nb <> 0 Then

					'
					' Split remainder
					'
					n2 = n Mod nb
					n1 = n - n2
				Else

					'
					' Split on block boundaries
					'
					n2 = n \ 2
					n1 = n - n2
					If n1 Mod nb = 0 Then
						Return
					End If
					r = nb - n1 Mod nb
					n1 = n1 + r
					n2 = n2 - r
				End If
			End If
		End Sub


		'************************************************************************
'        Level 2 variant of CMatrixRightTRSM
'        ************************************************************************

		Private Shared Sub cmatrixrighttrsm2(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim vc As complex = 0
			Dim vd As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' Special case
			'
			If n * m = 0 Then
				Return
			End If

			'
			' Try to call fast TRSM
			'
			If ablasf.cmatrixrighttrsmf(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If

			'
			' General case
			'
			If isupper Then

				'
				' Upper triangular matrix
				'
				If optype = 0 Then

					'
					' X*A^(-1)
					'
					For i = 0 To m - 1
						For j = 0 To n - 1
							If isunit Then
								vd = 1
							Else
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = x(i2 + i, j2 + j) / vd
							If j < n - 1 Then
								vc = x(i2 + i, j2 + j)
								i1_ = (j1 + j + 1) - (j2 + j + 1)
								For i_ = j2 + j + 1 To j2 + n - 1
									x(i2 + i, i_) = x(i2 + i, i_) - vc * a(i1 + j, i_ + i1_)
								Next
							End If
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' X*A^(-T)
					'
					For i = 0 To m - 1
						For j = n - 1 To 0 Step -1
							vc = 0
							vd = 1
							If j < n - 1 Then
								i1_ = (j1 + j + 1) - (j2 + j + 1)
								vc = 0.0
								For i_ = j2 + j + 1 To j2 + n - 1
									vc += x(i2 + i, i_) * a(i1 + j, i_ + i1_)
								Next
							End If
							If Not isunit Then
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vc) / vd
						Next
					Next
					Return
				End If
				If optype = 2 Then

					'
					' X*A^(-H)
					'
					For i = 0 To m - 1
						For j = n - 1 To 0 Step -1
							vc = 0
							vd = 1
							If j < n - 1 Then
								i1_ = (j1 + j + 1) - (j2 + j + 1)
								vc = 0.0
								For i_ = j2 + j + 1 To j2 + n - 1
									vc += x(i2 + i, i_) * Math.conj(a(i1 + j, i_ + i1_))
								Next
							End If
							If Not isunit Then
								vd = Math.conj(a(i1 + j, j1 + j))
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vc) / vd
						Next
					Next
					Return
				End If
			Else

				'
				' Lower triangular matrix
				'
				If optype = 0 Then

					'
					' X*A^(-1)
					'
					For i = 0 To m - 1
						For j = n - 1 To 0 Step -1
							If isunit Then
								vd = 1
							Else
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = x(i2 + i, j2 + j) / vd
							If j > 0 Then
								vc = x(i2 + i, j2 + j)
								i1_ = (j1) - (j2)
								For i_ = j2 To j2 + j - 1
									x(i2 + i, i_) = x(i2 + i, i_) - vc * a(i1 + j, i_ + i1_)
								Next
							End If
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' X*A^(-T)
					'
					For i = 0 To m - 1
						For j = 0 To n - 1
							vc = 0
							vd = 1
							If j > 0 Then
								i1_ = (j1) - (j2)
								vc = 0.0
								For i_ = j2 To j2 + j - 1
									vc += x(i2 + i, i_) * a(i1 + j, i_ + i1_)
								Next
							End If
							If Not isunit Then
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vc) / vd
						Next
					Next
					Return
				End If
				If optype = 2 Then

					'
					' X*A^(-H)
					'
					For i = 0 To m - 1
						For j = 0 To n - 1
							vc = 0
							vd = 1
							If j > 0 Then
								i1_ = (j1) - (j2)
								vc = 0.0
								For i_ = j2 To j2 + j - 1
									vc += x(i2 + i, i_) * Math.conj(a(i1 + j, i_ + i1_))
								Next
							End If
							If Not isunit Then
								vd = Math.conj(a(i1 + j, j1 + j))
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vc) / vd
						Next
					Next
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Level-2 subroutine
'        ************************************************************************

		Private Shared Sub cmatrixlefttrsm2(m As Integer, n As Integer, a As complex(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As complex(,), i2 As Integer, j2 As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim vc As complex = 0
			Dim vd As complex = 0
			Dim i_ As Integer = 0


			'
			' Special case
			'
			If n * m = 0 Then
				Return
			End If

			'
			' Try to call fast TRSM
			'
			If ablasf.cmatrixlefttrsmf(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If

			'
			' General case
			'
			If isupper Then

				'
				' Upper triangular matrix
				'
				If optype = 0 Then

					'
					' A^(-1)*X
					'
					For i = m - 1 To 0 Step -1
						For j = i + 1 To m - 1
							vc = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = x(i2 + i, i_) - vc * x(i2 + j, i_)
							Next
						Next
						If Not isunit Then
							vd = 1 / a(i1 + i, j1 + i)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = vd * x(i2 + i, i_)
							Next
						End If
					Next
					Return
				End If
				If optype = 1 Then

					'
					' A^(-T)*X
					'
					For i = 0 To m - 1
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + i, j1 + i)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i + 1 To m - 1
							vc = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vc * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
				If optype = 2 Then

					'
					' A^(-H)*X
					'
					For i = 0 To m - 1
						If isunit Then
							vd = 1
						Else
							vd = 1 / Math.conj(a(i1 + i, j1 + i))
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i + 1 To m - 1
							vc = Math.conj(a(i1 + i, j1 + j))
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vc * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
			Else

				'
				' Lower triangular matrix
				'
				If optype = 0 Then

					'
					' A^(-1)*X
					'
					For i = 0 To m - 1
						For j = 0 To i - 1
							vc = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = x(i2 + i, i_) - vc * x(i2 + j, i_)
							Next
						Next
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + j, j1 + j)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' A^(-T)*X
					'
					For i = m - 1 To 0 Step -1
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + i, j1 + i)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i - 1 To 0 Step -1
							vc = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vc * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
				If optype = 2 Then

					'
					' A^(-H)*X
					'
					For i = m - 1 To 0 Step -1
						If isunit Then
							vd = 1
						Else
							vd = 1 / Math.conj(a(i1 + i, j1 + i))
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i - 1 To 0 Step -1
							vc = Math.conj(a(i1 + i, j1 + j))
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vc * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Level 2 subroutine
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rmatrixrighttrsm2(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim vr As Double = 0
			Dim vd As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' Special case
			'
			If n * m = 0 Then
				Return
			End If

			'
			' Try to use "fast" code
			'
			If ablasf.rmatrixrighttrsmf(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If

			'
			' General case
			'
			If isupper Then

				'
				' Upper triangular matrix
				'
				If optype = 0 Then

					'
					' X*A^(-1)
					'
					For i = 0 To m - 1
						For j = 0 To n - 1
							If isunit Then
								vd = 1
							Else
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = x(i2 + i, j2 + j) / vd
							If j < n - 1 Then
								vr = x(i2 + i, j2 + j)
								i1_ = (j1 + j + 1) - (j2 + j + 1)
								For i_ = j2 + j + 1 To j2 + n - 1
									x(i2 + i, i_) = x(i2 + i, i_) - vr * a(i1 + j, i_ + i1_)
								Next
							End If
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' X*A^(-T)
					'
					For i = 0 To m - 1
						For j = n - 1 To 0 Step -1
							vr = 0
							vd = 1
							If j < n - 1 Then
								i1_ = (j1 + j + 1) - (j2 + j + 1)
								vr = 0.0
								For i_ = j2 + j + 1 To j2 + n - 1
									vr += x(i2 + i, i_) * a(i1 + j, i_ + i1_)
								Next
							End If
							If Not isunit Then
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vr) / vd
						Next
					Next
					Return
				End If
			Else

				'
				' Lower triangular matrix
				'
				If optype = 0 Then

					'
					' X*A^(-1)
					'
					For i = 0 To m - 1
						For j = n - 1 To 0 Step -1
							If isunit Then
								vd = 1
							Else
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = x(i2 + i, j2 + j) / vd
							If j > 0 Then
								vr = x(i2 + i, j2 + j)
								i1_ = (j1) - (j2)
								For i_ = j2 To j2 + j - 1
									x(i2 + i, i_) = x(i2 + i, i_) - vr * a(i1 + j, i_ + i1_)
								Next
							End If
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' X*A^(-T)
					'
					For i = 0 To m - 1
						For j = 0 To n - 1
							vr = 0
							vd = 1
							If j > 0 Then
								i1_ = (j1) - (j2)
								vr = 0.0
								For i_ = j2 To j2 + j - 1
									vr += x(i2 + i, i_) * a(i1 + j, i_ + i1_)
								Next
							End If
							If Not isunit Then
								vd = a(i1 + j, j1 + j)
							End If
							x(i2 + i, j2 + j) = (x(i2 + i, j2 + j) - vr) / vd
						Next
					Next
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Level 2 subroutine
'        ************************************************************************

		Private Shared Sub rmatrixlefttrsm2(m As Integer, n As Integer, a As Double(,), i1 As Integer, j1 As Integer, isupper As Boolean, _
			isunit As Boolean, optype As Integer, x As Double(,), i2 As Integer, j2 As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim vr As Double = 0
			Dim vd As Double = 0
			Dim i_ As Integer = 0


			'
			' Special case
			'
			If n = 0 OrElse m = 0 Then
				Return
			End If

			'
			' Try fast code
			'
			If ablasf.rmatrixlefttrsmf(m, n, a, i1, j1, isupper, _
				isunit, optype, x, i2, j2) Then
				Return
			End If

			'
			' General case
			'
			If isupper Then

				'
				' Upper triangular matrix
				'
				If optype = 0 Then

					'
					' A^(-1)*X
					'
					For i = m - 1 To 0 Step -1
						For j = i + 1 To m - 1
							vr = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = x(i2 + i, i_) - vr * x(i2 + j, i_)
							Next
						Next
						If Not isunit Then
							vd = 1 / a(i1 + i, j1 + i)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = vd * x(i2 + i, i_)
							Next
						End If
					Next
					Return
				End If
				If optype = 1 Then

					'
					' A^(-T)*X
					'
					For i = 0 To m - 1
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + i, j1 + i)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i + 1 To m - 1
							vr = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vr * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
			Else

				'
				' Lower triangular matrix
				'
				If optype = 0 Then

					'
					' A^(-1)*X
					'
					For i = 0 To m - 1
						For j = 0 To i - 1
							vr = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + i, i_) = x(i2 + i, i_) - vr * x(i2 + j, i_)
							Next
						Next
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + j, j1 + j)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
					Next
					Return
				End If
				If optype = 1 Then

					'
					' A^(-T)*X
					'
					For i = m - 1 To 0 Step -1
						If isunit Then
							vd = 1
						Else
							vd = 1 / a(i1 + i, j1 + i)
						End If
						For i_ = j2 To j2 + n - 1
							x(i2 + i, i_) = vd * x(i2 + i, i_)
						Next
						For j = i - 1 To 0 Step -1
							vr = a(i1 + i, j1 + j)
							For i_ = j2 To j2 + n - 1
								x(i2 + j, i_) = x(i2 + j, i_) - vr * x(i2 + i, i_)
							Next
						Next
					Next
					Return
				End If
			End If
		End Sub


		'************************************************************************
'        Level 2 subroutine
'        ************************************************************************

		Private Shared Sub cmatrixherk2(n As Integer, k As Integer, alpha As Double, a As complex(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As complex(,), ic As Integer, jc As Integer, isupper As Boolean)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim j2 As Integer = 0
			Dim v As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' Fast exit (nothing to be done)
			'
			If (CDbl(alpha) = CDbl(0) OrElse k = 0) AndAlso CDbl(beta) = CDbl(1) Then
				Return
			End If

			'
			' Try to call fast SYRK
			'
			If ablasf.cmatrixherkf(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper) Then
				Return
			End If

			'
			' SYRK
			'
			If optypea = 0 Then

				'
				' C=alpha*A*A^H+beta*C
				'
				For i = 0 To n - 1
					If isupper Then
						j1 = i
						j2 = n - 1
					Else
						j1 = 0
						j2 = i
					End If
					For j = j1 To j2
						If CDbl(alpha) <> CDbl(0) AndAlso k > 0 Then
							v = 0.0
							For i_ = ja To ja + k - 1
								v += a(ia + i, i_) * Math.conj(a(ia + j, i_))
							Next
						Else
							v = 0
						End If
						If CDbl(beta) = CDbl(0) Then
							c(ic + i, jc + j) = alpha * v
						Else
							c(ic + i, jc + j) = beta * c(ic + i, jc + j) + alpha * v
						End If
					Next
				Next
				Return
			Else

				'
				' C=alpha*A^H*A+beta*C
				'
				For i = 0 To n - 1
					If isupper Then
						j1 = i
						j2 = n - 1
					Else
						j1 = 0
						j2 = i
					End If
					If CDbl(beta) = CDbl(0) Then
						For j = j1 To j2
							c(ic + i, jc + j) = 0
						Next
					Else
						For i_ = jc + j1 To jc + j2
							c(ic + i, i_) = beta * c(ic + i, i_)
						Next
					End If
				Next
				For i = 0 To k - 1
					For j = 0 To n - 1
						If isupper Then
							j1 = j
							j2 = n - 1
						Else
							j1 = 0
							j2 = j
						End If
						v = alpha * Math.conj(a(ia + i, ja + j))
						i1_ = (ja + j1) - (jc + j1)
						For i_ = jc + j1 To jc + j2
							c(ic + j, i_) = c(ic + j, i_) + v * a(ia + i, i_ + i1_)
						Next
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        Level 2 subrotuine
'        ************************************************************************

		Private Shared Sub rmatrixsyrk2(n As Integer, k As Integer, alpha As Double, a As Double(,), ia As Integer, ja As Integer, _
			optypea As Integer, beta As Double, c As Double(,), ic As Integer, jc As Integer, isupper As Boolean)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim j2 As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' Fast exit (nothing to be done)
			'
			If (CDbl(alpha) = CDbl(0) OrElse k = 0) AndAlso CDbl(beta) = CDbl(1) Then
				Return
			End If

			'
			' Try to call fast SYRK
			'
			If ablasf.rmatrixsyrkf(n, k, alpha, a, ia, ja, _
				optypea, beta, c, ic, jc, isupper) Then
				Return
			End If

			'
			' SYRK
			'
			If optypea = 0 Then

				'
				' C=alpha*A*A^H+beta*C
				'
				For i = 0 To n - 1
					If isupper Then
						j1 = i
						j2 = n - 1
					Else
						j1 = 0
						j2 = i
					End If
					For j = j1 To j2
						If CDbl(alpha) <> CDbl(0) AndAlso k > 0 Then
							v = 0.0
							For i_ = ja To ja + k - 1
								v += a(ia + i, i_) * a(ia + j, i_)
							Next
						Else
							v = 0
						End If
						If CDbl(beta) = CDbl(0) Then
							c(ic + i, jc + j) = alpha * v
						Else
							c(ic + i, jc + j) = beta * c(ic + i, jc + j) + alpha * v
						End If
					Next
				Next
				Return
			Else

				'
				' C=alpha*A^H*A+beta*C
				'
				For i = 0 To n - 1
					If isupper Then
						j1 = i
						j2 = n - 1
					Else
						j1 = 0
						j2 = i
					End If
					If CDbl(beta) = CDbl(0) Then
						For j = j1 To j2
							c(ic + i, jc + j) = 0
						Next
					Else
						For i_ = jc + j1 To jc + j2
							c(ic + i, i_) = beta * c(ic + i, i_)
						Next
					End If
				Next
				For i = 0 To k - 1
					For j = 0 To n - 1
						If isupper Then
							j1 = j
							j2 = n - 1
						Else
							j1 = 0
							j2 = j
						End If
						v = alpha * a(ia + i, ja + j)
						i1_ = (ja + j1) - (jc + j1)
						For i_ = jc + j1 To jc + j2
							c(ic + j, i_) = c(ic + j, i_) + v * a(ia + i, i_ + i1_)
						Next
					Next
				Next
				Return
			End If
		End Sub


	End Class
	Public Class ortfac
		'************************************************************************
'        QR decomposition of a rectangular matrix of size MxN
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'            M   -   number of rows in matrix A.
'            N   -   number of columns in matrix A.
'
'        Output parameters:
'            A   -   matrices Q and R in compact form (see below).
'            Tau -   array of scalar factors which are used to form
'                    matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
'
'        Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'        MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
'
'        The elements of matrix R are located on and above the main diagonal of
'        matrix A. The elements which are located in Tau array and below the main
'        diagonal of matrix A are used to form matrix Q as follows:
'
'        Matrix Q is represented as a product of elementary reflections
'
'        Q = H(0)*H(2)*...*H(k-1),
'
'        where k = min(m,n), and each H(i) is in the form
'
'        H(i) = 1 - tau * v * (v^T)
'
'        where tau is a scalar stored in Tau[I]; v - real vector,
'        so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixqr(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
			Dim work As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim taubuf As Double() = New Double(-1) {}
			Dim minmn As Integer = 0
			Dim tmpa As Double(,) = New Double(-1, -1) {}
			Dim tmpt As Double(,) = New Double(-1, -1) {}
			Dim tmpr As Double(,) = New Double(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim rowscount As Integer = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New Double(-1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			minmn = System.Math.Min(m, n)
			work = New Double(System.Math.Max(m, n)) {}
			t = New Double(System.Math.Max(m, n)) {}
			tau = New Double(minmn - 1) {}
			taubuf = New Double(minmn - 1) {}
			tmpa = New Double(m - 1, ablas.ablasblocksize(a) - 1) {}
			tmpt = New Double(ablas.ablasblocksize(a) - 1, 2 * ablas.ablasblocksize(a) - 1) {}
			tmpr = New Double(2 * ablas.ablasblocksize(a) - 1, n - 1) {}

			'
			' Blocked code
			'
			blockstart = 0
			While blockstart <> minmn

				'
				' Determine block size
				'
				blocksize = minmn - blockstart
				If blocksize > ablas.ablasblocksize(a) Then
					blocksize = ablas.ablasblocksize(a)
				End If
				rowscount = m - blockstart

				'
				' QR decomposition of submatrix.
				' Matrix is copied to temporary storage to solve
				' some TLB issues arising from non-contiguous memory
				' access pattern.
				'
				ablas.rmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, tmpa, _
					0, 0)
				rmatrixqrbasecase(tmpa, rowscount, blocksize, work, t, taubuf)
				ablas.rmatrixcopy(rowscount, blocksize, tmpa, 0, 0, a, _
					blockstart, blockstart)
				i1_ = (0) - (blockstart)
				For i_ = blockstart To blockstart + blocksize - 1
					tau(i_) = taubuf(i_ + i1_)
				Next

				'
				' Update the rest, choose between:
				' a) Level 2 algorithm (when the rest of the matrix is small enough)
				' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
				'    representation for products of Householder transformations',
				'    by R. Schreiber and C. Van Loan.
				'
				If blockstart + blocksize <= n - 1 Then
					If n - blockstart - blocksize >= 2 * ablas.ablasblocksize(a) OrElse rowscount >= 4 * ablas.ablasblocksize(a) Then

						'
						' Prepare block reflector
						'
						rmatrixblockreflector(tmpa, taubuf, True, rowscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q'.
						'
						' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
						' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
						'
						ablas.rmatrixgemm(blocksize, n - blockstart - blocksize, rowscount, 1.0, tmpa, 0, _
							0, 1, a, blockstart, blockstart + blocksize, 0, _
							0.0, tmpr, 0, 0)
						ablas.rmatrixgemm(blocksize, n - blockstart - blocksize, blocksize, 1.0, tmpt, 0, _
							0, 1, tmpr, 0, 0, 0, _
							0.0, tmpr, blocksize, 0)
						ablas.rmatrixgemm(rowscount, n - blockstart - blocksize, blocksize, 1.0, tmpa, 0, _
							0, 0, tmpr, blocksize, 0, 0, _
							1.0, a, blockstart, blockstart + blocksize)
					Else

						'
						' Level 2 algorithm
						'
						For i = 0 To blocksize - 1
							i1_ = (i) - (1)
							For i_ = 1 To rowscount - i
								t(i_) = tmpa(i_ + i1_, i)
							Next
							t(1) = 1
							reflections.applyreflectionfromtheleft(a, taubuf(i), t, blockstart + i, m - 1, blockstart + blocksize, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart + blocksize
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixqr(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
			rmatrixqr(a, m, n, tau)
		End Sub


		'************************************************************************
'        LQ decomposition of a rectangular matrix of size MxN
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'            M   -   number of rows in matrix A.
'            N   -   number of columns in matrix A.
'
'        Output parameters:
'            A   -   matrices L and Q in compact form (see below)
'            Tau -   array of scalar factors which are used to form
'                    matrix Q. Array whose index ranges within [0..Min(M,N)-1].
'
'        Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'        MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
'
'        The elements of matrix L are located on and below  the  main  diagonal  of
'        matrix A. The elements which are located in Tau array and above  the  main
'        diagonal of matrix A are used to form matrix Q as follows:
'
'        Matrix Q is represented as a product of elementary reflections
'
'        Q = H(k-1)*H(k-2)*...*H(1)*H(0),
'
'        where k = min(m,n), and each H(i) is of the form
'
'        H(i) = 1 - tau * v * (v^T)
'
'        where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
'        v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixlq(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
			Dim work As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim taubuf As Double() = New Double(-1) {}
			Dim minmn As Integer = 0
			Dim tmpa As Double(,) = New Double(-1, -1) {}
			Dim tmpt As Double(,) = New Double(-1, -1) {}
			Dim tmpr As Double(,) = New Double(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim columnscount As Integer = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New Double(-1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			minmn = System.Math.Min(m, n)
			work = New Double(System.Math.Max(m, n)) {}
			t = New Double(System.Math.Max(m, n)) {}
			tau = New Double(minmn - 1) {}
			taubuf = New Double(minmn - 1) {}
			tmpa = New Double(ablas.ablasblocksize(a) - 1, n - 1) {}
			tmpt = New Double(ablas.ablasblocksize(a) - 1, 2 * ablas.ablasblocksize(a) - 1) {}
			tmpr = New Double(m - 1, 2 * ablas.ablasblocksize(a) - 1) {}

			'
			' Blocked code
			'
			blockstart = 0
			While blockstart <> minmn

				'
				' Determine block size
				'
				blocksize = minmn - blockstart
				If blocksize > ablas.ablasblocksize(a) Then
					blocksize = ablas.ablasblocksize(a)
				End If
				columnscount = n - blockstart

				'
				' LQ decomposition of submatrix.
				' Matrix is copied to temporary storage to solve
				' some TLB issues arising from non-contiguous memory
				' access pattern.
				'
				ablas.rmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, tmpa, _
					0, 0)
				rmatrixlqbasecase(tmpa, blocksize, columnscount, work, t, taubuf)
				ablas.rmatrixcopy(blocksize, columnscount, tmpa, 0, 0, a, _
					blockstart, blockstart)
				i1_ = (0) - (blockstart)
				For i_ = blockstart To blockstart + blocksize - 1
					tau(i_) = taubuf(i_ + i1_)
				Next

				'
				' Update the rest, choose between:
				' a) Level 2 algorithm (when the rest of the matrix is small enough)
				' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
				'    representation for products of Householder transformations',
				'    by R. Schreiber and C. Van Loan.
				'
				If blockstart + blocksize <= m - 1 Then
					If m - blockstart - blocksize >= 2 * ablas.ablasblocksize(a) Then

						'
						' Prepare block reflector
						'
						rmatrixblockreflector(tmpa, taubuf, False, columnscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q.
						'
						' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
						'
						ablas.rmatrixgemm(m - blockstart - blocksize, blocksize, columnscount, 1.0, a, blockstart + blocksize, _
							blockstart, 0, tmpa, 0, 0, 1, _
							0.0, tmpr, 0, 0)
						ablas.rmatrixgemm(m - blockstart - blocksize, blocksize, blocksize, 1.0, tmpr, 0, _
							0, 0, tmpt, 0, 0, 0, _
							0.0, tmpr, 0, blocksize)
						ablas.rmatrixgemm(m - blockstart - blocksize, columnscount, blocksize, 1.0, tmpr, 0, _
							blocksize, 0, tmpa, 0, 0, 0, _
							1.0, a, blockstart + blocksize, blockstart)
					Else

						'
						' Level 2 algorithm
						'
						For i = 0 To blocksize - 1
							i1_ = (i) - (1)
							For i_ = 1 To columnscount - i
								t(i_) = tmpa(i, i_ + i1_)
							Next
							t(1) = 1
							reflections.applyreflectionfromtheright(a, taubuf(i), t, blockstart + blocksize, m - 1, blockstart + i, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart + blocksize
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixlq(ByRef a As Double(,), m As Integer, n As Integer, ByRef tau As Double())
			rmatrixlq(a, m, n, tau)
		End Sub


		'************************************************************************
'        QR decomposition of a rectangular complex matrix of size MxN
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'            M   -   number of rows in matrix A.
'            N   -   number of columns in matrix A.
'
'        Output parameters:
'            A   -   matrices Q and R in compact form
'            Tau -   array of scalar factors which are used to form matrix Q. Array
'                    whose indexes range within [0.. Min(M,N)-1]
'
'        Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'        MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994
'        ************************************************************************

		Public Shared Sub cmatrixqr(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
			Dim work As complex() = New complex(-1) {}
			Dim t As complex() = New complex(-1) {}
			Dim taubuf As complex() = New complex(-1) {}
			Dim minmn As Integer = 0
			Dim tmpa As complex(,) = New complex(-1, -1) {}
			Dim tmpt As complex(,) = New complex(-1, -1) {}
			Dim tmpr As complex(,) = New complex(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim rowscount As Integer = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New complex(-1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			minmn = System.Math.Min(m, n)
			work = New complex(System.Math.Max(m, n)) {}
			t = New complex(System.Math.Max(m, n)) {}
			tau = New complex(minmn - 1) {}
			taubuf = New complex(minmn - 1) {}
			tmpa = New complex(m - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpt = New complex(ablas.ablascomplexblocksize(a) - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpr = New complex(2 * ablas.ablascomplexblocksize(a) - 1, n - 1) {}

			'
			' Blocked code
			'
			blockstart = 0
			While blockstart <> minmn

				'
				' Determine block size
				'
				blocksize = minmn - blockstart
				If blocksize > ablas.ablascomplexblocksize(a) Then
					blocksize = ablas.ablascomplexblocksize(a)
				End If
				rowscount = m - blockstart

				'
				' QR decomposition of submatrix.
				' Matrix is copied to temporary storage to solve
				' some TLB issues arising from non-contiguous memory
				' access pattern.
				'
				ablas.cmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, tmpa, _
					0, 0)
				cmatrixqrbasecase(tmpa, rowscount, blocksize, work, t, taubuf)
				ablas.cmatrixcopy(rowscount, blocksize, tmpa, 0, 0, a, _
					blockstart, blockstart)
				i1_ = (0) - (blockstart)
				For i_ = blockstart To blockstart + blocksize - 1
					tau(i_) = taubuf(i_ + i1_)
				Next

				'
				' Update the rest, choose between:
				' a) Level 2 algorithm (when the rest of the matrix is small enough)
				' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
				'    representation for products of Householder transformations',
				'    by R. Schreiber and C. Van Loan.
				'
				If blockstart + blocksize <= n - 1 Then
					If n - blockstart - blocksize >= 2 * ablas.ablascomplexblocksize(a) Then

						'
						' Prepare block reflector
						'
						cmatrixblockreflector(tmpa, taubuf, True, rowscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q'.
						'
						' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
						' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
						'
						ablas.cmatrixgemm(blocksize, n - blockstart - blocksize, rowscount, 1.0, tmpa, 0, _
							0, 2, a, blockstart, blockstart + blocksize, 0, _
							0.0, tmpr, 0, 0)
						ablas.cmatrixgemm(blocksize, n - blockstart - blocksize, blocksize, 1.0, tmpt, 0, _
							0, 2, tmpr, 0, 0, 0, _
							0.0, tmpr, blocksize, 0)
						ablas.cmatrixgemm(rowscount, n - blockstart - blocksize, blocksize, 1.0, tmpa, 0, _
							0, 0, tmpr, blocksize, 0, 0, _
							1.0, a, blockstart, blockstart + blocksize)
					Else

						'
						' Level 2 algorithm
						'
						For i = 0 To blocksize - 1
							i1_ = (i) - (1)
							For i_ = 1 To rowscount - i
								t(i_) = tmpa(i_ + i1_, i)
							Next
							t(1) = 1
							creflections.complexapplyreflectionfromtheleft(a, Math.conj(taubuf(i)), t, blockstart + i, m - 1, blockstart + blocksize, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart + blocksize
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixqr(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
			cmatrixqr(a, m, n, tau)
		End Sub


		'************************************************************************
'        LQ decomposition of a rectangular complex matrix of size MxN
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'            M   -   number of rows in matrix A.
'            N   -   number of columns in matrix A.
'
'        Output parameters:
'            A   -   matrices Q and L in compact form
'            Tau -   array of scalar factors which are used to form matrix Q. Array
'                    whose indexes range within [0.. Min(M,N)-1]
'
'        Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'        MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994
'        ************************************************************************

		Public Shared Sub cmatrixlq(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
			Dim work As complex() = New complex(-1) {}
			Dim t As complex() = New complex(-1) {}
			Dim taubuf As complex() = New complex(-1) {}
			Dim minmn As Integer = 0
			Dim tmpa As complex(,) = New complex(-1, -1) {}
			Dim tmpt As complex(,) = New complex(-1, -1) {}
			Dim tmpr As complex(,) = New complex(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim columnscount As Integer = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New complex(-1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			minmn = System.Math.Min(m, n)
			work = New complex(System.Math.Max(m, n)) {}
			t = New complex(System.Math.Max(m, n)) {}
			tau = New complex(minmn - 1) {}
			taubuf = New complex(minmn - 1) {}
			tmpa = New complex(ablas.ablascomplexblocksize(a) - 1, n - 1) {}
			tmpt = New complex(ablas.ablascomplexblocksize(a) - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpr = New complex(m - 1, 2 * ablas.ablascomplexblocksize(a) - 1) {}

			'
			' Blocked code
			'
			blockstart = 0
			While blockstart <> minmn

				'
				' Determine block size
				'
				blocksize = minmn - blockstart
				If blocksize > ablas.ablascomplexblocksize(a) Then
					blocksize = ablas.ablascomplexblocksize(a)
				End If
				columnscount = n - blockstart

				'
				' LQ decomposition of submatrix.
				' Matrix is copied to temporary storage to solve
				' some TLB issues arising from non-contiguous memory
				' access pattern.
				'
				ablas.cmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, tmpa, _
					0, 0)
				cmatrixlqbasecase(tmpa, blocksize, columnscount, work, t, taubuf)
				ablas.cmatrixcopy(blocksize, columnscount, tmpa, 0, 0, a, _
					blockstart, blockstart)
				i1_ = (0) - (blockstart)
				For i_ = blockstart To blockstart + blocksize - 1
					tau(i_) = taubuf(i_ + i1_)
				Next

				'
				' Update the rest, choose between:
				' a) Level 2 algorithm (when the rest of the matrix is small enough)
				' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
				'    representation for products of Householder transformations',
				'    by R. Schreiber and C. Van Loan.
				'
				If blockstart + blocksize <= m - 1 Then
					If m - blockstart - blocksize >= 2 * ablas.ablascomplexblocksize(a) Then

						'
						' Prepare block reflector
						'
						cmatrixblockreflector(tmpa, taubuf, False, columnscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q.
						'
						' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
						'
						ablas.cmatrixgemm(m - blockstart - blocksize, blocksize, columnscount, 1.0, a, blockstart + blocksize, _
							blockstart, 0, tmpa, 0, 0, 2, _
							0.0, tmpr, 0, 0)
						ablas.cmatrixgemm(m - blockstart - blocksize, blocksize, blocksize, 1.0, tmpr, 0, _
							0, 0, tmpt, 0, 0, 0, _
							0.0, tmpr, 0, blocksize)
						ablas.cmatrixgemm(m - blockstart - blocksize, columnscount, blocksize, 1.0, tmpr, 0, _
							blocksize, 0, tmpa, 0, 0, 0, _
							1.0, a, blockstart + blocksize, blockstart)
					Else

						'
						' Level 2 algorithm
						'
						For i = 0 To blocksize - 1
							i1_ = (i) - (1)
							For i_ = 1 To columnscount - i
								t(i_) = Math.conj(tmpa(i, i_ + i1_))
							Next
							t(1) = 1
							creflections.complexapplyreflectionfromtheright(a, taubuf(i), t, blockstart + blocksize, m - 1, blockstart + i, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart + blocksize
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixlq(ByRef a As complex(,), m As Integer, n As Integer, ByRef tau As complex())
			cmatrixlq(a, m, n, tau)
		End Sub


		'************************************************************************
'        Partial unpacking of matrix Q from the QR decomposition of a matrix A
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrices Q and R in compact form.
'                        Output of RMatrixQR subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'            Tau     -   scalar factors which are used to form Q.
'                        Output of the RMatrixQR subroutine.
'            QColumns -  required number of columns of matrix Q. M>=QColumns>=0.
'
'        Output parameters:
'            Q       -   first QColumns columns of matrix Q.
'                        Array whose indexes range within [0..M-1, 0..QColumns-1].
'                        If QColumns=0, the array remains unchanged.
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixqrunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qcolumns As Integer, ByRef q As Double(,))
			Dim work As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim taubuf As Double() = New Double(-1) {}
			Dim minmn As Integer = 0
			Dim refcnt As Integer = 0
			Dim tmpa As Double(,) = New Double(-1, -1) {}
			Dim tmpt As Double(,) = New Double(-1, -1) {}
			Dim tmpr As Double(,) = New Double(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim rowscount As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New Double(-1, -1) {}

			alglib.ap.assert(qcolumns <= m, "UnpackQFromQR: QColumns>M!")
			If (m <= 0 OrElse n <= 0) OrElse qcolumns <= 0 Then
				Return
			End If

			'
			' init
			'
			minmn = System.Math.Min(m, n)
			refcnt = System.Math.Min(minmn, qcolumns)
			q = New Double(m - 1, qcolumns - 1) {}
			For i = 0 To m - 1
				For j = 0 To qcolumns - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next
			work = New Double(System.Math.Max(m, qcolumns)) {}
			t = New Double(System.Math.Max(m, qcolumns)) {}
			taubuf = New Double(minmn - 1) {}
			tmpa = New Double(m - 1, ablas.ablasblocksize(a) - 1) {}
			tmpt = New Double(ablas.ablasblocksize(a) - 1, 2 * ablas.ablasblocksize(a) - 1) {}
			tmpr = New Double(2 * ablas.ablasblocksize(a) - 1, qcolumns - 1) {}

			'
			' Blocked code
			'
			blockstart = ablas.ablasblocksize(a) * (refcnt \ ablas.ablasblocksize(a))
			blocksize = refcnt - blockstart
			While blockstart >= 0
				rowscount = m - blockstart
				If blocksize > 0 Then

					'
					' Copy current block
					'
					ablas.rmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, tmpa, _
						0, 0)
					i1_ = (blockstart) - (0)
					For i_ = 0 To blocksize - 1
						taubuf(i_) = tau(i_ + i1_)
					Next

					'
					' Update, choose between:
					' a) Level 2 algorithm (when the rest of the matrix is small enough)
					' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					'    representation for products of Householder transformations',
					'    by R. Schreiber and C. Van Loan.
					'
					If qcolumns >= 2 * ablas.ablasblocksize(a) Then

						'
						' Prepare block reflector
						'
						rmatrixblockreflector(tmpa, taubuf, True, rowscount, blocksize, tmpt, _
							work)

						'
						' Multiply matrix by Q.
						'
						' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
						'
						ablas.rmatrixgemm(blocksize, qcolumns, rowscount, 1.0, tmpa, 0, _
							0, 1, q, blockstart, 0, 0, _
							0.0, tmpr, 0, 0)
						ablas.rmatrixgemm(blocksize, qcolumns, blocksize, 1.0, tmpt, 0, _
							0, 0, tmpr, 0, 0, 0, _
							0.0, tmpr, blocksize, 0)
						ablas.rmatrixgemm(rowscount, qcolumns, blocksize, 1.0, tmpa, 0, _
							0, 0, tmpr, blocksize, 0, 0, _
							1.0, q, blockstart, 0)
					Else

						'
						' Level 2 algorithm
						'
						For i = blocksize - 1 To 0 Step -1
							i1_ = (i) - (1)
							For i_ = 1 To rowscount - i
								t(i_) = tmpa(i_ + i1_, i)
							Next
							t(1) = 1
							reflections.applyreflectionfromtheleft(q, taubuf(i), t, blockstart + i, m - 1, 0, _
								qcolumns - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart - ablas.ablasblocksize(a)
				blocksize = ablas.ablasblocksize(a)
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixqrunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qcolumns As Integer, ByRef q As Double(,))
			rmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		End Sub


		'************************************************************************
'        Unpacking of matrix R from the QR decomposition of a matrix A
'
'        Input parameters:
'            A       -   matrices Q and R in compact form.
'                        Output of RMatrixQR subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'
'        Output parameters:
'            R       -   matrix R, array[0..M-1, 0..N-1].
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixqrunpackr(a As Double(,), m As Integer, n As Integer, ByRef r As Double(,))
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim i_ As Integer = 0

			r = New Double(-1, -1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			k = System.Math.Min(m, n)
			r = New Double(m - 1, n - 1) {}
			For i = 0 To n - 1
				r(0, i) = 0
			Next
			For i = 1 To m - 1
				For i_ = 0 To n - 1
					r(i, i_) = r(0, i_)
				Next
			Next
			For i = 0 To k - 1
				For i_ = i To n - 1
					r(i, i_) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Partial unpacking of matrix Q from the LQ decomposition of a matrix A
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrices L and Q in compact form.
'                        Output of RMatrixLQ subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'            Tau     -   scalar factors which are used to form Q.
'                        Output of the RMatrixLQ subroutine.
'            QRows   -   required number of rows in matrix Q. N>=QRows>=0.
'
'        Output parameters:
'            Q       -   first QRows rows of matrix Q. Array whose indexes range
'                        within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
'                        unchanged.
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixlqunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qrows As Integer, ByRef q As Double(,))
			Dim work As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim taubuf As Double() = New Double(-1) {}
			Dim minmn As Integer = 0
			Dim refcnt As Integer = 0
			Dim tmpa As Double(,) = New Double(-1, -1) {}
			Dim tmpt As Double(,) = New Double(-1, -1) {}
			Dim tmpr As Double(,) = New Double(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim columnscount As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New Double(-1, -1) {}

			alglib.ap.assert(qrows <= n, "RMatrixLQUnpackQ: QRows>N!")
			If (m <= 0 OrElse n <= 0) OrElse qrows <= 0 Then
				Return
			End If

			'
			' init
			'
			minmn = System.Math.Min(m, n)
			refcnt = System.Math.Min(minmn, qrows)
			work = New Double(System.Math.Max(m, n)) {}
			t = New Double(System.Math.Max(m, n)) {}
			taubuf = New Double(minmn - 1) {}
			tmpa = New Double(ablas.ablasblocksize(a) - 1, n - 1) {}
			tmpt = New Double(ablas.ablasblocksize(a) - 1, 2 * ablas.ablasblocksize(a) - 1) {}
			tmpr = New Double(qrows - 1, 2 * ablas.ablasblocksize(a) - 1) {}
			q = New Double(qrows - 1, n - 1) {}
			For i = 0 To qrows - 1
				For j = 0 To n - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' Blocked code
			'
			blockstart = ablas.ablasblocksize(a) * (refcnt \ ablas.ablasblocksize(a))
			blocksize = refcnt - blockstart
			While blockstart >= 0
				columnscount = n - blockstart
				If blocksize > 0 Then

					'
					' Copy submatrix
					'
					ablas.rmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, tmpa, _
						0, 0)
					i1_ = (blockstart) - (0)
					For i_ = 0 To blocksize - 1
						taubuf(i_) = tau(i_ + i1_)
					Next

					'
					' Update matrix, choose between:
					' a) Level 2 algorithm (when the rest of the matrix is small enough)
					' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					'    representation for products of Householder transformations',
					'    by R. Schreiber and C. Van Loan.
					'
					If qrows >= 2 * ablas.ablasblocksize(a) Then

						'
						' Prepare block reflector
						'
						rmatrixblockreflector(tmpa, taubuf, False, columnscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q'.
						'
						' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
						'
						ablas.rmatrixgemm(qrows, blocksize, columnscount, 1.0, q, 0, _
							blockstart, 0, tmpa, 0, 0, 1, _
							0.0, tmpr, 0, 0)
						ablas.rmatrixgemm(qrows, blocksize, blocksize, 1.0, tmpr, 0, _
							0, 0, tmpt, 0, 0, 1, _
							0.0, tmpr, 0, blocksize)
						ablas.rmatrixgemm(qrows, columnscount, blocksize, 1.0, tmpr, 0, _
							blocksize, 0, tmpa, 0, 0, 0, _
							1.0, q, 0, blockstart)
					Else

						'
						' Level 2 algorithm
						'
						For i = blocksize - 1 To 0 Step -1
							i1_ = (i) - (1)
							For i_ = 1 To columnscount - i
								t(i_) = tmpa(i, i_ + i1_)
							Next
							t(1) = 1
							reflections.applyreflectionfromtheright(q, taubuf(i), t, 0, qrows - 1, blockstart + i, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart - ablas.ablasblocksize(a)
				blocksize = ablas.ablasblocksize(a)
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixlqunpackq(a As Double(,), m As Integer, n As Integer, tau As Double(), qrows As Integer, ByRef q As Double(,))
			rmatrixlqunpackq(a, m, n, tau, qrows, q)
		End Sub


		'************************************************************************
'        Unpacking of matrix L from the LQ decomposition of a matrix A
'
'        Input parameters:
'            A       -   matrices Q and L in compact form.
'                        Output of RMatrixLQ subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'
'        Output parameters:
'            L       -   matrix L, array[0..M-1, 0..N-1].
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixlqunpackl(a As Double(,), m As Integer, n As Integer, ByRef l As Double(,))
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim i_ As Integer = 0

			l = New Double(-1, -1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			l = New Double(m - 1, n - 1) {}
			For i = 0 To n - 1
				l(0, i) = 0
			Next
			For i = 1 To m - 1
				For i_ = 0 To n - 1
					l(i, i_) = l(0, i_)
				Next
			Next
			For i = 0 To m - 1
				k = System.Math.Min(i, n - 1)
				For i_ = 0 To k
					l(i, i_) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A           -   matrices Q and R in compact form.
'                            Output of CMatrixQR subroutine .
'            M           -   number of rows in matrix A. M>=0.
'            N           -   number of columns in matrix A. N>=0.
'            Tau         -   scalar factors which are used to form Q.
'                            Output of CMatrixQR subroutine .
'            QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.
'
'        Output parameters:
'            Q           -   first QColumns columns of matrix Q.
'                            Array whose index ranges within [0..M-1, 0..QColumns-1].
'                            If QColumns=0, array isn't changed.
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixqrunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qcolumns As Integer, ByRef q As complex(,))
			Dim work As complex() = New complex(-1) {}
			Dim t As complex() = New complex(-1) {}
			Dim taubuf As complex() = New complex(-1) {}
			Dim minmn As Integer = 0
			Dim refcnt As Integer = 0
			Dim tmpa As complex(,) = New complex(-1, -1) {}
			Dim tmpt As complex(,) = New complex(-1, -1) {}
			Dim tmpr As complex(,) = New complex(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim rowscount As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New complex(-1, -1) {}

			alglib.ap.assert(qcolumns <= m, "UnpackQFromQR: QColumns>M!")
			If m <= 0 OrElse n <= 0 Then
				Return
			End If

			'
			' init
			'
			minmn = System.Math.Min(m, n)
			refcnt = System.Math.Min(minmn, qcolumns)
			work = New complex(System.Math.Max(m, n)) {}
			t = New complex(System.Math.Max(m, n)) {}
			taubuf = New complex(minmn - 1) {}
			tmpa = New complex(m - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpt = New complex(ablas.ablascomplexblocksize(a) - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpr = New complex(2 * ablas.ablascomplexblocksize(a) - 1, qcolumns - 1) {}
			q = New complex(m - 1, qcolumns - 1) {}
			For i = 0 To m - 1
				For j = 0 To qcolumns - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' Blocked code
			'
			blockstart = ablas.ablascomplexblocksize(a) * (refcnt \ ablas.ablascomplexblocksize(a))
			blocksize = refcnt - blockstart
			While blockstart >= 0
				rowscount = m - blockstart
				If blocksize > 0 Then

					'
					' QR decomposition of submatrix.
					' Matrix is copied to temporary storage to solve
					' some TLB issues arising from non-contiguous memory
					' access pattern.
					'
					ablas.cmatrixcopy(rowscount, blocksize, a, blockstart, blockstart, tmpa, _
						0, 0)
					i1_ = (blockstart) - (0)
					For i_ = 0 To blocksize - 1
						taubuf(i_) = tau(i_ + i1_)
					Next

					'
					' Update matrix, choose between:
					' a) Level 2 algorithm (when the rest of the matrix is small enough)
					' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					'    representation for products of Householder transformations',
					'    by R. Schreiber and C. Van Loan.
					'
					If qcolumns >= 2 * ablas.ablascomplexblocksize(a) Then

						'
						' Prepare block reflector
						'
						cmatrixblockreflector(tmpa, taubuf, True, rowscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q.
						'
						' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
						'
						ablas.cmatrixgemm(blocksize, qcolumns, rowscount, 1.0, tmpa, 0, _
							0, 2, q, blockstart, 0, 0, _
							0.0, tmpr, 0, 0)
						ablas.cmatrixgemm(blocksize, qcolumns, blocksize, 1.0, tmpt, 0, _
							0, 0, tmpr, 0, 0, 0, _
							0.0, tmpr, blocksize, 0)
						ablas.cmatrixgemm(rowscount, qcolumns, blocksize, 1.0, tmpa, 0, _
							0, 0, tmpr, blocksize, 0, 0, _
							1.0, q, blockstart, 0)
					Else

						'
						' Level 2 algorithm
						'
						For i = blocksize - 1 To 0 Step -1
							i1_ = (i) - (1)
							For i_ = 1 To rowscount - i
								t(i_) = tmpa(i_ + i1_, i)
							Next
							t(1) = 1
							creflections.complexapplyreflectionfromtheleft(q, taubuf(i), t, blockstart + i, m - 1, 0, _
								qcolumns - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart - ablas.ablascomplexblocksize(a)
				blocksize = ablas.ablascomplexblocksize(a)
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixqrunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qcolumns As Integer, ByRef q As complex(,))
			cmatrixqrunpackq(a, m, n, tau, qcolumns, q)
		End Sub


		'************************************************************************
'        Unpacking of matrix R from the QR decomposition of a matrix A
'
'        Input parameters:
'            A       -   matrices Q and R in compact form.
'                        Output of CMatrixQR subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'
'        Output parameters:
'            R       -   matrix R, array[0..M-1, 0..N-1].
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixqrunpackr(a As complex(,), m As Integer, n As Integer, ByRef r As complex(,))
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim i_ As Integer = 0

			r = New complex(-1, -1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			k = System.Math.Min(m, n)
			r = New complex(m - 1, n - 1) {}
			For i = 0 To n - 1
				r(0, i) = 0
			Next
			For i = 1 To m - 1
				For i_ = 0 To n - 1
					r(i, i_) = r(0, i_)
				Next
			Next
			For i = 0 To k - 1
				For i_ = i To n - 1
					r(i, i_) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that QP decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=512,   achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A           -   matrices Q and R in compact form.
'                            Output of CMatrixLQ subroutine .
'            M           -   number of rows in matrix A. M>=0.
'            N           -   number of columns in matrix A. N>=0.
'            Tau         -   scalar factors which are used to form Q.
'                            Output of CMatrixLQ subroutine .
'            QRows       -   required number of rows in matrix Q. N>=QColumns>=0.
'
'        Output parameters:
'            Q           -   first QRows rows of matrix Q.
'                            Array whose index ranges within [0..QRows-1, 0..N-1].
'                            If QRows=0, array isn't changed.
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixlqunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qrows As Integer, ByRef q As complex(,))
			Dim work As complex() = New complex(-1) {}
			Dim t As complex() = New complex(-1) {}
			Dim taubuf As complex() = New complex(-1) {}
			Dim minmn As Integer = 0
			Dim refcnt As Integer = 0
			Dim tmpa As complex(,) = New complex(-1, -1) {}
			Dim tmpt As complex(,) = New complex(-1, -1) {}
			Dim tmpr As complex(,) = New complex(-1, -1) {}
			Dim blockstart As Integer = 0
			Dim blocksize As Integer = 0
			Dim columnscount As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New complex(-1, -1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If

			'
			' Init
			'
			minmn = System.Math.Min(m, n)
			refcnt = System.Math.Min(minmn, qrows)
			work = New complex(System.Math.Max(m, n)) {}
			t = New complex(System.Math.Max(m, n)) {}
			taubuf = New complex(minmn - 1) {}
			tmpa = New complex(ablas.ablascomplexblocksize(a) - 1, n - 1) {}
			tmpt = New complex(ablas.ablascomplexblocksize(a) - 1, ablas.ablascomplexblocksize(a) - 1) {}
			tmpr = New complex(qrows - 1, 2 * ablas.ablascomplexblocksize(a) - 1) {}
			q = New complex(qrows - 1, n - 1) {}
			For i = 0 To qrows - 1
				For j = 0 To n - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' Blocked code
			'
			blockstart = ablas.ablascomplexblocksize(a) * (refcnt \ ablas.ablascomplexblocksize(a))
			blocksize = refcnt - blockstart
			While blockstart >= 0
				columnscount = n - blockstart
				If blocksize > 0 Then

					'
					' LQ decomposition of submatrix.
					' Matrix is copied to temporary storage to solve
					' some TLB issues arising from non-contiguous memory
					' access pattern.
					'
					ablas.cmatrixcopy(blocksize, columnscount, a, blockstart, blockstart, tmpa, _
						0, 0)
					i1_ = (blockstart) - (0)
					For i_ = 0 To blocksize - 1
						taubuf(i_) = tau(i_ + i1_)
					Next

					'
					' Update matrix, choose between:
					' a) Level 2 algorithm (when the rest of the matrix is small enough)
					' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
					'    representation for products of Householder transformations',
					'    by R. Schreiber and C. Van Loan.
					'
					If qrows >= 2 * ablas.ablascomplexblocksize(a) Then

						'
						' Prepare block reflector
						'
						cmatrixblockreflector(tmpa, taubuf, False, columnscount, blocksize, tmpt, _
							work)

						'
						' Multiply the rest of A by Q'.
						'
						' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
						'
						ablas.cmatrixgemm(qrows, blocksize, columnscount, 1.0, q, 0, _
							blockstart, 0, tmpa, 0, 0, 2, _
							0.0, tmpr, 0, 0)
						ablas.cmatrixgemm(qrows, blocksize, blocksize, 1.0, tmpr, 0, _
							0, 0, tmpt, 0, 0, 2, _
							0.0, tmpr, 0, blocksize)
						ablas.cmatrixgemm(qrows, columnscount, blocksize, 1.0, tmpr, 0, _
							blocksize, 0, tmpa, 0, 0, 0, _
							1.0, q, 0, blockstart)
					Else

						'
						' Level 2 algorithm
						'
						For i = blocksize - 1 To 0 Step -1
							i1_ = (i) - (1)
							For i_ = 1 To columnscount - i
								t(i_) = Math.conj(tmpa(i, i_ + i1_))
							Next
							t(1) = 1
							creflections.complexapplyreflectionfromtheright(q, Math.conj(taubuf(i)), t, 0, qrows - 1, blockstart + i, _
								n - 1, work)
						Next
					End If
				End If

				'
				' Advance
				'
				blockstart = blockstart - ablas.ablascomplexblocksize(a)
				blocksize = ablas.ablascomplexblocksize(a)
			End While
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixlqunpackq(a As complex(,), m As Integer, n As Integer, tau As complex(), qrows As Integer, ByRef q As complex(,))
			cmatrixlqunpackq(a, m, n, tau, qrows, q)
		End Sub


		'************************************************************************
'        Unpacking of matrix L from the LQ decomposition of a matrix A
'
'        Input parameters:
'            A       -   matrices Q and L in compact form.
'                        Output of CMatrixLQ subroutine.
'            M       -   number of rows in given matrix A. M>=0.
'            N       -   number of columns in given matrix A. N>=0.
'
'        Output parameters:
'            L       -   matrix L, array[0..M-1, 0..N-1].
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixlqunpackl(a As complex(,), m As Integer, n As Integer, ByRef l As complex(,))
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim i_ As Integer = 0

			l = New complex(-1, -1) {}

			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			l = New complex(m - 1, n - 1) {}
			For i = 0 To n - 1
				l(0, i) = 0
			Next
			For i = 1 To m - 1
				For i_ = 0 To n - 1
					l(i, i_) = l(0, i_)
				Next
			Next
			For i = 0 To m - 1
				k = System.Math.Min(i, n - 1)
				For i_ = 0 To k
					l(i, i_) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Base case for real QR
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994.
'             Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'             pseudocode, 2007-2010.
'        ************************************************************************

		Public Shared Sub rmatrixqrbasecase(ByRef a As Double(,), m As Integer, n As Integer, ByRef work As Double(), ByRef t As Double(), ByRef tau As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim minmn As Integer = 0
			Dim tmp As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			minmn = System.Math.Min(m, n)

			'
			' Test the input arguments
			'
			k = minmn
			For i = 0 To k - 1

				'
				' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
				'
				i1_ = (i) - (1)
				For i_ = 1 To m - i
					t(i_) = a(i_ + i1_, i)
				Next
				reflections.generatereflection(t, m - i, tmp)
				tau(i) = tmp
				i1_ = (1) - (i)
				For i_ = i To m - 1
					a(i_, i) = t(i_ + i1_)
				Next
				t(1) = 1
				If i < n Then

					'
					' Apply H(i) to A(i:m-1,i+1:n-1) from the left
					'
					reflections.applyreflectionfromtheleft(a, tau(i), t, i, m - 1, i + 1, _
						n - 1, work)
				End If
			Next
		End Sub


		'************************************************************************
'        Base case for real LQ
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994.
'             Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'             pseudocode, 2007-2010.
'        ************************************************************************

		Public Shared Sub rmatrixlqbasecase(ByRef a As Double(,), m As Integer, n As Integer, ByRef work As Double(), ByRef t As Double(), ByRef tau As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim tmp As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			k = System.Math.Min(m, n)
			For i = 0 To k - 1

				'
				' Generate elementary reflector H(i) to annihilate A(i,i+1:n-1)
				'
				i1_ = (i) - (1)
				For i_ = 1 To n - i
					t(i_) = a(i, i_ + i1_)
				Next
				reflections.generatereflection(t, n - i, tmp)
				tau(i) = tmp
				i1_ = (1) - (i)
				For i_ = i To n - 1
					a(i, i_) = t(i_ + i1_)
				Next
				t(1) = 1
				If i < n Then

					'
					' Apply H(i) to A(i+1:m,i:n) from the right
					'
					reflections.applyreflectionfromtheright(a, tau(i), t, i + 1, m - 1, i, _
						n - 1, work)
				End If
			Next
		End Sub


		'************************************************************************
'        Reduction of a rectangular matrix to  bidiagonal form
'
'        The algorithm reduces the rectangular matrix A to  bidiagonal form by
'        orthogonal transformations P and Q: A = Q*B*(P^T).
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Multithreaded acceleration is NOT supported for this function  because
'          ! bidiagonal decompostion is inherently sequential in nature.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   source matrix. array[0..M-1, 0..N-1]
'            M       -   number of rows in matrix A.
'            N       -   number of columns in matrix A.
'
'        Output parameters:
'            A       -   matrices Q, B, P in compact form (see below).
'            TauQ    -   scalar factors which are used to form matrix Q.
'            TauP    -   scalar factors which are used to form matrix P.
'
'        The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
'        replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
'        reflections which form MxM matrix Q and NxN matrix P, respectively.
'
'        If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
'        corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
'        product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
'        H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
'        vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
'        stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
'        G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
'        u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
'
'        If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
'        corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
'        H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
'        is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
'        G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
'        is stored in A(i,i+1:n-1).
'
'        EXAMPLE:
'
'        m=6, n=5 (m > n):               m=5, n=6 (m < n):
'
'        (  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
'        (  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
'        (  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
'        (  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
'        (  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
'        (  v1  v2  v3  v4  v5 )
'
'        Here vi and ui are vectors which form H(i) and G(i), and d and e -
'        are the diagonal and off-diagonal elements of matrix B.
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994.
'             Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'             pseudocode, 2007-2010.
'        ************************************************************************

		Public Shared Sub rmatrixbd(ByRef a As Double(,), m As Integer, n As Integer, ByRef tauq As Double(), ByRef taup As Double())
			Dim work As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim maxmn As Integer = 0
			Dim i As Integer = 0
			Dim ltau As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tauq = New Double(-1) {}
			taup = New Double(-1) {}


			'
			' Prepare
			'
			If n <= 0 OrElse m <= 0 Then
				Return
			End If
			maxmn = System.Math.Max(m, n)
			work = New Double(maxmn) {}
			t = New Double(maxmn) {}
			If m >= n Then
				tauq = New Double(n - 1) {}
				taup = New Double(n - 1) {}
				For i = 0 To n - 1
					tauq(i) = 0.0
					taup(i) = 0.0
				Next
			Else
				tauq = New Double(m - 1) {}
				taup = New Double(m - 1) {}
				For i = 0 To m - 1
					tauq(i) = 0.0
					taup(i) = 0.0
				Next
			End If

			'
			' Try to use MKL code
			'
			' NOTE: buffers Work[] and T[] are used for temporary storage of diagonals;
			' because they are present in A[], we do not use them.
			'
			If ablasmkl.rmatrixbdmkl(a, m, n, work, t, tauq, _
				taup) Then
				Return
			End If

			'
			' ALGLIB code
			'
			If m >= n Then

				'
				' Reduce to upper bidiagonal form
				'
				For i = 0 To n - 1

					'
					' Generate elementary reflector H(i) to annihilate A(i+1:m-1,i)
					'
					i1_ = (i) - (1)
					For i_ = 1 To m - i
						t(i_) = a(i_ + i1_, i)
					Next
					reflections.generatereflection(t, m - i, ltau)
					tauq(i) = ltau
					i1_ = (1) - (i)
					For i_ = i To m - 1
						a(i_, i) = t(i_ + i1_)
					Next
					t(1) = 1

					'
					' Apply H(i) to A(i:m-1,i+1:n-1) from the left
					'
					reflections.applyreflectionfromtheleft(a, ltau, t, i, m - 1, i + 1, _
						n - 1, work)
					If i < n - 1 Then

						'
						' Generate elementary reflector G(i) to annihilate
						' A(i,i+2:n-1)
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - i - 1
							t(i_) = a(i, i_ + i1_)
						Next
						reflections.generatereflection(t, n - 1 - i, ltau)
						taup(i) = ltau
						i1_ = (1) - (i + 1)
						For i_ = i + 1 To n - 1
							a(i, i_) = t(i_ + i1_)
						Next
						t(1) = 1

						'
						' Apply G(i) to A(i+1:m-1,i+1:n-1) from the right
						'
						reflections.applyreflectionfromtheright(a, ltau, t, i + 1, m - 1, i + 1, _
							n - 1, work)
					Else
						taup(i) = 0
					End If
				Next
			Else

				'
				' Reduce to lower bidiagonal form
				'
				For i = 0 To m - 1

					'
					' Generate elementary reflector G(i) to annihilate A(i,i+1:n-1)
					'
					i1_ = (i) - (1)
					For i_ = 1 To n - i
						t(i_) = a(i, i_ + i1_)
					Next
					reflections.generatereflection(t, n - i, ltau)
					taup(i) = ltau
					i1_ = (1) - (i)
					For i_ = i To n - 1
						a(i, i_) = t(i_ + i1_)
					Next
					t(1) = 1

					'
					' Apply G(i) to A(i+1:m-1,i:n-1) from the right
					'
					reflections.applyreflectionfromtheright(a, ltau, t, i + 1, m - 1, i, _
						n - 1, work)
					If i < m - 1 Then

						'
						' Generate elementary reflector H(i) to annihilate
						' A(i+2:m-1,i)
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To m - 1 - i
							t(i_) = a(i_ + i1_, i)
						Next
						reflections.generatereflection(t, m - 1 - i, ltau)
						tauq(i) = ltau
						i1_ = (1) - (i + 1)
						For i_ = i + 1 To m - 1
							a(i_, i) = t(i_ + i1_)
						Next
						t(1) = 1

						'
						' Apply H(i) to A(i+1:m-1,i+1:n-1) from the left
						'
						reflections.applyreflectionfromtheleft(a, ltau, t, i + 1, m - 1, i + 1, _
							n - 1, work)
					Else
						tauq(i) = 0
					End If
				Next
			End If
		End Sub


		'************************************************************************
'        Unpacking matrix Q which reduces a matrix to bidiagonal form.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'          
'        Input parameters:
'            QP          -   matrices Q and P in compact form.
'                            Output of ToBidiagonal subroutine.
'            M           -   number of rows in matrix A.
'            N           -   number of columns in matrix A.
'            TAUQ        -   scalar factors which are used to form Q.
'                            Output of ToBidiagonal subroutine.
'            QColumns    -   required number of columns in matrix Q.
'                            M>=QColumns>=0.
'
'        Output parameters:
'            Q           -   first QColumns columns of matrix Q.
'                            Array[0..M-1, 0..QColumns-1]
'                            If QColumns=0, the array is not modified.
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixbdunpackq(qp As Double(,), m As Integer, n As Integer, tauq As Double(), qcolumns As Integer, ByRef q As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0

			q = New Double(-1, -1) {}

			alglib.ap.assert(qcolumns <= m, "RMatrixBDUnpackQ: QColumns>M!")
			alglib.ap.assert(qcolumns >= 0, "RMatrixBDUnpackQ: QColumns<0!")
			If (m = 0 OrElse n = 0) OrElse qcolumns = 0 Then
				Return
			End If

			'
			' prepare Q
			'
			q = New Double(m - 1, qcolumns - 1) {}
			For i = 0 To m - 1
				For j = 0 To qcolumns - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' Calculate
			'
			rmatrixbdmultiplybyq(qp, m, n, tauq, q, m, _
				qcolumns, False, False)
		End Sub


		'************************************************************************
'        Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
'
'        The algorithm allows pre- or post-multiply by Q or Q'.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'          
'        Input parameters:
'            QP          -   matrices Q and P in compact form.
'                            Output of ToBidiagonal subroutine.
'            M           -   number of rows in matrix A.
'            N           -   number of columns in matrix A.
'            TAUQ        -   scalar factors which are used to form Q.
'                            Output of ToBidiagonal subroutine.
'            Z           -   multiplied matrix.
'                            array[0..ZRows-1,0..ZColumns-1]
'            ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                            ZRows=M, otherwise ZRows can be arbitrary.
'            ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                            ZColumns=M, otherwise ZColumns can be arbitrary.
'            FromTheRight -  pre- or post-multiply.
'            DoTranspose -   multiply by Q or Q'.
'
'        Output parameters:
'            Z           -   product of Z and Q.
'                            Array[0..ZRows-1,0..ZColumns-1]
'                            If ZRows=0 or ZColumns=0, the array is not modified.
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixbdmultiplybyq(qp As Double(,), m As Integer, n As Integer, tauq As Double(), ByRef z As Double(,), zrows As Integer, _
			zcolumns As Integer, fromtheright As Boolean, dotranspose As Boolean)
			Dim i As Integer = 0
			Dim i1 As Integer = 0
			Dim i2 As Integer = 0
			Dim istep As Integer = 0
			Dim v As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim dummy As Double() = New Double(-1) {}
			Dim mx As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If ((m <= 0 OrElse n <= 0) OrElse zrows <= 0) OrElse zcolumns <= 0 Then
				Return
			End If
			alglib.ap.assert((fromtheright AndAlso zcolumns = m) OrElse (Not fromtheright AndAlso zrows = m), "RMatrixBDMultiplyByQ: incorrect Z size!")

			'
			' Try to use MKL code
			'
			If ablasmkl.rmatrixbdmultiplybymkl(qp, m, n, tauq, dummy, z, _
				zrows, zcolumns, True, fromtheright, dotranspose) Then
				Return
			End If

			'
			' init
			'
			mx = System.Math.Max(m, n)
			mx = System.Math.Max(mx, zrows)
			mx = System.Math.Max(mx, zcolumns)
			v = New Double(mx) {}
			work = New Double(mx) {}
			If m >= n Then

				'
				' setup
				'
				If fromtheright Then
					i1 = 0
					i2 = n - 1
					istep = 1
				Else
					i1 = n - 1
					i2 = 0
					istep = -1
				End If
				If dotranspose Then
					i = i1
					i1 = i2
					i2 = i
					istep = -istep
				End If

				'
				' Process
				'
				i = i1
				Do
					i1_ = (i) - (1)
					For i_ = 1 To m - i
						v(i_) = qp(i_ + i1_, i)
					Next
					v(1) = 1
					If fromtheright Then
						reflections.applyreflectionfromtheright(z, tauq(i), v, 0, zrows - 1, i, _
							m - 1, work)
					Else
						reflections.applyreflectionfromtheleft(z, tauq(i), v, i, m - 1, 0, _
							zcolumns - 1, work)
					End If
					i = i + istep
				Loop While i <> i2 + istep
			Else

				'
				' setup
				'
				If fromtheright Then
					i1 = 0
					i2 = m - 2
					istep = 1
				Else
					i1 = m - 2
					i2 = 0
					istep = -1
				End If
				If dotranspose Then
					i = i1
					i1 = i2
					i2 = i
					istep = -istep
				End If

				'
				' Process
				'
				If m - 1 > 0 Then
					i = i1
					Do
						i1_ = (i + 1) - (1)
						For i_ = 1 To m - i - 1
							v(i_) = qp(i_ + i1_, i)
						Next
						v(1) = 1
						If fromtheright Then
							reflections.applyreflectionfromtheright(z, tauq(i), v, 0, zrows - 1, i + 1, _
								m - 1, work)
						Else
							reflections.applyreflectionfromtheleft(z, tauq(i), v, i + 1, m - 1, 0, _
								zcolumns - 1, work)
						End If
						i = i + istep
					Loop While i <> i2 + istep
				End If
			End If
		End Sub


		'************************************************************************
'        Unpacking matrix P which reduces matrix A to bidiagonal form.
'        The subroutine returns transposed matrix P.
'
'        Input parameters:
'            QP      -   matrices Q and P in compact form.
'                        Output of ToBidiagonal subroutine.
'            M       -   number of rows in matrix A.
'            N       -   number of columns in matrix A.
'            TAUP    -   scalar factors which are used to form P.
'                        Output of ToBidiagonal subroutine.
'            PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.
'
'        Output parameters:
'            PT      -   first PTRows columns of matrix P^T
'                        Array[0..PTRows-1, 0..N-1]
'                        If PTRows=0, the array is not modified.
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixbdunpackpt(qp As Double(,), m As Integer, n As Integer, taup As Double(), ptrows As Integer, ByRef pt As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0

			pt = New Double(-1, -1) {}

			alglib.ap.assert(ptrows <= n, "RMatrixBDUnpackPT: PTRows>N!")
			alglib.ap.assert(ptrows >= 0, "RMatrixBDUnpackPT: PTRows<0!")
			If (m = 0 OrElse n = 0) OrElse ptrows = 0 Then
				Return
			End If

			'
			' prepare PT
			'
			pt = New Double(ptrows - 1, n - 1) {}
			For i = 0 To ptrows - 1
				For j = 0 To n - 1
					If i = j Then
						pt(i, j) = 1
					Else
						pt(i, j) = 0
					End If
				Next
			Next

			'
			' Calculate
			'
			rmatrixbdmultiplybyp(qp, m, n, taup, pt, ptrows, _
				n, True, True)
		End Sub


		'************************************************************************
'        Multiplication by matrix P which reduces matrix A to  bidiagonal form.
'
'        The algorithm allows pre- or post-multiply by P or P'.
'
'        Input parameters:
'            QP          -   matrices Q and P in compact form.
'                            Output of RMatrixBD subroutine.
'            M           -   number of rows in matrix A.
'            N           -   number of columns in matrix A.
'            TAUP        -   scalar factors which are used to form P.
'                            Output of RMatrixBD subroutine.
'            Z           -   multiplied matrix.
'                            Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'            ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                            ZRows=N, otherwise ZRows can be arbitrary.
'            ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                            ZColumns=N, otherwise ZColumns can be arbitrary.
'            FromTheRight -  pre- or post-multiply.
'            DoTranspose -   multiply by P or P'.
'
'        Output parameters:
'            Z - product of Z and P.
'                        Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'                        If ZRows=0 or ZColumns=0, the array is not modified.
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixbdmultiplybyp(qp As Double(,), m As Integer, n As Integer, taup As Double(), ByRef z As Double(,), zrows As Integer, _
			zcolumns As Integer, fromtheright As Boolean, dotranspose As Boolean)
			Dim i As Integer = 0
			Dim v As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim dummy As Double() = New Double(-1) {}
			Dim mx As Integer = 0
			Dim i1 As Integer = 0
			Dim i2 As Integer = 0
			Dim istep As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If ((m <= 0 OrElse n <= 0) OrElse zrows <= 0) OrElse zcolumns <= 0 Then
				Return
			End If
			alglib.ap.assert((fromtheright AndAlso zcolumns = n) OrElse (Not fromtheright AndAlso zrows = n), "RMatrixBDMultiplyByP: incorrect Z size!")

			'
			' init
			'
			mx = System.Math.Max(m, n)
			mx = System.Math.Max(mx, zrows)
			mx = System.Math.Max(mx, zcolumns)
			v = New Double(mx) {}
			work = New Double(mx) {}
			If m >= n Then

				'
				' setup
				'
				If fromtheright Then
					i1 = n - 2
					i2 = 0
					istep = -1
				Else
					i1 = 0
					i2 = n - 2
					istep = 1
				End If
				If Not dotranspose Then
					i = i1
					i1 = i2
					i2 = i
					istep = -istep
				End If

				'
				' Process
				'
				If n - 1 > 0 Then
					i = i1
					Do
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - 1 - i
							v(i_) = qp(i, i_ + i1_)
						Next
						v(1) = 1
						If fromtheright Then
							reflections.applyreflectionfromtheright(z, taup(i), v, 0, zrows - 1, i + 1, _
								n - 1, work)
						Else
							reflections.applyreflectionfromtheleft(z, taup(i), v, i + 1, n - 1, 0, _
								zcolumns - 1, work)
						End If
						i = i + istep
					Loop While i <> i2 + istep
				End If
			Else

				'
				' setup
				'
				If fromtheright Then
					i1 = m - 1
					i2 = 0
					istep = -1
				Else
					i1 = 0
					i2 = m - 1
					istep = 1
				End If
				If Not dotranspose Then
					i = i1
					i1 = i2
					i2 = i
					istep = -istep
				End If

				'
				' Process
				'
				i = i1
				Do
					i1_ = (i) - (1)
					For i_ = 1 To n - i
						v(i_) = qp(i, i_ + i1_)
					Next
					v(1) = 1
					If fromtheright Then
						reflections.applyreflectionfromtheright(z, taup(i), v, 0, zrows - 1, i, _
							n - 1, work)
					Else
						reflections.applyreflectionfromtheleft(z, taup(i), v, i, n - 1, 0, _
							zcolumns - 1, work)
					End If
					i = i + istep
				Loop While i <> i2 + istep
			End If
		End Sub


		'************************************************************************
'        Unpacking of the main and secondary diagonals of bidiagonal decomposition
'        of matrix A.
'
'        Input parameters:
'            B   -   output of RMatrixBD subroutine.
'            M   -   number of rows in matrix B.
'            N   -   number of columns in matrix B.
'
'        Output parameters:
'            IsUpper -   True, if the matrix is upper bidiagonal.
'                        otherwise IsUpper is False.
'            D       -   the main diagonal.
'                        Array whose index ranges within [0..Min(M,N)-1].
'            E       -   the secondary diagonal (upper or lower, depending on
'                        the value of IsUpper).
'                        Array index ranges within [0..Min(M,N)-1], the last
'                        element is not used.
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixbdunpackdiagonals(b As Double(,), m As Integer, n As Integer, ByRef isupper As Boolean, ByRef d As Double(), ByRef e As Double())
			Dim i As Integer = 0

			isupper = New Boolean()
			d = New Double(-1) {}
			e = New Double(-1) {}

			isupper = m >= n
			If m <= 0 OrElse n <= 0 Then
				Return
			End If
			If isupper Then
				d = New Double(n - 1) {}
				e = New Double(n - 1) {}
				For i = 0 To n - 2
					d(i) = b(i, i)
					e(i) = b(i, i + 1)
				Next
				d(n - 1) = b(n - 1, n - 1)
			Else
				d = New Double(m - 1) {}
				e = New Double(m - 1) {}
				For i = 0 To m - 2
					d(i) = b(i, i)
					e(i) = b(i + 1, i)
				Next
				d(m - 1) = b(m - 1, m - 1)
			End If
		End Sub


		'************************************************************************
'        Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
'        where Q is an orthogonal matrix, H - Hessenberg matrix.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix A with elements [0..N-1, 0..N-1]
'            N       -   size of matrix A.
'
'        Output parameters:
'            A       -   matrices Q and P in  compact form (see below).
'            Tau     -   array of scalar factors which are used to form matrix Q.
'                        Array whose index ranges within [0..N-2]
'
'        Matrix H is located on the main diagonal, on the lower secondary  diagonal
'        and above the main diagonal of matrix A. The elements which are used to
'        form matrix Q are situated in array Tau and below the lower secondary
'        diagonal of matrix A as follows:
'
'        Matrix Q is represented as a product of elementary reflections
'
'        Q = H(0)*H(2)*...*H(n-2),
'
'        where each H(i) is given by
'
'        H(i) = 1 - tau * v * (v^T)
'
'        where tau is a scalar stored in Tau[I]; v - is a real vector,
'        so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1992
'        ************************************************************************

		Public Shared Sub rmatrixhessenberg(ByRef a As Double(,), n As Integer, ByRef tau As Double())
			Dim i As Integer = 0
			Dim v As Double = 0
			Dim t As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New Double(-1) {}

			alglib.ap.assert(n >= 0, "RMatrixHessenberg: incorrect N!")

			'
			' Quick return if possible
			'
			If n <= 1 Then
				Return
			End If

			'
			' Allocate place
			'
			tau = New Double(n - 2) {}
			t = New Double(n) {}
			work = New Double(n - 1) {}

			'
			' MKL version
			'
			If ablasmkl.rmatrixhessenbergmkl(a, n, tau) Then
				Return
			End If

			'
			' ALGLIB version
			'
			For i = 0 To n - 2

				'
				' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
				'
				i1_ = (i + 1) - (1)
				For i_ = 1 To n - i - 1
					t(i_) = a(i_ + i1_, i)
				Next
				reflections.generatereflection(t, n - i - 1, v)
				i1_ = (1) - (i + 1)
				For i_ = i + 1 To n - 1
					a(i_, i) = t(i_ + i1_)
				Next
				tau(i) = v
				t(1) = 1

				'
				' Apply H(i) to A(1:ihi,i+1:ihi) from the right
				'
				reflections.applyreflectionfromtheright(a, v, t, 0, n - 1, i + 1, _
					n - 1, work)

				'
				' Apply H(i) to A(i+1:ihi,i+1:n) from the left
				'
				reflections.applyreflectionfromtheleft(a, v, t, i + 1, n - 1, i + 1, _
					n - 1, work)
			Next
		End Sub


		'************************************************************************
'        Unpacking matrix Q which reduces matrix A to upper Hessenberg form
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A   -   output of RMatrixHessenberg subroutine.
'            N   -   size of matrix A.
'            Tau -   scalar factors which are used to form Q.
'                    Output of RMatrixHessenberg subroutine.
'
'        Output parameters:
'            Q   -   matrix Q.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixhessenbergunpackq(a As Double(,), n As Integer, tau As Double(), ByRef q As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New Double(-1, -1) {}

			If n = 0 Then
				Return
			End If

			'
			' init
			'
			q = New Double(n - 1, n - 1) {}
			v = New Double(n - 1) {}
			work = New Double(n - 1) {}
			For i = 0 To n - 1
				For j = 0 To n - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' MKL version
			'
			If ablasmkl.rmatrixhessenbergunpackqmkl(a, n, tau, q) Then
				Return
			End If

			'
			' ALGLIB version: unpack Q
			'
			For i = 0 To n - 2

				'
				' Apply H(i)
				'
				i1_ = (i + 1) - (1)
				For i_ = 1 To n - i - 1
					v(i_) = a(i_ + i1_, i)
				Next
				v(1) = 1
				reflections.applyreflectionfromtheright(q, tau(i), v, 0, n - 1, i + 1, _
					n - 1, work)
			Next
		End Sub


		'************************************************************************
'        Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
'
'        Input parameters:
'            A   -   output of RMatrixHessenberg subroutine.
'            N   -   size of matrix A.
'
'        Output parameters:
'            H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
'
'          -- ALGLIB --
'             2005-2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixhessenbergunpackh(a As Double(,), n As Integer, ByRef h As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			h = New Double(-1, -1) {}

			If n = 0 Then
				Return
			End If
			h = New Double(n - 1, n - 1) {}
			For i = 0 To n - 1
				For j = 0 To i - 2
					h(i, j) = 0
				Next
				j = System.Math.Max(0, i - 1)
				For i_ = j To n - 1
					h(i, i_) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Reduction of a symmetric matrix which is given by its higher or lower
'        triangular part to a tridiagonal matrix using orthogonal similarity
'        transformation: Q'*A*Q=T.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix to be transformed
'                        array with elements [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            IsUpper -   storage format. If IsUpper = True, then matrix A is given
'                        by its upper triangle, and the lower triangle is not used
'                        and not modified by the algorithm, and vice versa
'                        if IsUpper = False.
'
'        Output parameters:
'            A       -   matrices T and Q in  compact form (see lower)
'            Tau     -   array of factors which are forming matrices H(i)
'                        array with elements [0..N-2].
'            D       -   main diagonal of symmetric matrix T.
'                        array with elements [0..N-1].
'            E       -   secondary diagonal of symmetric matrix T.
'                        array with elements [0..N-2].
'
'
'          If IsUpper=True, the matrix Q is represented as a product of elementary
'          reflectors
'
'             Q = H(n-2) . . . H(2) H(0).
'
'          Each H(i) has the form
'
'             H(i) = I - tau * v * v'
'
'          where tau is a real scalar, and v is a real vector with
'          v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'          A(0:i-1,i+1), and tau in TAU(i).
'
'          If IsUpper=False, the matrix Q is represented as a product of elementary
'          reflectors
'
'             Q = H(0) H(2) . . . H(n-2).
'
'          Each H(i) has the form
'
'             H(i) = I - tau * v * v'
'
'          where tau is a real scalar, and v is a real vector with
'          v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'          and tau in TAU(i).
'
'          The contents of A on exit are illustrated by the following examples
'          with n = 5:
'
'          if UPLO = 'U':                       if UPLO = 'L':
'
'            (  d   e   v1  v2  v3 )              (  d                  )
'            (      d   e   v2  v3 )              (  e   d              )
'            (          d   e   v3 )              (  v0  e   d          )
'            (              d   e  )              (  v0  v1  e   d      )
'            (                  d  )              (  v0  v1  v2  e   d  )
'
'          where d and e denote diagonal and off-diagonal elements of T, and vi
'          denotes an element of the vector defining H(i).
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1992
'        ************************************************************************

		Public Shared Sub smatrixtd(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef tau As Double(), ByRef d As Double(), ByRef e As Double())
			Dim i As Integer = 0
			Dim alpha As Double = 0
			Dim taui As Double = 0
			Dim v As Double = 0
			Dim t As Double() = New Double(-1) {}
			Dim t2 As Double() = New Double(-1) {}
			Dim t3 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New Double(-1) {}
			d = New Double(-1) {}
			e = New Double(-1) {}

			If n <= 0 Then
				Return
			End If
			t = New Double(n) {}
			t2 = New Double(n) {}
			t3 = New Double(n) {}
			If n > 1 Then
				tau = New Double(n - 2) {}
			End If
			d = New Double(n - 1) {}
			If n > 1 Then
				e = New Double(n - 2) {}
			End If

			'
			' Try to use MKL
			'
			If ablasmkl.smatrixtdmkl(a, n, isupper, tau, d, e) Then
				Return
			End If

			'
			' ALGLIB version
			'
			If isupper Then

				'
				' Reduce the upper triangle of A
				'
				For i = n - 2 To 0 Step -1

					'
					' Generate elementary reflector H() = E - tau * v * v'
					'
					If i >= 1 Then
						i1_ = (0) - (2)
						For i_ = 2 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
					End If
					t(1) = a(i, i + 1)
					reflections.generatereflection(t, i + 1, taui)
					If i >= 1 Then
						i1_ = (2) - (0)
						For i_ = 0 To i - 1
							a(i_, i + 1) = t(i_ + i1_)
						Next
					End If
					a(i, i + 1) = t(1)
					e(i) = a(i, i + 1)
					If CDbl(taui) <> CDbl(0) Then

						'
						' Apply H from both sides to A
						'
						a(i, i + 1) = 1

						'
						' Compute  x := tau * A * v  storing x in TAU
						'
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
						sblas.symmetricmatrixvectormultiply(a, isupper, 0, i, t, taui, _
							t3)
						i1_ = (1) - (0)
						For i_ = 0 To i
							tau(i_) = t3(i_ + i1_)
						Next

						'
						' Compute  w := x - 1/2 * tau * (x'*v) * v
						'
						v = 0.0
						For i_ = 0 To i
							v += tau(i_) * a(i_, i + 1)
						Next
						alpha = -(0.5 * taui * v)
						For i_ = 0 To i
							tau(i_) = tau(i_) + alpha * a(i_, i + 1)
						Next

						'
						' Apply the transformation as a rank-2 update:
						'    A := A - v * w' - w * v'
						'
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t3(i_) = tau(i_ + i1_)
						Next
						sblas.symmetricrank2update(a, isupper, 0, i, t, t3, _
							t2, -1)
						a(i, i + 1) = e(i)
					End If
					d(i + 1) = a(i + 1, i + 1)
					tau(i) = taui
				Next
				d(0) = a(0, 0)
			Else

				'
				' Reduce the lower triangle of A
				'
				For i = 0 To n - 2

					'
					' Generate elementary reflector H = E - tau * v * v'
					'
					i1_ = (i + 1) - (1)
					For i_ = 1 To n - i - 1
						t(i_) = a(i_ + i1_, i)
					Next
					reflections.generatereflection(t, n - i - 1, taui)
					i1_ = (1) - (i + 1)
					For i_ = i + 1 To n - 1
						a(i_, i) = t(i_ + i1_)
					Next
					e(i) = a(i + 1, i)
					If CDbl(taui) <> CDbl(0) Then

						'
						' Apply H from both sides to A
						'
						a(i + 1, i) = 1

						'
						' Compute  x := tau * A * v  storing y in TAU
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - i - 1
							t(i_) = a(i_ + i1_, i)
						Next
						sblas.symmetricmatrixvectormultiply(a, isupper, i + 1, n - 1, t, taui, _
							t2)
						i1_ = (1) - (i)
						For i_ = i To n - 2
							tau(i_) = t2(i_ + i1_)
						Next

						'
						' Compute  w := x - 1/2 * tau * (x'*v) * v
						'
						i1_ = (i + 1) - (i)
						v = 0.0
						For i_ = i To n - 2
							v += tau(i_) * a(i_ + i1_, i)
						Next
						alpha = -(0.5 * taui * v)
						i1_ = (i + 1) - (i)
						For i_ = i To n - 2
							tau(i_) = tau(i_) + alpha * a(i_ + i1_, i)
						Next

						'
						' Apply the transformation as a rank-2 update:
						'     A := A - v * w' - w * v'
						'
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - i - 1
							t(i_) = a(i_ + i1_, i)
						Next
						i1_ = (i) - (1)
						For i_ = 1 To n - i - 1
							t2(i_) = tau(i_ + i1_)
						Next
						sblas.symmetricrank2update(a, isupper, i + 1, n - 1, t, t2, _
							t3, -1)
						a(i + 1, i) = e(i)
					End If
					d(i) = a(i, i)
					tau(i) = taui
				Next
				d(n - 1) = a(n - 1, n - 1)
			End If
		End Sub


		'************************************************************************
'        Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
'        form.
'
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   the result of a SMatrixTD subroutine
'            N       -   size of matrix A.
'            IsUpper -   storage format (a parameter of SMatrixTD subroutine)
'            Tau     -   the result of a SMatrixTD subroutine
'
'        Output parameters:
'            Q       -   transformation matrix.
'                        array with elements [0..N-1, 0..N-1].
'
'          -- ALGLIB --
'             Copyright 2005-2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub smatrixtdunpackq(a As Double(,), n As Integer, isupper As Boolean, tau As Double(), ByRef q As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New Double(-1, -1) {}

			If n = 0 Then
				Return
			End If

			'
			' init
			'
			q = New Double(n - 1, n - 1) {}
			v = New Double(n) {}
			work = New Double(n - 1) {}
			For i = 0 To n - 1
				For j = 0 To n - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next

			'
			' MKL version
			'
			If ablasmkl.smatrixtdunpackqmkl(a, n, isupper, tau, q) Then
				Return
			End If

			'
			' ALGLIB version: unpack Q
			'
			If isupper Then
				For i = 0 To n - 2

					'
					' Apply H(i)
					'
					i1_ = (0) - (1)
					For i_ = 1 To i + 1
						v(i_) = a(i_ + i1_, i + 1)
					Next
					v(i + 1) = 1
					reflections.applyreflectionfromtheleft(q, tau(i), v, 0, i, 0, _
						n - 1, work)
				Next
			Else
				For i = n - 2 To 0 Step -1

					'
					' Apply H(i)
					'
					i1_ = (i + 1) - (1)
					For i_ = 1 To n - i - 1
						v(i_) = a(i_ + i1_, i)
					Next
					v(1) = 1
					reflections.applyreflectionfromtheleft(q, tau(i), v, i + 1, n - 1, 0, _
						n - 1, work)
				Next
			End If
		End Sub


		'************************************************************************
'        Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
'        triangular part to a real  tridiagonal  matrix  using  unitary  similarity
'        transformation: Q'*A*Q = T.
'
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix to be transformed
'                        array with elements [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            IsUpper -   storage format. If IsUpper = True, then matrix A is  given
'                        by its upper triangle, and the lower triangle is not  used
'                        and not modified by the algorithm, and vice versa
'                        if IsUpper = False.
'
'        Output parameters:
'            A       -   matrices T and Q in  compact form (see lower)
'            Tau     -   array of factors which are forming matrices H(i)
'                        array with elements [0..N-2].
'            D       -   main diagonal of real symmetric matrix T.
'                        array with elements [0..N-1].
'            E       -   secondary diagonal of real symmetric matrix T.
'                        array with elements [0..N-2].
'
'
'          If IsUpper=True, the matrix Q is represented as a product of elementary
'          reflectors
'
'             Q = H(n-2) . . . H(2) H(0).
'
'          Each H(i) has the form
'
'             H(i) = I - tau * v * v'
'
'          where tau is a complex scalar, and v is a complex vector with
'          v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'          A(0:i-1,i+1), and tau in TAU(i).
'
'          If IsUpper=False, the matrix Q is represented as a product of elementary
'          reflectors
'
'             Q = H(0) H(2) . . . H(n-2).
'
'          Each H(i) has the form
'
'             H(i) = I - tau * v * v'
'
'          where tau is a complex scalar, and v is a complex vector with
'          v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'          and tau in TAU(i).
'
'          The contents of A on exit are illustrated by the following examples
'          with n = 5:
'
'          if UPLO = 'U':                       if UPLO = 'L':
'
'            (  d   e   v1  v2  v3 )              (  d                  )
'            (      d   e   v2  v3 )              (  e   d              )
'            (          d   e   v3 )              (  v0  e   d          )
'            (              d   e  )              (  v0  v1  e   d      )
'            (                  d  )              (  v0  v1  v2  e   d  )
'
'        where d and e denote diagonal and off-diagonal elements of T, and vi
'        denotes an element of the vector defining H(i).
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1992
'        ************************************************************************

		Public Shared Sub hmatrixtd(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef tau As complex(), ByRef d As Double(), ByRef e As Double())
			Dim i As Integer = 0
			Dim alpha As complex = 0
			Dim taui As complex = 0
			Dim v As complex = 0
			Dim t As complex() = New complex(-1) {}
			Dim t2 As complex() = New complex(-1) {}
			Dim t3 As complex() = New complex(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			tau = New complex(-1) {}
			d = New Double(-1) {}
			e = New Double(-1) {}


			'
			' Init and test
			'
			If n <= 0 Then
				Return
			End If
			For i = 0 To n - 1
				alglib.ap.assert(CDbl(a(i, i).y) = CDbl(0))
			Next
			If n > 1 Then
				tau = New complex(n - 2) {}
				e = New Double(n - 2) {}
			End If
			d = New Double(n - 1) {}
			t = New complex(n - 1) {}
			t2 = New complex(n - 1) {}
			t3 = New complex(n - 1) {}

			'
			' MKL version
			'
			If ablasmkl.hmatrixtdmkl(a, n, isupper, tau, d, e) Then
				Return
			End If

			'
			' ALGLIB version
			'
			If isupper Then

				'
				' Reduce the upper triangle of A
				'
				a(n - 1, n - 1) = a(n - 1, n - 1).x
				For i = n - 2 To 0 Step -1

					'
					' Generate elementary reflector H = I+1 - tau * v * v'
					'
					alpha = a(i, i + 1)
					t(1) = alpha
					If i >= 1 Then
						i1_ = (0) - (2)
						For i_ = 2 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
					End If
					creflections.complexgeneratereflection(t, i + 1, taui)
					If i >= 1 Then
						i1_ = (2) - (0)
						For i_ = 0 To i - 1
							a(i_, i + 1) = t(i_ + i1_)
						Next
					End If
					alpha = t(1)
					e(i) = alpha.x
					If taui <> 0 Then

						'
						' Apply H(I+1) from both sides to A
						'
						a(i, i + 1) = 1

						'
						' Compute  x := tau * A * v  storing x in TAU
						'
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
						hblas.hermitianmatrixvectormultiply(a, isupper, 0, i, t, taui, _
							t2)
						i1_ = (1) - (0)
						For i_ = 0 To i
							tau(i_) = t2(i_ + i1_)
						Next

						'
						' Compute  w := x - 1/2 * tau * (x'*v) * v
						'
						v = 0.0
						For i_ = 0 To i
							v += Math.conj(tau(i_)) * a(i_, i + 1)
						Next
						alpha = -(0.5 * taui * v)
						For i_ = 0 To i
							tau(i_) = tau(i_) + alpha * a(i_, i + 1)
						Next

						'
						' Apply the transformation as a rank-2 update:
						'    A := A - v * w' - w * v'
						'
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t(i_) = a(i_ + i1_, i + 1)
						Next
						i1_ = (0) - (1)
						For i_ = 1 To i + 1
							t3(i_) = tau(i_ + i1_)
						Next
						hblas.hermitianrank2update(a, isupper, 0, i, t, t3, _
							t2, -1)
					Else
						a(i, i) = a(i, i).x
					End If
					a(i, i + 1) = e(i)
					d(i + 1) = a(i + 1, i + 1).x
					tau(i) = taui
				Next
				d(0) = a(0, 0).x
			Else

				'
				' Reduce the lower triangle of A
				'
				a(0, 0) = a(0, 0).x
				For i = 0 To n - 2

					'
					' Generate elementary reflector H = I - tau * v * v'
					'
					i1_ = (i + 1) - (1)
					For i_ = 1 To n - i - 1
						t(i_) = a(i_ + i1_, i)
					Next
					creflections.complexgeneratereflection(t, n - i - 1, taui)
					i1_ = (1) - (i + 1)
					For i_ = i + 1 To n - 1
						a(i_, i) = t(i_ + i1_)
					Next
					e(i) = a(i + 1, i).x
					If taui <> 0 Then

						'
						' Apply H(i) from both sides to A(i+1:n,i+1:n)
						'
						a(i + 1, i) = 1

						'
						' Compute  x := tau * A * v  storing y in TAU
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - i - 1
							t(i_) = a(i_ + i1_, i)
						Next
						hblas.hermitianmatrixvectormultiply(a, isupper, i + 1, n - 1, t, taui, _
							t2)
						i1_ = (1) - (i)
						For i_ = i To n - 2
							tau(i_) = t2(i_ + i1_)
						Next

						'
						' Compute  w := x - 1/2 * tau * (x'*v) * v
						'
						i1_ = (i + 1) - (i)
						v = 0.0
						For i_ = i To n - 2
							v += Math.conj(tau(i_)) * a(i_ + i1_, i)
						Next
						alpha = -(0.5 * taui * v)
						i1_ = (i + 1) - (i)
						For i_ = i To n - 2
							tau(i_) = tau(i_) + alpha * a(i_ + i1_, i)
						Next

						'
						' Apply the transformation as a rank-2 update:
						' A := A - v * w' - w * v'
						'
						i1_ = (i + 1) - (1)
						For i_ = 1 To n - i - 1
							t(i_) = a(i_ + i1_, i)
						Next
						i1_ = (i) - (1)
						For i_ = 1 To n - i - 1
							t2(i_) = tau(i_ + i1_)
						Next
						hblas.hermitianrank2update(a, isupper, i + 1, n - 1, t, t2, _
							t3, -1)
					Else
						a(i + 1, i + 1) = a(i + 1, i + 1).x
					End If
					a(i + 1, i) = e(i)
					d(i) = a(i, i).x
					tau(i) = taui
				Next
				d(n - 1) = a(n - 1, n - 1).x
			End If
		End Sub


		'************************************************************************
'        Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
'        form.
'
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   the result of a HMatrixTD subroutine
'            N       -   size of matrix A.
'            IsUpper -   storage format (a parameter of HMatrixTD subroutine)
'            Tau     -   the result of a HMatrixTD subroutine
'
'        Output parameters:
'            Q       -   transformation matrix.
'                        array with elements [0..N-1, 0..N-1].
'
'          -- ALGLIB --
'             Copyright 2005-2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub hmatrixtdunpackq(a As complex(,), n As Integer, isupper As Boolean, tau As complex(), ByRef q As complex(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As complex() = New complex(-1) {}
			Dim work As complex() = New complex(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			q = New complex(-1, -1) {}

			If n = 0 Then
				Return
			End If

			'
			' init
			'
			q = New complex(n - 1, n - 1) {}
			v = New complex(n) {}
			work = New complex(n - 1) {}

			'
			' MKL version
			'
			If ablasmkl.hmatrixtdunpackqmkl(a, n, isupper, tau, q) Then
				Return
			End If

			'
			' ALGLIB version
			'
			For i = 0 To n - 1
				For j = 0 To n - 1
					If i = j Then
						q(i, j) = 1
					Else
						q(i, j) = 0
					End If
				Next
			Next
			If isupper Then
				For i = 0 To n - 2

					'
					' Apply H(i)
					'
					i1_ = (0) - (1)
					For i_ = 1 To i + 1
						v(i_) = a(i_ + i1_, i + 1)
					Next
					v(i + 1) = 1
					creflections.complexapplyreflectionfromtheleft(q, tau(i), v, 0, i, 0, _
						n - 1, work)
				Next
			Else
				For i = n - 2 To 0 Step -1

					'
					' Apply H(i)
					'
					i1_ = (i + 1) - (1)
					For i_ = 1 To n - i - 1
						v(i_) = a(i_ + i1_, i)
					Next
					v(1) = 1
					creflections.complexapplyreflectionfromtheleft(q, tau(i), v, i + 1, n - 1, 0, _
						n - 1, work)
				Next
			End If
		End Sub


		'************************************************************************
'        Base case for complex QR
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994.
'             Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'             pseudocode, 2007-2010.
'        ************************************************************************

		Private Shared Sub cmatrixqrbasecase(ByRef a As complex(,), m As Integer, n As Integer, ByRef work As complex(), ByRef t As complex(), ByRef tau As complex())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim mmi As Integer = 0
			Dim minmn As Integer = 0
			Dim tmp As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			minmn = System.Math.Min(m, n)
			If minmn <= 0 Then
				Return
			End If

			'
			' Test the input arguments
			'
			k = System.Math.Min(m, n)
			For i = 0 To k - 1

				'
				' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
				'
				mmi = m - i
				i1_ = (i) - (1)
				For i_ = 1 To mmi
					t(i_) = a(i_ + i1_, i)
				Next
				creflections.complexgeneratereflection(t, mmi, tmp)
				tau(i) = tmp
				i1_ = (1) - (i)
				For i_ = i To m - 1
					a(i_, i) = t(i_ + i1_)
				Next
				t(1) = 1
				If i < n - 1 Then

					'
					' Apply H'(i) to A(i:m,i+1:n) from the left
					'
					creflections.complexapplyreflectionfromtheleft(a, Math.conj(tau(i)), t, i, m - 1, i + 1, _
						n - 1, work)
				End If
			Next
		End Sub


		'************************************************************************
'        Base case for complex LQ
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994.
'             Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'             pseudocode, 2007-2010.
'        ************************************************************************

		Private Shared Sub cmatrixlqbasecase(ByRef a As complex(,), m As Integer, n As Integer, ByRef work As complex(), ByRef t As complex(), ByRef tau As complex())
			Dim i As Integer = 0
			Dim minmn As Integer = 0
			Dim tmp As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			minmn = System.Math.Min(m, n)
			If minmn <= 0 Then
				Return
			End If

			'
			' Test the input arguments
			'
			For i = 0 To minmn - 1

				'
				' Generate elementary reflector H(i)
				'
				' NOTE: ComplexGenerateReflection() generates left reflector,
				' i.e. H which reduces x by applyiong from the left, but we
				' need RIGHT reflector. So we replace H=E-tau*v*v' by H^H,
				' which changes v to conj(v).
				'
				i1_ = (i) - (1)
				For i_ = 1 To n - i
					t(i_) = Math.conj(a(i, i_ + i1_))
				Next
				creflections.complexgeneratereflection(t, n - i, tmp)
				tau(i) = tmp
				i1_ = (1) - (i)
				For i_ = i To n - 1
					a(i, i_) = Math.conj(t(i_ + i1_))
				Next
				t(1) = 1
				If i < m - 1 Then

					'
					' Apply H'(i)
					'
					creflections.complexapplyreflectionfromtheright(a, tau(i), t, i + 1, m - 1, i, _
						n - 1, work)
				End If
			Next
		End Sub


		'************************************************************************
'        Generate block reflector:
'        * fill unused parts of reflectors matrix by zeros
'        * fill diagonal of reflectors matrix by ones
'        * generate triangular factor T
'
'        PARAMETERS:
'            A           -   either LengthA*BlockSize (if ColumnwiseA) or
'                            BlockSize*LengthA (if not ColumnwiseA) matrix of
'                            elementary reflectors.
'                            Modified on exit.
'            Tau         -   scalar factors
'            ColumnwiseA -   reflectors are stored in rows or in columns
'            LengthA     -   length of largest reflector
'            BlockSize   -   number of reflectors
'            T           -   array[BlockSize,2*BlockSize]. Left BlockSize*BlockSize
'                            submatrix stores triangular factor on exit.
'            WORK        -   array[BlockSize]
'            
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rmatrixblockreflector(ByRef a As Double(,), ByRef tau As Double(), columnwisea As Boolean, lengtha As Integer, blocksize As Integer, ByRef t As Double(,), _
			ByRef work As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' fill beginning of new column with zeros,
			' load 1.0 in the first non-zero element
			'
			For k = 0 To blocksize - 1
				If columnwisea Then
					For i = 0 To k - 1
						a(i, k) = 0
					Next
				Else
					For i = 0 To k - 1
						a(k, i) = 0
					Next
				End If
				a(k, k) = 1
			Next

			'
			' Calculate Gram matrix of A
			'
			For i = 0 To blocksize - 1
				For j = 0 To blocksize - 1
					t(i, blocksize + j) = 0
				Next
			Next
			For k = 0 To lengtha - 1
				For j = 1 To blocksize - 1
					If columnwisea Then
						v = a(k, j)
						If CDbl(v) <> CDbl(0) Then
							i1_ = (0) - (blocksize)
							For i_ = blocksize To blocksize + j - 1
								t(j, i_) = t(j, i_) + v * a(k, i_ + i1_)
							Next
						End If
					Else
						v = a(j, k)
						If CDbl(v) <> CDbl(0) Then
							i1_ = (0) - (blocksize)
							For i_ = blocksize To blocksize + j - 1
								t(j, i_) = t(j, i_) + v * a(i_ + i1_, k)
							Next
						End If
					End If
				Next
			Next

			'
			' Prepare Y (stored in TmpA) and T (stored in TmpT)
			'
			For k = 0 To blocksize - 1

				'
				' fill non-zero part of T, use pre-calculated Gram matrix
				'
				i1_ = (blocksize) - (0)
				For i_ = 0 To k - 1
					work(i_) = t(k, i_ + i1_)
				Next
				For i = 0 To k - 1
					v = 0.0
					For i_ = i To k - 1
						v += t(i, i_) * work(i_)
					Next
					t(i, k) = -(tau(k) * v)
				Next
				t(k, k) = -tau(k)

				'
				' Rest of T is filled by zeros
				'
				For i = k + 1 To blocksize - 1
					t(i, k) = 0
				Next
			Next
		End Sub


		'************************************************************************
'        Generate block reflector (complex):
'        * fill unused parts of reflectors matrix by zeros
'        * fill diagonal of reflectors matrix by ones
'        * generate triangular factor T
'
'
'          -- ALGLIB routine --
'             17.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub cmatrixblockreflector(ByRef a As complex(,), ByRef tau As complex(), columnwisea As Boolean, lengtha As Integer, blocksize As Integer, ByRef t As complex(,), _
			ByRef work As complex())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim v As complex = 0
			Dim i_ As Integer = 0


			'
			' Prepare Y (stored in TmpA) and T (stored in TmpT)
			'
			For k = 0 To blocksize - 1

				'
				' fill beginning of new column with zeros,
				' load 1.0 in the first non-zero element
				'
				If columnwisea Then
					For i = 0 To k - 1
						a(i, k) = 0
					Next
				Else
					For i = 0 To k - 1
						a(k, i) = 0
					Next
				End If
				a(k, k) = 1

				'
				' fill non-zero part of T,
				'
				For i = 0 To k - 1
					If columnwisea Then
						v = 0.0
						For i_ = k To lengtha - 1
							v += Math.conj(a(i_, i)) * a(i_, k)
						Next
					Else
						v = 0.0
						For i_ = k To lengtha - 1
							v += a(i, i_) * Math.conj(a(k, i_))
						Next
					End If
					work(i) = v
				Next
				For i = 0 To k - 1
					v = 0.0
					For i_ = i To k - 1
						v += t(i, i_) * work(i_)
					Next
					t(i, k) = -(tau(k) * v)
				Next
				t(k, k) = -tau(k)

				'
				' Rest of T is filled by zeros
				'
				For i = k + 1 To blocksize - 1
					t(i, k) = 0
				Next
			Next
		End Sub


	End Class
	Public Class bdsvd
		'************************************************************************
'        Singular value decomposition of a bidiagonal matrix (extended algorithm)
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        The algorithm performs the singular value decomposition  of  a  bidiagonal
'        matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
'        orthogonal matrices, S - diagonal matrix with non-negative elements on the
'        main diagonal, in descending order.
'
'        The  algorithm  finds  singular  values.  In  addition,  the algorithm can
'        calculate  matrices  Q  and P (more precisely, not the matrices, but their
'        product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
'        matrices U and VT can be of any type, including identity. Furthermore, the
'        algorithm can calculate Q'*C (this product is calculated more  effectively
'        than U*Q,  because  this calculation operates with rows instead  of matrix
'        columns).
'
'        The feature of the algorithm is its ability to find  all  singular  values
'        including those which are arbitrarily close to 0  with  relative  accuracy
'        close to  machine precision. If the parameter IsFractionalAccuracyRequired
'        is set to True, all singular values will have high relative accuracy close
'        to machine precision. If the parameter is set to False, only  the  biggest
'        singular value will have relative accuracy  close  to  machine  precision.
'        The absolute error of other singular values is equal to the absolute error
'        of the biggest singular value.
'
'        Input parameters:
'            D       -   main diagonal of matrix B.
'                        Array whose index ranges within [0..N-1].
'            E       -   superdiagonal (or subdiagonal) of matrix B.
'                        Array whose index ranges within [0..N-2].
'            N       -   size of matrix B.
'            IsUpper -   True, if the matrix is upper bidiagonal.
'            IsFractionalAccuracyRequired -
'                        THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0
'                        SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.
'            U       -   matrix to be multiplied by Q.
'                        Array whose indexes range within [0..NRU-1, 0..N-1].
'                        The matrix can be bigger, in that case only the  submatrix
'                        [0..NRU-1, 0..N-1] will be multiplied by Q.
'            NRU     -   number of rows in matrix U.
'            C       -   matrix to be multiplied by Q'.
'                        Array whose indexes range within [0..N-1, 0..NCC-1].
'                        The matrix can be bigger, in that case only the  submatrix
'                        [0..N-1, 0..NCC-1] will be multiplied by Q'.
'            NCC     -   number of columns in matrix C.
'            VT      -   matrix to be multiplied by P^T.
'                        Array whose indexes range within [0..N-1, 0..NCVT-1].
'                        The matrix can be bigger, in that case only the  submatrix
'                        [0..N-1, 0..NCVT-1] will be multiplied by P^T.
'            NCVT    -   number of columns in matrix VT.
'
'        Output parameters:
'            D       -   singular values of matrix B in descending order.
'            U       -   if NRU>0, contains matrix U*Q.
'            VT      -   if NCVT>0, contains matrix (P^T)*VT.
'            C       -   if NCC>0, contains matrix Q'*C.
'
'        Result:
'            True, if the algorithm has converged.
'            False, if the algorithm hasn't converged (rare case).
'            
'        NOTE: multiplication U*Q is performed by means of transposition to internal
'              buffer, multiplication and backward transposition. It helps to avoid
'              costly columnwise operations and speed-up algorithm.
'
'        Additional information:
'            The type of convergence is controlled by the internal  parameter  TOL.
'            If the parameter is greater than 0, the singular values will have
'            relative accuracy TOL. If TOL<0, the singular values will have
'            absolute accuracy ABS(TOL)*norm(B).
'            By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
'            where Epsilon is the machine precision. It is not  recommended  to  use
'            TOL less than 10*Epsilon since this will  considerably  slow  down  the
'            algorithm and may not lead to error decreasing.
'            
'        History:
'            * 31 March, 2007.
'                changed MAXITR from 6 to 12.
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1999.
'        ************************************************************************

		Public Shared Function rmatrixbdsvd(ByRef d As Double(), e As Double(), n As Integer, isupper As Boolean, isfractionalaccuracyrequired As Boolean, ByRef u As Double(,), _
			nru As Integer, ByRef c As Double(,), ncc As Integer, ByRef vt As Double(,), ncvt As Integer) As Boolean
			Dim result As New Boolean()
			Dim i As Integer = 0
			Dim en As Double() = New Double(-1) {}
			Dim d1 As Double() = New Double(-1) {}
			Dim e1 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			e = DirectCast(e.Clone(), Double())

			result = False

			'
			' Try to use MKL
			'
			en = New Double(n - 1) {}
			For i = 0 To n - 2
				en(i) = e(i)
			Next
			en(n - 1) = 0.0
			If ablasmkl.rmatrixbdsvdmkl(d, en, n, isupper, u, nru, _
				c, ncc, vt, ncvt, result) Then
				Return result
			End If

			'
			' Use ALGLIB code
			'
			d1 = New Double(n) {}
			i1_ = (0) - (1)
			For i_ = 1 To n
				d1(i_) = d(i_ + i1_)
			Next
			If n > 1 Then
				e1 = New Double(n - 1) {}
				i1_ = (0) - (1)
				For i_ = 1 To n - 1
					e1(i_) = e(i_ + i1_)
				Next
			End If
			result = bidiagonalsvddecompositioninternal(d1, e1, n, isupper, isfractionalaccuracyrequired, u, _
				0, nru, c, 0, ncc, vt, _
				0, ncvt)
			i1_ = (1) - (0)
			For i_ = 0 To n - 1
				d(i_) = d1(i_ + i1_)
			Next
			Return result
		End Function


		Public Shared Function bidiagonalsvddecomposition(ByRef d As Double(), e As Double(), n As Integer, isupper As Boolean, isfractionalaccuracyrequired As Boolean, ByRef u As Double(,), _
			nru As Integer, ByRef c As Double(,), ncc As Integer, ByRef vt As Double(,), ncvt As Integer) As Boolean
			Dim result As New Boolean()

			e = DirectCast(e.Clone(), Double())

			result = bidiagonalsvddecompositioninternal(d, e, n, isupper, isfractionalaccuracyrequired, u, _
				1, nru, c, 1, ncc, vt, _
				1, ncvt)
			Return result
		End Function


		'************************************************************************
'        Internal working subroutine for bidiagonal decomposition
'        ************************************************************************

		Private Shared Function bidiagonalsvddecompositioninternal(d As Double(), e As Double(), n As Integer, isupper As Boolean, isfractionalaccuracyrequired As Boolean, uu As Double(,), _
			ustart As Integer, nru As Integer, c As Double(,), cstart As Integer, ncc As Integer, vt As Double(,), _
			vstart As Integer, ncvt As Integer) As Boolean
			Dim result As New Boolean()
			Dim i As Integer = 0
			Dim idir As Integer = 0
			Dim isub As Integer = 0
			Dim iter As Integer = 0
			Dim j As Integer = 0
			Dim ll As Integer = 0
			Dim lll As Integer = 0
			Dim m As Integer = 0
			Dim maxit As Integer = 0
			Dim oldll As Integer = 0
			Dim oldm As Integer = 0
			Dim abse As Double = 0
			Dim abss As Double = 0
			Dim cosl As Double = 0
			Dim cosr As Double = 0
			Dim cs As Double = 0
			Dim eps As Double = 0
			Dim f As Double = 0
			Dim g As Double = 0
			Dim h As Double = 0
			Dim mu As Double = 0
			Dim oldcs As Double = 0
			Dim oldsn As Double = 0
			Dim r As Double = 0
			Dim shift As Double = 0
			Dim sigmn As Double = 0
			Dim sigmx As Double = 0
			Dim sinl As Double = 0
			Dim sinr As Double = 0
			Dim sll As Double = 0
			Dim smax As Double = 0
			Dim smin As Double = 0
			Dim sminl As Double = 0
			Dim sminoa As Double = 0
			Dim sn As Double = 0
			Dim thresh As Double = 0
			Dim tol As Double = 0
			Dim tolmul As Double = 0
			Dim unfl As Double = 0
			Dim work0 As Double() = New Double(-1) {}
			Dim work1 As Double() = New Double(-1) {}
			Dim work2 As Double() = New Double(-1) {}
			Dim work3 As Double() = New Double(-1) {}
			Dim maxitr As Integer = 0
			Dim matrixsplitflag As New Boolean()
			Dim iterflag As New Boolean()
			Dim utemp As Double() = New Double(-1) {}
			Dim vttemp As Double() = New Double(-1) {}
			Dim ctemp As Double() = New Double(-1) {}
			Dim etemp As Double() = New Double(-1) {}
			Dim ut As Double(,) = New Double(-1, -1) {}
			Dim fwddir As New Boolean()
			Dim tmp As Double = 0
			Dim mm1 As Integer = 0
			Dim mm0 As Integer = 0
			Dim bchangedir As New Boolean()
			Dim uend As Integer = 0
			Dim cend As Integer = 0
			Dim vend As Integer = 0
			Dim i_ As Integer = 0

			e = DirectCast(e.Clone(), Double())

			result = True
			If n = 0 Then
				Return result
			End If
			If n = 1 Then
				If CDbl(d(1)) < CDbl(0) Then
					d(1) = -d(1)
					If ncvt > 0 Then
						For i_ = vstart To vstart + ncvt - 1
							vt(vstart, i_) = -1 * vt(vstart, i_)
						Next
					End If
				End If
				Return result
			End If

			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			ll = 0
			oldsn = 0

			'
			' init
			'
			work0 = New Double(n - 1) {}
			work1 = New Double(n - 1) {}
			work2 = New Double(n - 1) {}
			work3 = New Double(n - 1) {}
			uend = ustart + System.Math.Max(nru - 1, 0)
			vend = vstart + System.Math.Max(ncvt - 1, 0)
			cend = cstart + System.Math.Max(ncc - 1, 0)
			utemp = New Double(uend) {}
			vttemp = New Double(vend) {}
			ctemp = New Double(cend) {}
			maxitr = 12
			fwddir = True
			If nru > 0 Then
				ut = New Double(ustart + (n - 1), ustart + (nru - 1)) {}
				ablas.rmatrixtranspose(nru, n, uu, ustart, ustart, ut, _
					ustart, ustart)
			End If

			'
			' resize E from N-1 to N
			'
			etemp = New Double(n) {}
			For i = 1 To n - 1
				etemp(i) = e(i)
			Next
			e = New Double(n) {}
			For i = 1 To n - 1
				e(i) = etemp(i)
			Next
			e(n) = 0
			idir = 0

			'
			' Get machine constants
			'
			eps = Math.machineepsilon
			unfl = Math.minrealnumber

			'
			' If matrix lower bidiagonal, rotate to be upper bidiagonal
			' by applying Givens rotations on the left
			'
			If Not isupper Then
				For i = 1 To n - 1
					rotations.generaterotation(d(i), e(i), cs, sn, r)
					d(i) = r
					e(i) = sn * d(i + 1)
					d(i + 1) = cs * d(i + 1)
					work0(i) = cs
					work1(i) = sn
				Next

				'
				' Update singular vectors if desired
				'
				If nru > 0 Then
					rotations.applyrotationsfromtheleft(fwddir, 1 + ustart - 1, n + ustart - 1, ustart, uend, work0, _
						work1, ut, utemp)
				End If
				If ncc > 0 Then
					rotations.applyrotationsfromtheleft(fwddir, 1 + cstart - 1, n + cstart - 1, cstart, cend, work0, _
						work1, c, ctemp)
				End If
			End If

			'
			' Compute singular values to relative accuracy TOL
			' (By setting TOL to be negative, algorithm will compute
			' singular values to absolute accuracy ABS(TOL)*norm(input matrix))
			'
			tolmul = System.Math.Max(10, System.Math.Min(100, System.Math.Pow(eps, -0.125)))
			tol = tolmul * eps

			'
			' Compute approximate maximum, minimum singular values
			'
			smax = 0
			For i = 1 To n
				smax = System.Math.Max(smax, System.Math.Abs(d(i)))
			Next
			For i = 1 To n - 1
				smax = System.Math.Max(smax, System.Math.Abs(e(i)))
			Next
			sminl = 0
			If CDbl(tol) >= CDbl(0) Then

				'
				' Relative accuracy desired
				'
				sminoa = System.Math.Abs(d(1))
				If CDbl(sminoa) <> CDbl(0) Then
					mu = sminoa
					For i = 2 To n
						mu = System.Math.Abs(d(i)) * (mu / (mu + System.Math.Abs(e(i - 1))))
						sminoa = System.Math.Min(sminoa, mu)
						If CDbl(sminoa) = CDbl(0) Then
							Exit For
						End If
					Next
				End If
				sminoa = sminoa / System.Math.sqrt(n)
				thresh = System.Math.Max(tol * sminoa, maxitr * n * n * unfl)
			Else

				'
				' Absolute accuracy desired
				'
				thresh = System.Math.Max(System.Math.Abs(tol) * smax, maxitr * n * n * unfl)
			End If

			'
			' Prepare for main iteration loop for the singular values
			' (MAXIT is the maximum number of passes through the inner
			' loop permitted before nonconvergence signalled.)
			'
			maxit = maxitr * n * n
			iter = 0
			oldll = -1
			oldm = -1

			'
			' M points to last element of unconverged part of matrix
			'
			m = n

			'
			' Begin main iteration loop
			'
			While True

				'
				' Check for convergence or exceeding iteration count
				'
				If m <= 1 Then
					Exit While
				End If
				If iter > maxit Then
					result = False
					Return result
				End If

				'
				' Find diagonal block of matrix to work on
				'
				If CDbl(tol) < CDbl(0) AndAlso CDbl(System.Math.Abs(d(m))) <= CDbl(thresh) Then
					d(m) = 0
				End If
				smax = System.Math.Abs(d(m))
				smin = smax
				matrixsplitflag = False
				For lll = 1 To m - 1
					ll = m - lll
					abss = System.Math.Abs(d(ll))
					abse = System.Math.Abs(e(ll))
					If CDbl(tol) < CDbl(0) AndAlso CDbl(abss) <= CDbl(thresh) Then
						d(ll) = 0
					End If
					If CDbl(abse) <= CDbl(thresh) Then
						matrixsplitflag = True
						Exit For
					End If
					smin = System.Math.Min(smin, abss)
					smax = System.Math.Max(smax, System.Math.Max(abss, abse))
				Next
				If Not matrixsplitflag Then
					ll = 0
				Else

					'
					' Matrix splits since E(LL) = 0
					'
					e(ll) = 0
					If ll = m - 1 Then

						'
						' Convergence of bottom singular value, return to top of loop
						'
						m = m - 1
						Continue While
					End If
				End If
				ll = ll + 1

				'
				' E(LL) through E(M-1) are nonzero, E(LL-1) is zero
				'
				If ll = m - 1 Then

					'
					' 2 by 2 block, handle separately
					'
					svdv2x2(d(m - 1), e(m - 1), d(m), sigmn, sigmx, sinr, _
						cosr, sinl, cosl)
					d(m - 1) = sigmx
					e(m - 1) = 0
					d(m) = sigmn

					'
					' Compute singular vectors, if desired
					'
					If ncvt > 0 Then
						mm0 = m + (vstart - 1)
						mm1 = m - 1 + (vstart - 1)
						For i_ = vstart To vend
							vttemp(i_) = cosr * vt(mm1, i_)
						Next
						For i_ = vstart To vend
							vttemp(i_) = vttemp(i_) + sinr * vt(mm0, i_)
						Next
						For i_ = vstart To vend
							vt(mm0, i_) = cosr * vt(mm0, i_)
						Next
						For i_ = vstart To vend
							vt(mm0, i_) = vt(mm0, i_) - sinr * vt(mm1, i_)
						Next
						For i_ = vstart To vend
							vt(mm1, i_) = vttemp(i_)
						Next
					End If
					If nru > 0 Then
						mm0 = m + ustart - 1
						mm1 = m - 1 + ustart - 1
						For i_ = ustart To uend
							utemp(i_) = cosl * ut(mm1, i_)
						Next
						For i_ = ustart To uend
							utemp(i_) = utemp(i_) + sinl * ut(mm0, i_)
						Next
						For i_ = ustart To uend
							ut(mm0, i_) = cosl * ut(mm0, i_)
						Next
						For i_ = ustart To uend
							ut(mm0, i_) = ut(mm0, i_) - sinl * ut(mm1, i_)
						Next
						For i_ = ustart To uend
							ut(mm1, i_) = utemp(i_)
						Next
					End If
					If ncc > 0 Then
						mm0 = m + cstart - 1
						mm1 = m - 1 + cstart - 1
						For i_ = cstart To cend
							ctemp(i_) = cosl * c(mm1, i_)
						Next
						For i_ = cstart To cend
							ctemp(i_) = ctemp(i_) + sinl * c(mm0, i_)
						Next
						For i_ = cstart To cend
							c(mm0, i_) = cosl * c(mm0, i_)
						Next
						For i_ = cstart To cend
							c(mm0, i_) = c(mm0, i_) - sinl * c(mm1, i_)
						Next
						For i_ = cstart To cend
							c(mm1, i_) = ctemp(i_)
						Next
					End If
					m = m - 2
					Continue While
				End If

				'
				' If working on new submatrix, choose shift direction
				' (from larger end diagonal element towards smaller)
				'
				' Previously was
				'     "if (LL>OLDM) or (M<OLDLL) then"
				' fixed thanks to Michael Rolle < m@rolle.name >
				' Very strange that LAPACK still contains it.
				'
				bchangedir = False
				If idir = 1 AndAlso CDbl(System.Math.Abs(d(ll))) < CDbl(0.001 * System.Math.Abs(d(m))) Then
					bchangedir = True
				End If
				If idir = 2 AndAlso CDbl(System.Math.Abs(d(m))) < CDbl(0.001 * System.Math.Abs(d(ll))) Then
					bchangedir = True
				End If
				If (ll <> oldll OrElse m <> oldm) OrElse bchangedir Then
					If CDbl(System.Math.Abs(d(ll))) >= CDbl(System.Math.Abs(d(m))) Then

						'
						' Chase bulge from top (big end) to bottom (small end)
						'
						idir = 1
					Else

						'
						' Chase bulge from bottom (big end) to top (small end)
						'
						idir = 2
					End If
				End If

				'
				' Apply convergence tests
				'
				If idir = 1 Then

					'
					' Run convergence test in forward direction
					' First apply standard test to bottom of matrix
					'
					If CDbl(System.Math.Abs(e(m - 1))) <= CDbl(System.Math.Abs(tol) * System.Math.Abs(d(m))) OrElse (CDbl(tol) < CDbl(0) AndAlso CDbl(System.Math.Abs(e(m - 1))) <= CDbl(thresh)) Then
						e(m - 1) = 0
						Continue While
					End If
					If CDbl(tol) >= CDbl(0) Then

						'
						' If relative accuracy desired,
						' apply convergence criterion forward
						'
						mu = System.Math.Abs(d(ll))
						sminl = mu
						iterflag = False
						For lll = ll To m - 1
							If CDbl(System.Math.Abs(e(lll))) <= CDbl(tol * mu) Then
								e(lll) = 0
								iterflag = True
								Exit For
							End If
							mu = System.Math.Abs(d(lll + 1)) * (mu / (mu + System.Math.Abs(e(lll))))
							sminl = System.Math.Min(sminl, mu)
						Next
						If iterflag Then
							Continue While
						End If
					End If
				Else

					'
					' Run convergence test in backward direction
					' First apply standard test to top of matrix
					'
					If CDbl(System.Math.Abs(e(ll))) <= CDbl(System.Math.Abs(tol) * System.Math.Abs(d(ll))) OrElse (CDbl(tol) < CDbl(0) AndAlso CDbl(System.Math.Abs(e(ll))) <= CDbl(thresh)) Then
						e(ll) = 0
						Continue While
					End If
					If CDbl(tol) >= CDbl(0) Then

						'
						' If relative accuracy desired,
						' apply convergence criterion backward
						'
						mu = System.Math.Abs(d(m))
						sminl = mu
						iterflag = False
						For lll = m - 1 To ll Step -1
							If CDbl(System.Math.Abs(e(lll))) <= CDbl(tol * mu) Then
								e(lll) = 0
								iterflag = True
								Exit For
							End If
							mu = System.Math.Abs(d(lll)) * (mu / (mu + System.Math.Abs(e(lll))))
							sminl = System.Math.Min(sminl, mu)
						Next
						If iterflag Then
							Continue While
						End If
					End If
				End If
				oldll = ll
				oldm = m

				'
				' Compute shift.  First, test if shifting would ruin relative
				' accuracy, and if so set the shift to zero.
				'
				If CDbl(tol) >= CDbl(0) AndAlso CDbl(n * tol * (sminl / smax)) <= CDbl(System.Math.Max(eps, 0.01 * tol)) Then

					'
					' Use a zero shift to avoid loss of relative accuracy
					'
					shift = 0
				Else

					'
					' Compute the shift from 2-by-2 block at end of matrix
					'
					If idir = 1 Then
						sll = System.Math.Abs(d(ll))
						svd2x2(d(m - 1), e(m - 1), d(m), shift, r)
					Else
						sll = System.Math.Abs(d(m))
						svd2x2(d(ll), e(ll), d(ll + 1), shift, r)
					End If

					'
					' Test if shift negligible, and if so set to zero
					'
					If CDbl(sll) > CDbl(0) Then
						If CDbl(Math.sqr(shift / sll)) < CDbl(eps) Then
							shift = 0
						End If
					End If
				End If

				'
				' Increment iteration count
				'
				iter = iter + m - ll

				'
				' If SHIFT = 0, do simplified QR iteration
				'
				If CDbl(shift) = CDbl(0) Then
					If idir = 1 Then

						'
						' Chase bulge from top to bottom
						' Save cosines and sines for later singular vector updates
						'
						cs = 1
						oldcs = 1
						For i = ll To m - 1
							rotations.generaterotation(d(i) * cs, e(i), cs, sn, r)
							If i > ll Then
								e(i - 1) = oldsn * r
							End If
							rotations.generaterotation(oldcs * r, d(i + 1) * sn, oldcs, oldsn, tmp)
							d(i) = tmp
							work0(i - ll + 1) = cs
							work1(i - ll + 1) = sn
							work2(i - ll + 1) = oldcs
							work3(i - ll + 1) = oldsn
						Next
						h = d(m) * cs
						d(m) = h * oldcs
						e(m - 1) = h * oldsn

						'
						' Update singular vectors
						'
						If ncvt > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work0, _
								work1, vt, vttemp)
						End If
						If nru > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + ustart - 1, m + ustart - 1, ustart, uend, work2, _
								work3, ut, utemp)
						End If
						If ncc > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work2, _
								work3, c, ctemp)
						End If

						'
						' Test convergence
						'
						If CDbl(System.Math.Abs(e(m - 1))) <= CDbl(thresh) Then
							e(m - 1) = 0
						End If
					Else

						'
						' Chase bulge from bottom to top
						' Save cosines and sines for later singular vector updates
						'
						cs = 1
						oldcs = 1
						For i = m To ll + 1 Step -1
							rotations.generaterotation(d(i) * cs, e(i - 1), cs, sn, r)
							If i < m Then
								e(i) = oldsn * r
							End If
							rotations.generaterotation(oldcs * r, d(i - 1) * sn, oldcs, oldsn, tmp)
							d(i) = tmp
							work0(i - ll) = cs
							work1(i - ll) = -sn
							work2(i - ll) = oldcs
							work3(i - ll) = -oldsn
						Next
						h = d(ll) * cs
						d(ll) = h * oldcs
						e(ll) = h * oldsn

						'
						' Update singular vectors
						'
						If ncvt > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work2, _
								work3, vt, vttemp)
						End If
						If nru > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + ustart - 1, m + ustart - 1, ustart, uend, work0, _
								work1, ut, utemp)
						End If
						If ncc > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work0, _
								work1, c, ctemp)
						End If

						'
						' Test convergence
						'
						If CDbl(System.Math.Abs(e(ll))) <= CDbl(thresh) Then
							e(ll) = 0
						End If
					End If
				Else

					'
					' Use nonzero shift
					'
					If idir = 1 Then

						'
						' Chase bulge from top to bottom
						' Save cosines and sines for later singular vector updates
						'
						f = (System.Math.Abs(d(ll)) - shift) * (extsignbdsqr(1, d(ll)) + shift / d(ll))
						g = e(ll)
						For i = ll To m - 1
							rotations.generaterotation(f, g, cosr, sinr, r)
							If i > ll Then
								e(i - 1) = r
							End If
							f = cosr * d(i) + sinr * e(i)
							e(i) = cosr * e(i) - sinr * d(i)
							g = sinr * d(i + 1)
							d(i + 1) = cosr * d(i + 1)
							rotations.generaterotation(f, g, cosl, sinl, r)
							d(i) = r
							f = cosl * e(i) + sinl * d(i + 1)
							d(i + 1) = cosl * d(i + 1) - sinl * e(i)
							If i < m - 1 Then
								g = sinl * e(i + 1)
								e(i + 1) = cosl * e(i + 1)
							End If
							work0(i - ll + 1) = cosr
							work1(i - ll + 1) = sinr
							work2(i - ll + 1) = cosl
							work3(i - ll + 1) = sinl
						Next
						e(m - 1) = f

						'
						' Update singular vectors
						'
						If ncvt > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work0, _
								work1, vt, vttemp)
						End If
						If nru > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + ustart - 1, m + ustart - 1, ustart, uend, work2, _
								work3, ut, utemp)
						End If
						If ncc > 0 Then
							rotations.applyrotationsfromtheleft(fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work2, _
								work3, c, ctemp)
						End If

						'
						' Test convergence
						'
						If CDbl(System.Math.Abs(e(m - 1))) <= CDbl(thresh) Then
							e(m - 1) = 0
						End If
					Else

						'
						' Chase bulge from bottom to top
						' Save cosines and sines for later singular vector updates
						'
						f = (System.Math.Abs(d(m)) - shift) * (extsignbdsqr(1, d(m)) + shift / d(m))
						g = e(m - 1)
						For i = m To ll + 1 Step -1
							rotations.generaterotation(f, g, cosr, sinr, r)
							If i < m Then
								e(i) = r
							End If
							f = cosr * d(i) + sinr * e(i - 1)
							e(i - 1) = cosr * e(i - 1) - sinr * d(i)
							g = sinr * d(i - 1)
							d(i - 1) = cosr * d(i - 1)
							rotations.generaterotation(f, g, cosl, sinl, r)
							d(i) = r
							f = cosl * e(i - 1) + sinl * d(i - 1)
							d(i - 1) = cosl * d(i - 1) - sinl * e(i - 1)
							If i > ll + 1 Then
								g = sinl * e(i - 2)
								e(i - 2) = cosl * e(i - 2)
							End If
							work0(i - ll) = cosr
							work1(i - ll) = -sinr
							work2(i - ll) = cosl
							work3(i - ll) = -sinl
						Next
						e(ll) = f

						'
						' Test convergence
						'
						If CDbl(System.Math.Abs(e(ll))) <= CDbl(thresh) Then
							e(ll) = 0
						End If

						'
						' Update singular vectors if desired
						'
						If ncvt > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + vstart - 1, m + vstart - 1, vstart, vend, work2, _
								work3, vt, vttemp)
						End If
						If nru > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + ustart - 1, m + ustart - 1, ustart, uend, work0, _
								work1, ut, utemp)
						End If
						If ncc > 0 Then
							rotations.applyrotationsfromtheleft(Not fwddir, ll + cstart - 1, m + cstart - 1, cstart, cend, work0, _
								work1, c, ctemp)
						End If
					End If
				End If

				'
				' QR iteration finished, go back and check convergence
				'
				Continue While
			End While

			'
			' All singular values converged, so make them positive
			'
			For i = 1 To n
				If CDbl(d(i)) < CDbl(0) Then
					d(i) = -d(i)

					'
					' Change sign of singular vectors, if desired
					'
					If ncvt > 0 Then
						For i_ = vstart To vend
							vt(i + vstart - 1, i_) = -1 * vt(i + vstart - 1, i_)
						Next
					End If
				End If
			Next

			'
			' Sort the singular values into decreasing order (insertion sort on
			' singular values, but only one transposition per singular vector)
			'
			For i = 1 To n - 1

				'
				' Scan for smallest D(I)
				'
				isub = 1
				smin = d(1)
				For j = 2 To n + 1 - i
					If CDbl(d(j)) <= CDbl(smin) Then
						isub = j
						smin = d(j)
					End If
				Next
				If isub <> n + 1 - i Then

					'
					' Swap singular values and vectors
					'
					d(isub) = d(n + 1 - i)
					d(n + 1 - i) = smin
					If ncvt > 0 Then
						j = n + 1 - i
						For i_ = vstart To vend
							vttemp(i_) = vt(isub + vstart - 1, i_)
						Next
						For i_ = vstart To vend
							vt(isub + vstart - 1, i_) = vt(j + vstart - 1, i_)
						Next
						For i_ = vstart To vend
							vt(j + vstart - 1, i_) = vttemp(i_)
						Next
					End If
					If nru > 0 Then
						j = n + 1 - i
						For i_ = ustart To uend
							utemp(i_) = ut(isub + ustart - 1, i_)
						Next
						For i_ = ustart To uend
							ut(isub + ustart - 1, i_) = ut(j + ustart - 1, i_)
						Next
						For i_ = ustart To uend
							ut(j + ustart - 1, i_) = utemp(i_)
						Next
					End If
					If ncc > 0 Then
						j = n + 1 - i
						For i_ = cstart To cend
							ctemp(i_) = c(isub + cstart - 1, i_)
						Next
						For i_ = cstart To cend
							c(isub + cstart - 1, i_) = c(j + cstart - 1, i_)
						Next
						For i_ = cstart To cend
							c(j + cstart - 1, i_) = ctemp(i_)
						Next
					End If
				End If
			Next

			'
			' Copy U back from temporary storage
			'
			If nru > 0 Then
				ablas.rmatrixtranspose(n, nru, ut, ustart, ustart, uu, _
					ustart, ustart)
			End If
			Return result
		End Function


		Private Shared Function extsignbdsqr(a As Double, b As Double) As Double
			Dim result As Double = 0

			If CDbl(b) >= CDbl(0) Then
				result = System.Math.Abs(a)
			Else
				result = -System.Math.Abs(a)
			End If
			Return result
		End Function


		Private Shared Sub svd2x2(f As Double, g As Double, h As Double, ByRef ssmin As Double, ByRef ssmax As Double)
			Dim aas As Double = 0
			Dim at As Double = 0
			Dim au As Double = 0
			Dim c As Double = 0
			Dim fa As Double = 0
			Dim fhmn As Double = 0
			Dim fhmx As Double = 0
			Dim ga As Double = 0
			Dim ha As Double = 0

			ssmin = 0
			ssmax = 0

			fa = System.Math.Abs(f)
			ga = System.Math.Abs(g)
			ha = System.Math.Abs(h)
			fhmn = System.Math.Min(fa, ha)
			fhmx = System.Math.Max(fa, ha)
			If CDbl(fhmn) = CDbl(0) Then
				ssmin = 0
				If CDbl(fhmx) = CDbl(0) Then
					ssmax = ga
				Else
					ssmax = System.Math.Max(fhmx, ga) * System.Math.sqrt(1 + Math.sqr(System.Math.Min(fhmx, ga) / System.Math.Max(fhmx, ga)))
				End If
			Else
				If CDbl(ga) < CDbl(fhmx) Then
					aas = 1 + fhmn / fhmx
					at = (fhmx - fhmn) / fhmx
					au = Math.sqr(ga / fhmx)
					c = 2 / (System.Math.sqrt(aas * aas + au) + System.Math.sqrt(at * at + au))
					ssmin = fhmn * c
					ssmax = fhmx / c
				Else
					au = fhmx / ga
					If CDbl(au) = CDbl(0) Then

						'
						' Avoid possible harmful underflow if exponent range
						' asymmetric (true SSMIN may not underflow even if
						' AU underflows)
						'
						ssmin = fhmn * fhmx / ga
						ssmax = ga
					Else
						aas = 1 + fhmn / fhmx
						at = (fhmx - fhmn) / fhmx
						c = 1 / (System.Math.sqrt(1 + Math.sqr(aas * au)) + System.Math.sqrt(1 + Math.sqr(at * au)))
						ssmin = fhmn * c * au
						ssmin = ssmin + ssmin
						ssmax = ga / (c + c)
					End If
				End If
			End If
		End Sub


		Private Shared Sub svdv2x2(f As Double, g As Double, h As Double, ByRef ssmin As Double, ByRef ssmax As Double, ByRef snr As Double, _
			ByRef csr As Double, ByRef snl As Double, ByRef csl As Double)
			Dim gasmal As New Boolean()
			Dim swp As New Boolean()
			Dim pmax As Integer = 0
			Dim a As Double = 0
			Dim clt As Double = 0
			Dim crt As Double = 0
			Dim d As Double = 0
			Dim fa As Double = 0
			Dim ft As Double = 0
			Dim ga As Double = 0
			Dim gt As Double = 0
			Dim ha As Double = 0
			Dim ht As Double = 0
			Dim l As Double = 0
			Dim m As Double = 0
			Dim mm As Double = 0
			Dim r As Double = 0
			Dim s As Double = 0
			Dim slt As Double = 0
			Dim srt As Double = 0
			Dim t As Double = 0
			Dim temp As Double = 0
			Dim tsign As Double = 0
			Dim tt As Double = 0
			Dim v As Double = 0

			ssmin = 0
			ssmax = 0
			snr = 0
			csr = 0
			snl = 0
			csl = 0

			ft = f
			fa = System.Math.Abs(ft)
			ht = h
			ha = System.Math.Abs(h)

			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			clt = 0
			crt = 0
			slt = 0
			srt = 0
			tsign = 0

			'
			' PMAX points to the maximum absolute element of matrix
			'  PMAX = 1 if F largest in absolute values
			'  PMAX = 2 if G largest in absolute values
			'  PMAX = 3 if H largest in absolute values
			'
			pmax = 1
			swp = CDbl(ha) > CDbl(fa)
			If swp Then

				'
				' Now FA .ge. HA
				'
				pmax = 3
				temp = ft
				ft = ht
				ht = temp
				temp = fa
				fa = ha
				ha = temp
			End If
			gt = g
			ga = System.Math.Abs(gt)
			If CDbl(ga) = CDbl(0) Then

				'
				' Diagonal matrix
				'
				ssmin = ha
				ssmax = fa
				clt = 1
				crt = 1
				slt = 0
				srt = 0
			Else
				gasmal = True
				If CDbl(ga) > CDbl(fa) Then
					pmax = 2
					If CDbl(fa / ga) < CDbl(Math.machineepsilon) Then

						'
						' Case of very large GA
						'
						gasmal = False
						ssmax = ga
						If CDbl(ha) > CDbl(1) Then
							v = ga / ha
							ssmin = fa / v
						Else
							v = fa / ga
							ssmin = v * ha
						End If
						clt = 1
						slt = ht / gt
						srt = 1
						crt = ft / gt
					End If
				End If
				If gasmal Then

					'
					' Normal case
					'
					d = fa - ha
					If CDbl(d) = CDbl(fa) Then
						l = 1
					Else
						l = d / fa
					End If
					m = gt / ft
					t = 2 - l
					mm = m * m
					tt = t * t
					s = System.Math.sqrt(tt + mm)
					If CDbl(l) = CDbl(0) Then
						r = System.Math.Abs(m)
					Else
						r = System.Math.sqrt(l * l + mm)
					End If
					a = 0.5 * (s + r)
					ssmin = ha / a
					ssmax = fa * a
					If CDbl(mm) = CDbl(0) Then

						'
						' Note that M is very tiny
						'
						If CDbl(l) = CDbl(0) Then
							t = extsignbdsqr(2, ft) * extsignbdsqr(1, gt)
						Else
							t = gt / extsignbdsqr(d, ft) + m / t
						End If
					Else
						t = (m / (s + t) + m / (r + l)) * (1 + a)
					End If
					l = System.Math.sqrt(t * t + 4)
					crt = 2 / l
					srt = t / l
					clt = (crt + srt * m) / a
					v = ht / ft
					slt = v * srt / a
				End If
			End If
			If swp Then
				csl = srt
				snl = crt
				csr = slt
				snr = clt
			Else
				csl = clt
				snl = slt
				csr = crt
				snr = srt
			End If

			'
			' Correct signs of SSMAX and SSMIN
			'
			If pmax = 1 Then
				tsign = extsignbdsqr(1, csr) * extsignbdsqr(1, csl) * extsignbdsqr(1, f)
			End If
			If pmax = 2 Then
				tsign = extsignbdsqr(1, snr) * extsignbdsqr(1, csl) * extsignbdsqr(1, g)
			End If
			If pmax = 3 Then
				tsign = extsignbdsqr(1, snr) * extsignbdsqr(1, snl) * extsignbdsqr(1, h)
			End If
			ssmax = extsignbdsqr(ssmax, tsign)
			ssmin = extsignbdsqr(ssmin, tsign * extsignbdsqr(1, f) * extsignbdsqr(1, h))
		End Sub


	End Class
	Public Class svd
		'************************************************************************
'        Singular value decomposition of a rectangular matrix.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is only partially supported (some parts are
'          ! optimized, but most - are not).
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        The algorithm calculates the singular value decomposition of a matrix of
'        size MxN: A = U * S * V^T
'
'        The algorithm finds the singular values and, optionally, matrices U and V^T.
'        The algorithm can find both first min(M,N) columns of matrix U and rows of
'        matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
'        and NxN respectively).
'
'        Take into account that the subroutine does not return matrix V but V^T.
'
'        Input parameters:
'            A           -   matrix to be decomposed.
'                            Array whose indexes range within [0..M-1, 0..N-1].
'            M           -   number of rows in matrix A.
'            N           -   number of columns in matrix A.
'            UNeeded     -   0, 1 or 2. See the description of the parameter U.
'            VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
'            AdditionalMemory -
'                            If the parameter:
'                             * equals 0, the algorithm doesn use additional
'                               memory (lower requirements, lower performance).
'                             * equals 1, the algorithm uses additional
'                               memory of size min(M,N)*min(M,N) of real numbers.
'                               It often speeds up the algorithm.
'                             * equals 2, the algorithm uses additional
'                               memory of size M*min(M,N) of real numbers.
'                               It allows to get a maximum performance.
'                            The recommended value of the parameter is 2.
'
'        Output parameters:
'            W           -   contains singular values in descending order.
'            U           -   if UNeeded=0, U isn't changed, the left singular vectors
'                            are not calculated.
'                            if Uneeded=1, U contains left singular vectors (first
'                            min(M,N) columns of matrix U). Array whose indexes range
'                            within [0..M-1, 0..Min(M,N)-1].
'                            if UNeeded=2, U contains matrix U wholly. Array whose
'                            indexes range within [0..M-1, 0..M-1].
'            VT          -   if VTNeeded=0, VT isn changed, the right singular vectors
'                            are not calculated.
'                            if VTNeeded=1, VT contains right singular vectors (first
'                            min(M,N) rows of matrix V^T). Array whose indexes range
'                            within [0..min(M,N)-1, 0..N-1].
'                            if VTNeeded=2, VT contains matrix V^T wholly. Array whose
'                            indexes range within [0..N-1, 0..N-1].
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function rmatrixsvd(a As Double(,), m As Integer, n As Integer, uneeded As Integer, vtneeded As Integer, additionalmemory As Integer, _
			ByRef w As Double(), ByRef u As Double(,), ByRef vt As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tauq As Double() = New Double(-1) {}
			Dim taup As Double() = New Double(-1) {}
			Dim tau As Double() = New Double(-1) {}
			Dim e As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim t2 As Double(,) = New Double(-1, -1) {}
			Dim isupper As New Boolean()
			Dim minmn As Integer = 0
			Dim ncu As Integer = 0
			Dim nrvt As Integer = 0
			Dim nru As Integer = 0
			Dim ncvt As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			a = DirectCast(a.Clone(), Double(,))
			w = New Double(-1) {}
			u = New Double(-1, -1) {}
			vt = New Double(-1, -1) {}

			result = True
			If m = 0 OrElse n = 0 Then
				Return result
			End If
			alglib.ap.assert(uneeded >= 0 AndAlso uneeded <= 2, "SVDDecomposition: wrong parameters!")
			alglib.ap.assert(vtneeded >= 0 AndAlso vtneeded <= 2, "SVDDecomposition: wrong parameters!")
			alglib.ap.assert(additionalmemory >= 0 AndAlso additionalmemory <= 2, "SVDDecomposition: wrong parameters!")

			'
			' initialize
			'
			minmn = System.Math.Min(m, n)
			w = New Double(minmn) {}
			ncu = 0
			nru = 0
			If uneeded = 1 Then
				nru = m
				ncu = minmn
				u = New Double(nru - 1, ncu - 1) {}
			End If
			If uneeded = 2 Then
				nru = m
				ncu = m
				u = New Double(nru - 1, ncu - 1) {}
			End If
			nrvt = 0
			ncvt = 0
			If vtneeded = 1 Then
				nrvt = minmn
				ncvt = n
				vt = New Double(nrvt - 1, ncvt - 1) {}
			End If
			If vtneeded = 2 Then
				nrvt = n
				ncvt = n
				vt = New Double(nrvt - 1, ncvt - 1) {}
			End If

			'
			' M much larger than N
			' Use bidiagonal reduction with QR-decomposition
			'
			If CDbl(m) > CDbl(1.6 * n) Then
				If uneeded = 0 Then

					'
					' No left singular vectors to be computed
					'
					ortfac.rmatrixqr(a, m, n, tau)
					For i = 0 To n - 1
						For j = 0 To i - 1
							a(i, j) = 0
						Next
					Next
					ortfac.rmatrixbd(a, n, n, tauq, taup)
					ortfac.rmatrixbdunpackpt(a, n, n, taup, nrvt, vt)
					ortfac.rmatrixbdunpackdiagonals(a, n, n, isupper, w, e)
					result = bdsvd.rmatrixbdsvd(w, e, n, isupper, False, u, _
						0, a, 0, vt, ncvt)
					Return result
				Else

					'
					' Left singular vectors (may be full matrix U) to be computed
					'
					ortfac.rmatrixqr(a, m, n, tau)
					ortfac.rmatrixqrunpackq(a, m, n, tau, ncu, u)
					For i = 0 To n - 1
						For j = 0 To i - 1
							a(i, j) = 0
						Next
					Next
					ortfac.rmatrixbd(a, n, n, tauq, taup)
					ortfac.rmatrixbdunpackpt(a, n, n, taup, nrvt, vt)
					ortfac.rmatrixbdunpackdiagonals(a, n, n, isupper, w, e)
					If additionalmemory < 1 Then

						'
						' No additional memory can be used
						'
						ortfac.rmatrixbdmultiplybyq(a, n, n, tauq, u, m, _
							n, True, False)
						result = bdsvd.rmatrixbdsvd(w, e, n, isupper, False, u, _
							m, a, 0, vt, ncvt)
					Else

						'
						' Large U. Transforming intermediate matrix T2
						'
						work = New Double(System.Math.Max(m, n)) {}
						ortfac.rmatrixbdunpackq(a, n, n, tauq, n, t2)
						blas.copymatrix(u, 0, m - 1, 0, n - 1, a, _
							0, m - 1, 0, n - 1)
						blas.inplacetranspose(t2, 0, n - 1, 0, n - 1, work)
						result = bdsvd.rmatrixbdsvd(w, e, n, isupper, False, u, _
							0, t2, n, vt, ncvt)
						ablas.rmatrixgemm(m, n, n, 1.0, a, 0, _
							0, 0, t2, 0, 0, 1, _
							0.0, u, 0, 0)
					End If
					Return result
				End If
			End If

			'
			' N much larger than M
			' Use bidiagonal reduction with LQ-decomposition
			'
			If CDbl(n) > CDbl(1.6 * m) Then
				If vtneeded = 0 Then

					'
					' No right singular vectors to be computed
					'
					ortfac.rmatrixlq(a, m, n, tau)
					For i = 0 To m - 1
						For j = i + 1 To m - 1
							a(i, j) = 0
						Next
					Next
					ortfac.rmatrixbd(a, m, m, tauq, taup)
					ortfac.rmatrixbdunpackq(a, m, m, tauq, ncu, u)
					ortfac.rmatrixbdunpackdiagonals(a, m, m, isupper, w, e)
					work = New Double(m) {}
					blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
					result = bdsvd.rmatrixbdsvd(w, e, m, isupper, False, a, _
						0, u, nru, vt, 0)
					blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
					Return result
				Else

					'
					' Right singular vectors (may be full matrix VT) to be computed
					'
					ortfac.rmatrixlq(a, m, n, tau)
					ortfac.rmatrixlqunpackq(a, m, n, tau, nrvt, vt)
					For i = 0 To m - 1
						For j = i + 1 To m - 1
							a(i, j) = 0
						Next
					Next
					ortfac.rmatrixbd(a, m, m, tauq, taup)
					ortfac.rmatrixbdunpackq(a, m, m, tauq, ncu, u)
					ortfac.rmatrixbdunpackdiagonals(a, m, m, isupper, w, e)
					work = New Double(System.Math.Max(m, n)) {}
					blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
					If additionalmemory < 1 Then

						'
						' No additional memory available
						'
						ortfac.rmatrixbdmultiplybyp(a, m, m, taup, vt, m, _
							n, False, True)
						result = bdsvd.rmatrixbdsvd(w, e, m, isupper, False, a, _
							0, u, nru, vt, n)
					Else

						'
						' Large VT. Transforming intermediate matrix T2
						'
						ortfac.rmatrixbdunpackpt(a, m, m, taup, m, t2)
						result = bdsvd.rmatrixbdsvd(w, e, m, isupper, False, a, _
							0, u, nru, t2, m)
						blas.copymatrix(vt, 0, m - 1, 0, n - 1, a, _
							0, m - 1, 0, n - 1)
						ablas.rmatrixgemm(m, n, m, 1.0, t2, 0, _
							0, 0, a, 0, 0, 0, _
							0.0, vt, 0, 0)
					End If
					blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
					Return result
				End If
			End If

			'
			' M<=N
			' We can use inplace transposition of U to get rid of columnwise operations
			'
			If m <= n Then
				ortfac.rmatrixbd(a, m, n, tauq, taup)
				ortfac.rmatrixbdunpackq(a, m, n, tauq, ncu, u)
				ortfac.rmatrixbdunpackpt(a, m, n, taup, nrvt, vt)
				ortfac.rmatrixbdunpackdiagonals(a, m, n, isupper, w, e)
				work = New Double(m) {}
				blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
				result = bdsvd.rmatrixbdsvd(w, e, minmn, isupper, False, a, _
					0, u, nru, vt, ncvt)
				blas.inplacetranspose(u, 0, nru - 1, 0, ncu - 1, work)
				Return result
			End If

			'
			' Simple bidiagonal reduction
			'
			ortfac.rmatrixbd(a, m, n, tauq, taup)
			ortfac.rmatrixbdunpackq(a, m, n, tauq, ncu, u)
			ortfac.rmatrixbdunpackpt(a, m, n, taup, nrvt, vt)
			ortfac.rmatrixbdunpackdiagonals(a, m, n, isupper, w, e)
			If additionalmemory < 2 OrElse uneeded = 0 Then

				'
				' We cant use additional memory or there is no need in such operations
				'
				result = bdsvd.rmatrixbdsvd(w, e, minmn, isupper, False, u, _
					nru, a, 0, vt, ncvt)
			Else

				'
				' We can use additional memory
				'
				t2 = New Double(minmn - 1, m - 1) {}
				blas.copyandtranspose(u, 0, m - 1, 0, minmn - 1, t2, _
					0, minmn - 1, 0, m - 1)
				result = bdsvd.rmatrixbdsvd(w, e, minmn, isupper, False, u, _
					0, t2, m, vt, ncvt)
				blas.copyandtranspose(t2, 0, minmn - 1, 0, m - 1, u, _
					0, m - 1, 0, minmn - 1)
			End If
			Return result
		End Function


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Function _pexec_rmatrixsvd(a As Double(,), m As Integer, n As Integer, uneeded As Integer, vtneeded As Integer, additionalmemory As Integer, _
			ByRef w As Double(), ByRef u As Double(,), ByRef vt As Double(,)) As Boolean
			Return rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory, _
				w, u, vt)
		End Function


	End Class
	Public Class evd
		'************************************************************************
'        Finding the eigenvalues and eigenvectors of a symmetric matrix
'
'        The algorithm finds eigen pairs of a symmetric matrix by reducing it to
'        tridiagonal form and using the QL/QR algorithm.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   symmetric matrix which is given by its upper or lower
'                        triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'            IsUpper -   storage format.
'
'        Output parameters:
'            D       -   eigenvalues in ascending order.
'                        Array whose index ranges within [0..N-1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains the eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'                        The eigenvectors are stored in the matrix columns.
'
'        Result:
'            True, if the algorithm has converged.
'            False, if the algorithm hasn't converged (rare case).
'
'          -- ALGLIB --
'             Copyright 2005-2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixevd(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, ByRef d As Double(), ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tau As Double() = New Double(-1) {}
			Dim e As Double() = New Double(-1) {}

			a = DirectCast(a.Clone(), Double(,))
			d = New Double(-1) {}
			z = New Double(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "SMatrixEVD: incorrect ZNeeded")
			ortfac.smatrixtd(a, n, isupper, tau, d, e)
			If zneeded = 1 Then
				ortfac.smatrixtdunpackq(a, n, isupper, tau, z)
			End If
			result = smatrixtdevd(d, e, n, zneeded, z)
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
'        matrix  in  a  given half open interval (A, B] by using  a  bisection  and
'        inverse iteration
'
'        Input parameters:
'            A       -   symmetric matrix which is given by its upper or lower
'                        triangular part. Array [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'            IsUpperA -  storage format of matrix A.
'            B1, B2 -    half open interval (B1, B2] to search eigenvalues in.
'
'        Output parameters:
'            M       -   number of eigenvalues found in a given half-interval (M>=0).
'            W       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..M-1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..M-1].
'                        The eigenvectors are stored in the matrix columns.
'
'        Result:
'            True, if successful. M contains the number of eigenvalues in the given
'            half-interval (could be equal to 0), W contains the eigenvalues,
'            Z contains the eigenvectors (if needed).
'
'            False, if the bisection method subroutine wasn't able to find the
'            eigenvalues in the given interval or if the inverse iteration subroutine
'            wasn't able to find all the corresponding eigenvectors.
'            In that case, the eigenvalues and eigenvectors are not returned,
'            M is equal to 0.
'
'          -- ALGLIB --
'             Copyright 07.01.2006 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixevdr(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, b1 As Double, b2 As Double, _
			ByRef m As Integer, ByRef w As Double(), ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tau As Double() = New Double(-1) {}
			Dim e As Double() = New Double(-1) {}

			a = DirectCast(a.Clone(), Double(,))
			m = 0
			w = New Double(-1) {}
			z = New Double(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "SMatrixTDEVDR: incorrect ZNeeded")
			ortfac.smatrixtd(a, n, isupper, tau, w, e)
			If zneeded = 1 Then
				ortfac.smatrixtdunpackq(a, n, isupper, tau, z)
			End If
			result = smatrixtdevdr(w, e, n, zneeded, b1, b2, _
				m, z)
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
'        matrix with given indexes by using bisection and inverse iteration methods.
'
'        Input parameters:
'            A       -   symmetric matrix which is given by its upper or lower
'                        triangular part. Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'            IsUpperA -  storage format of matrix A.
'            I1, I2 -    index interval for searching (from I1 to I2).
'                        0 <= I1 <= I2 <= N-1.
'
'        Output parameters:
'            W       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..I2-I1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..I2-I1].
'                        In that case, the eigenvectors are stored in the matrix columns.
'
'        Result:
'            True, if successful. W contains the eigenvalues, Z contains the
'            eigenvectors (if needed).
'
'            False, if the bisection method subroutine wasn't able to find the
'            eigenvalues in the given interval or if the inverse iteration subroutine
'            wasn't able to find all the corresponding eigenvectors.
'            In that case, the eigenvalues and eigenvectors are not returned.
'
'          -- ALGLIB --
'             Copyright 07.01.2006 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixevdi(a As Double(,), n As Integer, zneeded As Integer, isupper As Boolean, i1 As Integer, i2 As Integer, _
			ByRef w As Double(), ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tau As Double() = New Double(-1) {}
			Dim e As Double() = New Double(-1) {}

			a = DirectCast(a.Clone(), Double(,))
			w = New Double(-1) {}
			z = New Double(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "SMatrixEVDI: incorrect ZNeeded")
			ortfac.smatrixtd(a, n, isupper, tau, w, e)
			If zneeded = 1 Then
				ortfac.smatrixtdunpackq(a, n, isupper, tau, z)
			End If
			result = smatrixtdevdi(w, e, n, zneeded, i1, i2, _
				z)
			Return result
		End Function


		'************************************************************************
'        Finding the eigenvalues and eigenvectors of a Hermitian matrix
'
'        The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
'        real tridiagonal form and using the QL/QR algorithm.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                        triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            IsUpper -   storage format.
'            ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                        not. If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'
'        Output parameters:
'            D       -   eigenvalues in ascending order.
'                        Array whose index ranges within [0..N-1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains the eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'                        The eigenvectors are stored in the matrix columns.
'
'        Result:
'            True, if the algorithm has converged.
'            False, if the algorithm hasn't converged (rare case).
'
'        Note:
'            eigenvectors of Hermitian matrix are defined up to  multiplication  by
'            a complex number L, such that |L|=1.
'
'          -- ALGLIB --
'             Copyright 2005, 23 March 2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function hmatrixevd(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, ByRef d As Double(), ByRef z As complex(,)) As Boolean
			Dim result As New Boolean()
			Dim tau As complex() = New complex(-1) {}
			Dim e As Double() = New Double(-1) {}
			Dim t As Double(,) = New Double(-1, -1) {}
			Dim qz As Double(,) = New Double(-1, -1) {}
			Dim q As complex(,) = New complex(-1, -1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0

			a = DirectCast(a.Clone(), complex(,))
			d = New Double(-1) {}
			z = New complex(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "HermitianEVD: incorrect ZNeeded")

			'
			' Reduce to tridiagonal form
			'
			ortfac.hmatrixtd(a, n, isupper, tau, d, e)
			If zneeded = 1 Then
				ortfac.hmatrixtdunpackq(a, n, isupper, tau, q)
				zneeded = 2
			End If

			'
			' TDEVD
			'
			result = smatrixtdevd(d, e, n, zneeded, t)

			'
			' Eigenvectors are needed
			' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
			'
			If result AndAlso zneeded <> 0 Then
				z = New complex(n - 1, n - 1) {}
				qz = New Double(n - 1, 2 * n - 1) {}

				'
				' Calculate Re(Q)*T
				'
				For i = 0 To n - 1
					For j = 0 To n - 1
						qz(i, j) = q(i, j).x
					Next
				Next
				ablas.rmatrixgemm(n, n, n, 1.0, qz, 0, _
					0, 0, t, 0, 0, 0, _
					0.0, qz, 0, n)
				For i = 0 To n - 1
					For j = 0 To n - 1
						z(i, j).x = qz(i, n + j)
					Next
				Next

				'
				' Calculate Im(Q)*T
				'
				For i = 0 To n - 1
					For j = 0 To n - 1
						qz(i, j) = q(i, j).y
					Next
				Next
				ablas.rmatrixgemm(n, n, n, 1.0, qz, 0, _
					0, 0, t, 0, 0, 0, _
					0.0, qz, 0, n)
				For i = 0 To n - 1
					For j = 0 To n - 1
						z(i, j).y = qz(i, n + j)
					Next
				Next
			End If
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
'        matrix  in  a  given half-interval (A, B] by using a bisection and inverse
'        iteration
'
'        Input parameters:
'            A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                        triangular  part.  Array  whose   indexes   range   within
'                        [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                        not. If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'            IsUpperA -  storage format of matrix A.
'            B1, B2 -    half-interval (B1, B2] to search eigenvalues in.
'
'        Output parameters:
'            M       -   number of eigenvalues found in a given half-interval, M>=0
'            W       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..M-1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..M-1].
'                        The eigenvectors are stored in the matrix columns.
'
'        Result:
'            True, if successful. M contains the number of eigenvalues in the given
'            half-interval (could be equal to 0), W contains the eigenvalues,
'            Z contains the eigenvectors (if needed).
'
'            False, if the bisection method subroutine  wasn't  able  to  find  the
'            eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'            subroutine  wasn't  able  to  find all the corresponding eigenvectors.
'            In that case, the eigenvalues and eigenvectors are not returned, M  is
'            equal to 0.
'
'        Note:
'            eigen vectors of Hermitian matrix are defined up to multiplication  by
'            a complex number L, such as |L|=1.
'
'          -- ALGLIB --
'             Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'        ************************************************************************

		Public Shared Function hmatrixevdr(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, b1 As Double, b2 As Double, _
			ByRef m As Integer, ByRef w As Double(), ByRef z As complex(,)) As Boolean
			Dim result As New Boolean()
			Dim q As complex(,) = New complex(-1, -1) {}
			Dim t As Double(,) = New Double(-1, -1) {}
			Dim tau As complex() = New complex(-1) {}
			Dim e As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			a = DirectCast(a.Clone(), complex(,))
			m = 0
			w = New Double(-1) {}
			z = New complex(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "HermitianEigenValuesAndVectorsInInterval: incorrect ZNeeded")

			'
			' Reduce to tridiagonal form
			'
			ortfac.hmatrixtd(a, n, isupper, tau, w, e)
			If zneeded = 1 Then
				ortfac.hmatrixtdunpackq(a, n, isupper, tau, q)
				zneeded = 2
			End If

			'
			' Bisection and inverse iteration
			'
			result = smatrixtdevdr(w, e, n, zneeded, b1, b2, _
				m, t)

			'
			' Eigenvectors are needed
			' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
			'
			If (result AndAlso zneeded <> 0) AndAlso m <> 0 Then
				work = New Double(m - 1) {}
				z = New complex(n - 1, m - 1) {}
				For i = 0 To n - 1

					'
					' Calculate real part
					'
					For k = 0 To m - 1
						work(k) = 0
					Next
					For k = 0 To n - 1
						v = q(i, k).x
						For i_ = 0 To m - 1
							work(i_) = work(i_) + v * t(k, i_)
						Next
					Next
					For k = 0 To m - 1
						z(i, k).x = work(k)
					Next

					'
					' Calculate imaginary part
					'
					For k = 0 To m - 1
						work(k) = 0
					Next
					For k = 0 To n - 1
						v = q(i, k).y
						For i_ = 0 To m - 1
							work(i_) = work(i_) + v * t(k, i_)
						Next
					Next
					For k = 0 To m - 1
						z(i, k).y = work(k)
					Next
				Next
			End If
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
'        matrix with given indexes by using bisection and inverse iteration methods
'
'        Input parameters:
'            A       -   Hermitian matrix which is given  by  its  upper  or  lower
'                        triangular part.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
'                        not. If ZNeeded is equal to:
'                         * 0, the eigenvectors are not returned;
'                         * 1, the eigenvectors are returned.
'            IsUpperA -  storage format of matrix A.
'            I1, I2 -    index interval for searching (from I1 to I2).
'                        0 <= I1 <= I2 <= N-1.
'
'        Output parameters:
'            W       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..I2-I1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains eigenvectors.
'                        Array whose indexes range within [0..N-1, 0..I2-I1].
'                        In  that  case,  the eigenvectors are stored in the matrix
'                        columns.
'
'        Result:
'            True, if successful. W contains the eigenvalues, Z contains the
'            eigenvectors (if needed).
'
'            False, if the bisection method subroutine  wasn't  able  to  find  the
'            eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
'            subroutine wasn't able to find  all  the  corresponding  eigenvectors.
'            In that case, the eigenvalues and eigenvectors are not returned.
'
'        Note:
'            eigen vectors of Hermitian matrix are defined up to multiplication  by
'            a complex number L, such as |L|=1.
'
'          -- ALGLIB --
'             Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
'        ************************************************************************

		Public Shared Function hmatrixevdi(a As complex(,), n As Integer, zneeded As Integer, isupper As Boolean, i1 As Integer, i2 As Integer, _
			ByRef w As Double(), ByRef z As complex(,)) As Boolean
			Dim result As New Boolean()
			Dim q As complex(,) = New complex(-1, -1) {}
			Dim t As Double(,) = New Double(-1, -1) {}
			Dim tau As complex() = New complex(-1) {}
			Dim e As Double() = New Double(-1) {}
			Dim work As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim m As Integer = 0
			Dim i_ As Integer = 0

			a = DirectCast(a.Clone(), complex(,))
			w = New Double(-1) {}
			z = New complex(-1, -1) {}

			alglib.ap.assert(zneeded = 0 OrElse zneeded = 1, "HermitianEigenValuesAndVectorsByIndexes: incorrect ZNeeded")

			'
			' Reduce to tridiagonal form
			'
			ortfac.hmatrixtd(a, n, isupper, tau, w, e)
			If zneeded = 1 Then
				ortfac.hmatrixtdunpackq(a, n, isupper, tau, q)
				zneeded = 2
			End If

			'
			' Bisection and inverse iteration
			'
			result = smatrixtdevdi(w, e, n, zneeded, i1, i2, _
				t)

			'
			' Eigenvectors are needed
			' Calculate Z = Q*T = Re(Q)*T + i*Im(Q)*T
			'
			m = i2 - i1 + 1
			If result AndAlso zneeded <> 0 Then
				work = New Double(m - 1) {}
				z = New complex(n - 1, m - 1) {}
				For i = 0 To n - 1

					'
					' Calculate real part
					'
					For k = 0 To m - 1
						work(k) = 0
					Next
					For k = 0 To n - 1
						v = q(i, k).x
						For i_ = 0 To m - 1
							work(i_) = work(i_) + v * t(k, i_)
						Next
					Next
					For k = 0 To m - 1
						z(i, k).x = work(k)
					Next

					'
					' Calculate imaginary part
					'
					For k = 0 To m - 1
						work(k) = 0
					Next
					For k = 0 To n - 1
						v = q(i, k).y
						For i_ = 0 To m - 1
							work(i_) = work(i_) + v * t(k, i_)
						Next
					Next
					For k = 0 To m - 1
						z(i, k).y = work(k)
					Next
				Next
			End If
			Return result
		End Function


		'************************************************************************
'        Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix
'
'        The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
'        using an QL/QR algorithm with implicit shifts.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            D       -   the main diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-1].
'            E       -   the secondary diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-2].
'            N       -   size of matrix A.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not needed;
'                         * 1, the eigenvectors of a tridiagonal matrix
'                           are multiplied by the square matrix Z. It is used if the
'                           tridiagonal matrix is obtained by the similarity
'                           transformation of a symmetric matrix;
'                         * 2, the eigenvectors of a tridiagonal matrix replace the
'                           square matrix Z;
'                         * 3, matrix Z contains the first row of the eigenvectors
'                           matrix.
'            Z       -   if ZNeeded=1, Z contains the square matrix by which the
'                        eigenvectors are multiplied.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'
'        Output parameters:
'            D       -   eigenvalues in ascending order.
'                        Array whose index ranges within [0..N-1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z hasn changed;
'                         * 1, Z contains the product of a given matrix (from the left)
'                           and the eigenvectors matrix (from the right);
'                         * 2, Z contains the eigenvectors.
'                         * 3, Z contains the first row of the eigenvectors matrix.
'                        If ZNeeded<3, Z is the array whose indexes range within [0..N-1, 0..N-1].
'                        In that case, the eigenvectors are stored in the matrix columns.
'                        If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].
'
'        Result:
'            True, if the algorithm has converged.
'            False, if the algorithm hasn't converged.
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             September 30, 1994
'        ************************************************************************

		Public Shared Function smatrixtdevd(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim d1 As Double() = New Double(-1) {}
			Dim e1 As Double() = New Double(-1) {}
			Dim ex As Double() = New Double(-1) {}
			Dim z1 As Double(,) = New Double(-1, -1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			e = DirectCast(e.Clone(), Double())

			alglib.ap.assert(n >= 1, "SMatrixTDEVD: N<=0")
			alglib.ap.assert(zneeded >= 0 AndAlso zneeded <= 3, "SMatrixTDEVD: incorrect ZNeeded")
			result = False

			'
			' Preprocess Z: make ZNeeded equal to 0, 1 or 3.
			' Ensure that memory for Z is allocated.
			'
			If zneeded = 2 Then

				'
				' Load identity to Z
				'
				apserv.rmatrixsetlengthatleast(z, n, n)
				For i = 0 To n - 1
					For j = 0 To n - 1
						z(i, j) = 0.0
					Next
					z(i, i) = 1.0
				Next
				zneeded = 1
			End If
			If zneeded = 3 Then

				'
				' Allocate memory
				'
				apserv.rmatrixsetlengthatleast(z, 1, n)
			End If

			'
			' Try to solve problem with MKL
			'
			ex = New Double(n - 1) {}
			For i = 0 To n - 2
				ex(i) = e(i)
			Next
			If ablasmkl.smatrixtdevdmkl(d, ex, n, zneeded, z, result) Then
				Return result
			End If

			'
			' Prepare 1-based task
			'
			d1 = New Double(n) {}
			e1 = New Double(n) {}
			i1_ = (0) - (1)
			For i_ = 1 To n
				d1(i_) = d(i_ + i1_)
			Next
			If n > 1 Then
				i1_ = (0) - (1)
				For i_ = 1 To n - 1
					e1(i_) = e(i_ + i1_)
				Next
			End If
			If zneeded = 1 Then
				z1 = New Double(n, n) {}
				For i = 1 To n
					i1_ = (0) - (1)
					For i_ = 1 To n
						z1(i, i_) = z(i - 1, i_ + i1_)
					Next
				Next
			End If

			'
			' Solve 1-based task
			'
			result = tridiagonalevd(d1, e1, n, zneeded, z1)
			If Not result Then
				Return result
			End If

			'
			' Convert back to 0-based result
			'
			i1_ = (1) - (0)
			For i_ = 0 To n - 1
				d(i_) = d1(i_ + i1_)
			Next
			If zneeded <> 0 Then
				If zneeded = 1 Then
					For i = 1 To n
						i1_ = (1) - (0)
						For i_ = 0 To n - 1
							z(i - 1, i_) = z1(i, i_ + i1_)
						Next
					Next
					Return result
				End If
				If zneeded = 2 Then
					z = New Double(n - 1, n - 1) {}
					For i = 1 To n
						i1_ = (1) - (0)
						For i_ = 0 To n - 1
							z(i - 1, i_) = z1(i, i_ + i1_)
						Next
					Next
					Return result
				End If
				If zneeded = 3 Then
					z = New Double(0, n - 1) {}
					i1_ = (1) - (0)
					For i_ = 0 To n - 1
						z(0, i_) = z1(1, i_ + i1_)
					Next
					Return result
				End If
				alglib.ap.assert(False, "SMatrixTDEVD: Incorrect ZNeeded!")
			End If
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
'        given half-interval (A, B] by using bisection and inverse iteration.
'
'        Input parameters:
'            D       -   the main diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-1].
'            E       -   the secondary diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-2].
'            N       -   size of matrix, N>=0.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not needed;
'                         * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                           by the square matrix Z. It is used if the tridiagonal
'                           matrix is obtained by the similarity transformation
'                           of a symmetric matrix.
'                         * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
'            A, B    -   half-interval (A, B] to search eigenvalues in.
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z isn't used and remains unchanged;
'                         * 1, Z contains the square matrix (array whose indexes range
'                           within [0..N-1, 0..N-1]) which reduces the given symmetric
'                           matrix to tridiagonal form;
'                         * 2, Z isn't used (but changed on the exit).
'
'        Output parameters:
'            D       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..M-1].
'            M       -   number of eigenvalues found in the given half-interval (M>=0).
'            Z       -   if ZNeeded is equal to:
'                         * 0, doesn't contain any information;
'                         * 1, contains the product of a given NxN matrix Z (from the
'                           left) and NxM matrix of the eigenvectors found (from the
'                           right). Array whose indexes range within [0..N-1, 0..M-1].
'                         * 2, contains the matrix of the eigenvectors found.
'                           Array whose indexes range within [0..N-1, 0..M-1].
'
'        Result:
'
'            True, if successful. In that case, M contains the number of eigenvalues
'            in the given half-interval (could be equal to 0), D contains the eigenvalues,
'            Z contains the eigenvectors (if needed).
'            It should be noted that the subroutine changes the size of arrays D and Z.
'
'            False, if the bisection method subroutine wasn't able to find the
'            eigenvalues in the given interval or if the inverse iteration subroutine
'            wasn't able to find all the corresponding eigenvectors. In that case,
'            the eigenvalues and eigenvectors are not returned, M is equal to 0.
'
'          -- ALGLIB --
'             Copyright 31.03.2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixtdevdr(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, a As Double, b As Double, _
			ByRef m As Integer, ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim errorcode As Integer = 0
			Dim nsplit As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim cr As Integer = 0
			Dim iblock As Integer() = New Integer(-1) {}
			Dim isplit As Integer() = New Integer(-1) {}
			Dim ifail As Integer() = New Integer(-1) {}
			Dim d1 As Double() = New Double(-1) {}
			Dim e1 As Double() = New Double(-1) {}
			Dim w As Double() = New Double(-1) {}
			Dim z2 As Double(,) = New Double(-1, -1) {}
			Dim z3 As Double(,) = New Double(-1, -1) {}
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			m = 0

			alglib.ap.assert(zneeded >= 0 AndAlso zneeded <= 2, "SMatrixTDEVDR: incorrect ZNeeded!")

			'
			' Special cases
			'
			If CDbl(b) <= CDbl(a) Then
				m = 0
				result = True
				Return result
			End If
			If n <= 0 Then
				m = 0
				result = True
				Return result
			End If

			'
			' Copy D,E to D1, E1
			'
			d1 = New Double(n) {}
			i1_ = (0) - (1)
			For i_ = 1 To n
				d1(i_) = d(i_ + i1_)
			Next
			If n > 1 Then
				e1 = New Double(n - 1) {}
				i1_ = (0) - (1)
				For i_ = 1 To n - 1
					e1(i_) = e(i_ + i1_)
				Next
			End If

			'
			' No eigen vectors
			'
			If zneeded = 0 Then
				result = internalbisectioneigenvalues(d1, e1, n, 2, 1, a, _
					b, 0, 0, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result OrElse m = 0 Then
					m = 0
					Return result
				End If
				d = New Double(m - 1) {}
				i1_ = (1) - (0)
				For i_ = 0 To m - 1
					d(i_) = w(i_ + i1_)
				Next
				Return result
			End If

			'
			' Eigen vectors are multiplied by Z
			'
			If zneeded = 1 Then

				'
				' Find eigen pairs
				'
				result = internalbisectioneigenvalues(d1, e1, n, 2, 2, a, _
					b, 0, 0, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result OrElse m = 0 Then
					m = 0
					Return result
				End If
				internaldstein(n, d1, e1, m, w, iblock, _
					isplit, z2, ifail, cr)
				If cr <> 0 Then
					m = 0
					result = False
					Return result
				End If

				'
				' Sort eigen values and vectors
				'
				For i = 1 To m
					k = i
					For j = i To m
						If CDbl(w(j)) < CDbl(w(k)) Then
							k = j
						End If
					Next
					v = w(i)
					w(i) = w(k)
					w(k) = v
					For j = 1 To n
						v = z2(j, i)
						z2(j, i) = z2(j, k)
						z2(j, k) = v
					Next
				Next

				'
				' Transform Z2 and overwrite Z
				'
				z3 = New Double(m, n) {}
				For i = 1 To m
					For i_ = 1 To n
						z3(i, i_) = z2(i_, i)
					Next
				Next
				For i = 1 To n
					For j = 1 To m
						i1_ = (1) - (0)
						v = 0.0
						For i_ = 0 To n - 1
							v += z(i - 1, i_) * z3(j, i_ + i1_)
						Next
						z2(i, j) = v
					Next
				Next
				z = New Double(n - 1, m - 1) {}
				For i = 1 To m
					i1_ = (1) - (0)
					For i_ = 0 To n - 1
						z(i_, i - 1) = z2(i_ + i1_, i)
					Next
				Next

				'
				' Store W
				'
				d = New Double(m - 1) {}
				For i = 1 To m
					d(i - 1) = w(i)
				Next
				Return result
			End If

			'
			' Eigen vectors are stored in Z
			'
			If zneeded = 2 Then

				'
				' Find eigen pairs
				'
				result = internalbisectioneigenvalues(d1, e1, n, 2, 2, a, _
					b, 0, 0, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result OrElse m = 0 Then
					m = 0
					Return result
				End If
				internaldstein(n, d1, e1, m, w, iblock, _
					isplit, z2, ifail, cr)
				If cr <> 0 Then
					m = 0
					result = False
					Return result
				End If

				'
				' Sort eigen values and vectors
				'
				For i = 1 To m
					k = i
					For j = i To m
						If CDbl(w(j)) < CDbl(w(k)) Then
							k = j
						End If
					Next
					v = w(i)
					w(i) = w(k)
					w(k) = v
					For j = 1 To n
						v = z2(j, i)
						z2(j, i) = z2(j, k)
						z2(j, k) = v
					Next
				Next

				'
				' Store W
				'
				d = New Double(m - 1) {}
				For i = 1 To m
					d(i - 1) = w(i)
				Next
				z = New Double(n - 1, m - 1) {}
				For i = 1 To m
					i1_ = (1) - (0)
					For i_ = 0 To n - 1
						z(i_, i - 1) = z2(i_ + i1_, i)
					Next
				Next
				Return result
			End If
			result = False
			Return result
		End Function


		'************************************************************************
'        Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
'        indexes (in ascending order) by using the bisection and inverse iteraion.
'
'        Input parameters:
'            D       -   the main diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-1].
'            E       -   the secondary diagonal of a tridiagonal matrix.
'                        Array whose index ranges within [0..N-2].
'            N       -   size of matrix. N>=0.
'            ZNeeded -   flag controlling whether the eigenvectors are needed or not.
'                        If ZNeeded is equal to:
'                         * 0, the eigenvectors are not needed;
'                         * 1, the eigenvectors of a tridiagonal matrix are multiplied
'                           by the square matrix Z. It is used if the
'                           tridiagonal matrix is obtained by the similarity transformation
'                           of a symmetric matrix.
'                         * 2, the eigenvectors of a tridiagonal matrix replace
'                           matrix Z.
'            I1, I2  -   index interval for searching (from I1 to I2).
'                        0 <= I1 <= I2 <= N-1.
'            Z       -   if ZNeeded is equal to:
'                         * 0, Z isn't used and remains unchanged;
'                         * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
'                           which reduces the given symmetric matrix to  tridiagonal form;
'                         * 2, Z isn't used (but changed on the exit).
'
'        Output parameters:
'            D       -   array of the eigenvalues found.
'                        Array whose index ranges within [0..I2-I1].
'            Z       -   if ZNeeded is equal to:
'                         * 0, doesn't contain any information;
'                         * 1, contains the product of a given NxN matrix Z (from the left) and
'                           Nx(I2-I1) matrix of the eigenvectors found (from the right).
'                           Array whose indexes range within [0..N-1, 0..I2-I1].
'                         * 2, contains the matrix of the eigenvalues found.
'                           Array whose indexes range within [0..N-1, 0..I2-I1].
'
'
'        Result:
'
'            True, if successful. In that case, D contains the eigenvalues,
'            Z contains the eigenvectors (if needed).
'            It should be noted that the subroutine changes the size of arrays D and Z.
'
'            False, if the bisection method subroutine wasn't able to find the eigenvalues
'            in the given interval or if the inverse iteration subroutine wasn't able
'            to find all the corresponding eigenvectors. In that case, the eigenvalues
'            and eigenvectors are not returned.
'
'          -- ALGLIB --
'             Copyright 25.12.2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixtdevdi(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, i1 As Integer, i2 As Integer, _
			ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim errorcode As Integer = 0
			Dim nsplit As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim m As Integer = 0
			Dim cr As Integer = 0
			Dim iblock As Integer() = New Integer(-1) {}
			Dim isplit As Integer() = New Integer(-1) {}
			Dim ifail As Integer() = New Integer(-1) {}
			Dim w As Double() = New Double(-1) {}
			Dim d1 As Double() = New Double(-1) {}
			Dim e1 As Double() = New Double(-1) {}
			Dim z2 As Double(,) = New Double(-1, -1) {}
			Dim z3 As Double(,) = New Double(-1, -1) {}
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert((0 <= i1 AndAlso i1 <= i2) AndAlso i2 < n, "SMatrixTDEVDI: incorrect I1/I2!")

			'
			' Copy D,E to D1, E1
			'
			d1 = New Double(n) {}
			i1_ = (0) - (1)
			For i_ = 1 To n
				d1(i_) = d(i_ + i1_)
			Next
			If n > 1 Then
				e1 = New Double(n - 1) {}
				i1_ = (0) - (1)
				For i_ = 1 To n - 1
					e1(i_) = e(i_ + i1_)
				Next
			End If

			'
			' No eigen vectors
			'
			If zneeded = 0 Then
				result = internalbisectioneigenvalues(d1, e1, n, 3, 1, 0, _
					0, i1 + 1, i2 + 1, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result Then
					Return result
				End If
				If m <> i2 - i1 + 1 Then
					result = False
					Return result
				End If
				d = New Double(m - 1) {}
				For i = 1 To m
					d(i - 1) = w(i)
				Next
				Return result
			End If

			'
			' Eigen vectors are multiplied by Z
			'
			If zneeded = 1 Then

				'
				' Find eigen pairs
				'
				result = internalbisectioneigenvalues(d1, e1, n, 3, 2, 0, _
					0, i1 + 1, i2 + 1, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result Then
					Return result
				End If
				If m <> i2 - i1 + 1 Then
					result = False
					Return result
				End If
				internaldstein(n, d1, e1, m, w, iblock, _
					isplit, z2, ifail, cr)
				If cr <> 0 Then
					result = False
					Return result
				End If

				'
				' Sort eigen values and vectors
				'
				For i = 1 To m
					k = i
					For j = i To m
						If CDbl(w(j)) < CDbl(w(k)) Then
							k = j
						End If
					Next
					v = w(i)
					w(i) = w(k)
					w(k) = v
					For j = 1 To n
						v = z2(j, i)
						z2(j, i) = z2(j, k)
						z2(j, k) = v
					Next
				Next

				'
				' Transform Z2 and overwrite Z
				'
				z3 = New Double(m, n) {}
				For i = 1 To m
					For i_ = 1 To n
						z3(i, i_) = z2(i_, i)
					Next
				Next
				For i = 1 To n
					For j = 1 To m
						i1_ = (1) - (0)
						v = 0.0
						For i_ = 0 To n - 1
							v += z(i - 1, i_) * z3(j, i_ + i1_)
						Next
						z2(i, j) = v
					Next
				Next
				z = New Double(n - 1, m - 1) {}
				For i = 1 To m
					i1_ = (1) - (0)
					For i_ = 0 To n - 1
						z(i_, i - 1) = z2(i_ + i1_, i)
					Next
				Next

				'
				' Store W
				'
				d = New Double(m - 1) {}
				For i = 1 To m
					d(i - 1) = w(i)
				Next
				Return result
			End If

			'
			' Eigen vectors are stored in Z
			'
			If zneeded = 2 Then

				'
				' Find eigen pairs
				'
				result = internalbisectioneigenvalues(d1, e1, n, 3, 2, 0, _
					0, i1 + 1, i2 + 1, -1, w, m, _
					nsplit, iblock, isplit, errorcode)
				If Not result Then
					Return result
				End If
				If m <> i2 - i1 + 1 Then
					result = False
					Return result
				End If
				internaldstein(n, d1, e1, m, w, iblock, _
					isplit, z2, ifail, cr)
				If cr <> 0 Then
					result = False
					Return result
				End If

				'
				' Sort eigen values and vectors
				'
				For i = 1 To m
					k = i
					For j = i To m
						If CDbl(w(j)) < CDbl(w(k)) Then
							k = j
						End If
					Next
					v = w(i)
					w(i) = w(k)
					w(k) = v
					For j = 1 To n
						v = z2(j, i)
						z2(j, i) = z2(j, k)
						z2(j, k) = v
					Next
				Next

				'
				' Store Z
				'
				z = New Double(n - 1, m - 1) {}
				For i = 1 To m
					i1_ = (1) - (0)
					For i_ = 0 To n - 1
						z(i_, i - 1) = z2(i_ + i1_, i)
					Next
				Next

				'
				' Store W
				'
				d = New Double(m - 1) {}
				For i = 1 To m
					d(i - 1) = w(i)
				Next
				Return result
			End If
			result = False
			Return result
		End Function


		'************************************************************************
'        Finding eigenvalues and eigenvectors of a general (unsymmetric) matrix
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison. Speed-up provided by MKL for this particular problem (EVD)
'          ! is really high, because  MKL  uses combination of (a) better low-level
'          ! optimizations, and (b) better EVD algorithms.
'          !
'          ! On one particular SSE-capable  machine  for  N=1024,  commercial  MKL-
'          ! -capable ALGLIB was:
'          ! * 7-10 times faster than open source "generic C" version
'          ! * 15-18 times faster than "pure C#" version
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        The algorithm finds eigenvalues and eigenvectors of a general matrix by
'        using the QR algorithm with multiple shifts. The algorithm can find
'        eigenvalues and both left and right eigenvectors.
'
'        The right eigenvector is a vector x such that A*x = w*x, and the left
'        eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
'        conjugate transposition of vector y).
'
'        Input parameters:
'            A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            VNeeded -   flag controlling whether eigenvectors are needed or not.
'                        If VNeeded is equal to:
'                         * 0, eigenvectors are not returned;
'                         * 1, right eigenvectors are returned;
'                         * 2, left eigenvectors are returned;
'                         * 3, both left and right eigenvectors are returned.
'
'        Output parameters:
'            WR      -   real parts of eigenvalues.
'                        Array whose index ranges within [0..N-1].
'            WR      -   imaginary parts of eigenvalues.
'                        Array whose index ranges within [0..N-1].
'            VL, VR  -   arrays of left and right eigenvectors (if they are needed).
'                        If WI[i]=0, the respective eigenvalue is a real number,
'                        and it corresponds to the column number I of matrices VL/VR.
'                        If WI[i]>0, we have a pair of complex conjugate numbers with
'                        positive and negative imaginary parts:
'                            the first eigenvalue WR[i] + sqrt(-1)*WI[i];
'                            the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
'                            WI[i]>0
'                            WI[i+1] = -WI[i] < 0
'                        In that case, the eigenvector  corresponding to the first
'                        eigenvalue is located in i and i+1 columns of matrices
'                        VL/VR (the column number i contains the real part, and the
'                        column number i+1 contains the imaginary part), and the vector
'                        corresponding to the second eigenvalue is a complex conjugate to
'                        the first vector.
'                        Arrays whose indexes range within [0..N-1, 0..N-1].
'
'        Result:
'            True, if the algorithm has converged.
'            False, if the algorithm has not converged.
'
'        Note 1:
'            Some users may ask the following question: what if WI[N-1]>0?
'            WI[N] must contain an eigenvalue which is complex conjugate to the
'            N-th eigenvalue, but the array has only size N?
'            The answer is as follows: such a situation cannot occur because the
'            algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is
'            strictly less than N-1.
'
'        Note 2:
'            The algorithm performance depends on the value of the internal parameter
'            NS of the InternalSchurDecomposition subroutine which defines the number
'            of shifts in the QR algorithm (similarly to the block width in block-matrix
'            algorithms of linear algebra). If you require maximum performance
'            on your machine, it is recommended to adjust this parameter manually.
'
'
'        See also the InternalTREVC subroutine.
'
'        The algorithm is based on the LAPACK 3.0 library.
'        ************************************************************************

		Public Shared Function rmatrixevd(a As Double(,), n As Integer, vneeded As Integer, ByRef wr As Double(), ByRef wi As Double(), ByRef vl As Double(,), _
			ByRef vr As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim a1 As Double(,) = New Double(-1, -1) {}
			Dim vl1 As Double(,) = New Double(-1, -1) {}
			Dim vr1 As Double(,) = New Double(-1, -1) {}
			Dim s1 As Double(,) = New Double(-1, -1) {}
			Dim s As Double(,) = New Double(-1, -1) {}
			Dim dummy As Double(,) = New Double(-1, -1) {}
			Dim wr1 As Double() = New Double(-1) {}
			Dim wi1 As Double() = New Double(-1) {}
			Dim tau As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim info As Integer = 0
			Dim sel1 As Boolean() = New Boolean(-1) {}
			Dim m1 As Integer = 0
			Dim i_ As Integer = 0

			a = DirectCast(a.Clone(), Double(,))
			wr = New Double(-1) {}
			wi = New Double(-1) {}
			vl = New Double(-1, -1) {}
			vr = New Double(-1, -1) {}

			alglib.ap.assert(vneeded >= 0 AndAlso vneeded <= 3, "RMatrixEVD: incorrect VNeeded!")
			If vneeded = 0 Then

				'
				' Eigen values only
				'
				ortfac.rmatrixhessenberg(a, n, tau)
				hsschur.rmatrixinternalschurdecomposition(a, n, 0, 0, wr, wi, _
					dummy, info)
				result = info = 0
				Return result
			End If

			'
			' Eigen values and vectors
			'
			ortfac.rmatrixhessenberg(a, n, tau)
			ortfac.rmatrixhessenbergunpackq(a, n, tau, s)
			hsschur.rmatrixinternalschurdecomposition(a, n, 1, 1, wr, wi, _
				s, info)
			result = info = 0
			If Not result Then
				Return result
			End If
			If vneeded = 1 OrElse vneeded = 3 Then
				vr = New Double(n - 1, n - 1) {}
				For i = 0 To n - 1
					For i_ = 0 To n - 1
						vr(i, i_) = s(i, i_)
					Next
				Next
			End If
			If vneeded = 2 OrElse vneeded = 3 Then
				vl = New Double(n - 1, n - 1) {}
				For i = 0 To n - 1
					For i_ = 0 To n - 1
						vl(i, i_) = s(i, i_)
					Next
				Next
			End If
			rmatrixinternaltrevc(a, n, vneeded, 1, sel1, vl, _
				vr, m1, info)
			result = info = 0
			Return result
		End Function


		Private Shared Function tridiagonalevd(ByRef d As Double(), e As Double(), n As Integer, zneeded As Integer, ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim maxit As Integer = 0
			Dim i As Integer = 0
			Dim ii As Integer = 0
			Dim iscale As Integer = 0
			Dim j As Integer = 0
			Dim jtot As Integer = 0
			Dim k As Integer = 0
			Dim t As Integer = 0
			Dim l As Integer = 0
			Dim l1 As Integer = 0
			Dim lend As Integer = 0
			Dim lendm1 As Integer = 0
			Dim lendp1 As Integer = 0
			Dim lendsv As Integer = 0
			Dim lm1 As Integer = 0
			Dim lsv As Integer = 0
			Dim m As Integer = 0
			Dim mm1 As Integer = 0
			Dim nm1 As Integer = 0
			Dim nmaxit As Integer = 0
			Dim tmpint As Integer = 0
			Dim anorm As Double = 0
			Dim b As Double = 0
			Dim c As Double = 0
			Dim eps As Double = 0
			Dim eps2 As Double = 0
			Dim f As Double = 0
			Dim g As Double = 0
			Dim p As Double = 0
			Dim r As Double = 0
			Dim rt1 As Double = 0
			Dim rt2 As Double = 0
			Dim s As Double = 0
			Dim safmax As Double = 0
			Dim safmin As Double = 0
			Dim ssfmax As Double = 0
			Dim ssfmin As Double = 0
			Dim tst As Double = 0
			Dim tmp As Double = 0
			Dim work1 As Double() = New Double(-1) {}
			Dim work2 As Double() = New Double(-1) {}
			Dim workc As Double() = New Double(-1) {}
			Dim works As Double() = New Double(-1) {}
			Dim wtemp As Double() = New Double(-1) {}
			Dim gotoflag As New Boolean()
			Dim zrows As Integer = 0
			Dim wastranspose As New Boolean()
			Dim i_ As Integer = 0

			e = DirectCast(e.Clone(), Double())

			alglib.ap.assert(zneeded >= 0 AndAlso zneeded <= 3, "TridiagonalEVD: Incorrent ZNeeded")

			'
			' Quick return if possible
			'
			If zneeded < 0 OrElse zneeded > 3 Then
				result = False
				Return result
			End If
			result = True
			If n = 0 Then
				Return result
			End If
			If n = 1 Then
				If zneeded = 2 OrElse zneeded = 3 Then
					z = New Double(1, 1) {}
					z(1, 1) = 1
				End If
				Return result
			End If
			maxit = 30

			'
			' Initialize arrays
			'
			wtemp = New Double(n) {}
			work1 = New Double(n - 1) {}
			work2 = New Double(n - 1) {}
			workc = New Double(n) {}
			works = New Double(n) {}

			'
			' Determine the unit roundoff and over/underflow thresholds.
			'
			eps = Math.machineepsilon
			eps2 = Math.sqr(eps)
			safmin = Math.minrealnumber
            safmax = Math.maxrealnumber
            ssfmax = System.Math.sqrt(safmax) / 3
            ssfmin = System.Math.sqrt(safmin) / eps2

            '
            ' Prepare Z
            '
            ' Here we are using transposition to get rid of column operations
            '
            '
            wastranspose = False
            zrows = 0
            If zneeded = 1 Then
                zrows = n
            End If
            If zneeded = 2 Then
                zrows = n
            End If
            If zneeded = 3 Then
                zrows = 1
            End If
            If zneeded = 1 Then
                wastranspose = True
                blas.inplacetranspose(z, 1, n, 1, n, wtemp)
            End If
            If zneeded = 2 Then
                wastranspose = True
                z = New Double(n, n) {}
                For i = 1 To n
                    For j = 1 To n
                        If i = j Then
                            z(i, j) = 1
                        Else
                            z(i, j) = 0
                        End If
                    Next
                Next
            End If
            If zneeded = 3 Then
                wastranspose = False
                z = New Double(1, n) {}
                For j = 1 To n
                    If j = 1 Then
                        z(1, j) = 1
                    Else
                        z(1, j) = 0
                    End If
                Next
            End If
            nmaxit = n * maxit
            jtot = 0

            '
            ' Determine where the matrix splits and choose QL or QR iteration
            ' for each block, according to whether top or bottom diagonal
            ' element is smaller.
            '
            l1 = 1
            nm1 = n - 1
            While True
                If l1 > n Then
                    Exit While
                End If
                If l1 > 1 Then
                    e(l1 - 1) = 0
                End If
                gotoflag = False
                m = l1
                If l1 <= nm1 Then
                    For m = l1 To nm1
                        tst = System.Math.Abs(e(m))
                        If CDbl(tst) = CDbl(0) Then
                            gotoflag = True
                            Exit For
                        End If
                        If CDbl(tst) <= CDbl(System.Math.sqrt(System.Math.Abs(d(m))) * System.Math.sqrt(System.Math.Abs(d(m + 1))) * eps) Then
                            e(m) = 0
                            gotoflag = True
                            Exit For
                        End If
                    Next
                End If
                If Not gotoflag Then
                    m = n
                End If

                '
                ' label 30:
                '
                l = l1
                lsv = l
                lend = m
                lendsv = lend
                l1 = m + 1
                If lend = l Then
                    Continue While
                End If

                '
                ' Scale submatrix in rows and columns L to LEND
                '
                If l = lend Then
                    anorm = System.Math.Abs(d(l))
                Else
                    anorm = System.Math.Max(System.Math.Abs(d(l)) + System.Math.Abs(e(l)), System.Math.Abs(e(lend - 1)) + System.Math.Abs(d(lend)))
                    For i = l + 1 To lend - 1
                        anorm = System.Math.Max(anorm, System.Math.Abs(d(i)) + System.Math.Abs(e(i)) + System.Math.Abs(e(i - 1)))
                    Next
                End If
                iscale = 0
                If CDbl(anorm) = CDbl(0) Then
                    Continue While
                End If
                If CDbl(anorm) > CDbl(ssfmax) Then
                    iscale = 1
                    tmp = ssfmax / anorm
                    tmpint = lend - 1
                    For i_ = l To lend
                        d(i_) = tmp * d(i_)
                    Next
                    For i_ = l To tmpint
                        e(i_) = tmp * e(i_)
                    Next
                End If
                If CDbl(anorm) < CDbl(ssfmin) Then
                    iscale = 2
                    tmp = ssfmin / anorm
                    tmpint = lend - 1
                    For i_ = l To lend
                        d(i_) = tmp * d(i_)
                    Next
                    For i_ = l To tmpint
                        e(i_) = tmp * e(i_)
                    Next
                End If

                '
                ' Choose between QL and QR iteration
                '
                If CDbl(System.Math.Abs(d(lend))) < CDbl(System.Math.Abs(d(l))) Then
                    lend = lsv
                    l = lendsv
                End If
                If lend > l Then

                    '
                    ' QL Iteration
                    '
                    ' Look for small subdiagonal element.
                    '
                    While True
                        gotoflag = False
                        If l <> lend Then
                            lendm1 = lend - 1
                            For m = l To lendm1
                                tst = Math.sqr(System.Math.Abs(e(m)))
                                If CDbl(tst) <= CDbl(eps2 * System.Math.Abs(d(m)) * System.Math.Abs(d(m + 1)) + safmin) Then
                                    gotoflag = True
                                    Exit For
                                End If
                            Next
                        End If
                        If Not gotoflag Then
                            m = lend
                        End If
                        If m < lend Then
                            e(m) = 0
                        End If
                        p = d(l)
                        If m <> l Then

                            '
                            ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                            ' to compute its eigensystem.
                            '
                            If m = l + 1 Then
                                If zneeded > 0 Then
                                    tdevdev2(d(l), e(l), d(l + 1), rt1, rt2, c, _
                                        s)
                                    work1(l) = c
                                    work2(l) = s
                                    workc(1) = work1(l)
                                    works(1) = work2(l)
                                    If Not wastranspose Then
                                        rotations.applyrotationsfromtheright(False, 1, zrows, l, l + 1, workc, _
                                            works, z, wtemp)
                                    Else
                                        rotations.applyrotationsfromtheleft(False, l, l + 1, 1, zrows, workc, _
                                            works, z, wtemp)
                                    End If
                                Else
                                    tdevde2(d(l), e(l), d(l + 1), rt1, rt2)
                                End If
                                d(l) = rt1
                                d(l + 1) = rt2
                                e(l) = 0
                                l = l + 2
                                If l <= lend Then
                                    Continue While
                                End If

                                '
                                ' GOTO 140
                                '
                                Exit While
                            End If
                            If jtot = nmaxit Then

                                '
                                ' GOTO 140
                                '
                                Exit While
                            End If
                            jtot = jtot + 1

                            '
                            ' Form shift.
                            '
                            g = (d(l + 1) - p) / (2 * e(l))
                            r = tdevdpythag(g, 1)
                            g = d(m) - p + e(l) / (g + tdevdextsign(r, g))
                            s = 1
                            c = 1
                            p = 0

                            '
                            ' Inner loop
                            '
                            mm1 = m - 1
                            For i = mm1 To l Step -1
                                f = s * e(i)
                                b = c * e(i)
                                rotations.generaterotation(g, f, c, s, r)
                                If i <> m - 1 Then
                                    e(i + 1) = r
                                End If
                                g = d(i + 1) - p
                                r = (d(i) - g) * s + 2 * c * b
                                p = s * r
                                d(i + 1) = g + p
                                g = c * r - b

                                '
                                ' If eigenvectors are desired, then save rotations.
                                '
                                If zneeded > 0 Then
                                    work1(i) = c
                                    work2(i) = -s
                                End If
                            Next

                            '
                            ' If eigenvectors are desired, then apply saved rotations.
                            '
                            If zneeded > 0 Then
                                For i = l To m - 1
                                    workc(i - l + 1) = work1(i)
                                    works(i - l + 1) = work2(i)
                                Next
                                If Not wastranspose Then
                                    rotations.applyrotationsfromtheright(False, 1, zrows, l, m, workc, _
                                        works, z, wtemp)
                                Else
                                    rotations.applyrotationsfromtheleft(False, l, m, 1, zrows, workc, _
                                        works, z, wtemp)
                                End If
                            End If
                            d(l) = d(l) - p
                            e(l) = g
                            Continue While
                        End If

                        '
                        ' Eigenvalue found.
                        '
                        d(l) = p
                        l = l + 1
                        If l <= lend Then
                            Continue While
                        End If
                        Exit While
                    End While
                Else

                    '
                    ' QR Iteration
                    '
                    ' Look for small superdiagonal element.
                    '
                    While True
                        gotoflag = False
                        If l <> lend Then
                            lendp1 = lend + 1
                            For m = l To lendp1 Step -1
                                tst = Math.sqr(System.Math.Abs(e(m - 1)))
                                If CDbl(tst) <= CDbl(eps2 * System.Math.Abs(d(m)) * System.Math.Abs(d(m - 1)) + safmin) Then
                                    gotoflag = True
                                    Exit For
                                End If
                            Next
                        End If
                        If Not gotoflag Then
                            m = lend
                        End If
                        If m > lend Then
                            e(m - 1) = 0
                        End If
                        p = d(l)
                        If m <> l Then

                            '
                            ' If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
                            ' to compute its eigensystem.
                            '
                            If m = l - 1 Then
                                If zneeded > 0 Then
                                    tdevdev2(d(l - 1), e(l - 1), d(l), rt1, rt2, c, _
                                        s)
                                    work1(m) = c
                                    work2(m) = s
                                    workc(1) = c
                                    works(1) = s
                                    If Not wastranspose Then
                                        rotations.applyrotationsfromtheright(True, 1, zrows, l - 1, l, workc, _
                                            works, z, wtemp)
                                    Else
                                        rotations.applyrotationsfromtheleft(True, l - 1, l, 1, zrows, workc, _
                                            works, z, wtemp)
                                    End If
                                Else
                                    tdevde2(d(l - 1), e(l - 1), d(l), rt1, rt2)
                                End If
                                d(l - 1) = rt1
                                d(l) = rt2
                                e(l - 1) = 0
                                l = l - 2
                                If l >= lend Then
                                    Continue While
                                End If
                                Exit While
                            End If
                            If jtot = nmaxit Then
                                Exit While
                            End If
                            jtot = jtot + 1

                            '
                            ' Form shift.
                            '
                            g = (d(l - 1) - p) / (2 * e(l - 1))
                            r = tdevdpythag(g, 1)
                            g = d(m) - p + e(l - 1) / (g + tdevdextsign(r, g))
                            s = 1
                            c = 1
                            p = 0

                            '
                            ' Inner loop
                            '
                            lm1 = l - 1
                            For i = m To lm1
                                f = s * e(i)
                                b = c * e(i)
                                rotations.generaterotation(g, f, c, s, r)
                                If i <> m Then
                                    e(i - 1) = r
                                End If
                                g = d(i) - p
                                r = (d(i + 1) - g) * s + 2 * c * b
                                p = s * r
                                d(i) = g + p
                                g = c * r - b

                                '
                                ' If eigenvectors are desired, then save rotations.
                                '
                                If zneeded > 0 Then
                                    work1(i) = c
                                    work2(i) = s
                                End If
                            Next

                            '
                            ' If eigenvectors are desired, then apply saved rotations.
                            '
                            If zneeded > 0 Then
                                For i = m To l - 1
                                    workc(i - m + 1) = work1(i)
                                    works(i - m + 1) = work2(i)
                                Next
                                If Not wastranspose Then
                                    rotations.applyrotationsfromtheright(True, 1, zrows, m, l, workc, _
                                        works, z, wtemp)
                                Else
                                    rotations.applyrotationsfromtheleft(True, m, l, 1, zrows, workc, _
                                        works, z, wtemp)
                                End If
                            End If
                            d(l) = d(l) - p
                            e(lm1) = g
                            Continue While
                        End If

                        '
                        ' Eigenvalue found.
                        '
                        d(l) = p
                        l = l - 1
                        If l >= lend Then
                            Continue While
                        End If
                        Exit While
                    End While
                End If

                '
                ' Undo scaling if necessary
                '
                If iscale = 1 Then
                    tmp = anorm / ssfmax
                    tmpint = lendsv - 1
                    For i_ = lsv To lendsv
                        d(i_) = tmp * d(i_)
                    Next
                    For i_ = lsv To tmpint
                        e(i_) = tmp * e(i_)
                    Next
                End If
                If iscale = 2 Then
                    tmp = anorm / ssfmin
                    tmpint = lendsv - 1
                    For i_ = lsv To lendsv
                        d(i_) = tmp * d(i_)
                    Next
                    For i_ = lsv To tmpint
                        e(i_) = tmp * e(i_)
                    Next
                End If

                '
                ' Check for no convergence to an eigenvalue after a total
                ' of N*MAXIT iterations.
                '
                If jtot >= nmaxit Then
                    result = False
                    If wastranspose Then
                        blas.inplacetranspose(z, 1, n, 1, n, wtemp)
                    End If
                    Return result
                End If
            End While

            '
            ' Order eigenvalues and eigenvectors.
            '
            If zneeded = 0 Then

                '
                ' Sort
                '
                If n = 1 Then
                    Return result
                End If
                If n = 2 Then
                    If CDbl(d(1)) > CDbl(d(2)) Then
                        tmp = d(1)
                        d(1) = d(2)
                        d(2) = tmp
                    End If
                    Return result
                End If
                i = 2
                Do
                    t = i
                    While t <> 1
                        k = t \ 2
                        If CDbl(d(k)) >= CDbl(d(t)) Then
                            t = 1
                        Else
                            tmp = d(k)
                            d(k) = d(t)
                            d(t) = tmp
                            t = k
                        End If
                    End While
                    i = i + 1
                Loop While i <= n
                i = n - 1
                Do
                    tmp = d(i + 1)
                    d(i + 1) = d(1)
                    d(1) = tmp
                    t = 1
                    While t <> 0
                        k = 2 * t
                        If k > i Then
                            t = 0
                        Else
                            If k < i Then
                                If CDbl(d(k + 1)) > CDbl(d(k)) Then
                                    k = k + 1
                                End If
                            End If
                            If CDbl(d(t)) >= CDbl(d(k)) Then
                                t = 0
                            Else
                                tmp = d(k)
                                d(k) = d(t)
                                d(t) = tmp
                                t = k
                            End If
                        End If
                    End While
                    i = i - 1
                Loop While i >= 1
            Else

                '
                ' Use Selection Sort to minimize swaps of eigenvectors
                '
                For ii = 2 To n
                    i = ii - 1
                    k = i
                    p = d(i)
                    For j = ii To n
                        If CDbl(d(j)) < CDbl(p) Then
                            k = j
                            p = d(j)
                        End If
                    Next
                    If k <> i Then
                        d(k) = d(i)
                        d(i) = p
                        If wastranspose Then
                            For i_ = 1 To n
                                wtemp(i_) = z(i, i_)
                            Next
                            For i_ = 1 To n
                                z(i, i_) = z(k, i_)
                            Next
                            For i_ = 1 To n
                                z(k, i_) = wtemp(i_)
                            Next
                        Else
                            For i_ = 1 To zrows
                                wtemp(i_) = z(i_, i)
                            Next
                            For i_ = 1 To zrows
                                z(i_, i) = z(i_, k)
                            Next
                            For i_ = 1 To zrows
                                z(i_, k) = wtemp(i_)
                            Next
                        End If
                    End If
                Next
                If wastranspose Then
                    blas.inplacetranspose(z, 1, n, 1, n, wtemp)
                End If
            End If
            Return result
        End Function


        '************************************************************************
        '        DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
        '           [  A   B  ]
        '           [  B   C  ].
        '        On return, RT1 is the eigenvalue of larger absolute value, and RT2
        '        is the eigenvalue of smaller absolute value.
        '
        '          -- LAPACK auxiliary routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             October 31, 1992
        '        ************************************************************************

        Private Shared Sub tdevde2(a As Double, b As Double, c As Double, ByRef rt1 As Double, ByRef rt2 As Double)
            Dim ab As Double = 0
            Dim acmn As Double = 0
            Dim acmx As Double = 0
            Dim adf As Double = 0
            Dim df As Double = 0
            Dim rt As Double = 0
            Dim sm As Double = 0
            Dim tb As Double = 0

            rt1 = 0
            rt2 = 0

            sm = a + c
            df = a - c
            adf = System.Math.Abs(df)
            tb = b + b
            ab = System.Math.Abs(tb)
            If CDbl(System.Math.Abs(a)) > CDbl(System.Math.Abs(c)) Then
                acmx = a
                acmn = c
            Else
                acmx = c
                acmn = a
            End If
            If CDbl(adf) > CDbl(ab) Then
                rt = adf * System.Math.sqrt(1 + Math.sqr(ab / adf))
            Else
                If CDbl(adf) < CDbl(ab) Then
                    rt = ab * System.Math.sqrt(1 + Math.sqr(adf / ab))
                Else

                    '
                    ' Includes case AB=ADF=0
                    '
                    rt = ab * System.Math.sqrt(2)
                End If
            End If
            If CDbl(sm) < CDbl(0) Then
                rt1 = 0.5 * (sm - rt)

                '
                ' Order of execution important.
                ' To get fully accurate smaller eigenvalue,
                ' next line needs to be executed in higher precision.
                '
                rt2 = acmx / rt1 * acmn - b / rt1 * b
            Else
                If CDbl(sm) > CDbl(0) Then
                    rt1 = 0.5 * (sm + rt)

                    '
                    ' Order of execution important.
                    ' To get fully accurate smaller eigenvalue,
                    ' next line needs to be executed in higher precision.
                    '
                    rt2 = acmx / rt1 * acmn - b / rt1 * b
                Else

                    '
                    ' Includes case RT1 = RT2 = 0
                    '
                    rt1 = 0.5 * rt
                    rt2 = -(0.5 * rt)
                End If
            End If
        End Sub


        '************************************************************************
        '        DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
        '
        '           [  A   B  ]
        '           [  B   C  ].
        '
        '        On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
        '        eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
        '        eigenvector for RT1, giving the decomposition
        '
        '           [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
        '           [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
        '
        '
        '          -- LAPACK auxiliary routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             October 31, 1992
        '        ************************************************************************

        Private Shared Sub tdevdev2(a As Double, b As Double, c As Double, ByRef rt1 As Double, ByRef rt2 As Double, ByRef cs1 As Double, _
            ByRef sn1 As Double)
            Dim sgn1 As Integer = 0
            Dim sgn2 As Integer = 0
            Dim ab As Double = 0
            Dim acmn As Double = 0
            Dim acmx As Double = 0
            Dim acs As Double = 0
            Dim adf As Double = 0
            Dim cs As Double = 0
            Dim ct As Double = 0
            Dim df As Double = 0
            Dim rt As Double = 0
            Dim sm As Double = 0
            Dim tb As Double = 0
            Dim tn As Double = 0

            rt1 = 0
            rt2 = 0
            cs1 = 0
            sn1 = 0


            '
            ' Compute the eigenvalues
            '
            sm = a + c
            df = a - c
            adf = System.Math.Abs(df)
            tb = b + b
            ab = System.Math.Abs(tb)
            If CDbl(System.Math.Abs(a)) > CDbl(System.Math.Abs(c)) Then
                acmx = a
                acmn = c
            Else
                acmx = c
                acmn = a
            End If
            If CDbl(adf) > CDbl(ab) Then
                rt = adf * System.Math.sqrt(1 + Math.sqr(ab / adf))
            Else
                If CDbl(adf) < CDbl(ab) Then
                    rt = ab * System.Math.sqrt(1 + Math.sqr(adf / ab))
                Else

                    '
                    ' Includes case AB=ADF=0
                    '
                    rt = ab * System.Math.sqrt(2)
                End If
            End If
            If CDbl(sm) < CDbl(0) Then
                rt1 = 0.5 * (sm - rt)
                sgn1 = -1

                '
                ' Order of execution important.
                ' To get fully accurate smaller eigenvalue,
                ' next line needs to be executed in higher precision.
                '
                rt2 = acmx / rt1 * acmn - b / rt1 * b
            Else
                If CDbl(sm) > CDbl(0) Then
                    rt1 = 0.5 * (sm + rt)
                    sgn1 = 1

                    '
                    ' Order of execution important.
                    ' To get fully accurate smaller eigenvalue,
                    ' next line needs to be executed in higher precision.
                    '
                    rt2 = acmx / rt1 * acmn - b / rt1 * b
                Else

                    '
                    ' Includes case RT1 = RT2 = 0
                    '
                    rt1 = 0.5 * rt
                    rt2 = -(0.5 * rt)
                    sgn1 = 1
                End If
            End If

            '
            ' Compute the eigenvector
            '
            If CDbl(df) >= CDbl(0) Then
                cs = df + rt
                sgn2 = 1
            Else
                cs = df - rt
                sgn2 = -1
            End If
            acs = System.Math.Abs(cs)
            If CDbl(acs) > CDbl(ab) Then
                ct = -(tb / cs)
                sn1 = 1 / System.Math.sqrt(1 + ct * ct)
                cs1 = ct * sn1
            Else
                If CDbl(ab) = CDbl(0) Then
                    cs1 = 1
                    sn1 = 0
                Else
                    tn = -(cs / tb)
                    cs1 = 1 / System.Math.sqrt(1 + tn * tn)
                    sn1 = tn * cs1
                End If
            End If
            If sgn1 = sgn2 Then
                tn = cs1
                cs1 = -sn1
                sn1 = tn
            End If
        End Sub


        '************************************************************************
        '        Internal routine
        '        ************************************************************************

        Private Shared Function tdevdpythag(a As Double, b As Double) As Double
            Dim result As Double = 0

            If CDbl(System.Math.Abs(a)) < CDbl(System.Math.Abs(b)) Then
                result = System.Math.Abs(b) * System.Math.sqrt(1 + Math.sqr(a / b))
            Else
                result = System.Math.Abs(a) * System.Math.sqrt(1 + Math.sqr(b / a))
            End If
            Return result
        End Function


        '************************************************************************
        '        Internal routine
        '        ************************************************************************

        Private Shared Function tdevdextsign(a As Double, b As Double) As Double
            Dim result As Double = 0

            If CDbl(b) >= CDbl(0) Then
                result = System.Math.Abs(a)
            Else
                result = -System.Math.Abs(a)
            End If
            Return result
        End Function


        Private Shared Function internalbisectioneigenvalues(d As Double(), e As Double(), n As Integer, irange As Integer, iorder As Integer, vl As Double, _
            vu As Double, il As Integer, iu As Integer, abstol As Double, ByRef w As Double(), ByRef m As Integer, _
            ByRef nsplit As Integer, ByRef iblock As Integer(), ByRef isplit As Integer(), ByRef errorcode As Integer) As Boolean
            Dim result As New Boolean()
            Dim fudge As Double = 0
            Dim relfac As Double = 0
            Dim ncnvrg As New Boolean()
            Dim toofew As New Boolean()
            Dim ib As Integer = 0
            Dim ibegin As Integer = 0
            Dim idiscl As Integer = 0
            Dim idiscu As Integer = 0
            Dim ie As Integer = 0
            Dim iend As Integer = 0
            Dim iinfo As Integer = 0
            Dim im As Integer = 0
            Dim iin As Integer = 0
            Dim ioff As Integer = 0
            Dim iout As Integer = 0
            Dim itmax As Integer = 0
            Dim iw As Integer = 0
            Dim iwoff As Integer = 0
            Dim j As Integer = 0
            Dim itmp1 As Integer = 0
            Dim jb As Integer = 0
            Dim jdisc As Integer = 0
            Dim je As Integer = 0
            Dim nwl As Integer = 0
            Dim nwu As Integer = 0
            Dim atoli As Double = 0
            Dim bnorm As Double = 0
            Dim gl As Double = 0
            Dim gu As Double = 0
            Dim pivmin As Double = 0
            Dim rtoli As Double = 0
            Dim safemn As Double = 0
            Dim tmp1 As Double = 0
            Dim tmp2 As Double = 0
            Dim tnorm As Double = 0
            Dim ulp As Double = 0
            Dim wkill As Double = 0
            Dim wl As Double = 0
            Dim wlu As Double = 0
            Dim wu As Double = 0
            Dim wul As Double = 0
            Dim scalefactor As Double = 0
            Dim t As Double = 0
            Dim idumma As Integer() = New Integer(-1) {}
            Dim work As Double() = New Double(-1) {}
            Dim iwork As Integer() = New Integer(-1) {}
            Dim ia1s2 As Integer() = New Integer(-1) {}
            Dim ra1s2 As Double() = New Double(-1) {}
            Dim ra1s2x2 As Double(,) = New Double(-1, -1) {}
            Dim ia1s2x2 As Integer(,) = New Integer(-1, -1) {}
            Dim ra1siin As Double() = New Double(-1) {}
            Dim ra2siin As Double() = New Double(-1) {}
            Dim ra3siin As Double() = New Double(-1) {}
            Dim ra4siin As Double() = New Double(-1) {}
            Dim ra1siinx2 As Double(,) = New Double(-1, -1) {}
            Dim ia1siinx2 As Integer(,) = New Integer(-1, -1) {}
            Dim iworkspace As Integer() = New Integer(-1) {}
            Dim rworkspace As Double() = New Double(-1) {}
            Dim tmpi As Integer = 0

            d = DirectCast(d.Clone(), Double())
            e = DirectCast(e.Clone(), Double())
            w = New Double(-1) {}
            m = 0
            nsplit = 0
            iblock = New Integer(-1) {}
            isplit = New Integer(-1) {}
            errorcode = 0


            '
            ' Quick return if possible
            '
            m = 0
            If n = 0 Then
                result = True
                Return result
            End If

            '
            ' Get machine constants
            ' NB is the minimum vector length for vector bisection, or 0
            ' if only scalar is to be done.
            '
            fudge = 2
            relfac = 2
            safemn = Math.minrealnumber
            ulp = 2 * Math.machineepsilon
            rtoli = ulp * relfac
            idumma = New Integer(1) {}
            work = New Double(4 * n) {}
            iwork = New Integer(3 * n) {}
            w = New Double(n) {}
            iblock = New Integer(n) {}
            isplit = New Integer(n) {}
            ia1s2 = New Integer(2) {}
            ra1s2 = New Double(2) {}
            ra1s2x2 = New Double(2, 2) {}
            ia1s2x2 = New Integer(2, 2) {}
            ra1siin = New Double(n) {}
            ra2siin = New Double(n) {}
            ra3siin = New Double(n) {}
            ra4siin = New Double(n) {}
            ra1siinx2 = New Double(n, 2) {}
            ia1siinx2 = New Integer(n, 2) {}
            iworkspace = New Integer(n) {}
            rworkspace = New Double(n) {}

            '
            ' these initializers are not really necessary,
            ' but without them compiler complains about uninitialized locals
            '
            wlu = 0
            wul = 0

            '
            ' Check for Errors
            '
            result = False
            errorcode = 0
            If irange <= 0 OrElse irange >= 4 Then
                errorcode = -4
            End If
            If iorder <= 0 OrElse iorder >= 3 Then
                errorcode = -5
            End If
            If n < 0 Then
                errorcode = -3
            End If
            If irange = 2 AndAlso CDbl(vl) >= CDbl(vu) Then
                errorcode = -6
            End If
            If irange = 3 AndAlso (il < 1 OrElse il > System.Math.Max(1, n)) Then
                errorcode = -8
            End If
            If irange = 3 AndAlso (iu < System.Math.Min(n, il) OrElse iu > n) Then
                errorcode = -9
            End If
            If errorcode <> 0 Then
                Return result
            End If

            '
            ' Initialize error flags
            '
            ncnvrg = False
            toofew = False

            '
            ' Simplifications:
            '
            If (irange = 3 AndAlso il = 1) AndAlso iu = n Then
                irange = 1
            End If

            '
            ' Special Case when N=1
            '
            If n = 1 Then
                nsplit = 1
                isplit(1) = 1
                If irange = 2 AndAlso (CDbl(vl) >= CDbl(d(1)) OrElse CDbl(vu) < CDbl(d(1))) Then
                    m = 0
                Else
                    w(1) = d(1)
                    iblock(1) = 1
                    m = 1
                End If
                result = True
                Return result
            End If

            '
            ' Scaling
            '
            t = System.Math.Abs(d(n))
            For j = 1 To n - 1
                t = System.Math.Max(t, System.Math.Abs(d(j)))
                t = System.Math.Max(t, System.Math.Abs(e(j)))
            Next
            scalefactor = 1
            If CDbl(t) <> CDbl(0) Then
                If CDbl(t) > CDbl(System.Math.sqrt(System.Math.sqrt(Math.minrealnumber)) * System.Math.sqrt(Math.maxrealnumber)) Then
                    scalefactor = t
                End If
                If CDbl(t) < CDbl(System.Math.sqrt(System.Math.sqrt(Math.maxrealnumber)) * System.Math.sqrt(Math.minrealnumber)) Then
                    scalefactor = t
                End If
                For j = 1 To n - 1
                    d(j) = d(j) / scalefactor
                    e(j) = e(j) / scalefactor
                Next
                d(n) = d(n) / scalefactor
            End If

            '
            ' Compute Splitting Points
            '
            nsplit = 1
            work(n) = 0
            pivmin = 1
            For j = 2 To n
                tmp1 = Math.sqr(e(j - 1))
                If CDbl(System.Math.Abs(d(j) * d(j - 1)) * Math.sqr(ulp) + safemn) > CDbl(tmp1) Then
                    isplit(nsplit) = j - 1
                    nsplit = nsplit + 1
                    work(j - 1) = 0
                Else
                    work(j - 1) = tmp1
                    pivmin = System.Math.Max(pivmin, tmp1)
                End If
            Next
            isplit(nsplit) = n
            pivmin = pivmin * safemn

            '
            ' Compute Interval and ATOLI
            '
            If irange = 3 Then

                '
                ' RANGE='I': Compute the interval containing eigenvalues
                '     IL through IU.
                '
                ' Compute Gershgorin interval for entire (split) matrix
                ' and use it as the initial interval
                '
                gu = d(1)
                gl = d(1)
                tmp1 = 0
                For j = 1 To n - 1
                    tmp2 = System.Math.sqrt(work(j))
                    gu = System.Math.Max(gu, d(j) + tmp1 + tmp2)
                    gl = System.Math.Min(gl, d(j) - tmp1 - tmp2)
                    tmp1 = tmp2
                Next
                gu = System.Math.Max(gu, d(n) + tmp1)
                gl = System.Math.Min(gl, d(n) - tmp1)
                tnorm = System.Math.Max(System.Math.Abs(gl), System.Math.Abs(gu))
                gl = gl - fudge * tnorm * ulp * n - fudge * 2 * pivmin
                gu = gu + fudge * tnorm * ulp * n + fudge * pivmin

                '
                ' Compute Iteration parameters
                '
                itmax = CInt(System.Math.Truncate(System.Math.Ceiling((System.Math.Log(tnorm + pivmin) - System.Math.Log(pivmin)) / System.Math.Log(2)))) + 2
                If CDbl(abstol) <= CDbl(0) Then
                    atoli = ulp * tnorm
                Else
                    atoli = abstol
                End If
                work(n + 1) = gl
                work(n + 2) = gl
                work(n + 3) = gu
                work(n + 4) = gu
                work(n + 5) = gl
                work(n + 6) = gu
                iwork(1) = -1
                iwork(2) = -1
                iwork(3) = n + 1
                iwork(4) = n + 1
                iwork(5) = il - 1
                iwork(6) = iu

                '
                ' Calling DLAEBZ
                '
                ' DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,
                '    WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,
                '    IWORK, W, IBLOCK, IINFO )
                '
                ia1s2(1) = iwork(5)
                ia1s2(2) = iwork(6)
                ra1s2(1) = work(n + 5)
                ra1s2(2) = work(n + 6)
                ra1s2x2(1, 1) = work(n + 1)
                ra1s2x2(2, 1) = work(n + 2)
                ra1s2x2(1, 2) = work(n + 3)
                ra1s2x2(2, 2) = work(n + 4)
                ia1s2x2(1, 1) = iwork(1)
                ia1s2x2(2, 1) = iwork(2)
                ia1s2x2(1, 2) = iwork(3)
                ia1s2x2(2, 2) = iwork(4)
                internaldlaebz(3, itmax, n, 2, 2, atoli, _
                    rtoli, pivmin, d, e, work, ia1s2, _
                    ra1s2x2, ra1s2, iout, ia1s2x2, w, iblock, _
                    iinfo)
                iwork(5) = ia1s2(1)
                iwork(6) = ia1s2(2)
                work(n + 5) = ra1s2(1)
                work(n + 6) = ra1s2(2)
                work(n + 1) = ra1s2x2(1, 1)
                work(n + 2) = ra1s2x2(2, 1)
                work(n + 3) = ra1s2x2(1, 2)
                work(n + 4) = ra1s2x2(2, 2)
                iwork(1) = ia1s2x2(1, 1)
                iwork(2) = ia1s2x2(2, 1)
                iwork(3) = ia1s2x2(1, 2)
                iwork(4) = ia1s2x2(2, 2)
                If iwork(6) = iu Then
                    wl = work(n + 1)
                    wlu = work(n + 3)
                    nwl = iwork(1)
                    wu = work(n + 4)
                    wul = work(n + 2)
                    nwu = iwork(4)
                Else
                    wl = work(n + 2)
                    wlu = work(n + 4)
                    nwl = iwork(2)
                    wu = work(n + 3)
                    wul = work(n + 1)
                    nwu = iwork(3)
                End If
                If ((nwl < 0 OrElse nwl >= n) OrElse nwu < 1) OrElse nwu > n Then
                    errorcode = 4
                    result = False
                    Return result
                End If
            Else

                '
                ' RANGE='A' or 'V' -- Set ATOLI
                '
                tnorm = System.Math.Max(System.Math.Abs(d(1)) + System.Math.Abs(e(1)), System.Math.Abs(d(n)) + System.Math.Abs(e(n - 1)))
                For j = 2 To n - 1
                    tnorm = System.Math.Max(tnorm, System.Math.Abs(d(j)) + System.Math.Abs(e(j - 1)) + System.Math.Abs(e(j)))
                Next
                If CDbl(abstol) <= CDbl(0) Then
                    atoli = ulp * tnorm
                Else
                    atoli = abstol
                End If
                If irange = 2 Then
                    wl = vl
                    wu = vu
                Else
                    wl = 0
                    wu = 0
                End If
            End If

            '
            ' Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.
            ' NWL accumulates the number of eigenvalues .le. WL,
            ' NWU accumulates the number of eigenvalues .le. WU
            '
            m = 0
            iend = 0
            errorcode = 0
            nwl = 0
            nwu = 0
            For jb = 1 To nsplit
                ioff = iend
                ibegin = ioff + 1
                iend = isplit(jb)
                iin = iend - ioff
                If iin = 1 Then

                    '
                    ' Special Case -- IIN=1
                    '
                    If irange = 1 OrElse CDbl(wl) >= CDbl(d(ibegin) - pivmin) Then
                        nwl = nwl + 1
                    End If
                    If irange = 1 OrElse CDbl(wu) >= CDbl(d(ibegin) - pivmin) Then
                        nwu = nwu + 1
                    End If
                    If irange = 1 OrElse (CDbl(wl) < CDbl(d(ibegin) - pivmin) AndAlso CDbl(wu) >= CDbl(d(ibegin) - pivmin)) Then
                        m = m + 1
                        w(m) = d(ibegin)
                        iblock(m) = jb
                    End If
                Else

                    '
                    ' General Case -- IIN > 1
                    '
                    ' Compute Gershgorin Interval
                    ' and use it as the initial interval
                    '
                    gu = d(ibegin)
                    gl = d(ibegin)
                    tmp1 = 0
                    For j = ibegin To iend - 1
                        tmp2 = System.Math.Abs(e(j))
                        gu = System.Math.Max(gu, d(j) + tmp1 + tmp2)
                        gl = System.Math.Min(gl, d(j) - tmp1 - tmp2)
                        tmp1 = tmp2
                    Next
                    gu = System.Math.Max(gu, d(iend) + tmp1)
                    gl = System.Math.Min(gl, d(iend) - tmp1)
                    bnorm = System.Math.Max(System.Math.Abs(gl), System.Math.Abs(gu))
                    gl = gl - fudge * bnorm * ulp * iin - fudge * pivmin
                    gu = gu + fudge * bnorm * ulp * iin + fudge * pivmin

                    '
                    ' Compute ATOLI for the current submatrix
                    '
                    If CDbl(abstol) <= CDbl(0) Then
                        atoli = ulp * System.Math.Max(System.Math.Abs(gl), System.Math.Abs(gu))
                    Else
                        atoli = abstol
                    End If
                    If irange > 1 Then
                        If CDbl(gu) < CDbl(wl) Then
                            nwl = nwl + iin
                            nwu = nwu + iin
                            Continue For
                        End If
                        gl = System.Math.Max(gl, wl)
                        gu = System.Math.Min(gu, wu)
                        If CDbl(gl) >= CDbl(gu) Then
                            Continue For
                        End If
                    End If

                    '
                    ' Set Up Initial Interval
                    '
                    work(n + 1) = gl
                    work(n + iin + 1) = gu

                    '
                    ' Calling DLAEBZ
                    '
                    ' CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
                    '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
                    '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,
                    '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
                    '
                    For tmpi = 1 To iin
                        ra1siin(tmpi) = d(ibegin - 1 + tmpi)
                        If ibegin - 1 + tmpi < n Then
                            ra2siin(tmpi) = e(ibegin - 1 + tmpi)
                        End If
                        ra3siin(tmpi) = work(ibegin - 1 + tmpi)
                        ra1siinx2(tmpi, 1) = work(n + tmpi)
                        ra1siinx2(tmpi, 2) = work(n + tmpi + iin)
                        ra4siin(tmpi) = work(n + 2 * iin + tmpi)
                        rworkspace(tmpi) = w(m + tmpi)
                        iworkspace(tmpi) = iblock(m + tmpi)
                        ia1siinx2(tmpi, 1) = iwork(tmpi)
                        ia1siinx2(tmpi, 2) = iwork(tmpi + iin)
                    Next
                    internaldlaebz(1, 0, iin, iin, 1, atoli, _
                        rtoli, pivmin, ra1siin, ra2siin, ra3siin, idumma, _
                        ra1siinx2, ra4siin, im, ia1siinx2, rworkspace, iworkspace, _
                        iinfo)
                    For tmpi = 1 To iin
                        work(n + tmpi) = ra1siinx2(tmpi, 1)
                        work(n + tmpi + iin) = ra1siinx2(tmpi, 2)
                        work(n + 2 * iin + tmpi) = ra4siin(tmpi)
                        w(m + tmpi) = rworkspace(tmpi)
                        iblock(m + tmpi) = iworkspace(tmpi)
                        iwork(tmpi) = ia1siinx2(tmpi, 1)
                        iwork(tmpi + iin) = ia1siinx2(tmpi, 2)
                    Next
                    nwl = nwl + iwork(1)
                    nwu = nwu + iwork(iin + 1)
                    iwoff = m - iwork(1)

                    '
                    ' Compute Eigenvalues
                    '
                    itmax = CInt(System.Math.Truncate(System.Math.Ceiling((System.Math.Log(gu - gl + pivmin) - System.Math.Log(pivmin)) / System.Math.Log(2)))) + 2

                    '
                    ' Calling DLAEBZ
                    '
                    'CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
                    '    D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
                    '    IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,
                    '    IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
                    '
                    For tmpi = 1 To iin
                        ra1siin(tmpi) = d(ibegin - 1 + tmpi)
                        If ibegin - 1 + tmpi < n Then
                            ra2siin(tmpi) = e(ibegin - 1 + tmpi)
                        End If
                        ra3siin(tmpi) = work(ibegin - 1 + tmpi)
                        ra1siinx2(tmpi, 1) = work(n + tmpi)
                        ra1siinx2(tmpi, 2) = work(n + tmpi + iin)
                        ra4siin(tmpi) = work(n + 2 * iin + tmpi)
                        rworkspace(tmpi) = w(m + tmpi)
                        iworkspace(tmpi) = iblock(m + tmpi)
                        ia1siinx2(tmpi, 1) = iwork(tmpi)
                        ia1siinx2(tmpi, 2) = iwork(tmpi + iin)
                    Next
                    internaldlaebz(2, itmax, iin, iin, 1, atoli, _
                        rtoli, pivmin, ra1siin, ra2siin, ra3siin, idumma, _
                        ra1siinx2, ra4siin, iout, ia1siinx2, rworkspace, iworkspace, _
                        iinfo)
                    For tmpi = 1 To iin
                        work(n + tmpi) = ra1siinx2(tmpi, 1)
                        work(n + tmpi + iin) = ra1siinx2(tmpi, 2)
                        work(n + 2 * iin + tmpi) = ra4siin(tmpi)
                        w(m + tmpi) = rworkspace(tmpi)
                        iblock(m + tmpi) = iworkspace(tmpi)
                        iwork(tmpi) = ia1siinx2(tmpi, 1)
                        iwork(tmpi + iin) = ia1siinx2(tmpi, 2)
                    Next

                    '
                    ' Copy Eigenvalues Into W and IBLOCK
                    ' Use -JB for block number for unconverged eigenvalues.
                    '
                    For j = 1 To iout
                        tmp1 = 0.5 * (work(j + n) + work(j + iin + n))

                        '
                        ' Flag non-convergence.
                        '
                        If j > iout - iinfo Then
                            ncnvrg = True
                            ib = -jb
                        Else
                            ib = jb
                        End If
                        For je = iwork(j) + 1 + iwoff To iwork(j + iin) + iwoff
                            w(je) = tmp1
                            iblock(je) = ib
                        Next
                    Next
                    m = m + im
                End If
            Next

            '
            ' If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU
            ' If NWL+1 < IL or NWU > IU, discard extra eigenvalues.
            '
            If irange = 3 Then
                im = 0
                idiscl = il - 1 - nwl
                idiscu = nwu - iu
                If idiscl > 0 OrElse idiscu > 0 Then
                    For je = 1 To m
                        If CDbl(w(je)) <= CDbl(wlu) AndAlso idiscl > 0 Then
                            idiscl = idiscl - 1
                        Else
                            If CDbl(w(je)) >= CDbl(wul) AndAlso idiscu > 0 Then
                                idiscu = idiscu - 1
                            Else
                                im = im + 1
                                w(im) = w(je)
                                iblock(im) = iblock(je)
                            End If
                        End If
                    Next
                    m = im
                End If
                If idiscl > 0 OrElse idiscu > 0 Then

                    '
                    ' Code to deal with effects of bad arithmetic:
                    ' Some low eigenvalues to be discarded are not in (WL,WLU],
                    ' or high eigenvalues to be discarded are not in (WUL,WU]
                    ' so just kill off the smallest IDISCL/largest IDISCU
                    ' eigenvalues, by simply finding the smallest/largest
                    ' eigenvalue(s).
                    '
                    ' (If N(w) is monotone non-decreasing, this should never
                    '  happen.)
                    '
                    If idiscl > 0 Then
                        wkill = wu
                        For jdisc = 1 To idiscl
                            iw = 0
                            For je = 1 To m
                                If iblock(je) <> 0 AndAlso (CDbl(w(je)) < CDbl(wkill) OrElse iw = 0) Then
                                    iw = je
                                    wkill = w(je)
                                End If
                            Next
                            iblock(iw) = 0
                        Next
                    End If
                    If idiscu > 0 Then
                        wkill = wl
                        For jdisc = 1 To idiscu
                            iw = 0
                            For je = 1 To m
                                If iblock(je) <> 0 AndAlso (CDbl(w(je)) > CDbl(wkill) OrElse iw = 0) Then
                                    iw = je
                                    wkill = w(je)
                                End If
                            Next
                            iblock(iw) = 0
                        Next
                    End If
                    im = 0
                    For je = 1 To m
                        If iblock(je) <> 0 Then
                            im = im + 1
                            w(im) = w(je)
                            iblock(im) = iblock(je)
                        End If
                    Next
                    m = im
                End If
                If idiscl < 0 OrElse idiscu < 0 Then
                    toofew = True
                End If
            End If

            '
            ' If ORDER='B', do nothing -- the eigenvalues are already sorted
            '    by block.
            ' If ORDER='E', sort the eigenvalues from smallest to largest
            '
            If iorder = 1 AndAlso nsplit > 1 Then
                For je = 1 To m - 1
                    ie = 0
                    tmp1 = w(je)
                    For j = je + 1 To m
                        If CDbl(w(j)) < CDbl(tmp1) Then
                            ie = j
                            tmp1 = w(j)
                        End If
                    Next
                    If ie <> 0 Then
                        itmp1 = iblock(ie)
                        w(ie) = w(je)
                        iblock(ie) = iblock(je)
                        w(je) = tmp1
                        iblock(je) = itmp1
                    End If
                Next
            End If
            For j = 1 To m
                w(j) = w(j) * scalefactor
            Next
            errorcode = 0
            If ncnvrg Then
                errorcode = errorcode + 1
            End If
            If toofew Then
                errorcode = errorcode + 2
            End If
            result = errorcode = 0
            Return result
        End Function


		Private Shared Sub internaldstein(n As Integer, d As Double(), e As Double(), m As Integer, w As Double(), iblock As Integer(), _
			isplit As Integer(), ByRef z As Double(,), ByRef ifail As Integer(), ByRef info As Integer)
			Dim maxits As Integer = 0
			Dim extra As Integer = 0
			Dim b1 As Integer = 0
			Dim blksiz As Integer = 0
			Dim bn As Integer = 0
			Dim gpind As Integer = 0
			Dim i As Integer = 0
			Dim iinfo As Integer = 0
			Dim its As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim jblk As Integer = 0
			Dim jmax As Integer = 0
			Dim nblk As Integer = 0
			Dim nrmchk As Integer = 0
			Dim dtpcrt As Double = 0
			Dim eps As Double = 0
			Dim eps1 As Double = 0
			Dim nrm As Double = 0
			Dim onenrm As Double = 0
			Dim ortol As Double = 0
			Dim pertol As Double = 0
			Dim scl As Double = 0
			Dim sep As Double = 0
			Dim tol As Double = 0
			Dim xj As Double = 0
			Dim xjm As Double = 0
			Dim ztr As Double = 0
			Dim work1 As Double() = New Double(-1) {}
			Dim work2 As Double() = New Double(-1) {}
			Dim work3 As Double() = New Double(-1) {}
			Dim work4 As Double() = New Double(-1) {}
			Dim work5 As Double() = New Double(-1) {}
			Dim iwork As Integer() = New Integer(-1) {}
			Dim tmpcriterion As New Boolean()
			Dim ti As Integer = 0
			Dim i1 As Integer = 0
			Dim i2 As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			e = DirectCast(e.Clone(), Double())
			w = DirectCast(w.Clone(), Double())
			z = New Double(-1, -1) {}
			ifail = New Integer(-1) {}
			info = 0

			maxits = 5
			extra = 2
			work1 = New Double(System.Math.Max(n, 1)) {}
			work2 = New Double(System.Math.Max(n - 1, 1)) {}
			work3 = New Double(System.Math.Max(n, 1)) {}
			work4 = New Double(System.Math.Max(n, 1)) {}
			work5 = New Double(System.Math.Max(n, 1)) {}
			iwork = New Integer(System.Math.Max(n, 1)) {}
			ifail = New Integer(System.Math.Max(m, 1)) {}
			z = New Double(System.Math.Max(n, 1), System.Math.Max(m, 1)) {}

			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			gpind = 0
			onenrm = 0
			ortol = 0
			dtpcrt = 0
			xjm = 0

			'
			' Test the input parameters.
			'
			info = 0
			For i = 1 To m
				ifail(i) = 0
			Next
			If n < 0 Then
				info = -1
				Return
			End If
			If m < 0 OrElse m > n Then
				info = -4
				Return
			End If
			For j = 2 To m
				If iblock(j) < iblock(j - 1) Then
					info = -6
					Exit For
				End If
				If iblock(j) = iblock(j - 1) AndAlso CDbl(w(j)) < CDbl(w(j - 1)) Then
					info = -5
					Exit For
				End If
			Next
			If info <> 0 Then
				Return
			End If

			'
			' Quick return if possible
			'
			If n = 0 OrElse m = 0 Then
				Return
			End If
			If n = 1 Then
				z(1, 1) = 1
				Return
			End If

			'
			' Some preparations
			'
			ti = n - 1
			For i_ = 1 To ti
				work1(i_) = e(i_)
			Next
			e = New Double(n) {}
			For i_ = 1 To ti
				e(i_) = work1(i_)
			Next
			For i_ = 1 To m
				work1(i_) = w(i_)
			Next
			w = New Double(n) {}
			For i_ = 1 To m
				w(i_) = work1(i_)
			Next

			'
			' Get machine constants.
			'
			eps = Math.machineepsilon

			'
			' Compute eigenvectors of matrix blocks.
			'
			j1 = 1
			For nblk = 1 To iblock(m)

				'
				' Find starting and ending indices of block nblk.
				'
				If nblk = 1 Then
					b1 = 1
				Else
					b1 = isplit(nblk - 1) + 1
				End If
				bn = isplit(nblk)
				blksiz = bn - b1 + 1
				If blksiz <> 1 Then

					'
					' Compute reorthogonalization criterion and stopping criterion.
					'
					gpind = b1
					onenrm = System.Math.Abs(d(b1)) + System.Math.Abs(e(b1))
					onenrm = System.Math.Max(onenrm, System.Math.Abs(d(bn)) + System.Math.Abs(e(bn - 1)))
					For i = b1 + 1 To bn - 1
						onenrm = System.Math.Max(onenrm, System.Math.Abs(d(i)) + System.Math.Abs(e(i - 1)) + System.Math.Abs(e(i)))
					Next
					ortol = 0.001 * onenrm
					dtpcrt = System.Math.sqrt(0.1 / blksiz)
				End If

				'
				' Loop through eigenvalues of block nblk.
				'
				jblk = 0
				For j = j1 To m
					If iblock(j) <> nblk Then
						j1 = j
						Exit For
					End If
					jblk = jblk + 1
					xj = w(j)
					If blksiz = 1 Then

						'
						' Skip all the work if the block size is one.
						'
						work1(1) = 1
					Else

						'
						' If eigenvalues j and j-1 are too close, add a relatively
						' small perturbation.
						'
						If jblk > 1 Then
							eps1 = System.Math.Abs(eps * xj)
							pertol = 10 * eps1
							sep = xj - xjm
							If CDbl(sep) < CDbl(pertol) Then
								xj = xjm + pertol
							End If
						End If
						its = 0
						nrmchk = 0

						'
						' Get random starting vector.
						'
						For ti = 1 To blksiz
                            work1(ti) = 2 * Math.randomreal() - 1
						Next

						'
						' Copy the matrix T so it won't be destroyed in factorization.
						'
						For ti = 1 To blksiz - 1
							work2(ti) = e(b1 + ti - 1)
							work3(ti) = e(b1 + ti - 1)
							work4(ti) = d(b1 + ti - 1)
						Next
						work4(blksiz) = d(b1 + blksiz - 1)

						'
						' Compute LU factors with partial pivoting  ( PT = LU )
						'
						tol = 0
						tdininternaldlagtf(blksiz, work4, xj, work2, work3, tol, _
							work5, iwork, iinfo)

						'
						' Update iteration count.
						'
						Do
							its = its + 1
							If its > maxits Then

								'
								' If stopping criterion was not satisfied, update info and
								' store eigenvector number in array ifail.
								'
								info = info + 1
								ifail(info) = j
								Exit Do
							End If

							'
							' Normalize and scale the righthand side vector Pb.
							'
							v = 0
							For ti = 1 To blksiz
								v = v + System.Math.Abs(work1(ti))
							Next
							scl = blksiz * onenrm * System.Math.Max(eps, System.Math.Abs(work4(blksiz))) / v
							For i_ = 1 To blksiz
								work1(i_) = scl * work1(i_)
							Next

							'
							' Solve the system LU = Pb.
							'
							tdininternaldlagts(blksiz, work4, work2, work3, work5, iwork, _
								work1, tol, iinfo)

							'
							' Reorthogonalize by modified Gram-Schmidt if eigenvalues are
							' close enough.
							'
							If jblk <> 1 Then
								If CDbl(System.Math.Abs(xj - xjm)) > CDbl(ortol) Then
									gpind = j
								End If
								If gpind <> j Then
									For i = gpind To j - 1
										i1 = b1
										i2 = b1 + blksiz - 1
										i1_ = (i1) - (1)
										ztr = 0.0
										For i_ = 1 To blksiz
											ztr += work1(i_) * z(i_ + i1_, i)
										Next
										i1_ = (i1) - (1)
										For i_ = 1 To blksiz
											work1(i_) = work1(i_) - ztr * z(i_ + i1_, i)
										Next
										apserv.touchint(i2)
									Next
								End If
							End If

							'
							' Check the infinity norm of the iterate.
							'
							jmax = blas.vectoridxabsmax(work1, 1, blksiz)
							nrm = System.Math.Abs(work1(jmax))

							'
							' Continue for additional iterations after norm reaches
							' stopping criterion.
							'
							tmpcriterion = False
							If CDbl(nrm) < CDbl(dtpcrt) Then
								tmpcriterion = True
							Else
								nrmchk = nrmchk + 1
								If nrmchk < extra + 1 Then
									tmpcriterion = True
								End If
							End If
						Loop While tmpcriterion

						'
						' Accept iterate as jth eigenvector.
						'
						scl = 1 / blas.vectornorm2(work1, 1, blksiz)
						jmax = blas.vectoridxabsmax(work1, 1, blksiz)
						If CDbl(work1(jmax)) < CDbl(0) Then
							scl = -scl
						End If
						For i_ = 1 To blksiz
							work1(i_) = scl * work1(i_)
						Next
					End If
					For i = 1 To n
						z(i, j) = 0
					Next
					For i = 1 To blksiz
						z(b1 + i - 1, j) = work1(i)
					Next

					'
					' Save the shift to check eigenvalue spacing at next
					' iteration.
					'
					xjm = xj
				Next
			Next
		End Sub


		Private Shared Sub tdininternaldlagtf(n As Integer, ByRef a As Double(), lambdav As Double, ByRef b As Double(), ByRef c As Double(), tol As Double, _
			ByRef d As Double(), ByRef iin As Integer(), ByRef info As Integer)
			Dim k As Integer = 0
			Dim eps As Double = 0
			Dim mult As Double = 0
			Dim piv1 As Double = 0
			Dim piv2 As Double = 0
			Dim scale1 As Double = 0
			Dim scale2 As Double = 0
			Dim temp As Double = 0
			Dim tl As Double = 0

			info = 0

			info = 0
			If n < 0 Then
				info = -1
				Return
			End If
			If n = 0 Then
				Return
			End If
			a(1) = a(1) - lambdav
			iin(n) = 0
			If n = 1 Then
				If CDbl(a(1)) = CDbl(0) Then
					iin(1) = 1
				End If
				Return
			End If
			eps = Math.machineepsilon
			tl = System.Math.Max(tol, eps)
			scale1 = System.Math.Abs(a(1)) + System.Math.Abs(b(1))
			For k = 1 To n - 1
				a(k + 1) = a(k + 1) - lambdav
				scale2 = System.Math.Abs(c(k)) + System.Math.Abs(a(k + 1))
				If k < n - 1 Then
					scale2 = scale2 + System.Math.Abs(b(k + 1))
				End If
				If CDbl(a(k)) = CDbl(0) Then
					piv1 = 0
				Else
					piv1 = System.Math.Abs(a(k)) / scale1
				End If
				If CDbl(c(k)) = CDbl(0) Then
					iin(k) = 0
					piv2 = 0
					scale1 = scale2
					If k < n - 1 Then
						d(k) = 0
					End If
				Else
					piv2 = System.Math.Abs(c(k)) / scale2
					If CDbl(piv2) <= CDbl(piv1) Then
						iin(k) = 0
						scale1 = scale2
						c(k) = c(k) / a(k)
						a(k + 1) = a(k + 1) - c(k) * b(k)
						If k < n - 1 Then
							d(k) = 0
						End If
					Else
						iin(k) = 1
						mult = a(k) / c(k)
						a(k) = c(k)
						temp = a(k + 1)
						a(k + 1) = b(k) - mult * temp
						If k < n - 1 Then
							d(k) = b(k + 1)
							b(k + 1) = -(mult * d(k))
						End If
						b(k) = temp
						c(k) = mult
					End If
				End If
				If CDbl(System.Math.Max(piv1, piv2)) <= CDbl(tl) AndAlso iin(n) = 0 Then
					iin(n) = k
				End If
			Next
			If CDbl(System.Math.Abs(a(n))) <= CDbl(scale1 * tl) AndAlso iin(n) = 0 Then
				iin(n) = n
			End If
		End Sub


		Private Shared Sub tdininternaldlagts(n As Integer, a As Double(), b As Double(), c As Double(), d As Double(), iin As Integer(), _
			ByRef y As Double(), ByRef tol As Double, ByRef info As Integer)
			Dim k As Integer = 0
			Dim absak As Double = 0
			Dim ak As Double = 0
			Dim bignum As Double = 0
			Dim eps As Double = 0
			Dim pert As Double = 0
			Dim sfmin As Double = 0
			Dim temp As Double = 0

			info = 0

			info = 0
			If n < 0 Then
				info = -1
				Return
			End If
			If n = 0 Then
				Return
			End If
			eps = Math.machineepsilon
			sfmin = Math.minrealnumber
			bignum = 1 / sfmin
			If CDbl(tol) <= CDbl(0) Then
				tol = System.Math.Abs(a(1))
				If n > 1 Then
					tol = System.Math.Max(tol, System.Math.Max(System.Math.Abs(a(2)), System.Math.Abs(b(1))))
				End If
				For k = 3 To n
					tol = System.Math.Max(tol, System.Math.Max(System.Math.Abs(a(k)), System.Math.Max(System.Math.Abs(b(k - 1)), System.Math.Abs(d(k - 2)))))
				Next
				tol = tol * eps
				If CDbl(tol) = CDbl(0) Then
					tol = eps
				End If
			End If
			For k = 2 To n
				If iin(k - 1) = 0 Then
					y(k) = y(k) - c(k - 1) * y(k - 1)
				Else
					temp = y(k - 1)
					y(k - 1) = y(k)
					y(k) = temp - c(k - 1) * y(k)
				End If
			Next
			For k = n To 1 Step -1
				If k <= n - 2 Then
					temp = y(k) - b(k) * y(k + 1) - d(k) * y(k + 2)
				Else
					If k = n - 1 Then
						temp = y(k) - b(k) * y(k + 1)
					Else
						temp = y(k)
					End If
				End If
				ak = a(k)
				pert = System.Math.Abs(tol)
				If CDbl(ak) < CDbl(0) Then
					pert = -pert
				End If
				While True
					absak = System.Math.Abs(ak)
					If CDbl(absak) < CDbl(1) Then
						If CDbl(absak) < CDbl(sfmin) Then
							If CDbl(absak) = CDbl(0) OrElse CDbl(System.Math.Abs(temp) * sfmin) > CDbl(absak) Then
								ak = ak + pert
								pert = 2 * pert
								Continue While
							Else
								temp = temp * bignum
								ak = ak * bignum
							End If
						Else
							If CDbl(System.Math.Abs(temp)) > CDbl(absak * bignum) Then
								ak = ak + pert
								pert = 2 * pert
								Continue While
							End If
						End If
					End If
					Exit While
				End While
				y(k) = temp / ak
			Next
		End Sub


		Private Shared Sub internaldlaebz(ijob As Integer, nitmax As Integer, n As Integer, mmax As Integer, minp As Integer, abstol As Double, _
			reltol As Double, pivmin As Double, d As Double(), e As Double(), e2 As Double(), ByRef nval As Integer(), _
			ByRef ab As Double(,), ByRef c As Double(), ByRef mout As Integer, ByRef nab As Integer(,), ByRef work As Double(), ByRef iwork As Integer(), _
			ByRef info As Integer)
			Dim itmp1 As Integer = 0
			Dim itmp2 As Integer = 0
			Dim j As Integer = 0
			Dim ji As Integer = 0
			Dim jit As Integer = 0
			Dim jp As Integer = 0
			Dim kf As Integer = 0
			Dim kfnew As Integer = 0
			Dim kl As Integer = 0
			Dim klnew As Integer = 0
			Dim tmp1 As Double = 0
			Dim tmp2 As Double = 0

			mout = 0
			info = 0

			info = 0
			If ijob < 1 OrElse ijob > 3 Then
				info = -1
				Return
			End If

			'
			' Initialize NAB
			'
			If ijob = 1 Then

				'
				' Compute the number of eigenvalues in the initial intervals.
				'
				mout = 0

				'
				'DIR$ NOVECTOR
				'
				For ji = 1 To minp
					For jp = 1 To 2
						tmp1 = d(1) - ab(ji, jp)
						If CDbl(System.Math.Abs(tmp1)) < CDbl(pivmin) Then
							tmp1 = -pivmin
						End If
						nab(ji, jp) = 0
						If CDbl(tmp1) <= CDbl(0) Then
							nab(ji, jp) = 1
						End If
						For j = 2 To n
							tmp1 = d(j) - e2(j - 1) / tmp1 - ab(ji, jp)
							If CDbl(System.Math.Abs(tmp1)) < CDbl(pivmin) Then
								tmp1 = -pivmin
							End If
							If CDbl(tmp1) <= CDbl(0) Then
								nab(ji, jp) = nab(ji, jp) + 1
							End If
						Next
					Next
					mout = mout + nab(ji, 2) - nab(ji, 1)
				Next
				Return
			End If

			'
			' Initialize for loop
			'
			' KF and KL have the following meaning:
			'   Intervals 1,...,KF-1 have converged.
			'   Intervals KF,...,KL  still need to be refined.
			'
			kf = 1
			kl = minp

			'
			' If IJOB=2, initialize C.
			' If IJOB=3, use the user-supplied starting point.
			'
			If ijob = 2 Then
				For ji = 1 To minp
					c(ji) = 0.5 * (ab(ji, 1) + ab(ji, 2))
				Next
			End If

			'
			' Iteration loop
			'
			For jit = 1 To nitmax

				'
				' Loop over intervals
				'
				'
				' Serial Version of the loop
				'
				klnew = kl
				For ji = kf To kl

					'
					' Compute N(w), the number of eigenvalues less than w
					'
					tmp1 = c(ji)
					tmp2 = d(1) - tmp1
					itmp1 = 0
					If CDbl(tmp2) <= CDbl(pivmin) Then
						itmp1 = 1
						tmp2 = System.Math.Min(tmp2, -pivmin)
					End If

					'
					' A series of compiler directives to defeat vectorization
					' for the next loop
					'
					'*$PL$ CMCHAR=' '
					'CDIR$          NEXTSCALAR
					'C$DIR          SCALAR
					'CDIR$          NEXT SCALAR
					'CVD$L          NOVECTOR
					'CDEC$          NOVECTOR
					'CVD$           NOVECTOR
					'*VDIR          NOVECTOR
					'*VOCL          LOOP,SCALAR
					'CIBM           PREFER SCALAR
					'*$PL$ CMCHAR='*'
					'
					For j = 2 To n
						tmp2 = d(j) - e2(j - 1) / tmp2 - tmp1
						If CDbl(tmp2) <= CDbl(pivmin) Then
							itmp1 = itmp1 + 1
							tmp2 = System.Math.Min(tmp2, -pivmin)
						End If
					Next
					If ijob <= 2 Then

						'
						' IJOB=2: Choose all intervals containing eigenvalues.
						'
						' Insure that N(w) is monotone
						'
						itmp1 = System.Math.Min(nab(ji, 2), System.Math.Max(nab(ji, 1), itmp1))

						'
						' Update the Queue -- add intervals if both halves
						' contain eigenvalues.
						'
						If itmp1 = nab(ji, 2) Then

							'
							' No eigenvalue in the upper interval:
							' just use the lower interval.
							'
							ab(ji, 2) = tmp1
						Else
							If itmp1 = nab(ji, 1) Then

								'
								' No eigenvalue in the lower interval:
								' just use the upper interval.
								'
								ab(ji, 1) = tmp1
							Else
								If klnew < mmax Then

									'
									' Eigenvalue in both intervals -- add upper to queue.
									'
									klnew = klnew + 1
									ab(klnew, 2) = ab(ji, 2)
									nab(klnew, 2) = nab(ji, 2)
									ab(klnew, 1) = tmp1
									nab(klnew, 1) = itmp1
									ab(ji, 2) = tmp1
									nab(ji, 2) = itmp1
								Else
									info = mmax + 1
									Return
								End If
							End If
						End If
					Else

						'
						' IJOB=3: Binary search.  Keep only the interval
						' containing  w  s.t. N(w) = NVAL
						'
						If itmp1 <= nval(ji) Then
							ab(ji, 1) = tmp1
							nab(ji, 1) = itmp1
						End If
						If itmp1 >= nval(ji) Then
							ab(ji, 2) = tmp1
							nab(ji, 2) = itmp1
						End If
					End If
				Next
				kl = klnew

				'
				' Check for convergence
				'
				kfnew = kf
				For ji = kf To kl
					tmp1 = System.Math.Abs(ab(ji, 2) - ab(ji, 1))
					tmp2 = System.Math.Max(System.Math.Abs(ab(ji, 2)), System.Math.Abs(ab(ji, 1)))
					If CDbl(tmp1) < CDbl(System.Math.Max(abstol, System.Math.Max(pivmin, reltol * tmp2))) OrElse nab(ji, 1) >= nab(ji, 2) Then

						'
						' Converged -- Swap with position KFNEW,
						' then increment KFNEW
						'
						If ji > kfnew Then
							tmp1 = ab(ji, 1)
							tmp2 = ab(ji, 2)
							itmp1 = nab(ji, 1)
							itmp2 = nab(ji, 2)
							ab(ji, 1) = ab(kfnew, 1)
							ab(ji, 2) = ab(kfnew, 2)
							nab(ji, 1) = nab(kfnew, 1)
							nab(ji, 2) = nab(kfnew, 2)
							ab(kfnew, 1) = tmp1
							ab(kfnew, 2) = tmp2
							nab(kfnew, 1) = itmp1
							nab(kfnew, 2) = itmp2
							If ijob = 3 Then
								itmp1 = nval(ji)
								nval(ji) = nval(kfnew)
								nval(kfnew) = itmp1
							End If
						End If
						kfnew = kfnew + 1
					End If
				Next
				kf = kfnew

				'
				' Choose Midpoints
				'
				For ji = kf To kl
					c(ji) = 0.5 * (ab(ji, 1) + ab(ji, 2))
				Next

				'
				' If no more intervals to refine, quit.
				'
				If kf > kl Then
					Exit For
				End If
			Next

			'
			' Converged
			'
			info = System.Math.Max(kl + 1 - kf, 0)
			mout = kl
		End Sub


		'************************************************************************
'        Internal subroutine
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             June 30, 1999
'        ************************************************************************

		Private Shared Sub rmatrixinternaltrevc(t As Double(,), n As Integer, side As Integer, howmny As Integer, vselect As Boolean(), ByRef vl As Double(,), _
			ByRef vr As Double(,), ByRef m As Integer, ByRef info As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim t1 As Double(,) = New Double(-1, -1) {}
			Dim vl1 As Double(,) = New Double(-1, -1) {}
			Dim vr1 As Double(,) = New Double(-1, -1) {}
			Dim vselect1 As Boolean() = New Boolean(-1) {}

			vselect = DirectCast(vselect.Clone(), Boolean())
			m = 0
			info = 0


			'
			' Allocate VL/VR, if needed
			'
			If howmny = 2 OrElse howmny = 3 Then
				If side = 1 OrElse side = 3 Then
					apserv.rmatrixsetlengthatleast(vr, n, n)
				End If
				If side = 2 OrElse side = 3 Then
					apserv.rmatrixsetlengthatleast(vl, n, n)
				End If
			End If

			'
			' Try to use MKL kernel
			'
			If ablasmkl.rmatrixinternaltrevcmkl(t, n, side, howmny, vl, vr, _
				m, info) Then
				Return
			End If

			'
			' ALGLIB version
			'
			t1 = New Double(n, n) {}
			For i = 0 To n - 1
				For j = 0 To n - 1
					t1(i + 1, j + 1) = t(i, j)
				Next
			Next
			If howmny = 3 Then
				vselect1 = New Boolean(n) {}
				For i = 0 To n - 1
					vselect1(1 + i) = vselect(i)
				Next
			End If
			If (side = 2 OrElse side = 3) AndAlso howmny = 1 Then
				vl1 = New Double(n, n) {}
				For i = 0 To n - 1
					For j = 0 To n - 1
						vl1(i + 1, j + 1) = vl(i, j)
					Next
				Next
			End If
			If (side = 1 OrElse side = 3) AndAlso howmny = 1 Then
				vr1 = New Double(n, n) {}
				For i = 0 To n - 1
					For j = 0 To n - 1
						vr1(i + 1, j + 1) = vr(i, j)
					Next
				Next
			End If
			internaltrevc(t1, n, side, howmny, vselect1, vl1, _
				vr1, m, info)
			If side <> 1 Then
				apserv.rmatrixsetlengthatleast(vl, n, n)
				For i = 0 To n - 1
					For j = 0 To n - 1
						vl(i, j) = vl1(i + 1, j + 1)
					Next
				Next
			End If
			If side <> 2 Then
				apserv.rmatrixsetlengthatleast(vr, n, n)
				For i = 0 To n - 1
					For j = 0 To n - 1
						vr(i, j) = vr1(i + 1, j + 1)
					Next
				Next
			End If
		End Sub


		'************************************************************************
'        Internal subroutine
'
'          -- LAPACK routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             June 30, 1999
'        ************************************************************************

		Private Shared Sub internaltrevc(t As Double(,), n As Integer, side As Integer, howmny As Integer, vselect As Boolean(), ByRef vl As Double(,), _
			ByRef vr As Double(,), ByRef m As Integer, ByRef info As Integer)
			Dim allv As New Boolean()
			Dim bothv As New Boolean()
			Dim leftv As New Boolean()
			Dim over As New Boolean()
			Dim pair As New Boolean()
			Dim rightv As New Boolean()
			Dim somev As New Boolean()
			Dim i As Integer = 0
			Dim ierr As Integer = 0
			Dim ii As Integer = 0
			Dim ip As Integer = 0
			Dim iis As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim j2 As Integer = 0
			Dim jnxt As Integer = 0
			Dim k As Integer = 0
			Dim ki As Integer = 0
			Dim n2 As Integer = 0
			Dim beta As Double = 0
			Dim bignum As Double = 0
			Dim emax As Double = 0
			Dim rec As Double = 0
			Dim remax As Double = 0
			Dim scl As Double = 0
			Dim smin As Double = 0
			Dim smlnum As Double = 0
			Dim ulp As Double = 0
			Dim unfl As Double = 0
			Dim vcrit As Double = 0
			Dim vmax As Double = 0
			Dim wi As Double = 0
			Dim wr As Double = 0
			Dim xnorm As Double = 0
			Dim x As Double(,) = New Double(-1, -1) {}
			Dim work As Double() = New Double(-1) {}
			Dim temp As Double() = New Double(-1) {}
			Dim temp11 As Double(,) = New Double(-1, -1) {}
			Dim temp22 As Double(,) = New Double(-1, -1) {}
			Dim temp11b As Double(,) = New Double(-1, -1) {}
			Dim temp21b As Double(,) = New Double(-1, -1) {}
			Dim temp12b As Double(,) = New Double(-1, -1) {}
			Dim temp22b As Double(,) = New Double(-1, -1) {}
			Dim skipflag As New Boolean()
			Dim k1 As Integer = 0
			Dim k2 As Integer = 0
			Dim k3 As Integer = 0
			Dim k4 As Integer = 0
			Dim vt As Double = 0
			Dim rswap4 As Boolean() = New Boolean(-1) {}
			Dim zswap4 As Boolean() = New Boolean(-1) {}
			Dim ipivot44 As Integer(,) = New Integer(-1, -1) {}
			Dim civ4 As Double() = New Double(-1) {}
			Dim crv4 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			vselect = DirectCast(vselect.Clone(), Boolean())
			m = 0
			info = 0

			x = New Double(2, 2) {}
			temp11 = New Double(1, 1) {}
			temp11b = New Double(1, 1) {}
			temp21b = New Double(2, 1) {}
			temp12b = New Double(1, 2) {}
			temp22b = New Double(2, 2) {}
			temp22 = New Double(2, 2) {}
			work = New Double(3 * n) {}
			temp = New Double(n) {}
			rswap4 = New Boolean(4) {}
			zswap4 = New Boolean(4) {}
			ipivot44 = New Integer(4, 4) {}
			civ4 = New Double(4) {}
			crv4 = New Double(4) {}
			If howmny <> 1 Then
				If side = 1 OrElse side = 3 Then
					vr = New Double(n, n) {}
				End If
				If side = 2 OrElse side = 3 Then
					vl = New Double(n, n) {}
				End If
			End If

			'
			' Decode and test the input parameters
			'
			bothv = side = 3
			rightv = side = 1 OrElse bothv
			leftv = side = 2 OrElse bothv
			allv = howmny = 2
			over = howmny = 1
			somev = howmny = 3
			info = 0
			If n < 0 Then
				info = -2
				Return
			End If
			If Not rightv AndAlso Not leftv Then
				info = -3
				Return
			End If
			If (Not allv AndAlso Not over) AndAlso Not somev Then
				info = -4
				Return
			End If

			'
			' Set M to the number of columns required to store the selected
			' eigenvectors, standardize the array SELECT if necessary, and
			' test MM.
			'
			If somev Then
				m = 0
				pair = False
				For j = 1 To n
					If pair Then
						pair = False
						vselect(j) = False
					Else
						If j < n Then
							If CDbl(t(j + 1, j)) = CDbl(0) Then
								If vselect(j) Then
									m = m + 1
								End If
							Else
								pair = True
								If vselect(j) OrElse vselect(j + 1) Then
									vselect(j) = True
									m = m + 2
								End If
							End If
						Else
							If vselect(n) Then
								m = m + 1
							End If
						End If
					End If
				Next
			Else
				m = n
			End If

			'
			' Quick return if possible.
			'
			If n = 0 Then
				Return
			End If

			'
			' Set the constants to control overflow.
			'
			unfl = Math.minrealnumber
			ulp = Math.machineepsilon
			smlnum = unfl * (n / ulp)
			bignum = (1 - ulp) / smlnum

			'
			' Compute 1-norm of each column of strictly upper triangular
			' part of T to control overflow in triangular solver.
			'
			work(1) = 0
			For j = 2 To n
				work(j) = 0
				For i = 1 To j - 1
					work(j) = work(j) + System.Math.Abs(t(i, j))
				Next
			Next

			'
			' Index IP is used to specify the real or complex eigenvalue:
			' IP = 0, real eigenvalue,
			'      1, first of conjugate complex pair: (wr,wi)
			'     -1, second of conjugate complex pair: (wr,wi)
			'
			n2 = 2 * n
			If rightv Then

				'
				' Compute right eigenvectors.
				'
				ip = 0
				iis = m
				For ki = n To 1 Step -1
					skipflag = False
					If ip = 1 Then
						skipflag = True
					Else
						If ki <> 1 Then
							If CDbl(t(ki, ki - 1)) <> CDbl(0) Then
								ip = -1
							End If
						End If
						If somev Then
							If ip = 0 Then
								If Not vselect(ki) Then
									skipflag = True
								End If
							Else
								If Not vselect(ki - 1) Then
									skipflag = True
								End If
							End If
						End If
					End If
					If Not skipflag Then

						'
						' Compute the KI-th eigenvalue (WR,WI).
						'
						wr = t(ki, ki)
						wi = 0
						If ip <> 0 Then
							wi = System.Math.sqrt(System.Math.Abs(t(ki, ki - 1))) * System.Math.sqrt(System.Math.Abs(t(ki - 1, ki)))
						End If
						smin = System.Math.Max(ulp * (System.Math.Abs(wr) + System.Math.Abs(wi)), smlnum)
						If ip = 0 Then

							'
							' Real right eigenvector
							'
							work(ki + n) = 1

							'
							' Form right-hand side
							'
							For k = 1 To ki - 1
								work(k + n) = -t(k, ki)
							Next

							'
							' Solve the upper quasi-triangular system:
							'   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
							'
							jnxt = ki - 1
							For j = ki - 1 To 1 Step -1
								If j > jnxt Then
									Continue For
								End If
								j1 = j
								j2 = j
								jnxt = j - 1
								If j > 1 Then
									If CDbl(t(j, j - 1)) <> CDbl(0) Then
										j1 = j - 1
										jnxt = j - 2
									End If
								End If
								If j1 = j2 Then

									'
									' 1-by-1 diagonal block
									'
									temp11(1, 1) = t(j, j)
									temp11b(1, 1) = work(j + n)
									internalhsevdlaln2(False, 1, 1, smin, 1, temp11, _
										1.0, 1.0, temp11b, wr, 0.0, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale X(1,1) to avoid overflow when updating
									' the right-hand side.
									'
									If CDbl(xnorm) > CDbl(1) Then
										If CDbl(work(j)) > CDbl(bignum / xnorm) Then
											x(1, 1) = x(1, 1) / xnorm
											scl = scl / xnorm
										End If
									End If

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										k1 = n + 1
										k2 = n + ki
										For i_ = k1 To k2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)

									'
									' Update right-hand side
									'
									k1 = 1 + n
									k2 = j - 1 + n
									k3 = j - 1
									vt = -x(1, 1)
									i1_ = (1) - (k1)
									For i_ = k1 To k2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
								Else

									'
									' 2-by-2 diagonal block
									'
									temp22(1, 1) = t(j - 1, j - 1)
									temp22(1, 2) = t(j - 1, j)
									temp22(2, 1) = t(j, j - 1)
									temp22(2, 2) = t(j, j)
									temp21b(1, 1) = work(j - 1 + n)
									temp21b(2, 1) = work(j + n)
									internalhsevdlaln2(False, 2, 1, smin, 1.0, temp22, _
										1.0, 1.0, temp21b, wr, 0, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale X(1,1) and X(2,1) to avoid overflow when
									' updating the right-hand side.
									'
									If CDbl(xnorm) > CDbl(1) Then
										beta = System.Math.Max(work(j - 1), work(j))
										If CDbl(beta) > CDbl(bignum / xnorm) Then
											x(1, 1) = x(1, 1) / xnorm
											x(2, 1) = x(2, 1) / xnorm
											scl = scl / xnorm
										End If
									End If

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										k1 = 1 + n
										k2 = ki + n
										For i_ = k1 To k2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j - 1 + n) = x(1, 1)
									work(j + n) = x(2, 1)

									'
									' Update right-hand side
									'
									k1 = 1 + n
									k2 = j - 2 + n
									k3 = j - 2
									k4 = j - 1
									vt = -x(1, 1)
									i1_ = (1) - (k1)
									For i_ = k1 To k2
										work(i_) = work(i_) + vt * t(i_ + i1_, k4)
									Next
									vt = -x(2, 1)
									i1_ = (1) - (k1)
									For i_ = k1 To k2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
								End If
							Next

							'
							' Copy the vector x or Q*x to VR and normalize.
							'
							If Not over Then
								k1 = 1 + n
								k2 = ki + n
								i1_ = (k1) - (1)
								For i_ = 1 To ki
									vr(i_, iis) = work(i_ + i1_)
								Next
								ii = blas.columnidxabsmax(vr, 1, ki, iis)
								remax = 1 / System.Math.Abs(vr(ii, iis))
								For i_ = 1 To ki
									vr(i_, iis) = remax * vr(i_, iis)
								Next
								For k = ki + 1 To n
									vr(k, iis) = 0
								Next
							Else
								If ki > 1 Then
									For i_ = 1 To n
										temp(i_) = vr(i_, ki)
									Next
									blas.matrixvectormultiply(vr, 1, n, 1, ki - 1, False, _
										work, 1 + n, ki - 1 + n, 1.0, temp, 1, _
										n, work(ki + n))
									For i_ = 1 To n
										vr(i_, ki) = temp(i_)
									Next
								End If
								ii = blas.columnidxabsmax(vr, 1, n, ki)
								remax = 1 / System.Math.Abs(vr(ii, ki))
								For i_ = 1 To n
									vr(i_, ki) = remax * vr(i_, ki)
								Next
							End If
						Else

							'
							' Complex right eigenvector.
							'
							' Initial solve
							'     [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
							'     [ (T(KI,KI-1)   T(KI,KI)   )               ]
							'
							If CDbl(System.Math.Abs(t(ki - 1, ki))) >= CDbl(System.Math.Abs(t(ki, ki - 1))) Then
								work(ki - 1 + n) = 1
								work(ki + n2) = wi / t(ki - 1, ki)
							Else
								work(ki - 1 + n) = -(wi / t(ki, ki - 1))
								work(ki + n2) = 1
							End If
							work(ki + n) = 0
							work(ki - 1 + n2) = 0

							'
							' Form right-hand side
							'
							For k = 1 To ki - 2
								work(k + n) = -(work(ki - 1 + n) * t(k, ki - 1))
								work(k + n2) = -(work(ki + n2) * t(k, ki))
							Next

							'
							' Solve upper quasi-triangular system:
							' (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2)
							'
							jnxt = ki - 2
							For j = ki - 2 To 1 Step -1
								If j > jnxt Then
									Continue For
								End If
								j1 = j
								j2 = j
								jnxt = j - 1
								If j > 1 Then
									If CDbl(t(j, j - 1)) <> CDbl(0) Then
										j1 = j - 1
										jnxt = j - 2
									End If
								End If
								If j1 = j2 Then

									'
									' 1-by-1 diagonal block
									'
									temp11(1, 1) = t(j, j)
									temp12b(1, 1) = work(j + n)
									temp12b(1, 2) = work(j + n + n)
									internalhsevdlaln2(False, 1, 2, smin, 1.0, temp11, _
										1.0, 1.0, temp12b, wr, wi, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale X(1,1) and X(1,2) to avoid overflow when
									' updating the right-hand side.
									'
									If CDbl(xnorm) > CDbl(1) Then
										If CDbl(work(j)) > CDbl(bignum / xnorm) Then
											x(1, 1) = x(1, 1) / xnorm
											x(1, 2) = x(1, 2) / xnorm
											scl = scl / xnorm
										End If
									End If

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										k1 = 1 + n
										k2 = ki + n
										For i_ = k1 To k2
											work(i_) = scl * work(i_)
										Next
										k1 = 1 + n2
										k2 = ki + n2
										For i_ = k1 To k2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)
									work(j + n2) = x(1, 2)

									'
									' Update the right-hand side
									'
									k1 = 1 + n
									k2 = j - 1 + n
									k3 = 1
									k4 = j - 1
									vt = -x(1, 1)
									i1_ = (k3) - (k1)
									For i_ = k1 To k2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
									k1 = 1 + n2
									k2 = j - 1 + n2
									k3 = 1
									k4 = j - 1
									vt = -x(1, 2)
									i1_ = (k3) - (k1)
									For i_ = k1 To k2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
								Else

									'
									' 2-by-2 diagonal block
									'
									temp22(1, 1) = t(j - 1, j - 1)
									temp22(1, 2) = t(j - 1, j)
									temp22(2, 1) = t(j, j - 1)
									temp22(2, 2) = t(j, j)
									temp22b(1, 1) = work(j - 1 + n)
									temp22b(1, 2) = work(j - 1 + n + n)
									temp22b(2, 1) = work(j + n)
									temp22b(2, 2) = work(j + n + n)
									internalhsevdlaln2(False, 2, 2, smin, 1.0, temp22, _
										1.0, 1.0, temp22b, wr, wi, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale X to avoid overflow when updating
									' the right-hand side.
									'
									If CDbl(xnorm) > CDbl(1) Then
										beta = System.Math.Max(work(j - 1), work(j))
										If CDbl(beta) > CDbl(bignum / xnorm) Then
											rec = 1 / xnorm
											x(1, 1) = x(1, 1) * rec
											x(1, 2) = x(1, 2) * rec
											x(2, 1) = x(2, 1) * rec
											x(2, 2) = x(2, 2) * rec
											scl = scl * rec
										End If
									End If

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										For i_ = 1 + n To ki + n
											work(i_) = scl * work(i_)
										Next
										For i_ = 1 + n2 To ki + n2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j - 1 + n) = x(1, 1)
									work(j + n) = x(2, 1)
									work(j - 1 + n2) = x(1, 2)
									work(j + n2) = x(2, 2)

									'
									' Update the right-hand side
									'
									vt = -x(1, 1)
									i1_ = (1) - (n + 1)
									For i_ = n + 1 To n + j - 2
										work(i_) = work(i_) + vt * t(i_ + i1_, j - 1)
									Next
									vt = -x(2, 1)
									i1_ = (1) - (n + 1)
									For i_ = n + 1 To n + j - 2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
									vt = -x(1, 2)
									i1_ = (1) - (n2 + 1)
									For i_ = n2 + 1 To n2 + j - 2
										work(i_) = work(i_) + vt * t(i_ + i1_, j - 1)
									Next
									vt = -x(2, 2)
									i1_ = (1) - (n2 + 1)
									For i_ = n2 + 1 To n2 + j - 2
										work(i_) = work(i_) + vt * t(i_ + i1_, j)
									Next
								End If
							Next

							'
							' Copy the vector x or Q*x to VR and normalize.
							'
							If Not over Then
								i1_ = (n + 1) - (1)
								For i_ = 1 To ki
									vr(i_, iis - 1) = work(i_ + i1_)
								Next
								i1_ = (n2 + 1) - (1)
								For i_ = 1 To ki
									vr(i_, iis) = work(i_ + i1_)
								Next
								emax = 0
								For k = 1 To ki
									emax = System.Math.Max(emax, System.Math.Abs(vr(k, iis - 1)) + System.Math.Abs(vr(k, iis)))
								Next
								remax = 1 / emax
								For i_ = 1 To ki
									vr(i_, iis - 1) = remax * vr(i_, iis - 1)
								Next
								For i_ = 1 To ki
									vr(i_, iis) = remax * vr(i_, iis)
								Next
								For k = ki + 1 To n
									vr(k, iis - 1) = 0
									vr(k, iis) = 0
								Next
							Else
								If ki > 2 Then
									For i_ = 1 To n
										temp(i_) = vr(i_, ki - 1)
									Next
									blas.matrixvectormultiply(vr, 1, n, 1, ki - 2, False, _
										work, 1 + n, ki - 2 + n, 1.0, temp, 1, _
										n, work(ki - 1 + n))
									For i_ = 1 To n
										vr(i_, ki - 1) = temp(i_)
									Next
									For i_ = 1 To n
										temp(i_) = vr(i_, ki)
									Next
									blas.matrixvectormultiply(vr, 1, n, 1, ki - 2, False, _
										work, 1 + n2, ki - 2 + n2, 1.0, temp, 1, _
										n, work(ki + n2))
									For i_ = 1 To n
										vr(i_, ki) = temp(i_)
									Next
								Else
									vt = work(ki - 1 + n)
									For i_ = 1 To n
										vr(i_, ki - 1) = vt * vr(i_, ki - 1)
									Next
									vt = work(ki + n2)
									For i_ = 1 To n
										vr(i_, ki) = vt * vr(i_, ki)
									Next
								End If
								emax = 0
								For k = 1 To n
									emax = System.Math.Max(emax, System.Math.Abs(vr(k, ki - 1)) + System.Math.Abs(vr(k, ki)))
								Next
								remax = 1 / emax
								For i_ = 1 To n
									vr(i_, ki - 1) = remax * vr(i_, ki - 1)
								Next
								For i_ = 1 To n
									vr(i_, ki) = remax * vr(i_, ki)
								Next
							End If
						End If
						iis = iis - 1
						If ip <> 0 Then
							iis = iis - 1
						End If
					End If
					If ip = 1 Then
						ip = 0
					End If
					If ip = -1 Then
						ip = 1
					End If
				Next
			End If
			If leftv Then

				'
				' Compute left eigenvectors.
				'
				ip = 0
				iis = 1
				For ki = 1 To n
					skipflag = False
					If ip = -1 Then
						skipflag = True
					Else
						If ki <> n Then
							If CDbl(t(ki + 1, ki)) <> CDbl(0) Then
								ip = 1
							End If
						End If
						If somev Then
							If Not vselect(ki) Then
								skipflag = True
							End If
						End If
					End If
					If Not skipflag Then

						'
						' Compute the KI-th eigenvalue (WR,WI).
						'
						wr = t(ki, ki)
						wi = 0
						If ip <> 0 Then
							wi = System.Math.sqrt(System.Math.Abs(t(ki, ki + 1))) * System.Math.sqrt(System.Math.Abs(t(ki + 1, ki)))
						End If
						smin = System.Math.Max(ulp * (System.Math.Abs(wr) + System.Math.Abs(wi)), smlnum)
						If ip = 0 Then

							'
							' Real left eigenvector.
							'
							work(ki + n) = 1

							'
							' Form right-hand side
							'
							For k = ki + 1 To n
								work(k + n) = -t(ki, k)
							Next

							'
							' Solve the quasi-triangular system:
							' (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
							'
							vmax = 1
							vcrit = bignum
							jnxt = ki + 1
							For j = ki + 1 To n
								If j < jnxt Then
									Continue For
								End If
								j1 = j
								j2 = j
								jnxt = j + 1
								If j < n Then
									If CDbl(t(j + 1, j)) <> CDbl(0) Then
										j2 = j + 1
										jnxt = j + 2
									End If
								End If
								If j1 = j2 Then

									'
									' 1-by-1 diagonal block
									'
									' Scale if necessary to avoid overflow when forming
									' the right-hand side.
									'
									If CDbl(work(j)) > CDbl(vcrit) Then
										rec = 1 / vmax
										For i_ = ki + n To n + n
											work(i_) = rec * work(i_)
										Next
										vmax = 1
										vcrit = bignum
									End If
									i1_ = (ki + 1 + n) - (ki + 1)
									vt = 0.0
									For i_ = ki + 1 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n) = work(j + n) - vt

									'
									' Solve (T(J,J)-WR)'*X = WORK
									'
									temp11(1, 1) = t(j, j)
									temp11b(1, 1) = work(j + n)
									internalhsevdlaln2(False, 1, 1, smin, 1.0, temp11, _
										1.0, 1.0, temp11b, wr, 0, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										For i_ = ki + n To n + n
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)
									vmax = System.Math.Max(System.Math.Abs(work(j + n)), vmax)
									vcrit = bignum / vmax
								Else

									'
									' 2-by-2 diagonal block
									'
									' Scale if necessary to avoid overflow when forming
									' the right-hand side.
									'
									beta = System.Math.Max(work(j), work(j + 1))
									If CDbl(beta) > CDbl(vcrit) Then
										rec = 1 / vmax
										For i_ = ki + n To n + n
											work(i_) = rec * work(i_)
										Next
										vmax = 1
										vcrit = bignum
									End If
									i1_ = (ki + 1 + n) - (ki + 1)
									vt = 0.0
									For i_ = ki + 1 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n) = work(j + n) - vt
									i1_ = (ki + 1 + n) - (ki + 1)
									vt = 0.0
									For i_ = ki + 1 To j - 1
										vt += t(i_, j + 1) * work(i_ + i1_)
									Next
									work(j + 1 + n) = work(j + 1 + n) - vt

									'
									' Solve
									'    [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
									'    [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
									'
									temp22(1, 1) = t(j, j)
									temp22(1, 2) = t(j, j + 1)
									temp22(2, 1) = t(j + 1, j)
									temp22(2, 2) = t(j + 1, j + 1)
									temp21b(1, 1) = work(j + n)
									temp21b(2, 1) = work(j + 1 + n)
									internalhsevdlaln2(True, 2, 1, smin, 1.0, temp22, _
										1.0, 1.0, temp21b, wr, 0, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										For i_ = ki + n To n + n
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)
									work(j + 1 + n) = x(2, 1)
									vmax = System.Math.Max(System.Math.Abs(work(j + n)), System.Math.Max(System.Math.Abs(work(j + 1 + n)), vmax))
									vcrit = bignum / vmax
								End If
							Next

							'
							' Copy the vector x or Q*x to VL and normalize.
							'
							If Not over Then
								i1_ = (ki + n) - (ki)
								For i_ = ki To n
									vl(i_, iis) = work(i_ + i1_)
								Next
								ii = blas.columnidxabsmax(vl, ki, n, iis)
								remax = 1 / System.Math.Abs(vl(ii, iis))
								For i_ = ki To n
									vl(i_, iis) = remax * vl(i_, iis)
								Next
								For k = 1 To ki - 1
									vl(k, iis) = 0
								Next
							Else
								If ki < n Then
									For i_ = 1 To n
										temp(i_) = vl(i_, ki)
									Next
									blas.matrixvectormultiply(vl, 1, n, ki + 1, n, False, _
										work, ki + 1 + n, n + n, 1.0, temp, 1, _
										n, work(ki + n))
									For i_ = 1 To n
										vl(i_, ki) = temp(i_)
									Next
								End If
								ii = blas.columnidxabsmax(vl, 1, n, ki)
								remax = 1 / System.Math.Abs(vl(ii, ki))
								For i_ = 1 To n
									vl(i_, ki) = remax * vl(i_, ki)
								Next
							End If
						Else

							'
							' Complex left eigenvector.
							'
							' Initial solve:
							'   ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
							'   ((T(KI+1,KI) T(KI+1,KI+1))                )
							'
							If CDbl(System.Math.Abs(t(ki, ki + 1))) >= CDbl(System.Math.Abs(t(ki + 1, ki))) Then
								work(ki + n) = wi / t(ki, ki + 1)
								work(ki + 1 + n2) = 1
							Else
								work(ki + n) = 1
								work(ki + 1 + n2) = -(wi / t(ki + 1, ki))
							End If
							work(ki + 1 + n) = 0
							work(ki + n2) = 0

							'
							' Form right-hand side
							'
							For k = ki + 2 To n
								work(k + n) = -(work(ki + n) * t(ki, k))
								work(k + n2) = -(work(ki + 1 + n2) * t(ki + 1, k))
							Next

							'
							' Solve complex quasi-triangular system:
							' ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
							'
							vmax = 1
							vcrit = bignum
							jnxt = ki + 2
							For j = ki + 2 To n
								If j < jnxt Then
									Continue For
								End If
								j1 = j
								j2 = j
								jnxt = j + 1
								If j < n Then
									If CDbl(t(j + 1, j)) <> CDbl(0) Then
										j2 = j + 1
										jnxt = j + 2
									End If
								End If
								If j1 = j2 Then

									'
									' 1-by-1 diagonal block
									'
									' Scale if necessary to avoid overflow when
									' forming the right-hand side elements.
									'
									If CDbl(work(j)) > CDbl(vcrit) Then
										rec = 1 / vmax
										For i_ = ki + n To n + n
											work(i_) = rec * work(i_)
										Next
										For i_ = ki + n2 To n + n2
											work(i_) = rec * work(i_)
										Next
										vmax = 1
										vcrit = bignum
									End If
									i1_ = (ki + 2 + n) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n) = work(j + n) - vt
									i1_ = (ki + 2 + n2) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n2) = work(j + n2) - vt

									'
									' Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2
									'
									temp11(1, 1) = t(j, j)
									temp12b(1, 1) = work(j + n)
									temp12b(1, 2) = work(j + n + n)
									internalhsevdlaln2(False, 1, 2, smin, 1.0, temp11, _
										1.0, 1.0, temp12b, wr, -wi, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										For i_ = ki + n To n + n
											work(i_) = scl * work(i_)
										Next
										For i_ = ki + n2 To n + n2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)
									work(j + n2) = x(1, 2)
									vmax = System.Math.Max(System.Math.Abs(work(j + n)), System.Math.Max(System.Math.Abs(work(j + n2)), vmax))
									vcrit = bignum / vmax
								Else

									'
									' 2-by-2 diagonal block
									'
									' Scale if necessary to avoid overflow when forming
									' the right-hand side elements.
									'
									beta = System.Math.Max(work(j), work(j + 1))
									If CDbl(beta) > CDbl(vcrit) Then
										rec = 1 / vmax
										For i_ = ki + n To n + n
											work(i_) = rec * work(i_)
										Next
										For i_ = ki + n2 To n + n2
											work(i_) = rec * work(i_)
										Next
										vmax = 1
										vcrit = bignum
									End If
									i1_ = (ki + 2 + n) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n) = work(j + n) - vt
									i1_ = (ki + 2 + n2) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j) * work(i_ + i1_)
									Next
									work(j + n2) = work(j + n2) - vt
									i1_ = (ki + 2 + n) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j + 1) * work(i_ + i1_)
									Next
									work(j + 1 + n) = work(j + 1 + n) - vt
									i1_ = (ki + 2 + n2) - (ki + 2)
									vt = 0.0
									For i_ = ki + 2 To j - 1
										vt += t(i_, j + 1) * work(i_ + i1_)
									Next
									work(j + 1 + n2) = work(j + 1 + n2) - vt

									'
									' Solve 2-by-2 complex linear equation
									'   ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
									'   ([T(j+1,j) T(j+1,j+1)]             )
									'
									temp22(1, 1) = t(j, j)
									temp22(1, 2) = t(j, j + 1)
									temp22(2, 1) = t(j + 1, j)
									temp22(2, 2) = t(j + 1, j + 1)
									temp22b(1, 1) = work(j + n)
									temp22b(1, 2) = work(j + n + n)
									temp22b(2, 1) = work(j + 1 + n)
									temp22b(2, 2) = work(j + 1 + n + n)
									internalhsevdlaln2(True, 2, 2, smin, 1.0, temp22, _
										1.0, 1.0, temp22b, wr, -wi, rswap4, _
										zswap4, ipivot44, civ4, crv4, x, scl, _
										xnorm, ierr)

									'
									' Scale if necessary
									'
									If CDbl(scl) <> CDbl(1) Then
										For i_ = ki + n To n + n
											work(i_) = scl * work(i_)
										Next
										For i_ = ki + n2 To n + n2
											work(i_) = scl * work(i_)
										Next
									End If
									work(j + n) = x(1, 1)
									work(j + n2) = x(1, 2)
									work(j + 1 + n) = x(2, 1)
									work(j + 1 + n2) = x(2, 2)
									vmax = System.Math.Max(System.Math.Abs(x(1, 1)), vmax)
									vmax = System.Math.Max(System.Math.Abs(x(1, 2)), vmax)
									vmax = System.Math.Max(System.Math.Abs(x(2, 1)), vmax)
									vmax = System.Math.Max(System.Math.Abs(x(2, 2)), vmax)
									vcrit = bignum / vmax
								End If
							Next

							'
							' Copy the vector x or Q*x to VL and normalize.
							'
							If Not over Then
								i1_ = (ki + n) - (ki)
								For i_ = ki To n
									vl(i_, iis) = work(i_ + i1_)
								Next
								i1_ = (ki + n2) - (ki)
								For i_ = ki To n
									vl(i_, iis + 1) = work(i_ + i1_)
								Next
								emax = 0
								For k = ki To n
									emax = System.Math.Max(emax, System.Math.Abs(vl(k, iis)) + System.Math.Abs(vl(k, iis + 1)))
								Next
								remax = 1 / emax
								For i_ = ki To n
									vl(i_, iis) = remax * vl(i_, iis)
								Next
								For i_ = ki To n
									vl(i_, iis + 1) = remax * vl(i_, iis + 1)
								Next
								For k = 1 To ki - 1
									vl(k, iis) = 0
									vl(k, iis + 1) = 0
								Next
							Else
								If ki < n - 1 Then
									For i_ = 1 To n
										temp(i_) = vl(i_, ki)
									Next
									blas.matrixvectormultiply(vl, 1, n, ki + 2, n, False, _
										work, ki + 2 + n, n + n, 1.0, temp, 1, _
										n, work(ki + n))
									For i_ = 1 To n
										vl(i_, ki) = temp(i_)
									Next
									For i_ = 1 To n
										temp(i_) = vl(i_, ki + 1)
									Next
									blas.matrixvectormultiply(vl, 1, n, ki + 2, n, False, _
										work, ki + 2 + n2, n + n2, 1.0, temp, 1, _
										n, work(ki + 1 + n2))
									For i_ = 1 To n
										vl(i_, ki + 1) = temp(i_)
									Next
								Else
									vt = work(ki + n)
									For i_ = 1 To n
										vl(i_, ki) = vt * vl(i_, ki)
									Next
									vt = work(ki + 1 + n2)
									For i_ = 1 To n
										vl(i_, ki + 1) = vt * vl(i_, ki + 1)
									Next
								End If
								emax = 0
								For k = 1 To n
									emax = System.Math.Max(emax, System.Math.Abs(vl(k, ki)) + System.Math.Abs(vl(k, ki + 1)))
								Next
								remax = 1 / emax
								For i_ = 1 To n
									vl(i_, ki) = remax * vl(i_, ki)
								Next
								For i_ = 1 To n
									vl(i_, ki + 1) = remax * vl(i_, ki + 1)
								Next
							End If
						End If
						iis = iis + 1
						If ip <> 0 Then
							iis = iis + 1
						End If
					End If
					If ip = -1 Then
						ip = 0
					End If
					If ip = 1 Then
						ip = -1
					End If
				Next
			End If
		End Sub


		'************************************************************************
'        DLALN2 solves a system of the form  (ca A - w D ) X = s B
'        or (ca A' - w D) X = s B   with possible scaling ("s") and
'        perturbation of A.  (A' means A-transpose.)
'
'        A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
'        real diagonal matrix, w is a real or complex value, and X and B are
'        NA x 1 matrices -- real if w is real, complex if w is complex.  NA
'        may be 1 or 2.
'
'        If w is complex, X and B are represented as NA x 2 matrices,
'        the first column of each being the real part and the second
'        being the imaginary part.
'
'        "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
'        so chosen that X can be computed without overflow.  X is further
'        scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
'        than overflow.
'
'        If both singular values of (ca A - w D) are less than SMIN,
'        SMIN*identity will be used instead of (ca A - w D).  If only one
'        singular value is less than SMIN, one element of (ca A - w D) will be
'        perturbed enough to make the smallest singular value roughly SMIN.
'        If both singular values are at least SMIN, (ca A - w D) will not be
'        perturbed.  In any case, the perturbation will be at most some small
'        multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
'        are computed by infinity-norm approximations, and thus will only be
'        correct to a factor of 2 or so.
'
'        Note: all input quantities are assumed to be smaller than overflow
'        by a reasonable factor.  (See BIGNUM.)
'
'          -- LAPACK auxiliary routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1992
'        ************************************************************************

		Private Shared Sub internalhsevdlaln2(ltrans As Boolean, na As Integer, nw As Integer, smin As Double, ca As Double, a As Double(,), _
			d1 As Double, d2 As Double, b As Double(,), wr As Double, wi As Double, ByRef rswap4 As Boolean(), _
			ByRef zswap4 As Boolean(), ByRef ipivot44 As Integer(,), ByRef civ4 As Double(), ByRef crv4 As Double(), ByRef x As Double(,), ByRef scl As Double, _
			ByRef xnorm As Double, ByRef info As Integer)
			Dim icmax As Integer = 0
			Dim j As Integer = 0
			Dim bbnd As Double = 0
			Dim bi1 As Double = 0
			Dim bi2 As Double = 0
			Dim bignum As Double = 0
			Dim bnorm As Double = 0
			Dim br1 As Double = 0
			Dim br2 As Double = 0
			Dim ci21 As Double = 0
			Dim ci22 As Double = 0
			Dim cmax As Double = 0
			Dim cnorm As Double = 0
			Dim cr21 As Double = 0
			Dim cr22 As Double = 0
			Dim csi As Double = 0
			Dim csr As Double = 0
			Dim li21 As Double = 0
			Dim lr21 As Double = 0
			Dim smini As Double = 0
			Dim smlnum As Double = 0
			Dim temp As Double = 0
			Dim u22abs As Double = 0
			Dim ui11 As Double = 0
			Dim ui11r As Double = 0
			Dim ui12 As Double = 0
			Dim ui12s As Double = 0
			Dim ui22 As Double = 0
			Dim ur11 As Double = 0
			Dim ur11r As Double = 0
			Dim ur12 As Double = 0
			Dim ur12s As Double = 0
			Dim ur22 As Double = 0
			Dim xi1 As Double = 0
			Dim xi2 As Double = 0
			Dim xr1 As Double = 0
			Dim xr2 As Double = 0
			Dim tmp1 As Double = 0
			Dim tmp2 As Double = 0

			scl = 0
			xnorm = 0
			info = 0

			zswap4(1) = False
			zswap4(2) = False
			zswap4(3) = True
			zswap4(4) = True
			rswap4(1) = False
			rswap4(2) = True
			rswap4(3) = False
			rswap4(4) = True
			ipivot44(1, 1) = 1
			ipivot44(2, 1) = 2
			ipivot44(3, 1) = 3
			ipivot44(4, 1) = 4
			ipivot44(1, 2) = 2
			ipivot44(2, 2) = 1
			ipivot44(3, 2) = 4
			ipivot44(4, 2) = 3
			ipivot44(1, 3) = 3
			ipivot44(2, 3) = 4
			ipivot44(3, 3) = 1
			ipivot44(4, 3) = 2
			ipivot44(1, 4) = 4
			ipivot44(2, 4) = 3
			ipivot44(3, 4) = 2
			ipivot44(4, 4) = 1
			smlnum = 2 * Math.minrealnumber
			bignum = 1 / smlnum
			smini = System.Math.Max(smin, smlnum)

			'
			' Don't check for input errors
			'
			info = 0

			'
			' Standard Initializations
			'
			scl = 1
			If na = 1 Then

				'
				' 1 x 1  (i.e., scalar) system   C X = B
				'
				If nw = 1 Then

					'
					' Real 1x1 system.
					'
					' C = ca A - w D
					'
					csr = ca * a(1, 1) - wr * d1
					cnorm = System.Math.Abs(csr)

					'
					' If | C | < SMINI, use C = SMINI
					'
					If CDbl(cnorm) < CDbl(smini) Then
						csr = smini
						cnorm = smini
						info = 1
					End If

					'
					' Check scaling for  X = B / C
					'
					bnorm = System.Math.Abs(b(1, 1))
					If CDbl(cnorm) < CDbl(1) AndAlso CDbl(bnorm) > CDbl(1) Then
						If CDbl(bnorm) > CDbl(bignum * cnorm) Then
							scl = 1 / bnorm
						End If
					End If

					'
					' Compute X
					'
					x(1, 1) = b(1, 1) * scl / csr
					xnorm = System.Math.Abs(x(1, 1))
				Else

					'
					' Complex 1x1 system (w is complex)
					'
					' C = ca A - w D
					'
					csr = ca * a(1, 1) - wr * d1
					csi = -(wi * d1)
					cnorm = System.Math.Abs(csr) + System.Math.Abs(csi)

					'
					' If | C | < SMINI, use C = SMINI
					'
					If CDbl(cnorm) < CDbl(smini) Then
						csr = smini
						csi = 0
						cnorm = smini
						info = 1
					End If

					'
					' Check scaling for  X = B / C
					'
					bnorm = System.Math.Abs(b(1, 1)) + System.Math.Abs(b(1, 2))
					If CDbl(cnorm) < CDbl(1) AndAlso CDbl(bnorm) > CDbl(1) Then
						If CDbl(bnorm) > CDbl(bignum * cnorm) Then
							scl = 1 / bnorm
						End If
					End If

					'
					' Compute X
					'
					internalhsevdladiv(scl * b(1, 1), scl * b(1, 2), csr, csi, tmp1, tmp2)
					x(1, 1) = tmp1
					x(1, 2) = tmp2
					xnorm = System.Math.Abs(x(1, 1)) + System.Math.Abs(x(1, 2))
				End If
			Else

				'
				' 2x2 System
				'
				' Compute the real part of  C = ca A - w D  (or  ca A' - w D )
				'
				crv4(1 + 0) = ca * a(1, 1) - wr * d1
				crv4(2 + 2) = ca * a(2, 2) - wr * d2
				If ltrans Then
					crv4(1 + 2) = ca * a(2, 1)
					crv4(2 + 0) = ca * a(1, 2)
				Else
					crv4(2 + 0) = ca * a(2, 1)
					crv4(1 + 2) = ca * a(1, 2)
				End If
				If nw = 1 Then

					'
					' Real 2x2 system  (w is real)
					'
					' Find the largest element in C
					'
					cmax = 0
					icmax = 0
					For j = 1 To 4
						If CDbl(System.Math.Abs(crv4(j))) > CDbl(cmax) Then
							cmax = System.Math.Abs(crv4(j))
							icmax = j
						End If
					Next

					'
					' If norm(C) < SMINI, use SMINI*identity.
					'
					If CDbl(cmax) < CDbl(smini) Then
						bnorm = System.Math.Max(System.Math.Abs(b(1, 1)), System.Math.Abs(b(2, 1)))
						If CDbl(smini) < CDbl(1) AndAlso CDbl(bnorm) > CDbl(1) Then
							If CDbl(bnorm) > CDbl(bignum * smini) Then
								scl = 1 / bnorm
							End If
						End If
						temp = scl / smini
						x(1, 1) = temp * b(1, 1)
						x(2, 1) = temp * b(2, 1)
						xnorm = temp * bnorm
						info = 1
						Return
					End If

					'
					' Gaussian elimination with complete pivoting.
					'
					ur11 = crv4(icmax)
					cr21 = crv4(ipivot44(2, icmax))
					ur12 = crv4(ipivot44(3, icmax))
					cr22 = crv4(ipivot44(4, icmax))
					ur11r = 1 / ur11
					lr21 = ur11r * cr21
					ur22 = cr22 - ur12 * lr21

					'
					' If smaller pivot < SMINI, use SMINI
					'
					If CDbl(System.Math.Abs(ur22)) < CDbl(smini) Then
						ur22 = smini
						info = 1
					End If
					If rswap4(icmax) Then
						br1 = b(2, 1)
						br2 = b(1, 1)
					Else
						br1 = b(1, 1)
						br2 = b(2, 1)
					End If
					br2 = br2 - lr21 * br1
					bbnd = System.Math.Max(System.Math.Abs(br1 * (ur22 * ur11r)), System.Math.Abs(br2))
					If CDbl(bbnd) > CDbl(1) AndAlso CDbl(System.Math.Abs(ur22)) < CDbl(1) Then
						If CDbl(bbnd) >= CDbl(bignum * System.Math.Abs(ur22)) Then
							scl = 1 / bbnd
						End If
					End If
					xr2 = br2 * scl / ur22
					xr1 = scl * br1 * ur11r - xr2 * (ur11r * ur12)
					If zswap4(icmax) Then
						x(1, 1) = xr2
						x(2, 1) = xr1
					Else
						x(1, 1) = xr1
						x(2, 1) = xr2
					End If
					xnorm = System.Math.Max(System.Math.Abs(xr1), System.Math.Abs(xr2))

					'
					' Further scaling if  norm(A) norm(X) > overflow
					'
					If CDbl(xnorm) > CDbl(1) AndAlso CDbl(cmax) > CDbl(1) Then
						If CDbl(xnorm) > CDbl(bignum / cmax) Then
							temp = cmax / bignum
							x(1, 1) = temp * x(1, 1)
							x(2, 1) = temp * x(2, 1)
							xnorm = temp * xnorm
							scl = temp * scl
						End If
					End If
				Else

					'
					' Complex 2x2 system  (w is complex)
					'
					' Find the largest element in C
					'
					civ4(1 + 0) = -(wi * d1)
					civ4(2 + 0) = 0
					civ4(1 + 2) = 0
					civ4(2 + 2) = -(wi * d2)
					cmax = 0
					icmax = 0
					For j = 1 To 4
						If CDbl(System.Math.Abs(crv4(j)) + System.Math.Abs(civ4(j))) > CDbl(cmax) Then
							cmax = System.Math.Abs(crv4(j)) + System.Math.Abs(civ4(j))
							icmax = j
						End If
					Next

					'
					' If norm(C) < SMINI, use SMINI*identity.
					'
					If CDbl(cmax) < CDbl(smini) Then
						bnorm = System.Math.Max(System.Math.Abs(b(1, 1)) + System.Math.Abs(b(1, 2)), System.Math.Abs(b(2, 1)) + System.Math.Abs(b(2, 2)))
						If CDbl(smini) < CDbl(1) AndAlso CDbl(bnorm) > CDbl(1) Then
							If CDbl(bnorm) > CDbl(bignum * smini) Then
								scl = 1 / bnorm
							End If
						End If
						temp = scl / smini
						x(1, 1) = temp * b(1, 1)
						x(2, 1) = temp * b(2, 1)
						x(1, 2) = temp * b(1, 2)
						x(2, 2) = temp * b(2, 2)
						xnorm = temp * bnorm
						info = 1
						Return
					End If

					'
					' Gaussian elimination with complete pivoting.
					'
					ur11 = crv4(icmax)
					ui11 = civ4(icmax)
					cr21 = crv4(ipivot44(2, icmax))
					ci21 = civ4(ipivot44(2, icmax))
					ur12 = crv4(ipivot44(3, icmax))
					ui12 = civ4(ipivot44(3, icmax))
					cr22 = crv4(ipivot44(4, icmax))
					ci22 = civ4(ipivot44(4, icmax))
					If icmax = 1 OrElse icmax = 4 Then

						'
						' Code when off-diagonals of pivoted C are real
						'
						If CDbl(System.Math.Abs(ur11)) > CDbl(System.Math.Abs(ui11)) Then
							temp = ui11 / ur11
							ur11r = 1 / (ur11 * (1 + Math.sqr(temp)))
							ui11r = -(temp * ur11r)
						Else
							temp = ur11 / ui11
							ui11r = -(1 / (ui11 * (1 + Math.sqr(temp))))
							ur11r = -(temp * ui11r)
						End If
						lr21 = cr21 * ur11r
						li21 = cr21 * ui11r
						ur12s = ur12 * ur11r
						ui12s = ur12 * ui11r
						ur22 = cr22 - ur12 * lr21
						ui22 = ci22 - ur12 * li21
					Else

						'
						' Code when diagonals of pivoted C are real
						'
						ur11r = 1 / ur11
						ui11r = 0
						lr21 = cr21 * ur11r
						li21 = ci21 * ur11r
						ur12s = ur12 * ur11r
						ui12s = ui12 * ur11r
						ur22 = cr22 - ur12 * lr21 + ui12 * li21
						ui22 = -(ur12 * li21) - ui12 * lr21
					End If
					u22abs = System.Math.Abs(ur22) + System.Math.Abs(ui22)

					'
					' If smaller pivot < SMINI, use SMINI
					'
					If CDbl(u22abs) < CDbl(smini) Then
						ur22 = smini
						ui22 = 0
						info = 1
					End If
					If rswap4(icmax) Then
						br2 = b(1, 1)
						br1 = b(2, 1)
						bi2 = b(1, 2)
						bi1 = b(2, 2)
					Else
						br1 = b(1, 1)
						br2 = b(2, 1)
						bi1 = b(1, 2)
						bi2 = b(2, 2)
					End If
					br2 = br2 - lr21 * br1 + li21 * bi1
					bi2 = bi2 - li21 * br1 - lr21 * bi1
					bbnd = System.Math.Max((System.Math.Abs(br1) + System.Math.Abs(bi1)) * (u22abs * (System.Math.Abs(ur11r) + System.Math.Abs(ui11r))), System.Math.Abs(br2) + System.Math.Abs(bi2))
					If CDbl(bbnd) > CDbl(1) AndAlso CDbl(u22abs) < CDbl(1) Then
						If CDbl(bbnd) >= CDbl(bignum * u22abs) Then
							scl = 1 / bbnd
							br1 = scl * br1
							bi1 = scl * bi1
							br2 = scl * br2
							bi2 = scl * bi2
						End If
					End If
					internalhsevdladiv(br2, bi2, ur22, ui22, xr2, xi2)
					xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2
					xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2
					If zswap4(icmax) Then
						x(1, 1) = xr2
						x(2, 1) = xr1
						x(1, 2) = xi2
						x(2, 2) = xi1
					Else
						x(1, 1) = xr1
						x(2, 1) = xr2
						x(1, 2) = xi1
						x(2, 2) = xi2
					End If
					xnorm = System.Math.Max(System.Math.Abs(xr1) + System.Math.Abs(xi1), System.Math.Abs(xr2) + System.Math.Abs(xi2))

					'
					' Further scaling if  norm(A) norm(X) > overflow
					'
					If CDbl(xnorm) > CDbl(1) AndAlso CDbl(cmax) > CDbl(1) Then
						If CDbl(xnorm) > CDbl(bignum / cmax) Then
							temp = cmax / bignum
							x(1, 1) = temp * x(1, 1)
							x(2, 1) = temp * x(2, 1)
							x(1, 2) = temp * x(1, 2)
							x(2, 2) = temp * x(2, 2)
							xnorm = temp * xnorm
							scl = temp * scl
						End If
					End If
				End If
			End If
		End Sub


		'************************************************************************
'        performs complex division in  real arithmetic
'
'                                a + i*b
'                     p + i*q = ---------
'                                c + i*d
'
'        The algorithm is due to Robert L. Smith and can be found
'        in D. Knuth, The art of Computer Programming, Vol.2, p.195
'
'          -- LAPACK auxiliary routine (version 3.0) --
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             October 31, 1992
'        ************************************************************************

		Private Shared Sub internalhsevdladiv(a As Double, b As Double, c As Double, d As Double, ByRef p As Double, ByRef q As Double)
			Dim e As Double = 0
			Dim f As Double = 0

			p = 0
			q = 0

			If CDbl(System.Math.Abs(d)) < CDbl(System.Math.Abs(c)) Then
				e = d / c
				f = c + d * e
				p = (a + b * e) / f
				q = (b - a * e) / f
			Else
				e = c / d
				f = d + c * e
				p = (b + a * e) / f
				q = (-a + b * e) / f
			End If
		End Sub


	End Class
	Public Class matgen
		'************************************************************************
'        Generation of a random uniformly distributed (Haar) orthogonal matrix
'
'        INPUT PARAMETERS:
'            N   -   matrix size, N>=1
'            
'        OUTPUT PARAMETERS:
'            A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
'
'        NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
'              "The Efficient Generation of  Random  Orthogonal  Matrices  with  an
'              Application to Condition Estimators".
'              
'              Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
'              * takes an NxN one
'              * takes uniformly distributed unit vector of dimension N+1.
'              * constructs a Householder reflection from the vector, then applies
'                it to the smaller matrix (embedded in the larger size with a 1 at
'                the bottom right corner).
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixrndorthogonal(n As Integer, ByRef a As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0

			a = New Double(-1, -1) {}

			alglib.ap.assert(n >= 1, "RMatrixRndOrthogonal: N<1!")
			a = New Double(n - 1, n - 1) {}
			For i = 0 To n - 1
				For j = 0 To n - 1
					If i = j Then
						a(i, j) = 1
					Else
						a(i, j) = 0
					End If
				Next
			Next
			rmatrixrndorthogonalfromtheright(a, n, n)
		End Sub


		'************************************************************************
'        Generation of random NxN matrix with given condition number and norm2(A)=1
'
'        INPUT PARAMETERS:
'            N   -   matrix size
'            C   -   condition number (in 2-norm)
'
'        OUTPUT PARAMETERS:
'            A   -   random matrix with norm2(A)=1 and cond(A)=C
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim l1 As Double = 0
			Dim l2 As Double = 0
			Dim rs As New hqrnd.hqrndstate()

			a = New Double(-1, -1) {}

			alglib.ap.assert(n >= 1 AndAlso CDbl(c) >= CDbl(1), "RMatrixRndCond: N<1 or C<1!")
			a = New Double(n - 1, n - 1) {}
			If n = 1 Then

				'
				' special case
				'
                a(0, 0) = 2 * Math.randominteger(2) - 1
                Return
            End If
            hqrnd.hqrndrandomize(rs)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = System.Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)
            rmatrixrndorthogonalfromtheleft(a, n, n)
            rmatrixrndorthogonalfromtheright(a, n, n)
        End Sub


        '************************************************************************
        '        Generation of a random Haar distributed orthogonal complex matrix
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size, N>=1
        '
        '        OUTPUT PARAMETERS:
        '            A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
        '
        '        NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
        '              "The Efficient Generation of  Random  Orthogonal  Matrices  with  an
        '              Application to Condition Estimators".
        '              
        '              Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
        '              * takes an NxN one
        '              * takes uniformly distributed unit vector of dimension N+1.
        '              * constructs a Householder reflection from the vector, then applies
        '                it to the smaller matrix (embedded in the larger size with a 1 at
        '                the bottom right corner).
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub cmatrixrndorthogonal(n As Integer, ByRef a As complex(,))
            Dim i As Integer = 0
            Dim j As Integer = 0

            a = New complex(-1, -1) {}

            alglib.ap.assert(n >= 1, "CMatrixRndOrthogonal: N<1!")
            a = New complex(n - 1, n - 1) {}
            For i = 0 To n - 1
                For j = 0 To n - 1
                    If i = j Then
                        a(i, j) = 1
                    Else
                        a(i, j) = 0
                    End If
                Next
            Next
            cmatrixrndorthogonalfromtheright(a, n, n)
        End Sub


        '************************************************************************
        '        Generation of random NxN complex matrix with given condition number C and
        '        norm2(A)=1
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size
        '            C   -   condition number (in 2-norm)
        '
        '        OUTPUT PARAMETERS:
        '            A   -   random matrix with norm2(A)=1 and cond(A)=C
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub cmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim l1 As Double = 0
            Dim l2 As Double = 0
            Dim state As New hqrnd.hqrndstate()
            Dim v As complex = 0

            a = New complex(-1, -1) {}

            alglib.ap.assert(n >= 1 AndAlso CDbl(c) >= CDbl(1), "CMatrixRndCond: N<1 or C<1!")
            a = New complex(n - 1, n - 1) {}
            If n = 1 Then

                '
                ' special case
                '
                hqrnd.hqrndrandomize(state)
                hqrnd.hqrndunit2(state, v.x, v.y)
                a(0, 0) = v
                Return
            End If
            hqrnd.hqrndrandomize(state)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = System.Math.Exp(hqrnd.hqrnduniformr(state) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)
            cmatrixrndorthogonalfromtheleft(a, n, n)
            cmatrixrndorthogonalfromtheright(a, n, n)
        End Sub


        '************************************************************************
        '        Generation of random NxN symmetric matrix with given condition number  and
        '        norm2(A)=1
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size
        '            C   -   condition number (in 2-norm)
        '
        '        OUTPUT PARAMETERS:
        '            A   -   random matrix with norm2(A)=1 and cond(A)=C
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub smatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim l1 As Double = 0
            Dim l2 As Double = 0
            Dim rs As New hqrnd.hqrndstate()

            a = New Double(-1, -1) {}

            alglib.ap.assert(n >= 1 AndAlso CDbl(c) >= CDbl(1), "SMatrixRndCond: N<1 or C<1!")
            a = New Double(n - 1, n - 1) {}
            If n = 1 Then

                '
                ' special case
                '
                a(0, 0) = 2 * Math.randominteger(2) - 1
                Return
            End If

            '
            ' Prepare matrix
            '
            hqrnd.hqrndrandomize(rs)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = (2 * hqrnd.hqrnduniformi(rs, 2) - 1) * System.Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)

            '
            ' Multiply
            '
            smatrixrndmultiply(a, n)
        End Sub


        '************************************************************************
        '        Generation of random NxN symmetric positive definite matrix with given
        '        condition number and norm2(A)=1
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size
        '            C   -   condition number (in 2-norm)
        '
        '        OUTPUT PARAMETERS:
        '            A   -   random SPD matrix with norm2(A)=1 and cond(A)=C
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub spdmatrixrndcond(n As Integer, c As Double, ByRef a As Double(,))
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim l1 As Double = 0
            Dim l2 As Double = 0
            Dim rs As New hqrnd.hqrndstate()

            a = New Double(-1, -1) {}


            '
            ' Special cases
            '
            If n <= 0 OrElse CDbl(c) < CDbl(1) Then
                Return
            End If
            a = New Double(n - 1, n - 1) {}
            If n = 1 Then
                a(0, 0) = 1
                Return
            End If

            '
            ' Prepare matrix
            '
            hqrnd.hqrndrandomize(rs)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = System.Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)

            '
            ' Multiply
            '
            smatrixrndmultiply(a, n)
        End Sub


        '************************************************************************
        '        Generation of random NxN Hermitian matrix with given condition number  and
        '        norm2(A)=1
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size
        '            C   -   condition number (in 2-norm)
        '
        '        OUTPUT PARAMETERS:
        '            A   -   random matrix with norm2(A)=1 and cond(A)=C
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub hmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim l1 As Double = 0
            Dim l2 As Double = 0
            Dim rs As New hqrnd.hqrndstate()

            a = New complex(-1, -1) {}

            alglib.ap.assert(n >= 1 AndAlso CDbl(c) >= CDbl(1), "HMatrixRndCond: N<1 or C<1!")
            a = New complex(n - 1, n - 1) {}
            If n = 1 Then

                '
                ' special case
                '
                a(0, 0) = 2 * Math.randominteger(2) - 1
                Return
            End If

            '
            ' Prepare matrix
            '
            hqrnd.hqrndrandomize(rs)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = (2 * hqrnd.hqrnduniformi(rs, 2) - 1) * System.Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)

            '
            ' Multiply
            '
            hmatrixrndmultiply(a, n)

            '
            ' post-process to ensure that matrix diagonal is real
            '
            For i = 0 To n - 1
                a(i, i).y = 0
            Next
        End Sub


        '************************************************************************
        '        Generation of random NxN Hermitian positive definite matrix with given
        '        condition number and norm2(A)=1
        '
        '        INPUT PARAMETERS:
        '            N   -   matrix size
        '            C   -   condition number (in 2-norm)
        '
        '        OUTPUT PARAMETERS:
        '            A   -   random HPD matrix with norm2(A)=1 and cond(A)=C
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub hpdmatrixrndcond(n As Integer, c As Double, ByRef a As complex(,))
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim l1 As Double = 0
            Dim l2 As Double = 0
            Dim rs As New hqrnd.hqrndstate()

            a = New complex(-1, -1) {}


            '
            ' Special cases
            '
            If n <= 0 OrElse CDbl(c) < CDbl(1) Then
                Return
            End If
            a = New complex(n - 1, n - 1) {}
            If n = 1 Then
                a(0, 0) = 1
                Return
            End If

            '
            ' Prepare matrix
            '
            hqrnd.hqrndrandomize(rs)
            l1 = 0
            l2 = System.Math.Log(1 / c)
            For i = 0 To n - 1
                For j = 0 To n - 1
                    a(i, j) = 0
                Next
            Next
            a(0, 0) = System.Math.Exp(l1)
            For i = 1 To n - 2
                a(i, i) = System.Math.Exp(hqrnd.hqrnduniformr(rs) * (l2 - l1) + l1)
            Next
            a(n - 1, n - 1) = System.Math.Exp(l2)

            '
            ' Multiply
            '
            hmatrixrndmultiply(a, n)

            '
            ' post-process to ensure that matrix diagonal is real
            '
            For i = 0 To n - 1
                a(i, i).y = 0
            Next
        End Sub


        '************************************************************************
        '        Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix
        '
        '        INPUT PARAMETERS:
        '            A   -   matrix, array[0..M-1, 0..N-1]
        '            M, N-   matrix size
        '
        '        OUTPUT PARAMETERS:
        '            A   -   A*Q, where Q is random NxN orthogonal matrix
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub rmatrixrndorthogonalfromtheright(ByRef a As Double(,), m As Integer, n As Integer)
            Dim tau As Double = 0
            Dim lambdav As Double = 0
            Dim s As Integer = 0
            Dim i As Integer = 0
            Dim u1 As Double = 0
            Dim u2 As Double = 0
            Dim w As Double() = New Double(-1) {}
            Dim v As Double() = New Double(-1) {}
            Dim state As New hqrnd.hqrndstate()
            Dim i_ As Integer = 0

            alglib.ap.assert(n >= 1 AndAlso m >= 1, "RMatrixRndOrthogonalFromTheRight: N<1 or M<1!")
            If n = 1 Then

                '
                ' Special case
                '
                tau = 2 * Math.randominteger(2) - 1
                For i = 0 To m - 1
                    a(i, 0) = a(i, 0) * tau
                Next
                Return
            End If

            '
            ' General case.
            ' First pass.
            '
            w = New Double(m - 1) {}
            v = New Double(n) {}
            hqrnd.hqrndrandomize(state)
            For s = 2 To n

                '
                ' Prepare random normal v
                '
                Do
                    i = 1
                    While i <= s
                        hqrnd.hqrndnormal2(state, u1, u2)
                        v(i) = u1
                        If i + 1 <= s Then
                            v(i + 1) = u2
                        End If
                        i = i + 2
                    End While
                    lambdav = 0.0
                    For i_ = 1 To s
                        lambdav += v(i_) * v(i_)
                    Next
                Loop While CDbl(lambdav) = CDbl(0)

                '
                ' Prepare and apply reflection
                '
                reflections.generatereflection(v, s, tau)
                v(1) = 1
                reflections.applyreflectionfromtheright(a, tau, v, 0, m - 1, n - s, _
                    n - 1, w)
            Next

            '
            ' Second pass.
            '
            For i = 0 To n - 1
                tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1
                For i_ = 0 To m - 1
                    a(i_, i) = tau * a(i_, i)
                Next
            Next
        End Sub


        '************************************************************************
        '        Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix
        '
        '        INPUT PARAMETERS:
        '            A   -   matrix, array[0..M-1, 0..N-1]
        '            M, N-   matrix size
        '
        '        OUTPUT PARAMETERS:
        '            A   -   Q*A, where Q is random MxM orthogonal matrix
        '
        '          -- ALGLIB routine --
        '             04.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub rmatrixrndorthogonalfromtheleft(ByRef a As Double(,), m As Integer, n As Integer)
            Dim tau As Double = 0
            Dim lambdav As Double = 0
            Dim s As Integer = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim u1 As Double = 0
            Dim u2 As Double = 0
            Dim w As Double() = New Double(-1) {}
            Dim v As Double() = New Double(-1) {}
            Dim state As New hqrnd.hqrndstate()
            Dim i_ As Integer = 0

            alglib.ap.assert(n >= 1 AndAlso m >= 1, "RMatrixRndOrthogonalFromTheRight: N<1 or M<1!")
            If m = 1 Then

                '
                ' special case
                '
                tau = 2 * Math.randominteger(2) - 1
                For j = 0 To n - 1
                    a(0, j) = a(0, j) * tau
                Next
                Return
            End If

            '
            ' General case.
            ' First pass.
            '
            w = New Double(n - 1) {}
            v = New Double(m) {}
            hqrnd.hqrndrandomize(state)
            For s = 2 To m

                '
                ' Prepare random normal v
                '
                Do
                    i = 1
                    While i <= s
                        hqrnd.hqrndnormal2(state, u1, u2)
                        v(i) = u1
                        If i + 1 <= s Then
                            v(i + 1) = u2
                        End If
                        i = i + 2
                    End While
                    lambdav = 0.0
                    For i_ = 1 To s
                        lambdav += v(i_) * v(i_)
                    Next
                Loop While CDbl(lambdav) = CDbl(0)

                '
                ' Prepare and apply reflection
                '
                reflections.generatereflection(v, s, tau)
                v(1) = 1
                reflections.applyreflectionfromtheleft(a, tau, v, m - s, m - 1, 0, _
                    n - 1, w)
            Next

            '
            ' Second pass.
            '
            For i = 0 To m - 1
                tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1
                For i_ = 0 To n - 1
                    a(i, i_) = tau * a(i, i_)
                Next
            Next
        End Sub


		'************************************************************************
'        Multiplication of MxN complex matrix by NxN random Haar distributed
'        complex orthogonal matrix
'
'        INPUT PARAMETERS:
'            A   -   matrix, array[0..M-1, 0..N-1]
'            M, N-   matrix size
'
'        OUTPUT PARAMETERS:
'            A   -   A*Q, where Q is random NxN orthogonal matrix
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixrndorthogonalfromtheright(ByRef a As complex(,), m As Integer, n As Integer)
			Dim lambdav As complex = 0
			Dim tau As complex = 0
			Dim s As Integer = 0
			Dim i As Integer = 0
			Dim w As complex() = New complex(-1) {}
			Dim v As complex() = New complex(-1) {}
			Dim state As New hqrnd.hqrndstate()
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1 AndAlso m >= 1, "CMatrixRndOrthogonalFromTheRight: N<1 or M<1!")
			If n = 1 Then

				'
				' Special case
				'
				hqrnd.hqrndrandomize(state)
				hqrnd.hqrndunit2(state, tau.x, tau.y)
				For i = 0 To m - 1
					a(i, 0) = a(i, 0) * tau
				Next
				Return
			End If

			'
			' General case.
			' First pass.
			'
			w = New complex(m - 1) {}
			v = New complex(n) {}
			hqrnd.hqrndrandomize(state)
			For s = 2 To n

				'
				' Prepare random normal v
				'
				Do
					For i = 1 To s
						hqrnd.hqrndnormal2(state, tau.x, tau.y)
						v(i) = tau
					Next
					lambdav = 0.0
					For i_ = 1 To s
						lambdav += v(i_) * Math.conj(v(i_))
					Next
				Loop While lambdav = 0

				'
				' Prepare and apply reflection
				'
				creflections.complexgeneratereflection(v, s, tau)
				v(1) = 1
				creflections.complexapplyreflectionfromtheright(a, tau, v, 0, m - 1, n - s, _
					n - 1, w)
			Next

			'
			' Second pass.
			'
			For i = 0 To n - 1
				hqrnd.hqrndunit2(state, tau.x, tau.y)
				For i_ = 0 To m - 1
					a(i_, i) = tau * a(i_, i)
				Next
			Next
		End Sub


		'************************************************************************
'        Multiplication of MxN complex matrix by MxM random Haar distributed
'        complex orthogonal matrix
'
'        INPUT PARAMETERS:
'            A   -   matrix, array[0..M-1, 0..N-1]
'            M, N-   matrix size
'
'        OUTPUT PARAMETERS:
'            A   -   Q*A, where Q is random MxM orthogonal matrix
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixrndorthogonalfromtheleft(ByRef a As complex(,), m As Integer, n As Integer)
			Dim tau As complex = 0
			Dim lambdav As complex = 0
			Dim s As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim w As complex() = New complex(-1) {}
			Dim v As complex() = New complex(-1) {}
			Dim state As New hqrnd.hqrndstate()
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1 AndAlso m >= 1, "CMatrixRndOrthogonalFromTheRight: N<1 or M<1!")
			If m = 1 Then

				'
				' special case
				'
				hqrnd.hqrndrandomize(state)
				hqrnd.hqrndunit2(state, tau.x, tau.y)
				For j = 0 To n - 1
					a(0, j) = a(0, j) * tau
				Next
				Return
			End If

			'
			' General case.
			' First pass.
			'
			w = New complex(n - 1) {}
			v = New complex(m) {}
			hqrnd.hqrndrandomize(state)
			For s = 2 To m

				'
				' Prepare random normal v
				'
				Do
					For i = 1 To s
						hqrnd.hqrndnormal2(state, tau.x, tau.y)
						v(i) = tau
					Next
					lambdav = 0.0
					For i_ = 1 To s
						lambdav += v(i_) * Math.conj(v(i_))
					Next
				Loop While lambdav = 0

				'
				' Prepare and apply reflection
				'
				creflections.complexgeneratereflection(v, s, tau)
				v(1) = 1
				creflections.complexapplyreflectionfromtheleft(a, tau, v, m - s, m - 1, 0, _
					n - 1, w)
			Next

			'
			' Second pass.
			'
			For i = 0 To m - 1
				hqrnd.hqrndunit2(state, tau.x, tau.y)
				For i_ = 0 To n - 1
					a(i, i_) = tau * a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Symmetric multiplication of NxN matrix by random Haar distributed
'        orthogonal  matrix
'
'        INPUT PARAMETERS:
'            A   -   matrix, array[0..N-1, 0..N-1]
'            N   -   matrix size
'
'        OUTPUT PARAMETERS:
'            A   -   Q'*A*Q, where Q is random NxN orthogonal matrix
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub smatrixrndmultiply(ByRef a As Double(,), n As Integer)
			Dim tau As Double = 0
			Dim lambdav As Double = 0
			Dim s As Integer = 0
			Dim i As Integer = 0
			Dim u1 As Double = 0
			Dim u2 As Double = 0
			Dim w As Double() = New Double(-1) {}
			Dim v As Double() = New Double(-1) {}
			Dim state As New hqrnd.hqrndstate()
			Dim i_ As Integer = 0


			'
			' General case.
			'
			w = New Double(n - 1) {}
			v = New Double(n) {}
			hqrnd.hqrndrandomize(state)
			For s = 2 To n

				'
				' Prepare random normal v
				'
				Do
					i = 1
					While i <= s
						hqrnd.hqrndnormal2(state, u1, u2)
						v(i) = u1
						If i + 1 <= s Then
							v(i + 1) = u2
						End If
						i = i + 2
					End While
					lambdav = 0.0
					For i_ = 1 To s
						lambdav += v(i_) * v(i_)
					Next
				Loop While CDbl(lambdav) = CDbl(0)

				'
				' Prepare and apply reflection
				'
				reflections.generatereflection(v, s, tau)
				v(1) = 1
				reflections.applyreflectionfromtheright(a, tau, v, 0, n - 1, n - s, _
					n - 1, w)
				reflections.applyreflectionfromtheleft(a, tau, v, n - s, n - 1, 0, _
					n - 1, w)
			Next

			'
			' Second pass.
			'
			For i = 0 To n - 1
				tau = 2 * hqrnd.hqrnduniformi(state, 2) - 1
				For i_ = 0 To n - 1
					a(i_, i) = tau * a(i_, i)
				Next
				For i_ = 0 To n - 1
					a(i, i_) = tau * a(i, i_)
				Next
			Next

			'
			' Copy upper triangle to lower
			'
			For i = 0 To n - 2
				For i_ = i + 1 To n - 1
					a(i_, i) = a(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Hermitian multiplication of NxN matrix by random Haar distributed
'        complex orthogonal matrix
'
'        INPUT PARAMETERS:
'            A   -   matrix, array[0..N-1, 0..N-1]
'            N   -   matrix size
'
'        OUTPUT PARAMETERS:
'            A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix
'
'          -- ALGLIB routine --
'             04.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub hmatrixrndmultiply(ByRef a As complex(,), n As Integer)
			Dim tau As complex = 0
			Dim lambdav As complex = 0
			Dim s As Integer = 0
			Dim i As Integer = 0
			Dim w As complex() = New complex(-1) {}
			Dim v As complex() = New complex(-1) {}
			Dim state As New hqrnd.hqrndstate()
			Dim i_ As Integer = 0


			'
			' General case.
			'
			w = New complex(n - 1) {}
			v = New complex(n) {}
			hqrnd.hqrndrandomize(state)
			For s = 2 To n

				'
				' Prepare random normal v
				'
				Do
					For i = 1 To s
						hqrnd.hqrndnormal2(state, tau.x, tau.y)
						v(i) = tau
					Next
					lambdav = 0.0
					For i_ = 1 To s
						lambdav += v(i_) * Math.conj(v(i_))
					Next
				Loop While lambdav = 0

				'
				' Prepare and apply reflection
				'
				creflections.complexgeneratereflection(v, s, tau)
				v(1) = 1
				creflections.complexapplyreflectionfromtheright(a, tau, v, 0, n - 1, n - s, _
					n - 1, w)
				creflections.complexapplyreflectionfromtheleft(a, Math.conj(tau), v, n - s, n - 1, 0, _
					n - 1, w)
			Next

			'
			' Second pass.
			'
			For i = 0 To n - 1
				hqrnd.hqrndunit2(state, tau.x, tau.y)
				For i_ = 0 To n - 1
					a(i_, i) = tau * a(i_, i)
				Next
				tau = Math.conj(tau)
				For i_ = 0 To n - 1
					a(i, i_) = tau * a(i, i_)
				Next
			Next

			'
			' Change all values from lower triangle by complex-conjugate values
			' from upper one
			'
			For i = 0 To n - 2
				For i_ = i + 1 To n - 1
					a(i_, i) = a(i, i_)
				Next
			Next
			For s = 0 To n - 2
				For i = s + 1 To n - 1
					a(i, s).y = -a(i, s).y
				Next
			Next
		End Sub


	End Class
	Public Class sparse
		'************************************************************************
'        Sparse matrix structure.
'
'        You should use ALGLIB functions to work with sparse matrix. Never  try  to
'        access its fields directly!
'
'        NOTES ON THE SPARSE STORAGE FORMATS
'
'        Sparse matrices can be stored using several formats:
'        * Hash-Table representation
'        * Compressed Row Storage (CRS)
'        * Skyline matrix storage (SKS)
'
'        Each of the formats has benefits and drawbacks:
'        * Hash-table is good for dynamic operations (insertion of new elements),
'          but does not support linear algebra operations
'        * CRS is good for operations like matrix-vector or matrix-matrix products,
'          but its initialization is less convenient - you have to tell row   sizes 
'          at the initialization, and you have to fill  matrix  only  row  by  row,
'          from left to right.
'        * SKS is a special format which is used to store triangular  factors  from
'          Cholesky factorization. It does not support  dynamic  modification,  and
'          support for linear algebra operations is very limited.
'
'        Tables below outline information about these two formats:
'
'            OPERATIONS WITH MATRIX      HASH        CRS         SKS
'            creation                    +           +           +
'            SparseGet                   +           +           +
'            SparseRewriteExisting       +           +           +
'            SparseSet                   +
'            SparseAdd                   +
'            SparseGetRow                            +           +
'            SparseGetCompressedRow                  +           +
'            sparse-dense linear algebra             +           +
'
'        ************************************************************************

		Public Class sparsematrix
			Inherits apobject
			Public vals As Double()
			Public idx As Integer()
			Public ridx As Integer()
			Public didx As Integer()
			Public uidx As Integer()
			Public matrixtype As Integer
			Public m As Integer
			Public n As Integer
			Public nfree As Integer
			Public ninitialized As Integer
			Public tablesize As Integer
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				vals = New Double(-1) {}
				idx = New Integer(-1) {}
				ridx = New Integer(-1) {}
				didx = New Integer(-1) {}
				uidx = New Integer(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New sparsematrix()
				_result.vals = DirectCast(vals.Clone(), Double())
				_result.idx = DirectCast(idx.Clone(), Integer())
				_result.ridx = DirectCast(ridx.Clone(), Integer())
				_result.didx = DirectCast(didx.Clone(), Integer())
				_result.uidx = DirectCast(uidx.Clone(), Integer())
				_result.matrixtype = matrixtype
				_result.m = m
				_result.n = n
				_result.nfree = nfree
				_result.ninitialized = ninitialized
				_result.tablesize = tablesize
				Return _result
			End Function
		End Class


		'************************************************************************
'        Temporary buffers for sparse matrix operations.
'
'        You should pass an instance of this structure to factorization  functions.
'        It allows to reuse memory during repeated sparse  factorizations.  You  do
'        not have to call some initialization function - simply passing an instance
'        to factorization function is enough.
'
'        ************************************************************************

		Public Class sparsebuffers
			Inherits apobject
			Public d As Integer()
			Public u As Integer()
			Public s As sparsematrix
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				d = New Integer(-1) {}
				u = New Integer(-1) {}
				s = New sparsematrix()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New sparsebuffers()
				_result.d = DirectCast(d.Clone(), Integer())
				_result.u = DirectCast(u.Clone(), Integer())
				_result.s = DirectCast(s.make_copy(), sparsematrix)
				Return _result
			End Function
		End Class




		Public Const desiredloadfactor As Double = 0.66
		Public Const maxloadfactor As Double = 0.75
		Public Const growfactor As Double = 2.0
		Public Const additional As Integer = 10
		Public Const linalgswitch As Integer = 16


		'************************************************************************
'        This function creates sparse matrix in a Hash-Table format.
'
'        This function creates Hast-Table matrix, which can be  converted  to  CRS
'        format after its initialization is over. Typical  usage  scenario  for  a
'        sparse matrix is:
'        1. creation in a Hash-Table format
'        2. insertion of the matrix elements
'        3. conversion to the CRS representation
'        4. matrix is passed to some linear algebra algorithm
'
'        Some  information  about  different matrix formats can be found below, in
'        the "NOTES" section.
'
'        INPUT PARAMETERS
'            M           -   number of rows in a matrix, M>=1
'            N           -   number of columns in a matrix, N>=1
'            K           -   K>=0, expected number of non-zero elements in a matrix.
'                            K can be inexact approximation, can be less than actual
'                            number  of  elements  (table will grow when needed) or 
'                            even zero).
'                            It is important to understand that although hash-table
'                            may grow automatically, it is better to  provide  good
'                            estimate of data size.
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table representation.
'                            All elements of the matrix are zero.
'
'        NOTE 1
'
'        Hash-tables use memory inefficiently, and they have to keep  some  amount
'        of the "spare memory" in order to have good performance. Hash  table  for
'        matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
'        where C is a small constant, about 1.5-2 in magnitude.
'
'        CRS storage, from the other side, is  more  memory-efficient,  and  needs
'        just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
'        in a matrix.
'
'        When you convert from the Hash-Table to CRS  representation, all unneeded
'        memory will be freed.
'
'        NOTE 2
'
'        Comments of SparseMatrix structure outline  information  about  different
'        sparse storage formats. We recommend you to read them before starting  to
'        use ALGLIB sparse matrices.
'
'        NOTE 3
'
'        This function completely  overwrites S with new sparse matrix. Previously
'        allocated storage is NOT reused. If you  want  to reuse already allocated
'        memory, call SparseCreateBuf function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreate(m As Integer, n As Integer, k As Integer, s As sparsematrix)
			sparsecreatebuf(m, n, k, s)
		End Sub


		'************************************************************************
'        This version of SparseCreate function creates sparse matrix in Hash-Table
'        format, reusing previously allocated storage as much  as  possible.  Read
'        comments for SparseCreate() for more information.
'
'        INPUT PARAMETERS
'            M           -   number of rows in a matrix, M>=1
'            N           -   number of columns in a matrix, N>=1
'            K           -   K>=0, expected number of non-zero elements in a matrix.
'                            K can be inexact approximation, can be less than actual
'                            number  of  elements  (table will grow when needed) or 
'                            even zero).
'                            It is important to understand that although hash-table
'                            may grow automatically, it is better to  provide  good
'                            estimate of data size.
'            S           -   SparseMatrix structure which MAY contain some  already
'                            allocated storage.
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table representation.
'                            All elements of the matrix are zero.
'                            Previously allocated storage is reused, if  its  size
'                            is compatible with expected number of non-zeros K.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreatebuf(m As Integer, n As Integer, k As Integer, s As sparsematrix)
			Dim i As Integer = 0

			alglib.ap.assert(m > 0, "SparseCreateBuf: M<=0")
			alglib.ap.assert(n > 0, "SparseCreateBuf: N<=0")
			alglib.ap.assert(k >= 0, "SparseCreateBuf: K<0")

			'
			' Hash-table size is max(existing_size,requested_size)
			'
			' NOTE: it is important to use ALL available memory for hash table
			'       because it is impossible to efficiently reallocate table
			'       without temporary storage. So, if we want table with up to
			'       1.000.000 elements, we have to create such table from the
			'       very beginning. Otherwise, the very idea of memory reuse
			'       will be compromised.
			'
			s.tablesize = CInt(System.Math.Truncate(System.Math.Round(k / desiredloadfactor + additional)))
			apserv.rvectorsetlengthatleast(s.vals, s.tablesize)
			s.tablesize = alglib.ap.len(s.vals)

			'
			' Initialize other fields
			'
			s.matrixtype = 0
			s.m = m
			s.n = n
			s.nfree = s.tablesize
			apserv.ivectorsetlengthatleast(s.idx, 2 * s.tablesize)
			For i = 0 To s.tablesize - 1
				s.idx(2 * i) = -1
			Next
		End Sub


		'************************************************************************
'        This function creates sparse matrix in a CRS format (expert function for
'        situations when you are running out of memory).
'
'        This function creates CRS matrix. Typical usage scenario for a CRS matrix 
'        is:
'        1. creation (you have to tell number of non-zero elements at each row  at 
'           this moment)
'        2. insertion of the matrix elements (row by row, from left to right) 
'        3. matrix is passed to some linear algebra algorithm
'
'        This function is a memory-efficient alternative to SparseCreate(), but it
'        is more complex because it requires you to know in advance how large your
'        matrix is. Some  information about  different matrix formats can be found 
'        in comments on SparseMatrix structure.  We recommend  you  to  read  them
'        before starting to use ALGLIB sparse matrices..
'
'        INPUT PARAMETERS
'            M           -   number of rows in a matrix, M>=1
'            N           -   number of columns in a matrix, N>=1
'            NER         -   number of elements at each row, array[M], NER[I]>=0
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS representation.
'                            You have to fill ALL non-zero elements by calling
'                            SparseSet() BEFORE you try to use this matrix.
'                            
'        NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
'              Previously allocated storage is NOT reused. If you  want  to  reuse
'              already allocated memory, call SparseCreateCRSBuf function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreatecrs(m As Integer, n As Integer, ner As Integer(), s As sparsematrix)
			Dim i As Integer = 0

			alglib.ap.assert(m > 0, "SparseCreateCRS: M<=0")
			alglib.ap.assert(n > 0, "SparseCreateCRS: N<=0")
			alglib.ap.assert(alglib.ap.len(ner) >= m, "SparseCreateCRS: Length(NER)<M")
			For i = 0 To m - 1
				alglib.ap.assert(ner(i) >= 0, "SparseCreateCRS: NER[] contains negative elements")
			Next
			sparsecreatecrsbuf(m, n, ner, s)
		End Sub


		'************************************************************************
'        This function creates sparse matrix in a CRS format (expert function  for
'        situations when you are running out  of  memory).  This  version  of  CRS
'        matrix creation function may reuse memory already allocated in S.
'
'        This function creates CRS matrix. Typical usage scenario for a CRS matrix 
'        is:
'        1. creation (you have to tell number of non-zero elements at each row  at 
'           this moment)
'        2. insertion of the matrix elements (row by row, from left to right) 
'        3. matrix is passed to some linear algebra algorithm
'
'        This function is a memory-efficient alternative to SparseCreate(), but it
'        is more complex because it requires you to know in advance how large your
'        matrix is. Some  information about  different matrix formats can be found 
'        in comments on SparseMatrix structure.  We recommend  you  to  read  them
'        before starting to use ALGLIB sparse matrices..
'
'        INPUT PARAMETERS
'            M           -   number of rows in a matrix, M>=1
'            N           -   number of columns in a matrix, N>=1
'            NER         -   number of elements at each row, array[M], NER[I]>=0
'            S           -   sparse matrix structure with possibly preallocated
'                            memory.
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS representation.
'                            You have to fill ALL non-zero elements by calling
'                            SparseSet() BEFORE you try to use this matrix.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreatecrsbuf(m As Integer, n As Integer, ner As Integer(), s As sparsematrix)
			Dim i As Integer = 0
			Dim noe As Integer = 0

			alglib.ap.assert(m > 0, "SparseCreateCRSBuf: M<=0")
			alglib.ap.assert(n > 0, "SparseCreateCRSBuf: N<=0")
			alglib.ap.assert(alglib.ap.len(ner) >= m, "SparseCreateCRSBuf: Length(NER)<M")
			noe = 0
			s.matrixtype = 1
			s.ninitialized = 0
			s.m = m
			s.n = n
			apserv.ivectorsetlengthatleast(s.ridx, s.m + 1)
			s.ridx(0) = 0
			For i = 0 To s.m - 1
				alglib.ap.assert(ner(i) >= 0, "SparseCreateCRSBuf: NER[] contains negative elements")
				noe = noe + ner(i)
				s.ridx(i + 1) = s.ridx(i) + ner(i)
			Next
			apserv.rvectorsetlengthatleast(s.vals, noe)
			apserv.ivectorsetlengthatleast(s.idx, noe)
			If noe = 0 Then
				sparseinitduidx(s)
			End If
		End Sub


		'************************************************************************
'        This function creates sparse matrix in  a  SKS  format  (skyline  storage
'        format). In most cases you do not need this function - CRS format  better
'        suits most use cases.
'
'        INPUT PARAMETERS
'            M, N        -   number of rows(M) and columns (N) in a matrix:
'                            * M=N (as for now, ALGLIB supports only square SKS)
'                            * N>=1
'                            * M>=1
'            D           -   "bottom" bandwidths, array[M], D[I]>=0.
'                            I-th element stores number of non-zeros at I-th  row,
'                            below the diagonal (diagonal itself is not  included)
'            U           -   "top" bandwidths, array[N], U[I]>=0.
'                            I-th element stores number of non-zeros  at I-th row,
'                            above the diagonal (diagonal itself  is not included)
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in SKS representation.
'                            All elements are filled by zeros.
'                            You may use SparseRewriteExisting() to  change  their
'                            values.
'                            
'        NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
'              Previously allocated storage is NOT reused. If you  want  to  reuse
'              already allocated memory, call SparseCreateSKSBuf function.
'
'          -- ALGLIB PROJECT --
'             Copyright 13.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreatesks(m As Integer, n As Integer, d As Integer(), u As Integer(), s As sparsematrix)
			Dim i As Integer = 0

			alglib.ap.assert(m > 0, "SparseCreateSKS: M<=0")
			alglib.ap.assert(n > 0, "SparseCreateSKS: N<=0")
			alglib.ap.assert(m = n, "SparseCreateSKS: M<>N")
			alglib.ap.assert(alglib.ap.len(d) >= m, "SparseCreateSKS: Length(D)<M")
			alglib.ap.assert(alglib.ap.len(u) >= n, "SparseCreateSKS: Length(U)<N")
			For i = 0 To m - 1
				alglib.ap.assert(d(i) >= 0, "SparseCreateSKS: D[] contains negative elements")
				alglib.ap.assert(d(i) <= i, "SparseCreateSKS: D[I]>I for some I")
			Next
			For i = 0 To n - 1
				alglib.ap.assert(u(i) >= 0, "SparseCreateSKS: U[] contains negative elements")
				alglib.ap.assert(u(i) <= i, "SparseCreateSKS: U[I]>I for some I")
			Next
			sparsecreatesksbuf(m, n, d, u, s)
		End Sub


		'************************************************************************
'        This is "buffered"  version  of  SparseCreateSKS()  which  reuses  memory
'        previously allocated in S (of course, memory is reallocated if needed).
'
'        This function creates sparse matrix in  a  SKS  format  (skyline  storage
'        format). In most cases you do not need this function - CRS format  better
'        suits most use cases.
'
'        INPUT PARAMETERS
'            M, N        -   number of rows(M) and columns (N) in a matrix:
'                            * M=N (as for now, ALGLIB supports only square SKS)
'                            * N>=1
'                            * M>=1
'            D           -   "bottom" bandwidths, array[M], 0<=D[I]<=I.
'                            I-th element stores number of non-zeros at I-th row,
'                            below the diagonal (diagonal itself is not included)
'            U           -   "top" bandwidths, array[N], 0<=U[I]<=I.
'                            I-th element stores number of non-zeros at I-th row,
'                            above the diagonal (diagonal itself is not included)
'
'        OUTPUT PARAMETERS
'            S           -   sparse M*N matrix in SKS representation.
'                            All elements are filled by zeros.
'                            You may use SparseSet()/SparseAdd() to change their
'                            values.
'
'          -- ALGLIB PROJECT --
'             Copyright 13.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecreatesksbuf(m As Integer, n As Integer, d As Integer(), u As Integer(), s As sparsematrix)
			Dim i As Integer = 0
			Dim minmn As Integer = 0
			Dim nz As Integer = 0
			Dim mxd As Integer = 0
			Dim mxu As Integer = 0

			alglib.ap.assert(m > 0, "SparseCreateSKSBuf: M<=0")
			alglib.ap.assert(n > 0, "SparseCreateSKSBuf: N<=0")
			alglib.ap.assert(m = n, "SparseCreateSKSBuf: M<>N")
			alglib.ap.assert(alglib.ap.len(d) >= m, "SparseCreateSKSBuf: Length(D)<M")
			alglib.ap.assert(alglib.ap.len(u) >= n, "SparseCreateSKSBuf: Length(U)<N")
			For i = 0 To m - 1
				alglib.ap.assert(d(i) >= 0, "SparseCreateSKSBuf: D[] contains negative elements")
				alglib.ap.assert(d(i) <= i, "SparseCreateSKSBuf: D[I]>I for some I")
			Next
			For i = 0 To n - 1
				alglib.ap.assert(u(i) >= 0, "SparseCreateSKSBuf: U[] contains negative elements")
				alglib.ap.assert(u(i) <= i, "SparseCreateSKSBuf: U[I]>I for some I")
			Next
			minmn = System.Math.Min(m, n)
			s.matrixtype = 2
			s.ninitialized = 0
			s.m = m
			s.n = n
			apserv.ivectorsetlengthatleast(s.ridx, minmn + 1)
			s.ridx(0) = 0
			nz = 0
			For i = 0 To minmn - 1
				nz = nz + 1 + d(i) + u(i)
				s.ridx(i + 1) = s.ridx(i) + 1 + d(i) + u(i)
			Next
			apserv.rvectorsetlengthatleast(s.vals, nz)
			For i = 0 To nz - 1
				s.vals(i) = 0.0
			Next
			apserv.ivectorsetlengthatleast(s.didx, m + 1)
			mxd = 0
			For i = 0 To m - 1
				s.didx(i) = d(i)
				mxd = System.Math.Max(mxd, d(i))
			Next
			s.didx(m) = mxd
			apserv.ivectorsetlengthatleast(s.uidx, n + 1)
			mxu = 0
			For i = 0 To n - 1
				s.uidx(i) = u(i)
				mxu = System.Math.Max(mxu, u(i))
			Next
			s.uidx(n) = mxu
		End Sub


		'************************************************************************
'        This function copies S0 to S1.
'        This function completely deallocates memory owned by S1 before creating a
'        copy of S0. If you want to reuse memory, use SparseCopyBuf.
'
'        NOTE:  this  function  does  not verify its arguments, it just copies all
'        fields of the structure.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopy(s0 As sparsematrix, s1 As sparsematrix)
			sparsecopybuf(s0, s1)
		End Sub


		'************************************************************************
'        This function copies S0 to S1.
'        Memory already allocated in S1 is reused as much as possible.
'
'        NOTE:  this  function  does  not verify its arguments, it just copies all
'        fields of the structure.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopybuf(s0 As sparsematrix, s1 As sparsematrix)
			Dim l As Integer = 0
			Dim i As Integer = 0

			s1.matrixtype = s0.matrixtype
			s1.m = s0.m
			s1.n = s0.n
			s1.nfree = s0.nfree
			s1.ninitialized = s0.ninitialized
			s1.tablesize = s0.tablesize

			'
			' Initialization for arrays
			'
			l = alglib.ap.len(s0.vals)
			apserv.rvectorsetlengthatleast(s1.vals, l)
			For i = 0 To l - 1
				s1.vals(i) = s0.vals(i)
			Next
			l = alglib.ap.len(s0.ridx)
			apserv.ivectorsetlengthatleast(s1.ridx, l)
			For i = 0 To l - 1
				s1.ridx(i) = s0.ridx(i)
			Next
			l = alglib.ap.len(s0.idx)
			apserv.ivectorsetlengthatleast(s1.idx, l)
			For i = 0 To l - 1
				s1.idx(i) = s0.idx(i)
			Next

			'
			' Initalization for CRS-parameters
			'
			l = alglib.ap.len(s0.uidx)
			apserv.ivectorsetlengthatleast(s1.uidx, l)
			For i = 0 To l - 1
				s1.uidx(i) = s0.uidx(i)
			Next
			l = alglib.ap.len(s0.didx)
			apserv.ivectorsetlengthatleast(s1.didx, l)
			For i = 0 To l - 1
				s1.didx(i) = s0.didx(i)
			Next
		End Sub


		'************************************************************************
'        This function efficiently swaps contents of S0 and S1.
'
'          -- ALGLIB PROJECT --
'             Copyright 16.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseswap(s0 As sparsematrix, s1 As sparsematrix)
			apserv.swapi(s1.matrixtype, s0.matrixtype)
			apserv.swapi(s1.m, s0.m)
			apserv.swapi(s1.n, s0.n)
			apserv.swapi(s1.nfree, s0.nfree)
			apserv.swapi(s1.ninitialized, s0.ninitialized)
			apserv.swapi(s1.tablesize, s0.tablesize)
			alglib.ap.swap(s1.vals, s0.vals)
			alglib.ap.swap(s1.ridx, s0.ridx)
			alglib.ap.swap(s1.idx, s0.idx)
			alglib.ap.swap(s1.uidx, s0.uidx)
			alglib.ap.swap(s1.didx, s0.didx)
		End Sub


		'************************************************************************
'        This function adds value to S[i,j] - element of the sparse matrix. Matrix
'        must be in a Hash-Table mode.
'
'        In case S[i,j] already exists in the table, V i added to  its  value.  In
'        case  S[i,j]  is  non-existent,  it  is  inserted  in  the  table.  Table
'        automatically grows when necessary.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table representation.
'                            Exception will be thrown for CRS matrix.
'            I           -   row index of the element to modify, 0<=I<M
'            J           -   column index of the element to modify, 0<=J<N
'            V           -   value to add, must be finite number
'
'        OUTPUT PARAMETERS
'            S           -   modified matrix
'            
'        NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted
'        from the table.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseadd(s As sparsematrix, i As Integer, j As Integer, v As Double)
			Dim hashcode As Integer = 0
			Dim tcode As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert(s.matrixtype = 0, "SparseAdd: matrix must be in the Hash-Table mode to do this operation")
			alglib.ap.assert(i >= 0, "SparseAdd: I<0")
			alglib.ap.assert(i < s.m, "SparseAdd: I>=M")
			alglib.ap.assert(j >= 0, "SparseAdd: J<0")
			alglib.ap.assert(j < s.n, "SparseAdd: J>=N")
			alglib.ap.assert(Math.isfinite(v), "SparseAdd: V is not finite number")
			If CDbl(v) = CDbl(0) Then
				Return
			End If
			tcode = -1
			k = s.tablesize
			If CDbl((1 - maxloadfactor) * k) >= CDbl(s.nfree) Then
				sparseresizematrix(s)
				k = s.tablesize
			End If
			hashcode = hash(i, j, k)
			While True
				If s.idx(2 * hashcode) = -1 Then
					If tcode <> -1 Then
						hashcode = tcode
					End If
					s.vals(hashcode) = v
					s.idx(2 * hashcode) = i
					s.idx(2 * hashcode + 1) = j
					If tcode = -1 Then
						s.nfree = s.nfree - 1
					End If
					Return
				Else
					If s.idx(2 * hashcode) = i AndAlso s.idx(2 * hashcode + 1) = j Then
						s.vals(hashcode) = s.vals(hashcode) + v
						If CDbl(s.vals(hashcode)) = CDbl(0) Then
							s.idx(2 * hashcode) = -2
						End If
						Return
					End If

					'
					' Is it deleted element?
					'
					If tcode = -1 AndAlso s.idx(2 * hashcode) = -2 Then
						tcode = hashcode
					End If

					'
					' Next step
					'
					hashcode = (hashcode + 1) Mod k
				End If
			End While
		End Sub


		'************************************************************************
'        This function modifies S[i,j] - element of the sparse matrix.
'
'        For Hash-based storage format:
'        * this function can be called at any moment - during matrix initialization
'          or later
'        * new value can be zero or non-zero.  In case new value of S[i,j] is zero,
'          this element is deleted from the table.
'        * this  function  has  no  effect when called with zero V for non-existent
'          element.
'
'        For CRS-bases storage format:
'        * this function can be called ONLY DURING MATRIX INITIALIZATION
'        * new value MUST be non-zero. Exception will be thrown for zero V.
'        * elements must be initialized in correct order -  from top row to bottom,
'          within row - from left to right.
'          
'        For SKS storage: NOT SUPPORTED! Use SparseRewriteExisting() to  work  with
'        SKS matrices.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table or CRS representation.
'            I           -   row index of the element to modify, 0<=I<M
'            J           -   column index of the element to modify, 0<=J<N
'            V           -   value to set, must be finite number, can be zero
'
'        OUTPUT PARAMETERS
'            S           -   modified matrix
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseset(s As sparsematrix, i As Integer, j As Integer, v As Double)
			Dim hashcode As Integer = 0
			Dim tcode As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert(s.matrixtype = 0 OrElse s.matrixtype = 1, "SparseSet: unsupported matrix storage format")
			alglib.ap.assert(i >= 0, "SparseSet: I<0")
			alglib.ap.assert(i < s.m, "SparseSet: I>=M")
			alglib.ap.assert(j >= 0, "SparseSet: J<0")
			alglib.ap.assert(j < s.n, "SparseSet: J>=N")
			alglib.ap.assert(Math.isfinite(v), "SparseSet: V is not finite number")

			'
			' Hash-table matrix
			'
			If s.matrixtype = 0 Then
				tcode = -1
				k = s.tablesize
				If CDbl((1 - maxloadfactor) * k) >= CDbl(s.nfree) Then
					sparseresizematrix(s)
					k = s.tablesize
				End If
				hashcode = hash(i, j, k)
				While True
					If s.idx(2 * hashcode) = -1 Then
						If CDbl(v) <> CDbl(0) Then
							If tcode <> -1 Then
								hashcode = tcode
							End If
							s.vals(hashcode) = v
							s.idx(2 * hashcode) = i
							s.idx(2 * hashcode + 1) = j
							If tcode = -1 Then
								s.nfree = s.nfree - 1
							End If
						End If
						Return
					Else
						If s.idx(2 * hashcode) = i AndAlso s.idx(2 * hashcode + 1) = j Then
							If CDbl(v) = CDbl(0) Then
								s.idx(2 * hashcode) = -2
							Else
								s.vals(hashcode) = v
							End If
							Return
						End If
						If tcode = -1 AndAlso s.idx(2 * hashcode) = -2 Then
							tcode = hashcode
						End If

						'
						' Next step
						'
						hashcode = (hashcode + 1) Mod k
					End If
				End While
			End If

			'
			' CRS matrix
			'
			If s.matrixtype = 1 Then
				alglib.ap.assert(CDbl(v) <> CDbl(0), "SparseSet: CRS format does not allow you to write zero elements")
				alglib.ap.assert(s.ridx(i) <= s.ninitialized, "SparseSet: too few initialized elements at some row (you have promised more when called SparceCreateCRS)")
				alglib.ap.assert(s.ridx(i + 1) > s.ninitialized, "SparseSet: too many initialized elements at some row (you have promised less when called SparceCreateCRS)")
				alglib.ap.assert(s.ninitialized = s.ridx(i) OrElse s.idx(s.ninitialized - 1) < j, "SparseSet: incorrect column order (you must fill every row from left to right)")
				s.vals(s.ninitialized) = v
				s.idx(s.ninitialized) = j
				s.ninitialized = s.ninitialized + 1

				'
				' If matrix has been created then
				' initiale 'S.UIdx' and 'S.DIdx'
				'
				If s.ninitialized = s.ridx(s.m) Then
					sparseinitduidx(s)
				End If
			End If
		End Sub


		'************************************************************************
'        This function returns S[i,j] - element of the sparse matrix.  Matrix  can
'        be in any mode (Hash-Table, CRS, SKS), but this function is less efficient
'        for CRS matrices. Hash-Table and SKS matrices can find  element  in  O(1)
'        time, while  CRS  matrices need O(log(RS)) time, where RS is an number of
'        non-zero elements in a row.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table representation.
'                            Exception will be thrown for CRS matrix.
'            I           -   row index of the element to modify, 0<=I<M
'            J           -   column index of the element to modify, 0<=J<N
'
'        RESULT
'            value of S[I,J] or zero (in case no element with such index is found)
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparseget(s As sparsematrix, i As Integer, j As Integer) As Double
			Dim result As Double = 0
			Dim hashcode As Integer = 0
			Dim k As Integer = 0
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0

			alglib.ap.assert(i >= 0, "SparseGet: I<0")
			alglib.ap.assert(i < s.m, "SparseGet: I>=M")
			alglib.ap.assert(j >= 0, "SparseGet: J<0")
			alglib.ap.assert(j < s.n, "SparseGet: J>=N")
			result = 0.0
			If s.matrixtype = 0 Then

				'
				' Hash-based storage
				'
				result = 0
				k = s.tablesize
				hashcode = hash(i, j, k)
				While True
					If s.idx(2 * hashcode) = -1 Then
						Return result
					End If
					If s.idx(2 * hashcode) = i AndAlso s.idx(2 * hashcode + 1) = j Then
						result = s.vals(hashcode)
						Return result
					End If
					hashcode = (hashcode + 1) Mod k
				End While
			End If
			If s.matrixtype = 1 Then

				'
				' CRS
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseGet: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				k0 = s.ridx(i)
				k1 = s.ridx(i + 1) - 1
				result = 0
				While k0 <= k1
					k = (k0 + k1) \ 2
					If s.idx(k) = j Then
						result = s.vals(k)
						Return result
					End If
					If s.idx(k) < j Then
						k0 = k + 1
					Else
						k1 = k - 1
					End If
				End While
				Return result
			End If
			If s.matrixtype = 2 Then

				'
				' SKS
				'
				alglib.ap.assert(s.m = s.n, "SparseGet: non-square SKS matrix not supported")
				result = 0
				If i = j Then

					'
					' Return diagonal element
					'
					result = s.vals(s.ridx(i) + s.didx(i))
					Return result
				End If
				If j < i Then

					'
					' Return subdiagonal element at I-th "skyline block"
					'
					k = s.didx(i)
					If i - j <= k Then
						result = s.vals(s.ridx(i) + k + j - i)
					End If
				Else

					'
					' Return superdiagonal element at J-th "skyline block"
					'
					k = s.uidx(j)
					If j - i <= k Then
						result = s.vals(s.ridx(j + 1) - (j - i))
					End If
					Return result
				End If
				Return result
			End If
			alglib.ap.assert(False, "SparseGet: unexpected matrix type")
			Return result
		End Function


		'************************************************************************
'        This function returns I-th diagonal element of the sparse matrix.
'
'        Matrix can be in any mode (Hash-Table or CRS storage), but this  function
'        is most efficient for CRS matrices - it requires less than 50 CPU  cycles
'        to extract diagonal element. For Hash-Table matrices we still  have  O(1)
'        query time, but function is many times slower.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table representation.
'                            Exception will be thrown for CRS matrix.
'            I           -   index of the element to modify, 0<=I<min(M,N)
'
'        RESULT
'            value of S[I,I] or zero (in case no element with such index is found)
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetdiagonal(s As sparsematrix, i As Integer) As Double
			Dim result As Double = 0

			alglib.ap.assert(i >= 0, "SparseGetDiagonal: I<0")
			alglib.ap.assert(i < s.m, "SparseGetDiagonal: I>=M")
			alglib.ap.assert(i < s.n, "SparseGetDiagonal: I>=N")
			result = 0
			If s.matrixtype = 0 Then
				result = sparseget(s, i, i)
				Return result
			End If
			If s.matrixtype = 1 Then
				If s.didx(i) <> s.uidx(i) Then
					result = s.vals(s.didx(i))
				End If
				Return result
			End If
			If s.matrixtype = 2 Then
				alglib.ap.assert(s.m = s.n, "SparseGetDiagonal: non-square SKS matrix not supported")
				result = s.vals(s.ridx(i) + s.didx(i))
				Return result
			End If
			alglib.ap.assert(False, "SparseGetDiagonal: unexpected matrix type")
			Return result
		End Function


		'************************************************************************
'        This function calculates matrix-vector product  S*x.  Matrix  S  must  be
'        stored in CRS or SKS format (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS or SKS format.
'            X           -   array[N], input vector. For  performance  reasons  we 
'                            make only quick checks - we check that array size  is
'                            at least N, but we do not check for NAN's or INF's.
'            Y           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            Y           -   array[M], S*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemv(s As sparsematrix, x As Double(), ByRef y As Double())
			Dim tval As Double = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim n As Integer = 0
			Dim m As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseMV: length(X)<N")
			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMV: incorrect matrix type (convert your matrix to CRS/SKS)")
			apserv.rvectorsetlengthatleast(y, s.m)
			n = s.n
			m = s.m
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To m - 1
					tval = 0
					lt = s.ridx(i)
					rt = s.ridx(i + 1) - 1
					For j = lt To rt
						tval = tval + x(s.idx(j)) * s.vals(j)
					Next
					y(i) = tval
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseMV: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					v = s.vals(ri + d) * x(i)
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						v = v + vv
					End If
					y(i) = v
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y(i_) = y(i_) + v * s.vals(i_ + i1_)
						Next
					End If
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates matrix-vector product  S^T*x. Matrix S  must  be
'        stored in CRS or SKS format (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS or SKS format.
'            X           -   array[M], input vector. For  performance  reasons  we 
'                            make only quick checks - we check that array size  is
'                            at least M, but we do not check for NAN's or INF's.
'            Y           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            Y           -   array[N], S^T*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemtv(s As sparsematrix, x As Double(), ByRef y As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim ct As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim n As Integer = 0
			Dim m As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMTV: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.len(x) >= s.m, "SparseMTV: Length(X)<M")
			n = s.n
			m = s.m
			apserv.rvectorsetlengthatleast(y, n)
			For i = 0 To n - 1
				y(i) = 0
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(m), "SparseMTV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To m - 1
					lt = s.ridx(i)
					rt = s.ridx(i + 1)
					v = x(i)
					For j = lt To rt - 1
						ct = s.idx(j)
						y(ct) = y(ct) + v * s.vals(j)
					Next
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseMV: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y(i_) = y(i_) + v * s.vals(i_ + i1_)
						Next
					End If
					v = s.vals(ri + d) * x(i)
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						v = v + vv
					End If
					y(i) = v
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function simultaneously calculates two matrix-vector products:
'            S*x and S^T*x.
'        S must be square (non-rectangular) matrix stored in  CRS  or  SKS  format
'        (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse N*N matrix in CRS or SKS format.
'            X           -   array[N], input vector. For  performance  reasons  we 
'                            make only quick checks - we check that array size  is
'                            at least N, but we do not check for NAN's or INF's.
'            Y0          -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            Y1          -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            Y0          -   array[N], S*x
'            Y1          -   array[N], S^T*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemv2(s As sparsematrix, x As Double(), ByRef y0 As Double(), ByRef y1 As Double())
			Dim l As Integer = 0
			Dim tval As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim vx As Double = 0
			Dim vs As Double = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim vd0 As Double = 0
			Dim vd1 As Double = 0
			Dim vi As Integer = 0
			Dim j0 As Integer = 0
			Dim j1 As Integer = 0
			Dim n As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMV2: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(s.m = s.n, "SparseMV2: matrix is non-square")
			l = alglib.ap.len(x)
			alglib.ap.assert(l >= s.n, "SparseMV2: Length(X)<N")
			n = s.n
			apserv.rvectorsetlengthatleast(y0, l)
			apserv.rvectorsetlengthatleast(y1, l)
			For i = 0 To n - 1
				y0(i) = 0
				y1(i) = 0
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseMV2: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To s.m - 1
					tval = 0
					vx = x(i)
					j0 = s.ridx(i)
					j1 = s.ridx(i + 1) - 1
					For j = j0 To j1
						vi = s.idx(j)
						vs = s.vals(j)
						tval = tval + x(vi) * vs
						y1(vi) = y1(vi) + vx * vs
					Next
					y0(i) = tval
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					vd0 = s.vals(ri + d) * x(i)
					vd1 = vd0
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y1(i_) = y1(i_) + v * s.vals(i_ + i1_)
						Next
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						vd0 = vd0 + vv
					End If
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y0(i_) = y0(i_) + v * s.vals(i_ + i1_)
						Next
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						vd1 = vd1 + vv
					End If
					y0(i) = vd0
					y1(i) = vd1
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates matrix-vector product  S*x, when S is  symmetric
'        matrix. Matrix S  must be stored in CRS or SKS format  (exception will be
'        thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*M matrix in CRS or SKS format.
'            IsUpper     -   whether upper or lower triangle of S is given:
'                            * if upper triangle is given,  only   S[i,j] for j>=i
'                              are used, and lower triangle is ignored (it can  be
'                              empty - these elements are not referenced at all).
'                            * if lower triangle is given,  only   S[i,j] for j<=i
'                              are used, and upper triangle is ignored.
'            X           -   array[N], input vector. For  performance  reasons  we 
'                            make only quick checks - we check that array size  is
'                            at least N, but we do not check for NAN's or INF's.
'            Y           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            Y           -   array[M], S*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsesmv(s As sparsematrix, isupper As Boolean, x As Double(), ByRef y As Double())
			Dim n As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim id As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim vy As Double = 0
			Dim vx As Double = 0
			Dim vd As Double = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseSMV: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseSMV: length(X)<N")
			alglib.ap.assert(s.m = s.n, "SparseSMV: non-square matrix")
			n = s.n
			apserv.rvectorsetlengthatleast(y, n)
			For i = 0 To n - 1
				y(i) = 0
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseSMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To n - 1
					If s.didx(i) <> s.uidx(i) Then
						y(i) = y(i) + s.vals(s.didx(i)) * x(s.idx(s.didx(i)))
					End If
					If isupper Then
						lt = s.uidx(i)
						rt = s.ridx(i + 1)
						vy = 0
						vx = x(i)
						For j = lt To rt - 1
							id = s.idx(j)
							v = s.vals(j)
							vy = vy + x(id) * v
							y(id) = y(id) + vx * v
						Next
						y(i) = y(i) + vy
					Else
						lt = s.ridx(i)
						rt = s.didx(i)
						vy = 0
						vx = x(i)
						For j = lt To rt - 1
							id = s.idx(j)
							v = s.vals(j)
							vy = vy + x(id) * v
							y(id) = y(id) + vx * v
						Next
						y(i) = y(i) + vy
					End If
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					vd = s.vals(ri + d) * x(i)
					If d > 0 AndAlso Not isupper Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y(i_) = y(i_) + v * s.vals(i_ + i1_)
						Next
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						vd = vd + vv
					End If
					If u > 0 AndAlso isupper Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						v = x(i)
						i1_ = (lt) - (lt1)
						For i_ = lt1 To rt1
							y(i_) = y(i_) + v * s.vals(i_ + i1_)
						Next
						i1_ = (lt1) - (lt)
						vv = 0.0
						For i_ = lt To rt
							vv += s.vals(i_) * x(i_ + i1_)
						Next
						vd = vd + vv
					End If
					y(i) = vd
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates vector-matrix-vector product x'*S*x, where  S is
'        symmetric matrix. Matrix S must be stored in CRS or SKS format (exception
'        will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*M matrix in CRS or SKS format.
'            IsUpper     -   whether upper or lower triangle of S is given:
'                            * if upper triangle is given,  only   S[i,j] for j>=i
'                              are used, and lower triangle is ignored (it can  be
'                              empty - these elements are not referenced at all).
'                            * if lower triangle is given,  only   S[i,j] for j<=i
'                              are used, and upper triangle is ignored.
'            X           -   array[N], input vector. For  performance  reasons  we 
'                            make only quick checks - we check that array size  is
'                            at least N, but we do not check for NAN's or INF's.
'            
'        RESULT
'            x'*S*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 27.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsevsmv(s As sparsematrix, isupper As Boolean, x As Double()) As Double
			Dim result As Double = 0
			Dim n As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim id As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim v As Double = 0
			Dim v0 As Double = 0
			Dim v1 As Double = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim lt1 As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseVSMV: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseVSMV: length(X)<N")
			alglib.ap.assert(s.m = s.n, "SparseVSMV: non-square matrix")
			n = s.n
			result = 0.0
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseVSMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To n - 1
					If s.didx(i) <> s.uidx(i) Then
						v = x(s.idx(s.didx(i)))
						result = result + v * s.vals(s.didx(i)) * v
					End If
					If isupper Then
						lt = s.uidx(i)
						rt = s.ridx(i + 1)
					Else
						lt = s.ridx(i)
						rt = s.didx(i)
					End If
					v0 = x(i)
					For j = lt To rt - 1
						id = s.idx(j)
						v1 = x(id)
						v = s.vals(j)
						result = result + 2 * v0 * v1 * v
					Next
				Next
				Return result
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					v = x(i)
					result = result + v * s.vals(ri + d) * v
					If d > 0 AndAlso Not isupper Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						k = d - 1
						v0 = x(i)
						v = 0.0
						For j = 0 To k
							v = v + x(lt1 + j) * s.vals(lt + j)
						Next
						result = result + 2 * v0 * v
					End If
					If u > 0 AndAlso isupper Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						k = u - 1
						v0 = x(i)
						v = 0.0
						For j = 0 To k
							v = v + x(lt1 + j) * s.vals(lt + j)
						Next
						result = result + 2 * v0 * v
					End If
				Next
				Return result
			End If
			Return result
		End Function


		'************************************************************************
'        This function calculates matrix-matrix product  S*A.  Matrix  S  must  be
'        stored in CRS or SKS format (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS or SKS format.
'            A           -   array[N][K], input dense matrix. For  performance reasons
'                            we make only quick checks - we check that array size  
'                            is at least N, but we do not check for NAN's or INF's.
'            K           -   number of columns of matrix (A).
'            B           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            B           -   array[M][K], S*A
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemm(s As sparsematrix, a As Double(,), k As Integer, ByRef b As Double(,))
			Dim tval As Double = 0
			Dim v As Double = 0
			Dim id As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim m As Integer = 0
			Dim n As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim vd As Double = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMM: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseMM: Rows(A)<N")
			alglib.ap.assert(k > 0, "SparseMM: K<=0")
			m = s.m
			n = s.n
			k1 = k - 1
			apserv.rmatrixsetlengthatleast(b, m, k)
			For i = 0 To m - 1
				For j = 0 To k - 1
					b(i, j) = 0
				Next
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(m), "SparseMM: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If k < linalgswitch Then
					For i = 0 To m - 1
						For j = 0 To k - 1
							tval = 0
							lt = s.ridx(i)
							rt = s.ridx(i + 1)
							For k0 = lt To rt - 1
								tval = tval + s.vals(k0) * a(s.idx(k0), j)
							Next
							b(i, j) = tval
						Next
					Next
				Else
					For i = 0 To m - 1
						lt = s.ridx(i)
						rt = s.ridx(i + 1)
						For j = lt To rt - 1
							id = s.idx(j)
							v = s.vals(j)
							For i_ = 0 To k - 1
								b(i, i_) = b(i, i_) + v * a(id, i_)
							Next
						Next
					Next
				End If
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(m = n, "SparseMM: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(i, k0) = b(i, k0) + v * a(j, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(j, i_)
								Next
							End If
						Next
					End If
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(j, k0) = b(j, k0) + v * a(i, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(j, i_) = b(j, i_) + v * a(i, i_)
								Next
							End If
						Next
					End If
					vd = s.vals(ri + d)
					For i_ = 0 To k - 1
						b(i, i_) = b(i, i_) + vd * a(i, i_)
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates matrix-matrix product  S^T*A. Matrix S  must  be
'        stored in CRS or SKS format (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in CRS or SKS format.
'            A           -   array[M][K], input dense matrix. For performance reasons
'                            we make only quick checks - we check that array size  is
'                            at least M, but we do not check for NAN's or INF's.
'            K           -   number of columns of matrix (A).                    
'            B           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            B           -   array[N][K], S^T*A
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemtm(s As sparsematrix, a As Double(,), k As Integer, ByRef b As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim ct As Integer = 0
			Dim v As Double = 0
			Dim m As Integer = 0
			Dim n As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMTM: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.rows(a) >= s.m, "SparseMTM: Rows(A)<M")
			alglib.ap.assert(k > 0, "SparseMTM: K<=0")
			m = s.m
			n = s.n
			k1 = k - 1
			apserv.rmatrixsetlengthatleast(b, n, k)
			For i = 0 To n - 1
				For j = 0 To k - 1
					b(i, j) = 0
				Next
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(m), "SparseMTM: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If k < linalgswitch Then
					For i = 0 To m - 1
						lt = s.ridx(i)
						rt = s.ridx(i + 1)
						For k0 = lt To rt - 1
							v = s.vals(k0)
							ct = s.idx(k0)
							For j = 0 To k - 1
								b(ct, j) = b(ct, j) + v * a(i, j)
							Next
						Next
					Next
				Else
					For i = 0 To m - 1
						lt = s.ridx(i)
						rt = s.ridx(i + 1)
						For j = lt To rt - 1
							v = s.vals(j)
							ct = s.idx(j)
							For i_ = 0 To k - 1
								b(ct, i_) = b(ct, i_) + v * a(i, i_)
							Next
						Next
					Next
				End If
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(m = n, "SparseMTM: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(j, k0) = b(j, k0) + v * a(i, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(j, i_) = b(j, i_) + v * a(i, i_)
								Next
							End If
						Next
					End If
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(i, k0) = b(i, k0) + v * a(j, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(j, i_)
								Next
							End If
						Next
					End If
					v = s.vals(ri + d)
					For i_ = 0 To k - 1
						b(i, i_) = b(i, i_) + v * a(i, i_)
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function simultaneously calculates two matrix-matrix products:
'            S*A and S^T*A.
'        S  must  be  square (non-rectangular) matrix stored in CRS or  SKS  format
'        (exception will be thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse N*N matrix in CRS or SKS format.
'            A           -   array[N][K], input dense matrix. For performance reasons
'                            we make only quick checks - we check that array size  is
'                            at least N, but we do not check for NAN's or INF's.
'            K           -   number of columns of matrix (A).                    
'            B0          -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            B1          -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            B0          -   array[N][K], S*A
'            B1          -   array[N][K], S^T*A
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsemm2(s As sparsematrix, a As Double(,), k As Integer, ByRef b0 As Double(,), ByRef b1 As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k0 As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim ct As Integer = 0
			Dim v As Double = 0
			Dim tval As Double = 0
			Dim n As Integer = 0
			Dim k1 As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseMM2: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(s.m = s.n, "SparseMM2: matrix is non-square")
			alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseMM2: Rows(A)<N")
			alglib.ap.assert(k > 0, "SparseMM2: K<=0")
			n = s.n
			k1 = k - 1
			apserv.rmatrixsetlengthatleast(b0, n, k)
			apserv.rmatrixsetlengthatleast(b1, n, k)
			For i = 0 To n - 1
				For j = 0 To k - 1
					b1(i, j) = 0
					b0(i, j) = 0
				Next
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseMM2: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If k < linalgswitch Then
					For i = 0 To n - 1
						For j = 0 To k - 1
							tval = 0
							lt = s.ridx(i)
							rt = s.ridx(i + 1)
							v = a(i, j)
							For k0 = lt To rt - 1
								ct = s.idx(k0)
								b1(ct, j) = b1(ct, j) + s.vals(k0) * v
								tval = tval + s.vals(k0) * a(ct, j)
							Next
							b0(i, j) = tval
						Next
					Next
				Else
					For i = 0 To n - 1
						lt = s.ridx(i)
						rt = s.ridx(i + 1)
						For j = lt To rt - 1
							v = s.vals(j)
							ct = s.idx(j)
							For i_ = 0 To k - 1
								b0(i, i_) = b0(i, i_) + v * a(ct, i_)
							Next
							For i_ = 0 To k - 1
								b1(ct, i_) = b1(ct, i_) + v * a(i, i_)
							Next
						Next
					Next
				End If
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseMM2: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If d > 0 Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b0(i, k0) = b0(i, k0) + v * a(j, k0)
									b1(j, k0) = b1(j, k0) + v * a(i, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b0(i, i_) = b0(i, i_) + v * a(j, i_)
								Next
								For i_ = 0 To k - 1
									b1(j, i_) = b1(j, i_) + v * a(i, i_)
								Next
							End If
						Next
					End If
					If u > 0 Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b0(j, k0) = b0(j, k0) + v * a(i, k0)
									b1(i, k0) = b1(i, k0) + v * a(j, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b0(j, i_) = b0(j, i_) + v * a(i, i_)
								Next
								For i_ = 0 To k - 1
									b1(i, i_) = b1(i, i_) + v * a(j, i_)
								Next
							End If
						Next
					End If
					v = s.vals(ri + d)
					For i_ = 0 To k - 1
						b0(i, i_) = b0(i, i_) + v * a(i, i_)
					Next
					For i_ = 0 To k - 1
						b1(i, i_) = b1(i, i_) + v * a(i, i_)
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates matrix-matrix product  S*A, when S  is  symmetric
'        matrix. Matrix S must be stored in CRS or SKS format  (exception  will  be
'        thrown otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse M*M matrix in CRS or SKS format.
'            IsUpper     -   whether upper or lower triangle of S is given:
'                            * if upper triangle is given,  only   S[i,j] for j>=i
'                              are used, and lower triangle is ignored (it can  be
'                              empty - these elements are not referenced at all).
'                            * if lower triangle is given,  only   S[i,j] for j<=i
'                              are used, and upper triangle is ignored.
'            A           -   array[N][K], input dense matrix. For performance reasons
'                            we make only quick checks - we check that array size is
'                            at least N, but we do not check for NAN's or INF's.
'            K           -   number of columns of matrix (A).  
'            B           -   output buffer, possibly preallocated. In case  buffer
'                            size is too small to store  result,  this  buffer  is
'                            automatically resized.
'            
'        OUTPUT PARAMETERS
'            B           -   array[M][K], S*A
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsesmm(s As sparsematrix, isupper As Boolean, a As Double(,), k As Integer, ByRef b As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k0 As Integer = 0
			Dim id As Integer = 0
			Dim k1 As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim v As Double = 0
			Dim vb As Double = 0
			Dim va As Double = 0
			Dim n As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseSMM: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(alglib.ap.rows(a) >= s.n, "SparseSMM: Rows(X)<N")
			alglib.ap.assert(s.m = s.n, "SparseSMM: matrix is non-square")
			n = s.n
			k1 = k - 1
			apserv.rmatrixsetlengthatleast(b, n, k)
			For i = 0 To n - 1
				For j = 0 To k - 1
					b(i, j) = 0
				Next
			Next
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseSMM: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If k > linalgswitch Then
					For i = 0 To n - 1
						For j = 0 To k - 1
							If s.didx(i) <> s.uidx(i) Then
								id = s.didx(i)
								b(i, j) = b(i, j) + s.vals(id) * a(s.idx(id), j)
							End If
							If isupper Then
								lt = s.uidx(i)
								rt = s.ridx(i + 1)
								vb = 0
								va = a(i, j)
								For k0 = lt To rt - 1
									id = s.idx(k0)
									v = s.vals(k0)
									vb = vb + a(id, j) * v
									b(id, j) = b(id, j) + va * v
								Next
								b(i, j) = b(i, j) + vb
							Else
								lt = s.ridx(i)
								rt = s.didx(i)
								vb = 0
								va = a(i, j)
								For k0 = lt To rt - 1
									id = s.idx(k0)
									v = s.vals(k0)
									vb = vb + a(id, j) * v
									b(id, j) = b(id, j) + va * v
								Next
								b(i, j) = b(i, j) + vb
							End If
						Next
					Next
				Else
					For i = 0 To n - 1
						If s.didx(i) <> s.uidx(i) Then
							id = s.didx(i)
							v = s.vals(id)
							For i_ = 0 To k - 1
								b(i, i_) = b(i, i_) + v * a(s.idx(id), i_)
							Next
						End If
						If isupper Then
							lt = s.uidx(i)
							rt = s.ridx(i + 1)
							For j = lt To rt - 1
								id = s.idx(j)
								v = s.vals(j)
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(id, i_)
								Next
								For i_ = 0 To k - 1
									b(id, i_) = b(id, i_) + v * a(i, i_)
								Next
							Next
						Else
							lt = s.ridx(i)
							rt = s.didx(i)
							For j = lt To rt - 1
								id = s.idx(j)
								v = s.vals(j)
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(id, i_)
								Next
								For i_ = 0 To k - 1
									b(id, i_) = b(id, i_) + v * a(i, i_)
								Next
							Next
						End If
					Next
				End If
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseMM2: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If d > 0 AndAlso Not isupper Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(i, k0) = b(i, k0) + v * a(j, k0)
									b(j, k0) = b(j, k0) + v * a(i, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(j, i_)
								Next
								For i_ = 0 To k - 1
									b(j, i_) = b(j, i_) + v * a(i, i_)
								Next
							End If
						Next
					End If
					If u > 0 AndAlso isupper Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						For j = lt1 To rt1
							v = s.vals(lt + (j - lt1))
							If k < linalgswitch Then

								'
								' Use loop
								'
								For k0 = 0 To k1
									b(j, k0) = b(j, k0) + v * a(i, k0)
									b(i, k0) = b(i, k0) + v * a(j, k0)
								Next
							Else

								'
								' Use vector operation
								'
								For i_ = 0 To k - 1
									b(j, i_) = b(j, i_) + v * a(i, i_)
								Next
								For i_ = 0 To k - 1
									b(i, i_) = b(i, i_) + v * a(j, i_)
								Next
							End If
						Next
					End If
					v = s.vals(ri + d)
					For i_ = 0 To k - 1
						b(i, i_) = b(i, i_) + v * a(i, i_)
					Next
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function calculates matrix-vector product op(S)*x, when x is  vector,
'        S is symmetric triangular matrix, op(S) is transposition or no  operation.
'        Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
'        otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse square matrix in CRS or SKS format.
'            IsUpper     -   whether upper or lower triangle of S is used:
'                            * if upper triangle is given,  only   S[i,j] for  j>=i
'                              are used, and lower triangle is  ignored (it can  be
'                              empty - these elements are not referenced at all).
'                            * if lower triangle is given,  only   S[i,j] for  j<=i
'                              are used, and upper triangle is ignored.
'            IsUnit      -   unit or non-unit diagonal:
'                            * if True, diagonal elements of triangular matrix  are
'                              considered equal to 1.0. Actual elements  stored  in
'                              S are not referenced at all.
'                            * if False, diagonal stored in S is used
'            OpType      -   operation type:
'                            * if 0, S*x is calculated
'                            * if 1, (S^T)*x is calculated (transposition)
'            X           -   array[N] which stores input  vector.  For  performance
'                            reasons we make only quick  checks  -  we  check  that
'                            array  size  is  at  least  N, but we do not check for
'                            NAN's or INF's.
'            Y           -   possibly  preallocated  input   buffer.  Automatically 
'                            resized if its size is too small.
'            
'        OUTPUT PARAMETERS
'            Y           -   array[N], op(S)*x
'            
'        NOTE: this function throws exception when called for non-CRS/SKS  matrix.
'        You must convert your matrix with SparseConvertToCRS/SKS()  before  using
'        this function.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsetrmv(s As sparsematrix, isupper As Boolean, isunit As Boolean, optype As Integer, x As Double(), ByRef y As Double())
			Dim n As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim j0 As Integer = 0
			Dim j1 As Integer = 0
			Dim v As Double = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0
			Dim lt1 As Integer = 0
			Dim rt1 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseTRMV: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(optype = 0 OrElse optype = 1, "SparseTRMV: incorrect operation type (must be 0 or 1)")
			alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseTRMV: Length(X)<N")
			alglib.ap.assert(s.m = s.n, "SparseTRMV: matrix is non-square")
			n = s.n
			apserv.rvectorsetlengthatleast(y, n)
			If isunit Then

				'
				' Set initial value of y to x
				'
				For i = 0 To n - 1
					y(i) = x(i)
				Next
			Else

				'
				' Set initial value of y to 0
				'
				For i = 0 To n - 1
					y(i) = 0
				Next
			End If
			If s.matrixtype = 1 Then

				'
				' CRS format
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseTRMV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				For i = 0 To n - 1

					'
					' Depending on IsUpper/IsUnit, select range of indexes to process
					'
					If isupper Then
						If isunit OrElse s.didx(i) = s.uidx(i) Then
							j0 = s.uidx(i)
						Else
							j0 = s.didx(i)
						End If
						j1 = s.ridx(i + 1) - 1
					Else
						j0 = s.ridx(i)
						If isunit OrElse s.didx(i) = s.uidx(i) Then
							j1 = s.didx(i) - 1
						Else
							j1 = s.didx(i)
						End If
					End If

					'
					' Depending on OpType, process subset of I-th row of input matrix
					'
					If optype = 0 Then
						v = 0.0
						For j = j0 To j1
							v = v + s.vals(j) * x(s.idx(j))
						Next
						y(i) = y(i) + v
					Else
						v = x(i)
						For j = j0 To j1
							k = s.idx(j)
							y(k) = y(k) + v * s.vals(j)
						Next
					End If
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseTRMV: non-square SKS matrices are not supported")
				For i = 0 To n - 1
					ri = s.ridx(i)
					ri1 = s.ridx(i + 1)
					d = s.didx(i)
					u = s.uidx(i)
					If Not isunit Then
						y(i) = y(i) + s.vals(ri + d) * x(i)
					End If
					If d > 0 AndAlso Not isupper Then
						lt = ri
						rt = ri + d - 1
						lt1 = i - d
						rt1 = i - 1
						If optype = 0 Then
							i1_ = (lt1) - (lt)
							v = 0.0
							For i_ = lt To rt
								v += s.vals(i_) * x(i_ + i1_)
							Next
							y(i) = y(i) + v
						Else
							v = x(i)
							i1_ = (lt) - (lt1)
							For i_ = lt1 To rt1
								y(i_) = y(i_) + v * s.vals(i_ + i1_)
							Next
						End If
					End If
					If u > 0 AndAlso isupper Then
						lt = ri1 - u
						rt = ri1 - 1
						lt1 = i - u
						rt1 = i - 1
						If optype = 0 Then
							v = x(i)
							i1_ = (lt) - (lt1)
							For i_ = lt1 To rt1
								y(i_) = y(i_) + v * s.vals(i_ + i1_)
							Next
						Else
							i1_ = (lt1) - (lt)
							v = 0.0
							For i_ = lt To rt
								v += s.vals(i_) * x(i_ + i1_)
							Next
							y(i) = y(i) + v
						End If
					End If
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function solves linear system op(S)*y=x  where  x  is  vector,  S  is
'        symmetric  triangular  matrix,  op(S)  is  transposition  or no operation.
'        Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
'        otherwise).
'
'        INPUT PARAMETERS
'            S           -   sparse square matrix in CRS or SKS format.
'            IsUpper     -   whether upper or lower triangle of S is used:
'                            * if upper triangle is given,  only   S[i,j] for  j>=i
'                              are used, and lower triangle is  ignored (it can  be
'                              empty - these elements are not referenced at all).
'                            * if lower triangle is given,  only   S[i,j] for  j<=i
'                              are used, and upper triangle is ignored.
'            IsUnit      -   unit or non-unit diagonal:
'                            * if True, diagonal elements of triangular matrix  are
'                              considered equal to 1.0. Actual elements  stored  in
'                              S are not referenced at all.
'                            * if False, diagonal stored in S is used. It  is  your
'                              responsibility  to  make  sure  that   diagonal   is
'                              non-zero.
'            OpType      -   operation type:
'                            * if 0, S*x is calculated
'                            * if 1, (S^T)*x is calculated (transposition)
'            X           -   array[N] which stores input  vector.  For  performance
'                            reasons we make only quick  checks  -  we  check  that
'                            array  size  is  at  least  N, but we do not check for
'                            NAN's or INF's.
'            
'        OUTPUT PARAMETERS
'            X           -   array[N], inv(op(S))*x
'            
'        NOTE: this function throws exception when called for  non-CRS/SKS  matrix.
'              You must convert your matrix  with  SparseConvertToCRS/SKS()  before
'              using this function.
'
'        NOTE: no assertion or tests are done during algorithm  operation.   It  is
'              your responsibility to provide invertible matrix to algorithm.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsetrsv(s As sparsematrix, isupper As Boolean, isunit As Boolean, optype As Integer, x As Double())
			Dim n As Integer = 0
			Dim fst As Integer = 0
			Dim lst As Integer = 0
			Dim stp As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim vd As Double = 0
			Dim j0 As Integer = 0
			Dim j1 As Integer = 0
			Dim ri As Integer = 0
			Dim ri1 As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim lt As Integer = 0
			Dim lt1 As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseTRSV: incorrect matrix type (convert your matrix to CRS/SKS)")
			alglib.ap.assert(optype = 0 OrElse optype = 1, "SparseTRSV: incorrect operation type (must be 0 or 1)")
			alglib.ap.assert(alglib.ap.len(x) >= s.n, "SparseTRSV: Length(X)<N")
			alglib.ap.assert(s.m = s.n, "SparseTRSV: matrix is non-square")
			n = s.n
			If s.matrixtype = 1 Then

				'
				' CRS format.
				'
				' Several branches for different combinations of IsUpper and OpType
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseTRSV: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If optype = 0 Then

					'
					' No transposition.
					'
					' S*x=y with upper or lower triangular S.
					'
					If isupper Then
						fst = n - 1
						lst = 0
						stp = -1
					Else
						fst = 0
						lst = n - 1
						stp = 1
					End If
					i = fst
					While (stp > 0 AndAlso i <= lst) OrElse (stp < 0 AndAlso i >= lst)

						'
						' Select range of indexes to process
						'
						If isupper Then
							j0 = s.uidx(i)
							j1 = s.ridx(i + 1) - 1
						Else
							j0 = s.ridx(i)
							j1 = s.didx(i) - 1
						End If

						'
						' Calculate X[I]
						'
						v = 0.0
						For j = j0 To j1
							v = v + s.vals(j) * x(s.idx(j))
						Next
						If Not isunit Then
							If s.didx(i) = s.uidx(i) Then
								vd = 0
							Else
								vd = s.vals(s.didx(i))
							End If
						Else
							vd = 1.0
						End If
						k = apserv.saferdiv(x(i) - v, vd, v)
						alglib.ap.assert(k <= 0, "SparseTRSV: near-overflow or division by exact zero")
						x(i) = v

						'
						' Next I
						'
						i = i + stp
					End While
					Return
				End If
				If optype = 1 Then

					'
					' Transposition.
					'
					' (S^T)*x=y with upper or lower triangular S.
					'
					If isupper Then
						fst = 0
						lst = n - 1
						stp = 1
					Else
						fst = n - 1
						lst = 0
						stp = -1
					End If
					i = fst
					While (stp > 0 AndAlso i <= lst) OrElse (stp < 0 AndAlso i >= lst)

						'
						' X[i] already stores A[i,i]*Y[i], the only thing left
						' is to divide by diagonal element.
						'
						If Not isunit Then
							If s.didx(i) = s.uidx(i) Then
								vd = 0
							Else
								vd = s.vals(s.didx(i))
							End If
						Else
							vd = 1.0
						End If
						k = apserv.saferdiv(x(i), vd, v)
						alglib.ap.assert(k <= 0, "SparseTRSV: near-overflow or division by exact zero")
						x(i) = v

						'
						' For upper triangular case:
						'     subtract X[i]*Ai from X[i+1:N-1]
						'
						' For lower triangular case:
						'     subtract X[i]*Ai from X[0:i-1]
						'
						' (here Ai is I-th row of original, untransposed A).
						'
						If isupper Then
							j0 = s.uidx(i)
							j1 = s.ridx(i + 1) - 1
						Else
							j0 = s.ridx(i)
							j1 = s.didx(i) - 1
						End If
						v = x(i)
						For j = j0 To j1
							k = s.idx(j)
							x(k) = x(k) - s.vals(j) * v
						Next

						'
						' Next I
						'
						i = i + stp
					End While
					Return
				End If
				alglib.ap.assert(False, "SparseTRSV: internal error")
			End If
			If s.matrixtype = 2 Then

				'
				' SKS format
				'
				alglib.ap.assert(s.m = s.n, "SparseTRSV: non-square SKS matrices are not supported")
				If (optype = 0 AndAlso Not isupper) OrElse (optype = 1 AndAlso isupper) Then

					'
					' Lower triangular op(S) (matrix itself can be upper triangular).
					'
					For i = 0 To n - 1

						'
						' Select range of indexes to process
						'
						ri = s.ridx(i)
						ri1 = s.ridx(i + 1)
						d = s.didx(i)
						u = s.uidx(i)
						If isupper Then
							lt = i - u
							lt1 = ri1 - u
							k = u - 1
						Else
							lt = i - d
							lt1 = ri
							k = d - 1
						End If

						'
						' Calculate X[I]
						'
						v = 0.0
						For j = 0 To k
							v = v + s.vals(lt1 + j) * x(lt + j)
						Next
						If isunit Then
							vd = 1
						Else
							vd = s.vals(ri + d)
						End If
						k = apserv.saferdiv(x(i) - v, vd, v)
						alglib.ap.assert(k <= 0, "SparseTRSV: near-overflow or division by exact zero")
						x(i) = v
					Next
					Return
				End If
				If (optype = 1 AndAlso Not isupper) OrElse (optype = 0 AndAlso isupper) Then

					'
					' Upper triangular op(S) (matrix itself can be lower triangular).
					'
					For i = n - 1 To 0 Step -1
						ri = s.ridx(i)
						ri1 = s.ridx(i + 1)
						d = s.didx(i)
						u = s.uidx(i)

						'
						' X[i] already stores A[i,i]*Y[i], the only thing left
						' is to divide by diagonal element.
						'
						If isunit Then
							vd = 1
						Else
							vd = s.vals(ri + d)
						End If
						k = apserv.saferdiv(x(i), vd, v)
						alglib.ap.assert(k <= 0, "SparseTRSV: near-overflow or division by exact zero")
						x(i) = v

						'
						' Subtract product of X[i] and I-th column of "effective" A from
						' unprocessed variables.
						'
						v = x(i)
						If isupper Then
							lt = i - u
							lt1 = ri1 - u
							k = u - 1
						Else
							lt = i - d
							lt1 = ri
							k = d - 1
						End If
						For j = 0 To k
							x(lt + j) = x(lt + j) - v * s.vals(lt1 + j)
						Next
					Next
					Return
				End If
				alglib.ap.assert(False, "SparseTRSV: internal error")
			End If
			alglib.ap.assert(False, "SparseTRSV: internal error")
		End Sub


		'************************************************************************
'        This procedure resizes Hash-Table matrix. It can be called when you  have
'        deleted too many elements from the matrix, and you want to  free unneeded
'        memory.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseresizematrix(s As sparsematrix)
			Dim k As Integer = 0
			Dim k1 As Integer = 0
			Dim i As Integer = 0
			Dim tvals As Double() = New Double(-1) {}
			Dim tidx As Integer() = New Integer(-1) {}

			alglib.ap.assert(s.matrixtype = 0, "SparseResizeMatrix: incorrect matrix type")

			'
			' Initialization for length and number of non-null elementd
			'
			k = s.tablesize
			k1 = 0

			'
			' Calculating number of non-null elements
			'
			For i = 0 To k - 1
				If s.idx(2 * i) >= 0 Then
					k1 = k1 + 1
				End If
			Next

			'
			' Initialization value for free space
			'
			s.tablesize = CInt(System.Math.Truncate(System.Math.Round(k1 / desiredloadfactor * growfactor + additional)))
			s.nfree = s.tablesize - k1
			tvals = New Double(s.tablesize - 1) {}
			tidx = New Integer(2 * s.tablesize - 1) {}
			alglib.ap.swap(s.vals, tvals)
			alglib.ap.swap(s.idx, tidx)
			For i = 0 To s.tablesize - 1
				s.idx(2 * i) = -1
			Next
			For i = 0 To k - 1
				If tidx(2 * i) >= 0 Then
					sparseset(s, tidx(2 * i), tidx(2 * i + 1), tvals(i))
				End If
			Next
		End Sub


		'************************************************************************
'        This function return average length of chain at hash-table.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetaveragelengthofchain(s As sparsematrix) As Double
			Dim result As Double = 0
			Dim nchains As Integer = 0
			Dim talc As Integer = 0
			Dim l As Integer = 0
			Dim i As Integer = 0
			Dim ind0 As Integer = 0
			Dim ind1 As Integer = 0
			Dim hashcode As Integer = 0


			'
			' If matrix represent in CRS then return zero and exit
			'
			If s.matrixtype <> 0 Then
				result = 0
				Return result
			End If
			nchains = 0
			talc = 0
			l = s.tablesize
			For i = 0 To l - 1
				ind0 = 2 * i
				If s.idx(ind0) <> -1 Then
					nchains = nchains + 1
					hashcode = hash(s.idx(ind0), s.idx(ind0 + 1), l)
					While True
						talc = talc + 1
						ind1 = 2 * hashcode
						If s.idx(ind0) = s.idx(ind1) AndAlso s.idx(ind0 + 1) = s.idx(ind1 + 1) Then
							Exit While
						End If
						hashcode = (hashcode + 1) Mod l
					End While
				End If
			Next
			If nchains = 0 Then
				result = 0
			Else
				result = CDbl(talc) / CDbl(nchains)
			End If
			Return result
		End Function


		'************************************************************************
'        This  function  is  used  to enumerate all elements of the sparse matrix.
'        Before  first  call  user  initializes  T0 and T1 counters by zero. These
'        counters are used to remember current position in a  matrix;  after  each
'        call they are updated by the function.
'
'        Subsequent calls to this function return non-zero elements of the  sparse
'        matrix, one by one. If you enumerate CRS matrix, matrix is traversed from
'        left to right, from top to bottom. In case you enumerate matrix stored as
'        Hash table, elements are returned in random order.
'
'        EXAMPLE
'            > T0=0
'            > T1=0
'            > while SparseEnumerate(S,T0,T1,I,J,V) do
'            >     ....do something with I,J,V
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in Hash-Table or CRS representation.
'            T0          -   internal counter
'            T1          -   internal counter
'            
'        OUTPUT PARAMETERS
'            T0          -   new value of the internal counter
'            T1          -   new value of the internal counter
'            I           -   row index of non-zero element, 0<=I<M.
'            J           -   column index of non-zero element, 0<=J<N
'            V           -   value of the T-th element
'            
'        RESULT
'            True in case of success (next non-zero element was retrieved)
'            False in case all non-zero elements were enumerated
'            
'        NOTE: you may call SparseRewriteExisting() during enumeration, but it  is
'              THE  ONLY  matrix  modification  function  you  can  call!!!  Other
'              matrix modification functions should not be called during enumeration!
'
'          -- ALGLIB PROJECT --
'             Copyright 14.03.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparseenumerate(s As sparsematrix, ByRef t0 As Integer, ByRef t1 As Integer, ByRef i As Integer, ByRef j As Integer, ByRef v As Double) As Boolean
			Dim result As New Boolean()
			Dim sz As Integer = 0
			Dim i0 As Integer = 0

			i = 0
			j = 0
			v = 0

			result = False
			If t0 < 0 OrElse (s.matrixtype <> 0 AndAlso t1 < 0) Then

				'
				' Incorrect T0/T1, terminate enumeration
				'
				result = False
				Return result
			End If
			If s.matrixtype = 0 Then

				'
				' Hash-table matrix
				'
				sz = s.tablesize
				For i0 = t0 To sz - 1
					If s.idx(2 * i0) = -1 OrElse s.idx(2 * i0) = -2 Then
						Continue For
					Else
						i = s.idx(2 * i0)
						j = s.idx(2 * i0 + 1)
						v = s.vals(i0)
						t0 = i0 + 1
						result = True
						Return result
					End If
				Next
				t0 = 0
				t1 = 0
				result = False
				Return result
			End If
			If s.matrixtype = 1 Then

				'
				' CRS matrix
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseEnumerate: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				If t0 >= s.ninitialized Then
					t0 = 0
					t1 = 0
					result = False
					Return result
				End If
				While t0 > s.ridx(t1 + 1) - 1 AndAlso t1 < s.m
					t1 = t1 + 1
				End While
				i = t1
				j = s.idx(t0)
				v = s.vals(t0)
				t0 = t0 + 1
				result = True
				Return result
			End If
			If s.matrixtype = 2 Then

				'
				' SKS matrix:
				' * T0 stores current offset in Vals[] array
				' * T1 stores index of the diagonal block
				'
				alglib.ap.assert(s.m = s.n, "SparseEnumerate: non-square SKS matrices are not supported")
				If t0 >= s.ridx(s.m) Then
					t0 = 0
					t1 = 0
					result = False
					Return result
				End If
				While t0 > s.ridx(t1 + 1) - 1 AndAlso t1 < s.m
					t1 = t1 + 1
				End While
				i0 = t0 - s.ridx(t1)
				If i0 < s.didx(t1) + 1 Then

					'
					' subdiagonal or diagonal element, row index is T1.
					'
					i = t1
					j = t1 - s.didx(t1) + i0
				Else

					'
					' superdiagonal element, column index is T1.
					'
					i = t1 - (s.ridx(t1 + 1) - t0)
					j = t1
				End If
				v = s.vals(t0)
				t0 = t0 + 1
				result = True
				Return result
			End If
			alglib.ap.assert(False, "SparseEnumerate: unexpected matrix type")
			Return result
		End Function


		'************************************************************************
'        This function rewrites existing (non-zero) element. It  returns  True   if
'        element  exists  or  False,  when  it  is  called for non-existing  (zero)
'        element.
'
'        This function works with any kind of the matrix.
'
'        The purpose of this function is to provide convenient thread-safe  way  to
'        modify  sparse  matrix.  Such  modification  (already  existing element is
'        rewritten) is guaranteed to be thread-safe without any synchronization, as
'        long as different threads modify different elements.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in any kind of representation
'                            (Hash, SKS, CRS).
'            I           -   row index of non-zero element to modify, 0<=I<M
'            J           -   column index of non-zero element to modify, 0<=J<N
'            V           -   value to rewrite, must be finite number
'
'        OUTPUT PARAMETERS
'            S           -   modified matrix
'        RESULT
'            True in case when element exists
'            False in case when element doesn't exist or it is zero
'            
'          -- ALGLIB PROJECT --
'             Copyright 14.03.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparserewriteexisting(s As sparsematrix, i As Integer, j As Integer, v As Double) As Boolean
			Dim result As New Boolean()
			Dim hashcode As Integer = 0
			Dim k As Integer = 0
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0

			alglib.ap.assert(0 <= i AndAlso i < s.m, "SparseRewriteExisting: invalid argument I(either I<0 or I>=S.M)")
			alglib.ap.assert(0 <= j AndAlso j < s.n, "SparseRewriteExisting: invalid argument J(either J<0 or J>=S.N)")
			alglib.ap.assert(Math.isfinite(v), "SparseRewriteExisting: invalid argument V(either V is infinite or V is NaN)")
			result = False

			'
			' Hash-table matrix
			'
			If s.matrixtype = 0 Then
				k = s.tablesize
				hashcode = hash(i, j, k)
				While True
					If s.idx(2 * hashcode) = -1 Then
						Return result
					End If
					If s.idx(2 * hashcode) = i AndAlso s.idx(2 * hashcode + 1) = j Then
						s.vals(hashcode) = v
						result = True
						Return result
					End If
					hashcode = (hashcode + 1) Mod k
				End While
			End If

			'
			' CRS matrix
			'
			If s.matrixtype = 1 Then
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseRewriteExisting: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				k0 = s.ridx(i)
				k1 = s.ridx(i + 1) - 1
				While k0 <= k1
					k = (k0 + k1) \ 2
					If s.idx(k) = j Then
						s.vals(k) = v
						result = True
						Return result
					End If
					If s.idx(k) < j Then
						k0 = k + 1
					Else
						k1 = k - 1
					End If
				End While
			End If

			'
			' SKS
			'
			If s.matrixtype = 2 Then
				alglib.ap.assert(s.m = s.n, "SparseRewriteExisting: non-square SKS matrix not supported")
				If i = j Then

					'
					' Rewrite diagonal element
					'
					result = True
					s.vals(s.ridx(i) + s.didx(i)) = v
					Return result
				End If
				If j < i Then

					'
					' Return subdiagonal element at I-th "skyline block"
					'
					k = s.didx(i)
					If i - j <= k Then
						s.vals(s.ridx(i) + k + j - i) = v
						result = True
					End If
				Else

					'
					' Return superdiagonal element at J-th "skyline block"
					'
					k = s.uidx(j)
					If j - i <= k Then
						s.vals(s.ridx(j + 1) - (j - i)) = v
						result = True
					End If
				End If
				Return result
			End If
			Return result
		End Function


		'************************************************************************
'        This function returns I-th row of the sparse matrix. Matrix must be stored
'        in CRS or SKS format.
'
'        INPUT PARAMETERS:
'            S           -   sparse M*N matrix in CRS format
'            I           -   row index, 0<=I<M
'            IRow        -   output buffer, can be  preallocated.  In  case  buffer
'                            size  is  too  small  to  store  I-th   row,   it   is
'                            automatically reallocated.
'         
'        OUTPUT PARAMETERS:
'            IRow        -   array[M], I-th row.
'            
'        NOTE: this function has O(N) running time, where N is a  column  count. It
'              allocates and fills N-element  array,  even  although  most  of  its
'              elemets are zero.
'              
'        NOTE: If you have O(non-zeros-per-row) time and memory  requirements,  use
'              SparseGetCompressedRow() function. It  returns  data  in  compressed
'              format.
'
'        NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
'              is passed, this function throws exception.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsegetrow(s As sparsematrix, i As Integer, ByRef irow As Double())
			Dim i0 As Integer = 0
			Dim j0 As Integer = 0
			Dim j1 As Integer = 0
			Dim j As Integer = 0
			Dim upperprofile As Integer = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseGetRow: S must be CRS/SKS-based matrix")
			alglib.ap.assert(i >= 0 AndAlso i < s.m, "SparseGetRow: I<0 or I>=M")

			'
			' Prepare output buffer
			'
			apserv.rvectorsetlengthatleast(irow, s.n)
			For i0 = 0 To s.n - 1
				irow(i0) = 0
			Next

			'
			' Output
			'
			If s.matrixtype = 1 Then
				For i0 = s.ridx(i) To s.ridx(i + 1) - 1
					irow(s.idx(i0)) = s.vals(i0)
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' Copy subdiagonal and diagonal parts
				'
				alglib.ap.assert(s.n = s.m, "SparseGetRow: non-square SKS matrices are not supported")
				j0 = i - s.didx(i)
				i0 = -j0 + s.ridx(i)
				For j = j0 To i
					irow(j) = s.vals(j + i0)
				Next

				'
				' Copy superdiagonal part
				'
				upperprofile = s.uidx(s.n)
				j0 = i + 1
				j1 = System.Math.Min(s.n - 1, i + upperprofile)
				For j = j0 To j1
					If j - i <= s.uidx(j) Then
						irow(j) = s.vals(s.ridx(j + 1) - (j - i))
					End If
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function returns I-th row of the sparse matrix IN COMPRESSED FORMAT -
'        only non-zero elements are returned (with their indexes). Matrix  must  be
'        stored in CRS or SKS format.
'
'        INPUT PARAMETERS:
'            S           -   sparse M*N matrix in CRS format
'            I           -   row index, 0<=I<M
'            ColIdx      -   output buffer for column indexes, can be preallocated.
'                            In case buffer size is too small to store I-th row, it
'                            is automatically reallocated.
'            Vals        -   output buffer for values, can be preallocated. In case
'                            buffer size is too small to  store  I-th  row,  it  is
'                            automatically reallocated.
'         
'        OUTPUT PARAMETERS:
'            ColIdx      -   column   indexes   of  non-zero  elements,  sorted  by
'                            ascending. Symbolically non-zero elements are  counted
'                            (i.e. if you allocated place for element, but  it  has
'                            zero numerical value - it is counted).
'            Vals        -   values. Vals[K] stores value of  matrix  element  with
'                            indexes (I,ColIdx[K]). Symbolically non-zero  elements
'                            are counted (i.e. if you allocated place for  element,
'                            but it has zero numerical value - it is counted).
'            NZCnt       -   number of symbolically non-zero elements per row.
'
'        NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
'              is passed, this function throws exception.
'              
'        NOTE: this function may allocate additional, unnecessary place for  ColIdx
'              and Vals arrays. It is dictated by  performance  reasons  -  on  SKS
'              matrices it is faster  to  allocate  space  at  the  beginning  with
'              some "extra"-space, than performing two passes over matrix  -  first
'              time to calculate exact space required for data, second  time  -  to
'              store data itself.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsegetcompressedrow(s As sparsematrix, i As Integer, ByRef colidx As Integer(), ByRef vals As Double(), ByRef nzcnt As Integer)
			Dim k As Integer = 0
			Dim k0 As Integer = 0
			Dim j As Integer = 0
			Dim j0 As Integer = 0
			Dim j1 As Integer = 0
			Dim i0 As Integer = 0
			Dim upperprofile As Integer = 0

			nzcnt = 0

			alglib.ap.assert(s.matrixtype = 1 OrElse s.matrixtype = 2, "SparseGetRow: S must be CRS/SKS-based matrix")
			alglib.ap.assert(i >= 0 AndAlso i < s.m, "SparseGetRow: I<0 or I>=M")

			'
			' Initialize NZCnt
			'
			nzcnt = 0

			'
			' CRS matrix - just copy data
			'
			If s.matrixtype = 1 Then
				nzcnt = s.ridx(i + 1) - s.ridx(i)
				apserv.ivectorsetlengthatleast(colidx, nzcnt)
				apserv.rvectorsetlengthatleast(vals, nzcnt)
				k0 = s.ridx(i)
				For k = 0 To nzcnt - 1
					colidx(k) = s.idx(k0 + k)
					vals(k) = s.vals(k0 + k)
				Next
				Return
			End If

			'
			' SKS matrix - a bit more complex sequence
			'
			If s.matrixtype = 2 Then
				alglib.ap.assert(s.n = s.m, "SparseGetCompressedRow: non-square SKS matrices are not supported")

				'
				' Allocate enough place for storage
				'
				upperprofile = s.uidx(s.n)
				apserv.ivectorsetlengthatleast(colidx, s.didx(i) + 1 + upperprofile)
				apserv.rvectorsetlengthatleast(vals, s.didx(i) + 1 + upperprofile)

				'
				' Copy subdiagonal and diagonal parts
				'
				j0 = i - s.didx(i)
				i0 = -j0 + s.ridx(i)
				For j = j0 To i
					colidx(nzcnt) = j
					vals(nzcnt) = s.vals(j + i0)
					nzcnt = nzcnt + 1
				Next

				'
				' Copy superdiagonal part
				'
				j0 = i + 1
				j1 = System.Math.Min(s.n - 1, i + upperprofile)
				For j = j0 To j1
					If j - i <= s.uidx(j) Then
						colidx(nzcnt) = j
						vals(nzcnt) = s.vals(s.ridx(j + 1) - (j - i))
						nzcnt = nzcnt + 1
					End If
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This function performs efficient in-place  transpose  of  SKS  matrix.  No
'        additional memory is allocated during transposition.
'
'        This function supports only skyline storage format (SKS).
'
'        INPUT PARAMETERS
'            S       -   sparse matrix in SKS format.
'
'        OUTPUT PARAMETERS
'            S           -   sparse matrix, transposed.
'
'          -- ALGLIB PROJECT --
'             Copyright 16.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsetransposesks(s As sparsematrix)
			Dim n As Integer = 0
			Dim d As Integer = 0
			Dim u As Integer = 0
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim t0 As Integer = 0
			Dim t1 As Integer = 0
			Dim v As Double = 0

			alglib.ap.assert(s.matrixtype = 2, "SparseTransposeSKS: only SKS matrices are supported")
			alglib.ap.assert(s.m = s.n, "SparseTransposeSKS: non-square SKS matrices are not supported")
			n = s.n
			For i = 1 To n - 1
				d = s.didx(i)
				u = s.uidx(i)
				k = s.uidx(i)
				s.uidx(i) = s.didx(i)
				s.didx(i) = k
				If d = u Then

					'
					' Upper skyline height equal to lower skyline height,
					' simple exchange is needed for transposition
					'
					t0 = s.ridx(i)
					For k = 0 To d - 1
						v = s.vals(t0 + k)
						s.vals(t0 + k) = s.vals(t0 + d + 1 + k)
						s.vals(t0 + d + 1 + k) = v
					Next
				End If
				If d > u Then

					'
					' Upper skyline height is less than lower skyline height.
					'
					' Transposition becomes a bit tricky: we have to rearrange
					' "L0 L1 D U" to "U D L0 L1", where |L0|=|U|=u, |L1|=d-u.
					'
					' In order to do this we perform a sequence of swaps and
					' in-place reversals:
					' * swap(L0,U)         =>  "U   L1  D   L0"
					' * reverse("L1 D L0") =>  "U   L0~ D   L1~" (where X~ is a reverse of X)
					' * reverse("L0~ D")   =>  "U   D   L0  L1~"
					' * reverse("L1")      =>  "U   D   L0  L1"
					'
					t0 = s.ridx(i)
					t1 = s.ridx(i) + d + 1
					For k = 0 To u - 1
						v = s.vals(t0 + k)
						s.vals(t0 + k) = s.vals(t1 + k)
						s.vals(t1 + k) = v
					Next
					t0 = s.ridx(i) + u
					t1 = s.ridx(i + 1) - 1
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
					t0 = s.ridx(i) + u
					t1 = s.ridx(i) + u + u
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
					t0 = s.ridx(i + 1) - (d - u)
					t1 = s.ridx(i + 1) - 1
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
				End If
				If d < u Then

					'
					' Upper skyline height is greater than lower skyline height.
					'
					' Transposition becomes a bit tricky: we have to rearrange
					' "L D U0 U1" to "U0 U1 D L", where |U1|=|L|=d, |U0|=u-d.
					'
					' In order to do this we perform a sequence of swaps and
					' in-place reversals:
					' * swap(L,U1)         =>  "U1  D   U0  L"
					' * reverse("U1 D U0") =>  "U0~ D   U1~ L" (where X~ is a reverse of X)
					' * reverse("U0~")     =>  "U0  D   U1~ L"
					' * reverse("D U1~")   =>  "U0  U1  D   L"
					'
					t0 = s.ridx(i)
					t1 = s.ridx(i + 1) - d
					For k = 0 To d - 1
						v = s.vals(t0 + k)
						s.vals(t0 + k) = s.vals(t1 + k)
						s.vals(t1 + k) = v
					Next
					t0 = s.ridx(i)
					t1 = s.ridx(i) + u
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
					t0 = s.ridx(i)
					t1 = s.ridx(i) + u - d - 1
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
					t0 = s.ridx(i) + u - d
					t1 = s.ridx(i + 1) - d - 1
					While t1 > t0
						v = s.vals(t0)
						s.vals(t0) = s.vals(t1)
						s.vals(t1) = v
						t0 = t0 + 1
						t1 = t1 - 1
					End While
				End If
			Next
			k = s.uidx(n)
			s.uidx(n) = s.didx(n)
			s.didx(n) = k
		End Sub


		'************************************************************************
'        This  function  performs  in-place  conversion  to  desired sparse storage
'        format.
'
'        INPUT PARAMETERS
'            S0      -   sparse matrix in any format.
'            Fmt     -   desired storage format  of  the  output,  as  returned  by
'                        SparseGetMatrixType() function:
'                        * 0 for hash-based storage
'                        * 1 for CRS
'                        * 2 for SKS
'
'        OUTPUT PARAMETERS
'            S0          -   sparse matrix in requested format.
'            
'        NOTE: in-place conversion wastes a lot of memory which is  used  to  store
'              temporaries.  If  you  perform  a  lot  of  repeated conversions, we
'              recommend to use out-of-place buffered  conversion  functions,  like
'              SparseCopyToBuf(), which can reuse already allocated memory.
'
'          -- ALGLIB PROJECT --
'             Copyright 16.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseconvertto(s0 As sparsematrix, fmt As Integer)
			alglib.ap.assert((fmt = 0 OrElse fmt = 1) OrElse fmt = 2, "SparseConvertTo: invalid fmt parameter")
			If fmt = 0 Then
				sparseconverttohash(s0)
				Return
			End If
			If fmt = 1 Then
				sparseconverttocrs(s0)
				Return
			End If
			If fmt = 2 Then
				sparseconverttosks(s0)
				Return
			End If
			alglib.ap.assert(False, "SparseConvertTo: invalid matrix type")
		End Sub


		'************************************************************************
'        This  function  performs out-of-place conversion to desired sparse storage
'        format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
'        S1 is reused to maximum extent possible.
'
'        INPUT PARAMETERS
'            S0      -   sparse matrix in any format.
'            Fmt     -   desired storage format  of  the  output,  as  returned  by
'                        SparseGetMatrixType() function:
'                        * 0 for hash-based storage
'                        * 1 for CRS
'                        * 2 for SKS
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in requested format.
'
'          -- ALGLIB PROJECT --
'             Copyright 16.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytobuf(s0 As sparsematrix, fmt As Integer, s1 As sparsematrix)
			alglib.ap.assert((fmt = 0 OrElse fmt = 1) OrElse fmt = 2, "SparseCopyToBuf: invalid fmt parameter")
			If fmt = 0 Then
				sparsecopytohashbuf(s0, s1)
				Return
			End If
			If fmt = 1 Then
				sparsecopytocrsbuf(s0, s1)
				Return
			End If
			If fmt = 2 Then
				sparsecopytosksbuf(s0, s1)
				Return
			End If
			alglib.ap.assert(False, "SparseCopyToBuf: invalid matrix type")
		End Sub


		'************************************************************************
'        This function performs in-place conversion to Hash table storage.
'
'        INPUT PARAMETERS
'            S           -   sparse matrix in CRS format.
'
'        OUTPUT PARAMETERS
'            S           -   sparse matrix in Hash table format.
'
'        NOTE: this  function  has   no  effect  when  called with matrix which  is
'              already in Hash table mode.
'
'        NOTE: in-place conversion involves allocation of temporary arrays. If  you
'              perform a lot of repeated in- place  conversions,  it  may  lead  to
'              memory fragmentation. Consider using out-of-place SparseCopyToHashBuf()
'              function in this case.
'            
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseconverttohash(s As sparsematrix)
			Dim tidx As Integer() = New Integer(-1) {}
			Dim tridx As Integer() = New Integer(-1) {}
			Dim tdidx As Integer() = New Integer(-1) {}
			Dim tuidx As Integer() = New Integer(-1) {}
			Dim tvals As Double() = New Double(-1) {}
			Dim n As Integer = 0
			Dim m As Integer = 0
			Dim offs0 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseConvertToHash: invalid matrix type")
			If s.matrixtype = 0 Then

				'
				' Already in Hash mode
				'
				Return
			End If
			If s.matrixtype = 1 Then

				'
				' From CRS to Hash
				'
				s.matrixtype = 0
				m = s.m
				n = s.n
				alglib.ap.swap(s.idx, tidx)
				alglib.ap.swap(s.ridx, tridx)
				alglib.ap.swap(s.vals, tvals)
				sparsecreatebuf(m, n, tridx(m), s)
				For i = 0 To m - 1
					For j = tridx(i) To tridx(i + 1) - 1
						sparseset(s, i, tidx(j), tvals(j))
					Next
				Next
				Return
			End If
			If s.matrixtype = 2 Then

				'
				' From SKS to Hash
				'
				s.matrixtype = 0
				m = s.m
				n = s.n
				alglib.ap.swap(s.ridx, tridx)
				alglib.ap.swap(s.didx, tdidx)
				alglib.ap.swap(s.uidx, tuidx)
				alglib.ap.swap(s.vals, tvals)
				sparsecreatebuf(m, n, tridx(m), s)
				For i = 0 To m - 1

					'
					' copy subdiagonal and diagonal parts of I-th block
					'
					offs0 = tridx(i)
					k = tdidx(i) + 1
					For j = 0 To k - 1
						sparseset(s, i, i - tdidx(i) + j, tvals(offs0 + j))
					Next

					'
					' Copy superdiagonal part of I-th block
					'
					offs0 = tridx(i) + tdidx(i) + 1
					k = tuidx(i)
					For j = 0 To k - 1
						sparseset(s, i - k + j, i, tvals(offs0 + j))
					Next
				Next
				Return
			End If
			alglib.ap.assert(False, "SparseConvertToHash: invalid matrix type")
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to  Hash table storage
'        format. S0 is copied to S1 and converted on-the-fly.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in Hash table format.
'
'        NOTE: if S0 is stored as Hash-table, it is just copied without conversion.
'
'        NOTE: this function de-allocates memory  occupied  by  S1 before  starting
'              conversion. If you perform a  lot  of  repeated  conversions, it may
'              lead to memory fragmentation. In this case we recommend you  to  use
'              SparseCopyToHashBuf() function which re-uses memory in S1 as much as
'              possible.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytohash(s0 As sparsematrix, s1 As sparsematrix)
			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToHash: invalid matrix type")
			sparsecopytohashbuf(s0, s1)
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to  Hash table storage
'        format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
'        S1 is reused to maximum extent possible.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in Hash table format.
'
'        NOTE: if S0 is stored as Hash-table, it is just copied without conversion.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytohashbuf(s0 As sparsematrix, s1 As sparsematrix)
			Dim val As Double = 0
			Dim t0 As Integer = 0
			Dim t1 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToHashBuf: invalid matrix type")
			If s0.matrixtype = 0 Then

				'
				' Already hash, just copy
				'
				sparsecopybuf(s0, s1)
				Return
			End If
			If s0.matrixtype = 1 Then

				'
				' CRS storage
				'
				t0 = 0
				t1 = 0
				sparsecreatebuf(s0.m, s0.n, s0.ridx(s0.m), s1)
				While sparseenumerate(s0, t0, t1, i, j, val)
					sparseset(s1, i, j, val)
				End While
				Return
			End If
			If s0.matrixtype = 2 Then

				'
				' SKS storage
				'
				t0 = 0
				t1 = 0
				sparsecreatebuf(s0.m, s0.n, s0.ridx(s0.m), s1)
				While sparseenumerate(s0, t0, t1, i, j, val)
					sparseset(s1, i, j, val)
				End While
				Return
			End If
			alglib.ap.assert(False, "SparseCopyToHashBuf: invalid matrix type")
		End Sub


		'************************************************************************
'        This function converts matrix to CRS format.
'
'        Some  algorithms  (linear  algebra ones, for example) require matrices in
'        CRS format. This function allows to perform in-place conversion.
'
'        INPUT PARAMETERS
'            S           -   sparse M*N matrix in any format
'
'        OUTPUT PARAMETERS
'            S           -   matrix in CRS format
'            
'        NOTE: this   function  has  no  effect  when  called with matrix which is
'              already in CRS mode.
'              
'        NOTE: this function allocates temporary memory to store a   copy  of  the
'              matrix. If you perform a lot of repeated conversions, we  recommend
'              you  to  use  SparseCopyToCRSBuf()  function,   which   can   reuse
'              previously allocated memory.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseconverttocrs(s As sparsematrix)
			Dim m As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim tvals As Double() = New Double(-1) {}
			Dim tidx As Integer() = New Integer(-1) {}
			Dim temp As Integer() = New Integer(-1) {}
			Dim tridx As Integer() = New Integer(-1) {}
			Dim nonne As Integer = 0
			Dim k As Integer = 0
			Dim offs0 As Integer = 0
			Dim offs1 As Integer = 0

			m = s.m
			If s.matrixtype = 0 Then

				'
				' From Hash-table to CRS.
				' First, create local copy of the hash table.
				'
				s.matrixtype = 1
				k = s.tablesize
				alglib.ap.swap(s.vals, tvals)
				alglib.ap.swap(s.idx, tidx)

				'
				' Fill RIdx by number of elements per row:
				' RIdx[I+1] stores number of elements in I-th row.
				'
				' Convert RIdx from row sizes to row offsets.
				' Set NInitialized
				'
				nonne = 0
				apserv.ivectorsetlengthatleast(s.ridx, s.m + 1)
				For i = 0 To s.m
					s.ridx(i) = 0
				Next
				For i = 0 To k - 1
					If tidx(2 * i) >= 0 Then
						s.ridx(tidx(2 * i) + 1) = s.ridx(tidx(2 * i) + 1) + 1
						nonne = nonne + 1
					End If
				Next
				For i = 0 To s.m - 1
					s.ridx(i + 1) = s.ridx(i + 1) + s.ridx(i)
				Next
				s.ninitialized = s.ridx(s.m)

				'
				' Allocate memory and move elements to Vals/Idx.
				' Initially, elements are sorted by rows, but unsorted within row.
				' After initial insertion we sort elements within row.
				'
				temp = New Integer(s.m - 1) {}
				For i = 0 To s.m - 1
					temp(i) = 0
				Next
				apserv.rvectorsetlengthatleast(s.vals, nonne)
				apserv.ivectorsetlengthatleast(s.idx, nonne)
				For i = 0 To k - 1
					If tidx(2 * i) >= 0 Then
						s.vals(s.ridx(tidx(2 * i)) + temp(tidx(2 * i))) = tvals(i)
						s.idx(s.ridx(tidx(2 * i)) + temp(tidx(2 * i))) = tidx(2 * i + 1)
						temp(tidx(2 * i)) = temp(tidx(2 * i)) + 1
					End If
				Next
				For i = 0 To s.m - 1
					tsort.tagsortmiddleir(s.idx, s.vals, s.ridx(i), s.ridx(i + 1) - s.ridx(i))
				Next

				'
				' Initialization 'S.UIdx' and 'S.DIdx'
				'
				sparseinitduidx(s)
				Return
			End If
			If s.matrixtype = 1 Then

				'
				' Already CRS
				'
				Return
			End If
			If s.matrixtype = 2 Then
				alglib.ap.assert(s.m = s.n, "SparseConvertToCRS: non-square SKS matrices are not supported")

				'
				' From SKS to CRS.
				'
				' First, create local copy of the SKS matrix (Vals,
				' Idx, RIdx are stored; DIdx/UIdx for some time are
				' left in the SparseMatrix structure).
				'
				s.matrixtype = 1
				alglib.ap.swap(s.vals, tvals)
				alglib.ap.swap(s.idx, tidx)
				alglib.ap.swap(s.ridx, tridx)

				'
				' Fill RIdx by number of elements per row:
				' RIdx[I+1] stores number of elements in I-th row.
				'
				' Convert RIdx from row sizes to row offsets.
				' Set NInitialized
				'
				apserv.ivectorsetlengthatleast(s.ridx, m + 1)
				s.ridx(0) = 0
				For i = 1 To m
					s.ridx(i) = 1
				Next
				nonne = 0
				For i = 0 To m - 1
					s.ridx(i + 1) = s.didx(i) + s.ridx(i + 1)
					For j = i - s.uidx(i) To i - 1
						s.ridx(j + 1) = s.ridx(j + 1) + 1
					Next
					nonne = nonne + s.didx(i) + 1 + s.uidx(i)
				Next
				For i = 0 To s.m - 1
					s.ridx(i + 1) = s.ridx(i + 1) + s.ridx(i)
				Next
				s.ninitialized = s.ridx(s.m)

				'
				' Allocate memory and move elements to Vals/Idx.
				' Initially, elements are sorted by rows, and are sorted within row too.
				' No additional post-sorting is required.
				'
				temp = New Integer(m - 1) {}
				For i = 0 To m - 1
					temp(i) = 0
				Next
				apserv.rvectorsetlengthatleast(s.vals, nonne)
				apserv.ivectorsetlengthatleast(s.idx, nonne)
				For i = 0 To m - 1

					'
					' copy subdiagonal and diagonal parts of I-th block
					'
					offs0 = tridx(i)
					offs1 = s.ridx(i) + temp(i)
					k = s.didx(i) + 1
					For j = 0 To k - 1
						s.vals(offs1 + j) = tvals(offs0 + j)
						s.idx(offs1 + j) = i - s.didx(i) + j
					Next
					temp(i) = temp(i) + s.didx(i) + 1

					'
					' Copy superdiagonal part of I-th block
					'
					offs0 = tridx(i) + s.didx(i) + 1
					k = s.uidx(i)
					For j = 0 To k - 1
						offs1 = s.ridx(i - k + j) + temp(i - k + j)
						s.vals(offs1) = tvals(offs0 + j)
						s.idx(offs1) = i
						temp(i - k + j) = temp(i - k + j) + 1
					Next
				Next

				'
				' Initialization 'S.UIdx' and 'S.DIdx'
				'
				sparseinitduidx(s)
				Return
			End If
			alglib.ap.assert(False, "SparseConvertToCRS: invalid matrix type")
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
'        copied to S1 and converted on-the-fly.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in CRS format.
'            
'        NOTE: if S0 is stored as CRS, it is just copied without conversion.
'
'        NOTE: this function de-allocates memory occupied by S1 before starting CRS
'              conversion. If you perform a lot of repeated CRS conversions, it may
'              lead to memory fragmentation. In this case we recommend you  to  use
'              SparseCopyToCRSBuf() function which re-uses memory in S1 as much  as
'              possible.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytocrs(s0 As sparsematrix, s1 As sparsematrix)
			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToCRS: invalid matrix type")
			sparsecopytocrsbuf(s0, s1)
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
'        copied to S1 and converted on-the-fly. Memory allocated in S1 is reused to
'        maximum extent possible.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'            S1          -   matrix which may contain some pre-allocated memory, or
'                            can be just uninitialized structure.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in CRS format.
'            
'        NOTE: if S0 is stored as CRS, it is just copied without conversion.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytocrsbuf(s0 As sparsematrix, s1 As sparsematrix)
			Dim temp As Integer() = New Integer(-1) {}
			Dim nonne As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim offs0 As Integer = 0
			Dim offs1 As Integer = 0
			Dim m As Integer = 0

			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToCRSBuf: invalid matrix type")
			m = s0.m
			If s0.matrixtype = 0 Then

				'
				' Convert from hash-table to CRS
				' Done like ConvertToCRS function
				'
				s1.matrixtype = 1
				s1.m = s0.m
				s1.n = s0.n
				s1.nfree = s0.nfree
				nonne = 0
				k = s0.tablesize
				apserv.ivectorsetlengthatleast(s1.ridx, s1.m + 1)
				For i = 0 To s1.m
					s1.ridx(i) = 0
				Next
				temp = New Integer(s1.m - 1) {}
				For i = 0 To s1.m - 1
					temp(i) = 0
				Next

				'
				' Number of elements per row
				'
				For i = 0 To k - 1
					If s0.idx(2 * i) >= 0 Then
						s1.ridx(s0.idx(2 * i) + 1) = s1.ridx(s0.idx(2 * i) + 1) + 1
						nonne = nonne + 1
					End If
				Next

				'
				' Fill RIdx (offsets of rows)
				'
				For i = 0 To s1.m - 1
					s1.ridx(i + 1) = s1.ridx(i + 1) + s1.ridx(i)
				Next

				'
				' Allocate memory
				'
				apserv.rvectorsetlengthatleast(s1.vals, nonne)
				apserv.ivectorsetlengthatleast(s1.idx, nonne)
				For i = 0 To k - 1
					If s0.idx(2 * i) >= 0 Then
						s1.vals(s1.ridx(s0.idx(2 * i)) + temp(s0.idx(2 * i))) = s0.vals(i)
						s1.idx(s1.ridx(s0.idx(2 * i)) + temp(s0.idx(2 * i))) = s0.idx(2 * i + 1)
						temp(s0.idx(2 * i)) = temp(s0.idx(2 * i)) + 1
					End If
				Next

				'
				' Set NInitialized
				'
				s1.ninitialized = s1.ridx(s1.m)

				'
				' Sorting of elements
				'
				For i = 0 To s1.m - 1
					tsort.tagsortmiddleir(s1.idx, s1.vals, s1.ridx(i), s1.ridx(i + 1) - s1.ridx(i))
				Next

				'
				' Initialization 'S.UIdx' and 'S.DIdx'
				'
				sparseinitduidx(s1)
				Return
			End If
			If s0.matrixtype = 1 Then

				'
				' Already CRS, just copy
				'
				sparsecopybuf(s0, s1)
				Return
			End If
			If s0.matrixtype = 2 Then
				alglib.ap.assert(s0.m = s0.n, "SparseCopyToCRS: non-square SKS matrices are not supported")

				'
				' From SKS to CRS.
				'
				s1.m = s0.m
				s1.n = s0.n
				s1.matrixtype = 1

				'
				' Fill RIdx by number of elements per row:
				' RIdx[I+1] stores number of elements in I-th row.
				'
				' Convert RIdx from row sizes to row offsets.
				' Set NInitialized
				'
				apserv.ivectorsetlengthatleast(s1.ridx, m + 1)
				s1.ridx(0) = 0
				For i = 1 To m
					s1.ridx(i) = 1
				Next
				nonne = 0
				For i = 0 To m - 1
					s1.ridx(i + 1) = s0.didx(i) + s1.ridx(i + 1)
					For j = i - s0.uidx(i) To i - 1
						s1.ridx(j + 1) = s1.ridx(j + 1) + 1
					Next
					nonne = nonne + s0.didx(i) + 1 + s0.uidx(i)
				Next
				For i = 0 To m - 1
					s1.ridx(i + 1) = s1.ridx(i + 1) + s1.ridx(i)
				Next
				s1.ninitialized = s1.ridx(m)

				'
				' Allocate memory and move elements to Vals/Idx.
				' Initially, elements are sorted by rows, and are sorted within row too.
				' No additional post-sorting is required.
				'
				temp = New Integer(m - 1) {}
				For i = 0 To m - 1
					temp(i) = 0
				Next
				apserv.rvectorsetlengthatleast(s1.vals, nonne)
				apserv.ivectorsetlengthatleast(s1.idx, nonne)
				For i = 0 To m - 1

					'
					' copy subdiagonal and diagonal parts of I-th block
					'
					offs0 = s0.ridx(i)
					offs1 = s1.ridx(i) + temp(i)
					k = s0.didx(i) + 1
					For j = 0 To k - 1
						s1.vals(offs1 + j) = s0.vals(offs0 + j)
						s1.idx(offs1 + j) = i - s0.didx(i) + j
					Next
					temp(i) = temp(i) + s0.didx(i) + 1

					'
					' Copy superdiagonal part of I-th block
					'
					offs0 = s0.ridx(i) + s0.didx(i) + 1
					k = s0.uidx(i)
					For j = 0 To k - 1
						offs1 = s1.ridx(i - k + j) + temp(i - k + j)
						s1.vals(offs1) = s0.vals(offs0 + j)
						s1.idx(offs1) = i
						temp(i - k + j) = temp(i - k + j) + 1
					Next
				Next

				'
				' Initialization 'S.UIdx' and 'S.DIdx'
				'
				sparseinitduidx(s1)
				Return
			End If
			alglib.ap.assert(False, "SparseCopyToCRSBuf: unexpected matrix type")
		End Sub


		'************************************************************************
'        This function performs in-place conversion to SKS format.
'
'        INPUT PARAMETERS
'            S           -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S           -   sparse matrix in SKS format.
'
'        NOTE: this  function  has   no  effect  when  called with matrix which  is
'              already in SKS mode.
'
'        NOTE: in-place conversion involves allocation of temporary arrays. If  you
'              perform a lot of repeated in- place  conversions,  it  may  lead  to
'              memory fragmentation. Consider using out-of-place SparseCopyToSKSBuf()
'              function in this case.
'            
'          -- ALGLIB PROJECT --
'             Copyright 15.01.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparseconverttosks(s As sparsematrix)
			Dim tridx As Integer() = New Integer(-1) {}
			Dim tdidx As Integer() = New Integer(-1) {}
			Dim tuidx As Integer() = New Integer(-1) {}
			Dim tvals As Double() = New Double(-1) {}
			Dim n As Integer = 0
			Dim t0 As Integer = 0
			Dim t1 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseConvertToSKS: invalid matrix type")
			alglib.ap.assert(s.m = s.n, "SparseConvertToSKS: rectangular matrices are not supported")
			n = s.n
			If s.matrixtype = 2 Then

				'
				' Already in SKS mode
				'
				Return
			End If

			'
			' Generate internal copy of SKS matrix
			'
			apserv.ivectorsetlengthatleast(tdidx, n + 1)
			apserv.ivectorsetlengthatleast(tuidx, n + 1)
			For i = 0 To n
				tdidx(i) = 0
				tuidx(i) = 0
			Next
			t0 = 0
			t1 = 0
			While sparseenumerate(s, t0, t1, i, j, v)
				If j < i Then
					tdidx(i) = System.Math.Max(tdidx(i), i - j)
				Else
					tuidx(j) = System.Math.Max(tuidx(j), j - i)
				End If
			End While
			apserv.ivectorsetlengthatleast(tridx, n + 1)
			tridx(0) = 0
			For i = 1 To n
				tridx(i) = tridx(i - 1) + tdidx(i - 1) + 1 + tuidx(i - 1)
			Next
			apserv.rvectorsetlengthatleast(tvals, tridx(n))
			k = tridx(n)
			For i = 0 To k - 1
				tvals(i) = 0.0
			Next
			t0 = 0
			t1 = 0
			While sparseenumerate(s, t0, t1, i, j, v)
				If j <= i Then
					tvals(tridx(i) + tdidx(i) - (i - j)) = v
				Else
					tvals(tridx(j + 1) - (j - i)) = v
				End If
			End While
			For i = 0 To n - 1
				tdidx(n) = System.Math.Max(tdidx(n), tdidx(i))
				tuidx(n) = System.Math.Max(tuidx(n), tuidx(i))
			Next
			s.matrixtype = 2
			s.ninitialized = 0
			s.nfree = 0
			s.m = n
			s.n = n
			alglib.ap.swap(s.didx, tdidx)
			alglib.ap.swap(s.uidx, tuidx)
			alglib.ap.swap(s.ridx, tridx)
			alglib.ap.swap(s.vals, tvals)
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to SKS storage format.
'        S0 is copied to S1 and converted on-the-fly.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in SKS format.
'
'        NOTE: if S0 is stored as SKS, it is just copied without conversion.
'
'        NOTE: this function de-allocates memory  occupied  by  S1 before  starting
'              conversion. If you perform a  lot  of  repeated  conversions, it may
'              lead to memory fragmentation. In this case we recommend you  to  use
'              SparseCopyToSKSBuf() function which re-uses memory in S1 as much  as
'              possible.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytosks(s0 As sparsematrix, s1 As sparsematrix)
			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToSKS: invalid matrix type")
			sparsecopytosksbuf(s0, s1)
		End Sub


		'************************************************************************
'        This  function  performs  out-of-place  conversion  to SKS format.  S0  is
'        copied to S1 and converted on-the-fly. Memory  allocated  in S1 is  reused
'        to maximum extent possible.
'
'        INPUT PARAMETERS
'            S0          -   sparse matrix in any format.
'
'        OUTPUT PARAMETERS
'            S1          -   sparse matrix in SKS format.
'
'        NOTE: if S0 is stored as SKS, it is just copied without conversion.
'
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsecopytosksbuf(s0 As sparsematrix, s1 As sparsematrix)
			Dim v As Double = 0
			Dim n As Integer = 0
			Dim t0 As Integer = 0
			Dim t1 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert((s0.matrixtype = 0 OrElse s0.matrixtype = 1) OrElse s0.matrixtype = 2, "SparseCopyToSKSBuf: invalid matrix type")
			alglib.ap.assert(s0.m = s0.n, "SparseCopyToSKSBuf: rectangular matrices are not supported")
			n = s0.n
			If s0.matrixtype = 2 Then

				'
				' Already SKS, just copy
				'
				sparsecopybuf(s0, s1)
				Return
			End If

			'
			' Generate copy of matrix in the SKS format
			'
			apserv.ivectorsetlengthatleast(s1.didx, n + 1)
			apserv.ivectorsetlengthatleast(s1.uidx, n + 1)
			For i = 0 To n
				s1.didx(i) = 0
				s1.uidx(i) = 0
			Next
			t0 = 0
			t1 = 0
			While sparseenumerate(s0, t0, t1, i, j, v)
				If j < i Then
					s1.didx(i) = System.Math.Max(s1.didx(i), i - j)
				Else
					s1.uidx(j) = System.Math.Max(s1.uidx(j), j - i)
				End If
			End While
			apserv.ivectorsetlengthatleast(s1.ridx, n + 1)
			s1.ridx(0) = 0
			For i = 1 To n
				s1.ridx(i) = s1.ridx(i - 1) + s1.didx(i - 1) + 1 + s1.uidx(i - 1)
			Next
			apserv.rvectorsetlengthatleast(s1.vals, s1.ridx(n))
			k = s1.ridx(n)
			For i = 0 To k - 1
				s1.vals(i) = 0.0
			Next
			t0 = 0
			t1 = 0
			While sparseenumerate(s0, t0, t1, i, j, v)
				If j <= i Then
					s1.vals(s1.ridx(i) + s1.didx(i) - (i - j)) = v
				Else
					s1.vals(s1.ridx(j + 1) - (j - i)) = v
				End If
			End While
			For i = 0 To n - 1
				s1.didx(n) = System.Math.Max(s1.didx(n), s1.didx(i))
				s1.uidx(n) = System.Math.Max(s1.uidx(n), s1.uidx(i))
			Next
			s1.matrixtype = 2
			s1.ninitialized = 0
			s1.nfree = 0
			s1.m = n
			s1.n = n
		End Sub


		'************************************************************************
'        This function returns type of the matrix storage format.
'
'        INPUT PARAMETERS:
'            S           -   sparse matrix.
'
'        RESULT:
'            sparse storage format used by matrix:
'                0   -   Hash-table
'                1   -   CRS (compressed row storage)
'                2   -   SKS (skyline)
'
'        NOTE: future  versions  of  ALGLIB  may  include additional sparse storage
'              formats.
'
'            
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetmatrixtype(s As sparsematrix) As Integer
			Dim result As Integer = 0

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseGetMatrixType: invalid matrix type")
			result = s.matrixtype
			Return result
		End Function


		'************************************************************************
'        This function checks matrix storage format and returns True when matrix is
'        stored using Hash table representation.
'
'        INPUT PARAMETERS:
'            S   -   sparse matrix.
'
'        RESULT:
'            True if matrix type is Hash table
'            False if matrix type is not Hash table 
'            
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparseishash(s As sparsematrix) As Boolean
			Dim result As New Boolean()

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseIsHash: invalid matrix type")
			result = s.matrixtype = 0
			Return result
		End Function


		'************************************************************************
'        This function checks matrix storage format and returns True when matrix is
'        stored using CRS representation.
'
'        INPUT PARAMETERS:
'            S   -   sparse matrix.
'
'        RESULT:
'            True if matrix type is CRS
'            False if matrix type is not CRS
'            
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparseiscrs(s As sparsematrix) As Boolean
			Dim result As New Boolean()

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseIsCRS: invalid matrix type")
			result = s.matrixtype = 1
			Return result
		End Function


		'************************************************************************
'        This function checks matrix storage format and returns True when matrix is
'        stored using SKS representation.
'
'        INPUT PARAMETERS:
'            S   -   sparse matrix.
'
'        RESULT:
'            True if matrix type is SKS
'            False if matrix type is not SKS
'            
'          -- ALGLIB PROJECT --
'             Copyright 20.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparseissks(s As sparsematrix) As Boolean
			Dim result As New Boolean()

			alglib.ap.assert((s.matrixtype = 0 OrElse s.matrixtype = 1) OrElse s.matrixtype = 2, "SparseIsSKS: invalid matrix type")
			result = s.matrixtype = 2
			Return result
		End Function


		'************************************************************************
'        The function frees all memory occupied by  sparse  matrix.  Sparse  matrix
'        structure becomes unusable after this call.
'
'        OUTPUT PARAMETERS
'            S   -   sparse matrix to delete
'            
'          -- ALGLIB PROJECT --
'             Copyright 24.07.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub sparsefree(s As sparsematrix)
			s.matrixtype = -1
			s.m = 0
			s.n = 0
			s.nfree = 0
			s.ninitialized = 0
			s.tablesize = 0
		End Sub


		'************************************************************************
'        The function returns number of rows of a sparse matrix.
'
'        RESULT: number of rows of a sparse matrix.
'            
'          -- ALGLIB PROJECT --
'             Copyright 23.08.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetnrows(s As sparsematrix) As Integer
			Dim result As Integer = 0

			result = s.m
			Return result
		End Function


		'************************************************************************
'        The function returns number of columns of a sparse matrix.
'
'        RESULT: number of columns of a sparse matrix.
'            
'          -- ALGLIB PROJECT --
'             Copyright 23.08.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetncols(s As sparsematrix) As Integer
			Dim result As Integer = 0

			result = s.n
			Return result
		End Function


		'************************************************************************
'        The function returns number of strictly upper triangular non-zero elements
'        in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
'        in the sparse matrix data structure. If some element  has  zero  numerical
'        value, it is still counted.
'
'        This function has different cost for different types of matrices:
'        * for hash-based matrices it involves complete pass over entire hash-table
'          with O(NNZ) cost, where NNZ is number of non-zero elements
'        * for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).
'
'        RESULT: number of non-zero elements strictly above main diagonal
'            
'          -- ALGLIB PROJECT --
'             Copyright 12.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetuppercount(s As sparsematrix) As Integer
			Dim result As Integer = 0
			Dim sz As Integer = 0
			Dim i0 As Integer = 0
			Dim i As Integer = 0

			result = -1
			If s.matrixtype = 0 Then

				'
				' Hash-table matrix
				'
				result = 0
				sz = s.tablesize
				For i0 = 0 To sz - 1
					i = s.idx(2 * i0)
					If i >= 0 AndAlso s.idx(2 * i0 + 1) > i Then
						result = result + 1
					End If
				Next
				Return result
			End If
			If s.matrixtype = 1 Then

				'
				' CRS matrix
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseGetUpperCount: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				result = 0
				sz = s.m
				For i = 0 To sz - 1
					result = result + (s.ridx(i + 1) - s.uidx(i))
				Next
				Return result
			End If
			If s.matrixtype = 2 Then

				'
				' SKS matrix
				'
				alglib.ap.assert(s.m = s.n, "SparseGetUpperCount: non-square SKS matrices are not supported")
				result = 0
				sz = s.m
				For i = 0 To sz - 1
					result = result + s.uidx(i)
				Next
				Return result
			End If
			alglib.ap.assert(False, "SparseGetUpperCount: internal error")
			Return result
		End Function


		'************************************************************************
'        The function returns number of strictly lower triangular non-zero elements
'        in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
'        in the sparse matrix data structure. If some element  has  zero  numerical
'        value, it is still counted.
'
'        This function has different cost for different types of matrices:
'        * for hash-based matrices it involves complete pass over entire hash-table
'          with O(NNZ) cost, where NNZ is number of non-zero elements
'        * for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).
'
'        RESULT: number of non-zero elements strictly below main diagonal
'            
'          -- ALGLIB PROJECT --
'             Copyright 12.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsegetlowercount(s As sparsematrix) As Integer
			Dim result As Integer = 0
			Dim sz As Integer = 0
			Dim i0 As Integer = 0
			Dim i As Integer = 0

			result = -1
			If s.matrixtype = 0 Then

				'
				' Hash-table matrix
				'
				result = 0
				sz = s.tablesize
				For i0 = 0 To sz - 1
					i = s.idx(2 * i0)
					If i >= 0 AndAlso s.idx(2 * i0 + 1) < i Then
						result = result + 1
					End If
				Next
				Return result
			End If
			If s.matrixtype = 1 Then

				'
				' CRS matrix
				'
				alglib.ap.assert(s.ninitialized = s.ridx(s.m), "SparseGetUpperCount: some rows/elements of the CRS matrix were not initialized (you must initialize everything you promised to SparseCreateCRS)")
				result = 0
				sz = s.m
				For i = 0 To sz - 1
					result = result + (s.didx(i) - s.ridx(i))
				Next
				Return result
			End If
			If s.matrixtype = 2 Then

				'
				' SKS matrix
				'
				alglib.ap.assert(s.m = s.n, "SparseGetUpperCount: non-square SKS matrices are not supported")
				result = 0
				sz = s.m
				For i = 0 To sz - 1
					result = result + s.didx(i)
				Next
				Return result
			End If
			alglib.ap.assert(False, "SparseGetUpperCount: internal error")
			Return result
		End Function


		'************************************************************************
'        Procedure for initialization 'S.DIdx' and 'S.UIdx'
'
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub sparseinitduidx(s As sparsematrix)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lt As Integer = 0
			Dim rt As Integer = 0

			alglib.ap.assert(s.matrixtype = 1, "SparseInitDUIdx: internal error, incorrect matrix type")
			apserv.ivectorsetlengthatleast(s.didx, s.m)
			apserv.ivectorsetlengthatleast(s.uidx, s.m)
			For i = 0 To s.m - 1
				s.uidx(i) = -1
				s.didx(i) = -1
				lt = s.ridx(i)
				rt = s.ridx(i + 1)
				For j = lt To rt - 1
					If i < s.idx(j) AndAlso s.uidx(i) = -1 Then
						s.uidx(i) = j
						Exit For
					Else
						If i = s.idx(j) Then
							s.didx(i) = j
						End If
					End If
				Next
				If s.uidx(i) = -1 Then
					s.uidx(i) = s.ridx(i + 1)
				End If
				If s.didx(i) = -1 Then
					s.didx(i) = s.uidx(i)
				End If
			Next
		End Sub


		'************************************************************************
'        This is hash function.
'
'          -- ALGLIB PROJECT --
'             Copyright 14.10.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Function hash(i As Integer, j As Integer, tabsize As Integer) As Integer
			Dim result As Integer = 0
			Dim r As New hqrnd.hqrndstate()

			hqrnd.hqrndseed(i, j, r)
			result = hqrnd.hqrnduniformi(r, tabsize)
			Return result
		End Function


	End Class
	Public Class trfac
		'************************************************************************
'        LU decomposition of a general real matrix with row pivoting
'
'        A is represented as A = P*L*U, where:
'        * L is lower unitriangular matrix
'        * U is upper triangular matrix
'        * P = P0*P1*...*PK, K=min(M,N)-1,
'          Pi - permutation matrix for I and Pivots[I]
'
'        This is cache-oblivous implementation of LU decomposition.
'        It is optimized for square matrices. As for rectangular matrices:
'        * best case - M>>N
'        * worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that LU decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'          
'        INPUT PARAMETERS:
'            A       -   array[0..M-1, 0..N-1].
'            M       -   number of rows in matrix A.
'            N       -   number of columns in matrix A.
'
'
'        OUTPUT PARAMETERS:
'            A       -   matrices L and U in compact form:
'                        * L is stored under main diagonal
'                        * U is stored on and above main diagonal
'            Pivots  -   permutation matrix in compact form.
'                        array[0..Min(M-1,N-1)].
'
'          -- ALGLIB routine --
'             10.01.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixlu(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
			pivots = New Integer(-1) {}

			alglib.ap.assert(m > 0, "RMatrixLU: incorrect M!")
			alglib.ap.assert(n > 0, "RMatrixLU: incorrect N!")
			rmatrixplu(a, m, n, pivots)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixlu(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
			rmatrixlu(a, m, n, pivots)
		End Sub


		'************************************************************************
'        LU decomposition of a general complex matrix with row pivoting
'
'        A is represented as A = P*L*U, where:
'        * L is lower unitriangular matrix
'        * U is upper triangular matrix
'        * P = P0*P1*...*PK, K=min(M,N)-1,
'          Pi - permutation matrix for I and Pivots[I]
'
'        This is cache-oblivous implementation of LU decomposition. It is optimized
'        for square matrices. As for rectangular matrices:
'        * best case - M>>N
'        * worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that LU decomposition  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            A       -   array[0..M-1, 0..N-1].
'            M       -   number of rows in matrix A.
'            N       -   number of columns in matrix A.
'
'
'        OUTPUT PARAMETERS:
'            A       -   matrices L and U in compact form:
'                        * L is stored under main diagonal
'                        * U is stored on and above main diagonal
'            Pivots  -   permutation matrix in compact form.
'                        array[0..Min(M-1,N-1)].
'
'          -- ALGLIB routine --
'             10.01.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixlu(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
			pivots = New Integer(-1) {}

			alglib.ap.assert(m > 0, "CMatrixLU: incorrect M!")
			alglib.ap.assert(n > 0, "CMatrixLU: incorrect N!")
			cmatrixplu(a, m, n, pivots)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixlu(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
			cmatrixlu(a, m, n, pivots)
		End Sub


		'************************************************************************
'        Cache-oblivious Cholesky decomposition
'
'        The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
'        definite matrix. The result of an algorithm is a representation  of  A  as
'        A=U'*U  or A=L*L' (here X' detones conj(X^T)).
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that Cholesky decomposition is harder
'          ! to parallelize than, say, matrix-matrix product - this  algorithm  has
'          ! several synchronization points which  can  not  be  avoided.  However,
'          ! parallelism starts to be profitable starting from N=500.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower triangle of a factorized matrix.
'                        array with elements [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                        a symmetric matrix, otherwise A contains a lower one.
'
'        OUTPUT PARAMETERS:
'            A       -   the result of factorization. If IsUpper=True, then
'                        the upper triangle contains matrix U, so that A = U'*U,
'                        and the elements below the main diagonal are not modified.
'                        Similarly, if IsUpper = False.
'
'        RESULT:
'            If  the  matrix  is  positive-definite,  the  function  returns  True.
'            Otherwise, the function returns False. Contents of A is not determined
'            in such case.
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function hpdmatrixcholesky(ByRef a As complex(,), n As Integer, isupper As Boolean) As Boolean
			Dim result As New Boolean()
			Dim tmp As complex() = New complex(-1) {}

			If n < 1 Then
				result = False
				Return result
			End If
			result = hpdmatrixcholeskyrec(a, 0, n, isupper, tmp)
			Return result
		End Function


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Function _pexec_hpdmatrixcholesky(ByRef a As complex(,), n As Integer, isupper As Boolean) As Boolean
			Return hpdmatrixcholesky(a, n, isupper)
		End Function


		'************************************************************************
'        Cache-oblivious Cholesky decomposition
'
'        The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'        definite matrix. The result of an algorithm is a representation  of  A  as
'        A=U^T*U  or A=L*L^T
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that Cholesky decomposition is harder
'          ! to parallelize than, say, matrix-matrix product - this  algorithm  has
'          ! several synchronization points which  can  not  be  avoided.  However,
'          ! parallelism starts to be profitable starting from N=500.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower triangle of a factorized matrix.
'                        array with elements [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                        a symmetric matrix, otherwise A contains a lower one.
'
'        OUTPUT PARAMETERS:
'            A       -   the result of factorization. If IsUpper=True, then
'                        the upper triangle contains matrix U, so that A = U^T*U,
'                        and the elements below the main diagonal are not modified.
'                        Similarly, if IsUpper = False.
'
'        RESULT:
'            If  the  matrix  is  positive-definite,  the  function  returns  True.
'            Otherwise, the function returns False. Contents of A is not determined
'            in such case.
'
'          -- ALGLIB routine --
'             15.12.2009
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spdmatrixcholesky(ByRef a As Double(,), n As Integer, isupper As Boolean) As Boolean
			Dim result As New Boolean()
			Dim tmp As Double() = New Double(-1) {}

			If n < 1 Then
				result = False
				Return result
			End If
			result = spdmatrixcholeskyrec(a, 0, n, isupper, tmp)
			Return result
		End Function


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Function _pexec_spdmatrixcholesky(ByRef a As Double(,), n As Integer, isupper As Boolean) As Boolean
			Return spdmatrixcholesky(a, n, isupper)
		End Function


		'************************************************************************
'        Update of Cholesky decomposition: rank-1 update to original A.  "Buffered"
'        version which uses preallocated buffer which is saved  between  subsequent
'        function calls.
'
'        This function uses internally allocated buffer which is not saved  between
'        subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
'        we  recommend   you   to   use   "buffered"   version   of  this function:
'        SPDMatrixCholeskyUpdateAdd1Buf().
'
'        INPUT PARAMETERS:
'            A       -   upper or lower Cholesky factor.
'                        array with elements [0..N-1, 0..N-1].
'                        Exception is thrown if array size is too small.
'            N       -   size of matrix A, N>0
'            IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                        otherwise A contains a lower one.
'            U       -   array[N], rank-1 update to A: A_mod = A + u*u'
'                        Exception is thrown if array size is too small.
'            BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                        needed. It is recommended to  reuse  this  buffer  if  you
'                        perform a lot of subsequent decompositions.
'
'        OUTPUT PARAMETERS:
'            A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                        triangle contains matrix U, and the elements below the main
'                        diagonal are not modified. Similarly, if IsUpper = False.
'                        
'        NOTE: this function always succeeds, so it does not return completion code
'
'        NOTE: this function checks sizes of input arrays, but it does  NOT  checks
'              for presence of infinities or NAN's.
'
'          -- ALGLIB --
'             03.02.2014
'             Sergey Bochkanov
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyupdateadd1(a As Double(,), n As Integer, isupper As Boolean, u As Double())
			Dim bufr As Double() = New Double(-1) {}

			alglib.ap.assert(n > 0, "SPDMatrixCholeskyUpdateAdd1: N<=0")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyUpdateAdd1: Rows(A)<N")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyUpdateAdd1: Cols(A)<N")
			alglib.ap.assert(alglib.ap.len(u) >= n, "SPDMatrixCholeskyUpdateAdd1: Length(U)<N")
			spdmatrixcholeskyupdateadd1buf(a, n, isupper, u, bufr)
		End Sub


		'************************************************************************
'        Update of Cholesky decomposition: "fixing" some variables.
'
'        This function uses internally allocated buffer which is not saved  between
'        subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
'        we  recommend   you   to   use   "buffered"   version   of  this function:
'        SPDMatrixCholeskyUpdateFixBuf().
'
'        "FIXING" EXPLAINED:
'
'            Suppose we have N*N positive definite matrix A. "Fixing" some variable
'            means filling corresponding row/column of  A  by  zeros,  and  setting
'            diagonal element to 1.
'            
'            For example, if we fix 2nd variable in 4*4 matrix A, it becomes Af:
'            
'                ( A00  A01  A02  A03 )      ( Af00  0   Af02 Af03 )
'                ( A10  A11  A12  A13 )      (  0    1    0    0   )
'                ( A20  A21  A22  A23 )  =>  ( Af20  0   Af22 Af23 )
'                ( A30  A31  A32  A33 )      ( Af30  0   Af32 Af33 )
'            
'            If we have Cholesky decomposition of A, it must be recalculated  after
'            variables were  fixed.  However,  it  is  possible  to  use  efficient
'            algorithm, which needs O(K*N^2)  time  to  "fix"  K  variables,  given
'            Cholesky decomposition of original, "unfixed" A.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower Cholesky factor.
'                        array with elements [0..N-1, 0..N-1].
'                        Exception is thrown if array size is too small.
'            N       -   size of matrix A, N>0
'            IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                        otherwise A contains a lower one.
'            Fix     -   array[N], I-th element is True if I-th  variable  must  be
'                        fixed. Exception is thrown if array size is too small.
'            BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                        needed. It is recommended to  reuse  this  buffer  if  you
'                        perform a lot of subsequent decompositions.
'
'        OUTPUT PARAMETERS:
'            A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                        triangle contains matrix U, and the elements below the main
'                        diagonal are not modified. Similarly, if IsUpper = False.
'                        
'        NOTE: this function always succeeds, so it does not return completion code
'
'        NOTE: this function checks sizes of input arrays, but it does  NOT  checks
'              for presence of infinities or NAN's.
'              
'        NOTE: this  function  is  efficient  only  for  moderate amount of updated
'              variables - say, 0.1*N or 0.3*N. For larger amount of  variables  it
'              will  still  work,  but  you  may  get   better   performance   with
'              straightforward Cholesky.
'
'          -- ALGLIB --
'             03.02.2014
'             Sergey Bochkanov
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyupdatefix(a As Double(,), n As Integer, isupper As Boolean, fix As Boolean())
			Dim bufr As Double() = New Double(-1) {}

			alglib.ap.assert(n > 0, "SPDMatrixCholeskyUpdateFix: N<=0")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyUpdateFix: Rows(A)<N")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyUpdateFix: Cols(A)<N")
			alglib.ap.assert(alglib.ap.len(fix) >= n, "SPDMatrixCholeskyUpdateFix: Length(Fix)<N")
			spdmatrixcholeskyupdatefixbuf(a, n, isupper, fix, bufr)
		End Sub


		'************************************************************************
'        Update of Cholesky decomposition: rank-1 update to original A.  "Buffered"
'        version which uses preallocated buffer which is saved  between  subsequent
'        function calls.
'
'        See comments for SPDMatrixCholeskyUpdateAdd1() for more information.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower Cholesky factor.
'                        array with elements [0..N-1, 0..N-1].
'                        Exception is thrown if array size is too small.
'            N       -   size of matrix A, N>0
'            IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                        otherwise A contains a lower one.
'            U       -   array[N], rank-1 update to A: A_mod = A + u*u'
'                        Exception is thrown if array size is too small.
'            BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                        needed. It is recommended to  reuse  this  buffer  if  you
'                        perform a lot of subsequent decompositions.
'
'        OUTPUT PARAMETERS:
'            A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                        triangle contains matrix U, and the elements below the main
'                        diagonal are not modified. Similarly, if IsUpper = False.
'
'          -- ALGLIB --
'             03.02.2014
'             Sergey Bochkanov
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyupdateadd1buf(a As Double(,), n As Integer, isupper As Boolean, u As Double(), ByRef bufr As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim nz As Integer = 0
			Dim cs As Double = 0
			Dim sn As Double = 0
			Dim v As Double = 0
			Dim vv As Double = 0

			alglib.ap.assert(n > 0, "SPDMatrixCholeskyUpdateAdd1Buf: N<=0")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyUpdateAdd1Buf: Rows(A)<N")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyUpdateAdd1Buf: Cols(A)<N")
			alglib.ap.assert(alglib.ap.len(u) >= n, "SPDMatrixCholeskyUpdateAdd1Buf: Length(U)<N")

			'
			' Find index of first non-zero entry in U
			'
			nz = n
			For i = 0 To n - 1
				If CDbl(u(i)) <> CDbl(0) Then
					nz = i
					Exit For
				End If
			Next
			If nz = n Then

				'
				' Nothing to update
				'
				Return
			End If

			'
			' If working with upper triangular matrix
			'
			If isupper Then

				'
				' Perform a sequence of updates which fix variables one by one.
				' This approach is different from one which is used when we work
				' with lower triangular matrix.
				'
				apserv.rvectorsetlengthatleast(bufr, n)
				For j = nz To n - 1
					bufr(j) = u(j)
				Next
				For i = nz To n - 1
					If CDbl(bufr(i)) <> CDbl(0) Then
						rotations.generaterotation(a(i, i), bufr(i), cs, sn, v)
						a(i, i) = v
						bufr(i) = 0.0
						For j = i + 1 To n - 1
							v = a(i, j)
							vv = bufr(j)
							a(i, j) = cs * v + sn * vv
							bufr(j) = -(sn * v) + cs * vv
						Next
					End If
				Next
			Else

				'
				' Calculate rows of modified Cholesky factor, row-by-row
				' (updates performed during variable fixing are applied
				' simultaneously to each row)
				'
				apserv.rvectorsetlengthatleast(bufr, 3 * n)
				For j = nz To n - 1
					bufr(j) = u(j)
				Next
				For i = nz To n - 1

					'
					' Update all previous updates [Idx+1...I-1] to I-th row
					'
					vv = bufr(i)
					For j = nz To i - 1
						cs = bufr(n + 2 * j + 0)
						sn = bufr(n + 2 * j + 1)
						v = a(i, j)
						a(i, j) = cs * v + sn * vv
						vv = -(sn * v) + cs * vv
					Next

					'
					' generate rotation applied to I-th element of update vector
					'
					rotations.generaterotation(a(i, i), vv, cs, sn, v)
					a(i, i) = v
					bufr(n + 2 * i + 0) = cs
					bufr(n + 2 * i + 1) = sn
				Next
			End If
		End Sub


		'************************************************************************
'        Update of Cholesky  decomposition:  "fixing"  some  variables.  "Buffered"
'        version which uses preallocated buffer which is saved  between  subsequent
'        function calls.
'
'        See comments for SPDMatrixCholeskyUpdateFix() for more information.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower Cholesky factor.
'                        array with elements [0..N-1, 0..N-1].
'                        Exception is thrown if array size is too small.
'            N       -   size of matrix A, N>0
'            IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
'                        otherwise A contains a lower one.
'            Fix     -   array[N], I-th element is True if I-th  variable  must  be
'                        fixed. Exception is thrown if array size is too small.
'            BufR    -   possibly preallocated  buffer;  automatically  resized  if
'                        needed. It is recommended to  reuse  this  buffer  if  you
'                        perform a lot of subsequent decompositions.
'
'        OUTPUT PARAMETERS:
'            A       -   updated factorization.  If  IsUpper=True,  then  the  upper
'                        triangle contains matrix U, and the elements below the main
'                        diagonal are not modified. Similarly, if IsUpper = False.
'
'          -- ALGLIB --
'             03.02.2014
'             Sergey Bochkanov
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyupdatefixbuf(a As Double(,), n As Integer, isupper As Boolean, fix As Boolean(), ByRef bufr As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim nfix As Integer = 0
			Dim idx As Integer = 0
			Dim cs As Double = 0
			Dim sn As Double = 0
			Dim v As Double = 0
			Dim vv As Double = 0

			alglib.ap.assert(n > 0, "SPDMatrixCholeskyUpdateFixBuf: N<=0")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyUpdateFixBuf: Rows(A)<N")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyUpdateFixBuf: Cols(A)<N")
			alglib.ap.assert(alglib.ap.len(fix) >= n, "SPDMatrixCholeskyUpdateFixBuf: Length(Fix)<N")

			'
			' Count number of variables to fix.
			' Quick exit if NFix=0 or NFix=N
			'
			nfix = 0
			For i = 0 To n - 1
				If fix(i) Then
					apserv.inc(nfix)
				End If
			Next
			If nfix = 0 Then

				'
				' Nothing to fix
				'
				Return
			End If
			If nfix = n Then

				'
				' All variables are fixed.
				' Set A to identity and exit.
				'
				If isupper Then
					For i = 0 To n - 1
						a(i, i) = 1
						For j = i + 1 To n - 1
							a(i, j) = 0
						Next
					Next
				Else
					For i = 0 To n - 1
						For j = 0 To i - 1
							a(i, j) = 0
						Next
						a(i, i) = 1
					Next
				End If
				Return
			End If

			'
			' If working with upper triangular matrix
			'
			If isupper Then

				'
				' Perform a sequence of updates which fix variables one by one.
				' This approach is different from one which is used when we work
				' with lower triangular matrix.
				'
				apserv.rvectorsetlengthatleast(bufr, n)
				For k = 0 To n - 1
					If fix(k) Then
						idx = k

						'
						' Quick exit if it is last variable
						'
						If idx = n - 1 Then
							For i = 0 To idx - 1
								a(i, idx) = 0.0
							Next
							a(idx, idx) = 1.0
							Continue For
						End If

						'
						' We have Cholesky decomposition of quadratic term in A,
						' with upper triangle being stored as given below:
						'
						'         ( U00 u01 U02 )
						'     U = (     u11 u12 )
						'         (         U22 )
						'
						' Here u11 is diagonal element corresponding to variable K. We
						' want to fix this variable, and we do so by modifying U as follows:
						'
						'             ( U00  0  U02 )
						'     U_mod = (      1   0  )
						'             (         U_m )
						'
						' with U_m = CHOLESKY [ (U22^T)*U22 + (u12^T)*u12 ]
						'
						' Of course, we can calculate U_m by calculating (U22^T)*U22 explicitly,
						' modifying it and performing Cholesky decomposition of modified matrix.
						' However, we can treat it as follows:
						' * we already have CHOLESKY[(U22^T)*U22], which is equal to U22
						' * we have rank-1 update (u12^T)*u12 applied to (U22^T)*U22
						' * thus, we can calculate updated Cholesky with O(N^2) algorithm
						'   instead of O(N^3) one
						'
						For j = idx + 1 To n - 1
							bufr(j) = a(idx, j)
						Next
						For i = 0 To idx - 1
							a(i, idx) = 0.0
						Next
						a(idx, idx) = 1.0
						For i = idx + 1 To n - 1
							a(idx, i) = 0.0
						Next
						For i = idx + 1 To n - 1
							If CDbl(bufr(i)) <> CDbl(0) Then
								rotations.generaterotation(a(i, i), bufr(i), cs, sn, v)
								a(i, i) = v
								bufr(i) = 0.0
								For j = i + 1 To n - 1
									v = a(i, j)
									vv = bufr(j)
									a(i, j) = cs * v + sn * vv
									bufr(j) = -(sn * v) + cs * vv
								Next
							End If
						Next
					End If
				Next
			Else

				'
				' Calculate rows of modified Cholesky factor, row-by-row
				' (updates performed during variable fixing are applied
				' simultaneously to each row)
				'
				apserv.rvectorsetlengthatleast(bufr, 3 * n)
				For k = 0 To n - 1
					If fix(k) Then
						idx = k

						'
						' Quick exit if it is last variable
						'
						If idx = n - 1 Then
							For i = 0 To idx - 1
								a(idx, i) = 0.0
							Next
							a(idx, idx) = 1.0
							Continue For
						End If

						'
						' store column to buffer and clear row/column of A
						'
						For j = idx + 1 To n - 1
							bufr(j) = a(j, idx)
						Next
						For i = 0 To idx - 1
							a(idx, i) = 0.0
						Next
						a(idx, idx) = 1.0
						For i = idx + 1 To n - 1
							a(i, idx) = 0.0
						Next

						'
						' Apply update to rows of A
						'
						For i = idx + 1 To n - 1

							'
							' Update all previous updates [Idx+1...I-1] to I-th row
							'
							vv = bufr(i)
							For j = idx + 1 To i - 1
								cs = bufr(n + 2 * j + 0)
								sn = bufr(n + 2 * j + 1)
								v = a(i, j)
								a(i, j) = cs * v + sn * vv
								vv = -(sn * v) + cs * vv
							Next

							'
							' generate rotation applied to I-th element of update vector
							'
							rotations.generaterotation(a(i, i), vv, cs, sn, v)
							a(i, i) = v
							bufr(n + 2 * i + 0) = cs
							bufr(n + 2 * i + 1) = sn
						Next
					End If
				Next
			End If
		End Sub


		'************************************************************************
'        Sparse Cholesky decomposition for skyline matrixm using in-place algorithm
'        without allocating additional storage.
'
'        The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'        definite sparse matrix. The result of an algorithm is a representation  of
'        A as A=U^T*U or A=L*L^T
'
'        This  function  is  a  more  efficient alternative to general, but  slower
'        SparseCholeskyX(), because it does not  create  temporary  copies  of  the
'        target. It performs factorization in-place, which gives  best  performance
'        on low-profile matrices. Its drawback, however, is that it can not perform
'        profile-reducing permutation of input matrix.
'
'        INPUT PARAMETERS:
'            A       -   sparse matrix in skyline storage (SKS) format.
'            N       -   size of matrix A (can be smaller than actual size of A)
'            IsUpper -   if IsUpper=True, then factorization is performed on  upper
'                        triangle. Another triangle is ignored (it may contant some
'                        data, but it is not changed).
'            
'
'        OUTPUT PARAMETERS:
'            A       -   the result of factorization, stored in SKS. If IsUpper=True,
'                        then the upper  triangle  contains  matrix  U,  such  that
'                        A = U^T*U. Lower triangle is not changed.
'                        Similarly, if IsUpper = False. In this case L is returned,
'                        and we have A = L*(L^T).
'                        Note that THIS function does not  perform  permutation  of
'                        rows to reduce bandwidth.
'
'        RESULT:
'            If  the  matrix  is  positive-definite,  the  function  returns  True.
'            Otherwise, the function returns False. Contents of A is not determined
'            in such case.
'
'        NOTE: for  performance  reasons  this  function  does NOT check that input
'              matrix  includes  only  finite  values. It is your responsibility to
'              make sure that there are no infinite or NAN values in the matrix.
'
'          -- ALGLIB routine --
'             16.01.2014
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsecholeskyskyline(a As sparse.sparsematrix, n As Integer, isupper As Boolean) As Boolean
			Dim result As New Boolean()
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim jnz As Integer = 0
			Dim jnza As Integer = 0
			Dim jnzl As Integer = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim a12 As Double = 0
			Dim nready As Integer = 0
			Dim nadd As Integer = 0
			Dim banda As Integer = 0
			Dim offsa As Integer = 0
			Dim offsl As Integer = 0

			alglib.ap.assert(n >= 0, "SparseCholeskySkyline: N<0")
			alglib.ap.assert(sparse.sparsegetnrows(a) >= n, "SparseCholeskySkyline: rows(A)<N")
			alglib.ap.assert(sparse.sparsegetncols(a) >= n, "SparseCholeskySkyline: cols(A)<N")
			alglib.ap.assert(sparse.sparseissks(a), "SparseCholeskySkyline: A is not stored in SKS format")
			result = False

			'
			' transpose if needed
			'
			If isupper Then
				sparse.sparsetransposesks(a)
			End If

			'
			' Perform Cholesky decomposition:
			' * we assume than leading NReady*NReady submatrix is done
			' * having Cholesky decomposition of NReady*NReady submatrix we
			'   obtain decomposition of larger (NReady+NAdd)*(NReady+NAdd) one.
			'
			' Here is algorithm. At the start we have
			'
			'     (      |   )
			'     (  L   |   )
			' S = (      |   )
			'     (----------)
			'     (  A   | B )
			'
			' with L being already computed Cholesky factor, A and B being
			' unprocessed parts of the matrix. Of course, L/A/B are stored
			' in SKS format.
			'
			' Then, we calculate A1:=(inv(L)*A')' and replace A with A1.
			' Then, we calculate B1:=B-A1*A1'     and replace B with B1
			'
			' Finally, we calculate small NAdd*NAdd Cholesky of B1 with
			' dense solver. Now, L/A1/B1 are Cholesky decomposition of the
			' larger (NReady+NAdd)*(NReady+NAdd) matrix.
			'
			nready = 0
			nadd = 1
			While nready < n
				alglib.ap.assert(nadd = 1, "SkylineCholesky: internal error")

				'
				' Calculate A1:=(inv(L)*A')'
				'
				' Elements are calculated row by row (example below is given
				' for NAdd=1):
				' * first, we solve L[0,0]*A1[0]=A[0]
				' * then, we solve  L[1,0]*A1[0]+L[1,1]*A1[1]=A[1]
				' * then, we move to next row and so on
				' * during calculation of A1 we update A12 - squared norm of A1
				'
				' We extensively use sparsity of both A/A1 and L:
				' * first, equations from 0 to BANDWIDTH(A1)-1 are completely zero
				' * second, for I>=BANDWIDTH(A1), I-th equation is reduced from
				'     L[I,0]*A1[0] + L[I,1]*A1[1] + ... + L[I,I]*A1[I] = A[I]
				'   to
				'     L[I,JNZ]*A1[JNZ] + ... + L[I,I]*A1[I] = A[I]
				'   where JNZ = max(NReady-BANDWIDTH(A1),I-BANDWIDTH(L[i]))
				'   (JNZ is an index of the firts column where both A and L become
				'   nonzero).
				'
				' NOTE: we rely on details of SparseMatrix internal storage format.
				'       This is allowed by SparseMatrix specification.
				'
				a12 = 0.0
				If a.didx(nready) > 0 Then
					banda = a.didx(nready)
					For i = nready - banda To nready - 1

						'
						' Elements of A1[0:I-1] were computed:
						' * A1[0:NReady-BandA-1] are zero (sparse)
						' * A1[NReady-BandA:I-1] replaced corresponding elements of A
						'
						' Now it is time to get I-th one.
						'
						' First, we calculate:
						' * JNZA  - index of the first column where A become nonzero
						' * JNZL  - index of the first column where L become nonzero
						' * JNZ   - index of the first column where both A and L become nonzero
						' * OffsA - offset of A[JNZ] in A.Vals
						' * OffsL - offset of L[I,JNZ] in A.Vals
						'
						' Then, we solve SUM(A1[j]*L[I,j],j=JNZ..I-1) + A1[I]*L[I,I] = A[I],
						' with A1[JNZ..I-1] already known, and A1[I] unknown.
						'
						jnza = nready - banda
						jnzl = i - a.didx(i)
						jnz = System.Math.Max(jnza, jnzl)
						offsa = a.ridx(nready) + (jnz - jnza)
						offsl = a.ridx(i) + (jnz - jnzl)
						v = 0.0
						k = i - 1 - jnz
						For j = 0 To k
							v = v + a.vals(offsa + j) * a.vals(offsl + j)
						Next
						vv = (a.vals(offsa + k + 1) - v) / a.vals(offsl + k + 1)
						a.vals(offsa + k + 1) = vv
						a12 = a12 + vv * vv
					Next
				End If

				'
				' Calculate CHOLESKY(B-A1*A1')
				'
				offsa = a.ridx(nready) + a.didx(nready)
				v = a.vals(offsa)
				If CDbl(v) <= CDbl(a12) Then
					result = False
					Return result
				End If
				a.vals(offsa) = System.Math.sqrt(v - a12)

				'
				' Increase size of the updated matrix
				'
				apserv.inc(nready)
			End While

			'
			' transpose if needed
			'
			If isupper Then
				sparse.sparsetransposesks(a)
			End If
			result = True
			Return result
		End Function


		'************************************************************************
'        Sparse Cholesky decomposition: "expert" function.
'
'        The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'        definite sparse matrix. The result is representation of A  as  A=U^T*U  or
'        A=L*L^T
'
'        Triangular factor L or U is written to separate SparseMatrix structure. If
'        output buffer already contrains enough memory to store L/U, this memory is
'        reused.
'
'        INPUT PARAMETERS:
'            A       -   upper or lower triangle of sparse matrix.
'                        Matrix can be in any sparse storage format.
'            N       -   size of matrix A (can be smaller than actual size of A)
'            IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                        a symmetric matrix, otherwise A contains a lower one.
'                        Another triangle is ignored.
'            P0, P1  -   integer arrays:
'                        * for Ordering=-3  -  user-supplied permutation  of  rows/
'                          columns, which complies  to  requirements stated  in the
'                          "OUTPUT PARAMETERS" section.  Both  P0 and  P1  must  be
'                          initialized by user.
'                        * for other values of  Ordering  -  possibly  preallocated
'                          buffer,  which   is   filled   by  internally  generated
'                          permutation. Automatically resized if its  size  is  too
'                          small to store data.
'            Ordering-   sparse matrix reordering algorithm which is used to reduce
'                        fill-in amount:
'                        * -3    use ordering supplied by user in P0/P1
'                        * -2    use random ordering
'                        * -1    use original order
'                        * 0     use best algorithm implemented so far
'                        If input matrix is  given  in  SKS  format,  factorization
'                        function ignores Ordering and uses original order  of  the
'                        columns. The idea is that if you already store  matrix  in
'                        SKS format, it is better not to perform costly reordering.
'            Algo    -   type of algorithm which is used during factorization:
'                        * 0     use best  algorithm  (for  SKS  input  or   output
'                                matrices Algo=2 is used; otherwise Algo=1 is used)
'                        * 1     use CRS-based algorithm
'                        * 2     use skyline-based factorization algorithm.
'                                This algorithm is a  fastest  one  for low-profile
'                                matrices,  but  requires  too  much of memory  for
'                                matrices with large bandwidth.
'            Fmt     -   desired storage format  of  the  output,  as  returned  by
'                        SparseGetMatrixType() function:
'                        * 0 for hash-based storage
'                        * 1 for CRS
'                        * 2 for SKS
'                        If you do not know what format to choose, use 1 (CRS).
'            Buf     -   SparseBuffers structure which is used to store temporaries.
'                        This function may reuse previously allocated  storage,  so
'                        if you perform repeated factorizations it is beneficial to
'                        reuse Buf.
'            C       -   SparseMatrix structure  which  can  be  just  some  random
'                        garbage. In  case  in  contains  enough  memory  to  store
'                        triangular factors, this memory will be reused. Othwerwise,
'                        algorithm will automatically allocate enough memory.
'            
'
'        OUTPUT PARAMETERS:
'            C       -   the result of factorization, stored in desired format.  If
'                        IsUpper=True, then the upper triangle  contains  matrix U,
'                        such  that  (P'*A*P) = U^T*U,  where  P  is  a permutation
'                        matrix (see below). The elements below the  main  diagonal
'                        are zero.
'                        Similarly, if IsUpper = False. In this case L is returned,
'                        and we have (P'*A*P) = L*(L^T).
'            P0      -   permutation  (according   to   Ordering  parameter)  which
'                        minimizes amount of fill-in:
'                        * P0 is array[N]
'                        * permutation is applied to A before  factorization  takes
'                          place, i.e. we have U'*U = L*L' = P'*A*P
'                        * P0[k]=j means that column/row j of A  is  moved  to k-th
'                          position before starting factorization.
'            P1      -   permutation P in another format, array[N]:
'                        * P1[k]=j means that k-th column/row of A is moved to j-th
'                          position
'
'        RESULT:
'            If  the  matrix  is  positive-definite,  the  function  returns  True.
'            Otherwise, the function returns False. Contents of C is not determined
'            in such case.
'
'        NOTE: for  performance  reasons  this  function  does NOT check that input
'              matrix  includes  only  finite  values. It is your responsibility to
'              make sure that there are no infinite or NAN values in the matrix.
'
'          -- ALGLIB routine --
'             16.01.2014
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Function sparsecholeskyx(a As sparse.sparsematrix, n As Integer, isupper As Boolean, ByRef p0 As Integer(), ByRef p1 As Integer(), ordering As Integer, _
			algo As Integer, fmt As Integer, buf As sparse.sparsebuffers, c As sparse.sparsematrix) As Boolean
			Dim result As New Boolean()
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim t0 As Integer = 0
			Dim t1 As Integer = 0
			Dim v As Double = 0
			Dim rs As New hqrnd.hqrndstate()

			alglib.ap.assert(n >= 0, "SparseMatrixCholeskyBuf: N<0")
			alglib.ap.assert(sparse.sparsegetnrows(a) >= n, "SparseMatrixCholeskyBuf: rows(A)<N")
			alglib.ap.assert(sparse.sparsegetncols(a) >= n, "SparseMatrixCholeskyBuf: cols(A)<N")
			alglib.ap.assert(ordering >= -3 AndAlso ordering <= 0, "SparseMatrixCholeskyBuf: invalid Ordering parameter")
			alglib.ap.assert(algo >= 0 AndAlso algo <= 2, "SparseMatrixCholeskyBuf: invalid Algo parameter")
			hqrnd.hqrndrandomize(rs)

			'
			' Perform some quick checks.
			' Because sparse matrices are expensive data structures, these
			' checks are better to perform during early stages of the factorization.
			'
			result = False
			If n < 1 Then
				Return result
			End If
			For i = 0 To n - 1
				If CDbl(sparse.sparsegetdiagonal(a, i)) <= CDbl(0) Then
					Return result
				End If
			Next

			'
			' First, determine appropriate ordering:
			' * for SKS inputs, Ordering=-1 is automatically chosen (overrides user settings)
			'
			If ordering = 0 Then
				ordering = -1
			End If
			If sparse.sparseissks(a) Then
				ordering = -1
			End If
			If ordering = -3 Then

				'
				' User-supplied ordering.
				' Check its correctness.
				'
				alglib.ap.assert(alglib.ap.len(p0) >= n, "SparseCholeskyX: user-supplied permutation is too short")
				alglib.ap.assert(alglib.ap.len(p1) >= n, "SparseCholeskyX: user-supplied permutation is too short")
				For i = 0 To n - 1
					alglib.ap.assert(p0(i) >= 0 AndAlso p0(i) < n, "SparseCholeskyX: user-supplied permutation includes values outside of [0,N)")
					alglib.ap.assert(p1(i) >= 0 AndAlso p1(i) < n, "SparseCholeskyX: user-supplied permutation includes values outside of [0,N)")
					alglib.ap.assert(p1(p0(i)) = i, "SparseCholeskyX: user-supplied permutation is inconsistent - P1 is not inverse of P0")
				Next
			End If
			If ordering = -2 Then

				'
				' Use random ordering
				'
				apserv.ivectorsetlengthatleast(p0, n)
				apserv.ivectorsetlengthatleast(p1, n)
				For i = 0 To n - 1
					p0(i) = i
				Next
				For i = 0 To n - 1
					j = i + hqrnd.hqrnduniformi(rs, n - i)
					If j <> i Then
						k = p0(i)
						p0(i) = p0(j)
						p0(j) = k
					End If
				Next
				For i = 0 To n - 1
					p1(p0(i)) = i
				Next
			End If
			If ordering = -1 Then

				'
				' Use initial ordering
				'
				apserv.ivectorsetlengthatleast(p0, n)
				apserv.ivectorsetlengthatleast(p1, n)
				For i = 0 To n - 1
					p0(i) = i
					p1(i) = i
				Next
			End If

			'
			' Determine algorithm to use:
			' * for SKS input or output - use SKS solver (overrides user settings)
			' * default is to use Algo=1
			'
			If algo = 0 Then
				algo = 1
			End If
			If sparse.sparseissks(a) OrElse fmt = 2 Then
				algo = 2
			End If
			algo = 2
			If algo = 2 Then

				'
				' Skyline Cholesky with non-skyline output.
				'
				' Call CholeskyX() recursively with Buf.S as output matrix,
				' then perform conversion from SKS to desired format. We can
				' use Buf.S in reccurrent call because SKS-to-SKS CholeskyX()
				' does not uses this field.
				'
				If fmt <> 2 Then
					result = sparsecholeskyx(a, n, isupper, p0, p1, -3, _
						algo, 2, buf, buf.s)
					If result Then
						sparse.sparsecopytobuf(buf.s, fmt, c)
					End If
					Return result
				End If

				'
				' Skyline Cholesky with skyline output
				'
				If sparse.sparseissks(a) AndAlso ordering = -1 Then

					'
					' Non-permuted skyline matrix.
					'
					' Quickly copy matrix to output buffer without permutation.
					'
					' NOTE: Buf.D is used as dummy vector filled with zeros.
					'
					apserv.ivectorsetlengthatleast(buf.d, n)
					For i = 0 To n - 1
						buf.d(i) = 0
					Next
					If isupper Then

						'
						' Create strictly upper-triangular matrix,
						' copy upper triangle of input.
						'
						sparse.sparsecreatesksbuf(n, n, buf.d, a.uidx, c)
						For i = 0 To n - 1
							t0 = a.ridx(i + 1) - a.uidx(i) - 1
							t1 = a.ridx(i + 1) - 1
							k = c.ridx(i + 1) - c.uidx(i) - 1
							For j = t0 To t1
								c.vals(k) = a.vals(j)
								k = k + 1
							Next
						Next
					Else

						'
						' Create strictly lower-triangular matrix,
						' copy lower triangle of input.
						'
						sparse.sparsecreatesksbuf(n, n, a.didx, buf.d, c)
						For i = 0 To n - 1
							t0 = a.ridx(i)
							t1 = a.ridx(i) + a.didx(i)
							k = c.ridx(i)
							For j = t0 To t1
								c.vals(k) = a.vals(j)
								k = k + 1
							Next
						Next
					End If
				Else

					'
					' Non-identity permutations OR non-skyline input:
					' * investigate profile of permuted A
					' * create skyline matrix in output buffer
					' * copy input with permutation
					'
					apserv.ivectorsetlengthatleast(buf.d, n)
					apserv.ivectorsetlengthatleast(buf.u, n)
					For i = 0 To n - 1
						buf.d(i) = 0
						buf.u(i) = 0
					Next
					t0 = 0
					t1 = 0
					While sparse.sparseenumerate(a, t0, t1, i, j, v)
						If (isupper AndAlso j >= i) OrElse (Not isupper AndAlso j <= i) Then
							i = p1(i)
							j = p1(j)
							If (j < i AndAlso isupper) OrElse (j > i AndAlso Not isupper) Then
								apserv.swapi(i, j)
							End If
							If i > j Then
								buf.d(i) = System.Math.Max(buf.d(i), i - j)
							Else
								buf.u(j) = System.Math.Max(buf.u(j), j - i)
							End If
						End If
					End While
					sparse.sparsecreatesksbuf(n, n, buf.d, buf.u, c)
					t0 = 0
					t1 = 0
					While sparse.sparseenumerate(a, t0, t1, i, j, v)
						If (isupper AndAlso j >= i) OrElse (Not isupper AndAlso j <= i) Then
							i = p1(i)
							j = p1(j)
							If (j < i AndAlso isupper) OrElse (j > i AndAlso Not isupper) Then
								apserv.swapi(j, i)
							End If
							sparse.sparserewriteexisting(c, i, j, v)
						End If
					End While
				End If
				result = sparsecholeskyskyline(c, n, isupper)
				Return result
			End If
			alglib.ap.assert(False, "SparseCholeskyX: internal error - unexpected algorithm")
			Return result
		End Function


		Public Shared Sub rmatrixlup(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
			Dim tmp As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim mx As Double = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			pivots = New Integer(-1) {}


			'
			' Internal LU decomposition subroutine.
			' Never call it directly.
			'
			alglib.ap.assert(m > 0, "RMatrixLUP: incorrect M!")
			alglib.ap.assert(n > 0, "RMatrixLUP: incorrect N!")

			'
			' Scale matrix to avoid overflows,
			' decompose it, then scale back.
			'
			mx = 0
			For i = 0 To m - 1
				For j = 0 To n - 1
					mx = System.Math.Max(mx, System.Math.Abs(a(i, j)))
				Next
			Next
			If CDbl(mx) <> CDbl(0) Then
				v = 1 / mx
				For i = 0 To m - 1
					For i_ = 0 To n - 1
						a(i, i_) = v * a(i, i_)
					Next
				Next
			End If
			pivots = New Integer(System.Math.Min(m, n) - 1) {}
			tmp = New Double(2 * System.Math.Max(m, n) - 1) {}
			rmatrixluprec(a, 0, m, n, pivots, tmp)
			If CDbl(mx) <> CDbl(0) Then
				v = mx
				For i = 0 To m - 1
					For i_ = 0 To System.Math.Min(i, n - 1)
						a(i, i_) = v * a(i, i_)
					Next
				Next
			End If
		End Sub


		Public Shared Sub cmatrixlup(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
			Dim tmp As complex() = New complex(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim mx As Double = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			pivots = New Integer(-1) {}


			'
			' Internal LU decomposition subroutine.
			' Never call it directly.
			'
			alglib.ap.assert(m > 0, "CMatrixLUP: incorrect M!")
			alglib.ap.assert(n > 0, "CMatrixLUP: incorrect N!")

			'
			' Scale matrix to avoid overflows,
			' decompose it, then scale back.
			'
			mx = 0
			For i = 0 To m - 1
				For j = 0 To n - 1
                    mx = System.Math.Max(mx, Math.abscomplex(a(i, j)))
                Next
            Next
            If CDbl(mx) <> CDbl(0) Then
                v = 1 / mx
                For i = 0 To m - 1
                    For i_ = 0 To n - 1
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
            pivots = New Integer(System.Math.Min(m, n) - 1) {}
            tmp = New complex(2 * System.Math.Max(m, n) - 1) {}
            cmatrixluprec(a, 0, m, n, pivots, tmp)
            If CDbl(mx) <> CDbl(0) Then
                v = mx
                For i = 0 To m - 1
                    For i_ = 0 To System.Math.Min(i, n - 1)
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
        End Sub


        Public Shared Sub rmatrixplu(ByRef a As Double(,), m As Integer, n As Integer, ByRef pivots As Integer())
            Dim tmp As Double() = New Double(-1) {}
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim mx As Double = 0
            Dim v As Double = 0
            Dim i_ As Integer = 0

            pivots = New Integer(-1) {}


            '
            ' Internal LU decomposition subroutine.
            ' Never call it directly.
            '
            alglib.ap.assert(m > 0, "RMatrixPLU: incorrect M!")
            alglib.ap.assert(n > 0, "RMatrixPLU: incorrect N!")
            tmp = New Double(2 * System.Math.Max(m, n) - 1) {}
            pivots = New Integer(System.Math.Min(m, n) - 1) {}

            '
            ' Scale matrix to avoid overflows,
            ' decompose it, then scale back.
            '
            mx = 0
            For i = 0 To m - 1
                For j = 0 To n - 1
                    mx = System.Math.Max(mx, System.Math.Abs(a(i, j)))
                Next
            Next
            If CDbl(mx) <> CDbl(0) Then
                v = 1 / mx
                For i = 0 To m - 1
                    For i_ = 0 To n - 1
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
            rmatrixplurec(a, 0, m, n, pivots, tmp)
            If CDbl(mx) <> CDbl(0) Then
                v = mx
                For i = 0 To System.Math.Min(m, n) - 1
                    For i_ = i To n - 1
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
        End Sub


        Public Shared Sub cmatrixplu(ByRef a As complex(,), m As Integer, n As Integer, ByRef pivots As Integer())
            Dim tmp As complex() = New complex(-1) {}
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim mx As Double = 0
            Dim v As complex = 0
            Dim i_ As Integer = 0

            pivots = New Integer(-1) {}


            '
            ' Internal LU decomposition subroutine.
            ' Never call it directly.
            '
            alglib.ap.assert(m > 0, "CMatrixPLU: incorrect M!")
            alglib.ap.assert(n > 0, "CMatrixPLU: incorrect N!")
            tmp = New complex(2 * System.Math.Max(m, n) - 1) {}
            pivots = New Integer(System.Math.Min(m, n) - 1) {}

            '
            ' Scale matrix to avoid overflows,
            ' decompose it, then scale back.
            '
            mx = 0
            For i = 0 To m - 1
                For j = 0 To n - 1
                    mx = System.Math.Max(mx, Math.abscomplex(a(i, j)))
                Next
            Next
            If CDbl(mx) <> CDbl(0) Then
                v = 1 / mx
                For i = 0 To m - 1
                    For i_ = 0 To n - 1
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
            cmatrixplurec(a, 0, m, n, pivots, tmp)
            If CDbl(mx) <> CDbl(0) Then
                v = mx
                For i = 0 To System.Math.Min(m, n) - 1
                    For i_ = i To n - 1
                        a(i, i_) = v * a(i, i_)
                    Next
                Next
            End If
        End Sub


        '************************************************************************
        '        Recursive computational subroutine for SPDMatrixCholesky.
        '
        '        INPUT PARAMETERS:
        '            A       -   matrix given by upper or lower triangle
        '            Offs    -   offset of diagonal block to decompose
        '            N       -   diagonal block size
        '            IsUpper -   what half is given
        '            Tmp     -   temporary array; allocated by function, if its size is too
        '                        small; can be reused on subsequent calls.
        '                        
        '        OUTPUT PARAMETERS:
        '            A       -   upper (or lower) triangle contains Cholesky decomposition
        '
        '        RESULT:
        '            True, on success
        '            False, on failure
        '
        '          -- ALGLIB routine --
        '             15.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Public Shared Function spdmatrixcholeskyrec(ByRef a As Double(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As Double()) As Boolean
            Dim result As New Boolean()
            Dim n1 As Integer = 0
            Dim n2 As Integer = 0


            '
            ' check N
            '
            If n < 1 Then
                result = False
                Return result
            End If

            '
            ' Prepare buffer
            '
            If alglib.ap.len(tmp) < 2 * n Then
                tmp = New Double(2 * n - 1) {}
            End If

            '
            ' special cases
            '
            ' NOTE: we do not use MKL to accelerate Cholesky basecase
            '       because basecase cost is negligible when compared to
            '       the cost of entire decomposition (most time is spent
            '       in GEMM snd SYRK).
            '
            If n = 1 Then
                If CDbl(a(offs, offs)) > CDbl(0) Then
                    a(offs, offs) = System.Math.sqrt(a(offs, offs))
                    result = True
                Else
                    result = False
                End If
                Return result
            End If
            If n <= ablas.ablasblocksize(a) Then
                result = spdmatrixcholesky2(a, offs, n, isupper, tmp)
                Return result
            End If

            '
            ' general case: split task in cache-oblivious manner
            '
            result = True
            ablas.ablassplitlength(a, n, n1, n2)
            result = spdmatrixcholeskyrec(a, offs, n1, isupper, tmp)
            If Not result Then
                Return result
            End If
            If n2 > 0 Then
                If isupper Then
                    ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
                        False, 1, a, offs, offs + n1)
                    ablas.rmatrixsyrk(n2, n1, -1.0, a, offs, offs + n1, _
                        1, 1.0, a, offs + n1, offs + n1, isupper)
                Else
                    ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
                        False, 1, a, offs + n1, offs)
                    ablas.rmatrixsyrk(n2, n1, -1.0, a, offs + n1, offs, _
                        0, 1.0, a, offs + n1, offs + n1, isupper)
                End If
                result = spdmatrixcholeskyrec(a, offs + n1, n2, isupper, tmp)
                If Not result Then
                    Return result
                End If
            End If
            Return result
        End Function


        '************************************************************************
        '        Recurrent complex LU subroutine.
        '        Never call it directly.
        '
        '          -- ALGLIB routine --
        '             04.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub cmatrixluprec(ByRef a As complex(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As complex())
            Dim i As Integer = 0
            Dim m1 As Integer = 0
            Dim m2 As Integer = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Kernel case
            '
            If System.Math.Min(m, n) <= ablas.ablascomplexblocksize(a) Then
                cmatrixlup2(a, offs, m, n, pivots, tmp)
                Return
            End If

            '
            ' Preliminary step, make N>=M
            '
            '     ( A1 )
            ' A = (    ), where A1 is square
            '     ( A2 )
            '
            ' Factorize A1, update A2
            '
            If m > n Then
                cmatrixluprec(a, offs, n, n, pivots, tmp)
                For i = 0 To n - 1
                    i1_ = (offs + n) - (0)
                    For i_ = 0 To m - n - 1
                        tmp(i_) = a(i_ + i1_, offs + i)
                    Next
                    For i_ = offs + n To offs + m - 1
                        a(i_, offs + i) = a(i_, pivots(offs + i))
                    Next
                    i1_ = (0) - (offs + n)
                    For i_ = offs + n To offs + m - 1
                        a(i_, pivots(offs + i)) = tmp(i_ + i1_)
                    Next
                Next
                ablas.cmatrixrighttrsm(m - n, n, a, offs, offs, True, _
                    True, 0, a, offs + n, offs)
                Return
            End If

            '
            ' Non-kernel case
            '
            ablas.ablascomplexsplitlength(a, m, m1, m2)
            cmatrixluprec(a, offs, m1, n, pivots, tmp)
            If m2 > 0 Then
                For i = 0 To m1 - 1
                    If offs + i <> pivots(offs + i) Then
                        i1_ = (offs + m1) - (0)
                        For i_ = 0 To m2 - 1
                            tmp(i_) = a(i_ + i1_, offs + i)
                        Next
                        For i_ = offs + m1 To offs + m - 1
                            a(i_, offs + i) = a(i_, pivots(offs + i))
                        Next
                        i1_ = (0) - (offs + m1)
                        For i_ = offs + m1 To offs + m - 1
                            a(i_, pivots(offs + i)) = tmp(i_ + i1_)
                        Next
                    End If
                Next
                ablas.cmatrixrighttrsm(m2, m1, a, offs, offs, True, _
                    True, 0, a, offs + m1, offs)
                ablas.cmatrixgemm(m - m1, n - m1, m1, -1.0, a, offs + m1, _
                    offs, 0, a, offs, offs + m1, 0, _
                    1.0, a, offs + m1, offs + m1)
                cmatrixluprec(a, offs + m1, m - m1, n - m1, pivots, tmp)
                For i = 0 To m2 - 1
                    If offs + m1 + i <> pivots(offs + m1 + i) Then
                        i1_ = (offs) - (0)
                        For i_ = 0 To m1 - 1
                            tmp(i_) = a(i_ + i1_, offs + m1 + i)
                        Next
                        For i_ = offs To offs + m1 - 1
                            a(i_, offs + m1 + i) = a(i_, pivots(offs + m1 + i))
                        Next
                        i1_ = (0) - (offs)
                        For i_ = offs To offs + m1 - 1
                            a(i_, pivots(offs + m1 + i)) = tmp(i_ + i1_)
                        Next
                    End If
                Next
            End If
        End Sub


        '************************************************************************
        '        Recurrent real LU subroutine.
        '        Never call it directly.
        '
        '          -- ALGLIB routine --
        '             04.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub rmatrixluprec(ByRef a As Double(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As Double())
            Dim i As Integer = 0
            Dim m1 As Integer = 0
            Dim m2 As Integer = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Kernel case
            '
            If System.Math.Min(m, n) <= ablas.ablasblocksize(a) Then
                rmatrixlup2(a, offs, m, n, pivots, tmp)
                Return
            End If

            '
            ' Preliminary step, make N>=M
            '
            '     ( A1 )
            ' A = (    ), where A1 is square
            '     ( A2 )
            '
            ' Factorize A1, update A2
            '
            If m > n Then
                rmatrixluprec(a, offs, n, n, pivots, tmp)
                For i = 0 To n - 1
                    If offs + i <> pivots(offs + i) Then
                        i1_ = (offs + n) - (0)
                        For i_ = 0 To m - n - 1
                            tmp(i_) = a(i_ + i1_, offs + i)
                        Next
                        For i_ = offs + n To offs + m - 1
                            a(i_, offs + i) = a(i_, pivots(offs + i))
                        Next
                        i1_ = (0) - (offs + n)
                        For i_ = offs + n To offs + m - 1
                            a(i_, pivots(offs + i)) = tmp(i_ + i1_)
                        Next
                    End If
                Next
                ablas.rmatrixrighttrsm(m - n, n, a, offs, offs, True, _
                    True, 0, a, offs + n, offs)
                Return
            End If

            '
            ' Non-kernel case
            '
            ablas.ablassplitlength(a, m, m1, m2)
            rmatrixluprec(a, offs, m1, n, pivots, tmp)
            If m2 > 0 Then
                For i = 0 To m1 - 1
                    If offs + i <> pivots(offs + i) Then
                        i1_ = (offs + m1) - (0)
                        For i_ = 0 To m2 - 1
                            tmp(i_) = a(i_ + i1_, offs + i)
                        Next
                        For i_ = offs + m1 To offs + m - 1
                            a(i_, offs + i) = a(i_, pivots(offs + i))
                        Next
                        i1_ = (0) - (offs + m1)
                        For i_ = offs + m1 To offs + m - 1
                            a(i_, pivots(offs + i)) = tmp(i_ + i1_)
                        Next
                    End If
                Next
                ablas.rmatrixrighttrsm(m2, m1, a, offs, offs, True, _
                    True, 0, a, offs + m1, offs)
                ablas.rmatrixgemm(m - m1, n - m1, m1, -1.0, a, offs + m1, _
                    offs, 0, a, offs, offs + m1, 0, _
                    1.0, a, offs + m1, offs + m1)
                rmatrixluprec(a, offs + m1, m - m1, n - m1, pivots, tmp)
                For i = 0 To m2 - 1
                    If offs + m1 + i <> pivots(offs + m1 + i) Then
                        i1_ = (offs) - (0)
                        For i_ = 0 To m1 - 1
                            tmp(i_) = a(i_ + i1_, offs + m1 + i)
                        Next
                        For i_ = offs To offs + m1 - 1
                            a(i_, offs + m1 + i) = a(i_, pivots(offs + m1 + i))
                        Next
                        i1_ = (0) - (offs)
                        For i_ = offs To offs + m1 - 1
                            a(i_, pivots(offs + m1 + i)) = tmp(i_ + i1_)
                        Next
                    End If
                Next
            End If
        End Sub


        '************************************************************************
        '        Recurrent complex LU subroutine.
        '        Never call it directly.
        '
        '          -- ALGLIB routine --
        '             04.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub cmatrixplurec(ByRef a As complex(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As complex())
            Dim i As Integer = 0
            Dim n1 As Integer = 0
            Dim n2 As Integer = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Kernel case
            '
            If System.Math.Min(m, n) <= ablas.ablascomplexblocksize(a) Then
                cmatrixplu2(a, offs, m, n, pivots, tmp)
                Return
            End If

            '
            ' Preliminary step, make M>=N.
            '
            ' A = (A1 A2), where A1 is square
            ' Factorize A1, update A2
            '
            If n > m Then
                cmatrixplurec(a, offs, m, m, pivots, tmp)
                For i = 0 To m - 1
                    i1_ = (offs + m) - (0)
                    For i_ = 0 To n - m - 1
                        tmp(i_) = a(offs + i, i_ + i1_)
                    Next
                    For i_ = offs + m To offs + n - 1
                        a(offs + i, i_) = a(pivots(offs + i), i_)
                    Next
                    i1_ = (0) - (offs + m)
                    For i_ = offs + m To offs + n - 1
                        a(pivots(offs + i), i_) = tmp(i_ + i1_)
                    Next
                Next
                ablas.cmatrixlefttrsm(m, n - m, a, offs, offs, False, _
                    True, 0, a, offs, offs + m)
                Return
            End If

            '
            ' Non-kernel case
            '
            ablas.ablascomplexsplitlength(a, n, n1, n2)
            cmatrixplurec(a, offs, m, n1, pivots, tmp)
            If n2 > 0 Then
                For i = 0 To n1 - 1
                    If offs + i <> pivots(offs + i) Then
                        i1_ = (offs + n1) - (0)
                        For i_ = 0 To n2 - 1
                            tmp(i_) = a(offs + i, i_ + i1_)
                        Next
                        For i_ = offs + n1 To offs + n - 1
                            a(offs + i, i_) = a(pivots(offs + i), i_)
                        Next
                        i1_ = (0) - (offs + n1)
                        For i_ = offs + n1 To offs + n - 1
                            a(pivots(offs + i), i_) = tmp(i_ + i1_)
                        Next
                    End If
                Next
                ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, False, _
                    True, 0, a, offs, offs + n1)
                ablas.cmatrixgemm(m - n1, n - n1, n1, -1.0, a, offs + n1, _
                    offs, 0, a, offs, offs + n1, 0, _
                    1.0, a, offs + n1, offs + n1)
                cmatrixplurec(a, offs + n1, m - n1, n - n1, pivots, tmp)
                For i = 0 To n2 - 1
                    If offs + n1 + i <> pivots(offs + n1 + i) Then
                        i1_ = (offs) - (0)
                        For i_ = 0 To n1 - 1
                            tmp(i_) = a(offs + n1 + i, i_ + i1_)
                        Next
                        For i_ = offs To offs + n1 - 1
                            a(offs + n1 + i, i_) = a(pivots(offs + n1 + i), i_)
                        Next
                        i1_ = (0) - (offs)
                        For i_ = offs To offs + n1 - 1
                            a(pivots(offs + n1 + i), i_) = tmp(i_ + i1_)
                        Next
                    End If
                Next
            End If
        End Sub


        '************************************************************************
        '        Recurrent real LU subroutine.
        '        Never call it directly.
        '
        '          -- ALGLIB routine --
        '             04.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub rmatrixplurec(ByRef a As Double(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As Double())
            Dim i As Integer = 0
            Dim n1 As Integer = 0
            Dim n2 As Integer = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Basecases
            '
            If ablasmkl.rmatrixplumkl(a, offs, m, n, pivots) Then
                Return
            End If
            If System.Math.Min(m, n) <= ablas.ablasblocksize(a) Then
                rmatrixplu2(a, offs, m, n, pivots, tmp)
                Return
            End If

            '
            ' Preliminary step, make M>=N.
            '
            ' A = (A1 A2), where A1 is square
            ' Factorize A1, update A2
            '
            If n > m Then
                rmatrixplurec(a, offs, m, m, pivots, tmp)
                For i = 0 To m - 1
                    i1_ = (offs + m) - (0)
                    For i_ = 0 To n - m - 1
                        tmp(i_) = a(offs + i, i_ + i1_)
                    Next
                    For i_ = offs + m To offs + n - 1
                        a(offs + i, i_) = a(pivots(offs + i), i_)
                    Next
                    i1_ = (0) - (offs + m)
                    For i_ = offs + m To offs + n - 1
                        a(pivots(offs + i), i_) = tmp(i_ + i1_)
                    Next
                Next
                ablas.rmatrixlefttrsm(m, n - m, a, offs, offs, False, _
                    True, 0, a, offs, offs + m)
                Return
            End If

            '
            ' Non-kernel case
            '
            ablas.ablassplitlength(a, n, n1, n2)
            rmatrixplurec(a, offs, m, n1, pivots, tmp)
            If n2 > 0 Then
                For i = 0 To n1 - 1
                    If offs + i <> pivots(offs + i) Then
                        i1_ = (offs + n1) - (0)
                        For i_ = 0 To n2 - 1
                            tmp(i_) = a(offs + i, i_ + i1_)
                        Next
                        For i_ = offs + n1 To offs + n - 1
                            a(offs + i, i_) = a(pivots(offs + i), i_)
                        Next
                        i1_ = (0) - (offs + n1)
                        For i_ = offs + n1 To offs + n - 1
                            a(pivots(offs + i), i_) = tmp(i_ + i1_)
                        Next
                    End If
                Next
                ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, False, _
                    True, 0, a, offs, offs + n1)
                ablas.rmatrixgemm(m - n1, n - n1, n1, -1.0, a, offs + n1, _
                    offs, 0, a, offs, offs + n1, 0, _
                    1.0, a, offs + n1, offs + n1)
                rmatrixplurec(a, offs + n1, m - n1, n - n1, pivots, tmp)
                For i = 0 To n2 - 1
                    If offs + n1 + i <> pivots(offs + n1 + i) Then
                        i1_ = (offs) - (0)
                        For i_ = 0 To n1 - 1
                            tmp(i_) = a(offs + n1 + i, i_ + i1_)
                        Next
                        For i_ = offs To offs + n1 - 1
                            a(offs + n1 + i, i_) = a(pivots(offs + n1 + i), i_)
                        Next
                        i1_ = (0) - (offs)
                        For i_ = offs To offs + n1 - 1
                            a(pivots(offs + n1 + i), i_) = tmp(i_ + i1_)
                        Next
                    End If
                Next
            End If
        End Sub


        '************************************************************************
        '        Complex LUP kernel
        '
        '          -- ALGLIB routine --
        '             10.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub cmatrixlup2(ByRef a As complex(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As complex())
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim jp As Integer = 0
            Dim s As complex = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Quick return if possible
            '
            If m = 0 OrElse n = 0 Then
                Return
            End If

            '
            ' main cycle
            '
            For j = 0 To System.Math.Min(m - 1, n - 1)

                '
                ' Find pivot, swap columns
                '
                jp = j
                For i = j + 1 To n - 1
                    If CDbl(Math.abscomplex(a(offs + j, offs + i))) > CDbl(Math.abscomplex(a(offs + j, offs + jp))) Then
                        jp = i
                    End If
                Next
                pivots(offs + j) = offs + jp
                If jp <> j Then
                    i1_ = (offs) - (0)
                    For i_ = 0 To m - 1
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    For i_ = offs To offs + m - 1
                        a(i_, offs + j) = a(i_, offs + jp)
                    Next
                    i1_ = (0) - (offs)
                    For i_ = offs To offs + m - 1
                        a(i_, offs + jp) = tmp(i_ + i1_)
                    Next
                End If

                '
                ' LU decomposition of 1x(N-J) matrix
                '
                If a(offs + j, offs + j) <> 0 AndAlso j + 1 <= n - 1 Then
                    s = 1 / a(offs + j, offs + j)
                    For i_ = offs + j + 1 To offs + n - 1
                        a(offs + j, i_) = s * a(offs + j, i_)
                    Next
                End If

                '
                ' Update trailing (M-J-1)x(N-J-1) matrix
                '
                If j < System.Math.Min(m - 1, n - 1) Then
                    i1_ = (offs + j + 1) - (0)
                    For i_ = 0 To m - j - 2
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    i1_ = (offs + j + 1) - (m)
                    For i_ = m To m + n - j - 2
                        tmp(i_) = -a(offs + j, i_ + i1_)
                    Next
                    ablas.cmatrixrank1(m - j - 1, n - j - 1, a, offs + j + 1, offs + j + 1, tmp, _
                        0, tmp, m)
                End If
            Next
        End Sub


        '************************************************************************
        '        Real LUP kernel
        '
        '          -- ALGLIB routine --
        '             10.01.2010
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Sub rmatrixlup2(ByRef a As Double(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As Double())
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim jp As Integer = 0
            Dim s As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Quick return if possible
            '
            If m = 0 OrElse n = 0 Then
                Return
            End If

            '
            ' main cycle
            '
            For j = 0 To System.Math.Min(m - 1, n - 1)

                '
                ' Find pivot, swap columns
                '
                jp = j
                For i = j + 1 To n - 1
                    If CDbl(System.Math.Abs(a(offs + j, offs + i))) > CDbl(System.Math.Abs(a(offs + j, offs + jp))) Then
                        jp = i
                    End If
                Next
                pivots(offs + j) = offs + jp
                If jp <> j Then
                    i1_ = (offs) - (0)
                    For i_ = 0 To m - 1
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    For i_ = offs To offs + m - 1
                        a(i_, offs + j) = a(i_, offs + jp)
                    Next
                    i1_ = (0) - (offs)
                    For i_ = offs To offs + m - 1
                        a(i_, offs + jp) = tmp(i_ + i1_)
                    Next
                End If

                '
                ' LU decomposition of 1x(N-J) matrix
                '
                If CDbl(a(offs + j, offs + j)) <> CDbl(0) AndAlso j + 1 <= n - 1 Then
                    s = 1 / a(offs + j, offs + j)
                    For i_ = offs + j + 1 To offs + n - 1
                        a(offs + j, i_) = s * a(offs + j, i_)
                    Next
                End If

                '
                ' Update trailing (M-J-1)x(N-J-1) matrix
                '
                If j < System.Math.Min(m - 1, n - 1) Then
                    i1_ = (offs + j + 1) - (0)
                    For i_ = 0 To m - j - 2
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    i1_ = (offs + j + 1) - (m)
                    For i_ = m To m + n - j - 2
                        tmp(i_) = -a(offs + j, i_ + i1_)
                    Next
                    ablas.rmatrixrank1(m - j - 1, n - j - 1, a, offs + j + 1, offs + j + 1, tmp, _
                        0, tmp, m)
                End If
            Next
        End Sub


        '************************************************************************
        '        Complex PLU kernel
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             June 30, 1992
        '        ************************************************************************

        Private Shared Sub cmatrixplu2(ByRef a As complex(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As complex())
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim jp As Integer = 0
            Dim s As complex = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Quick return if possible
            '
            If m = 0 OrElse n = 0 Then
                Return
            End If
            For j = 0 To System.Math.Min(m - 1, n - 1)

                '
                ' Find pivot and test for singularity.
                '
                jp = j
                For i = j + 1 To m - 1
                    If CDbl(Math.abscomplex(a(offs + i, offs + j))) > CDbl(Math.abscomplex(a(offs + jp, offs + j))) Then
                        jp = i
                    End If
                Next
                pivots(offs + j) = offs + jp
                If a(offs + jp, offs + j) <> 0 Then

                    '
                    'Apply the interchange to rows
                    '
                    If jp <> j Then
                        For i = 0 To n - 1
                            s = a(offs + j, offs + i)
                            a(offs + j, offs + i) = a(offs + jp, offs + i)
                            a(offs + jp, offs + i) = s
                        Next
                    End If

                    '
                    'Compute elements J+1:M of J-th column.
                    '
                    If j + 1 <= m - 1 Then
                        s = 1 / a(offs + j, offs + j)
                        For i_ = offs + j + 1 To offs + m - 1
                            a(i_, offs + j) = s * a(i_, offs + j)
                        Next
                    End If
                End If
                If j < System.Math.Min(m, n) - 1 Then

                    '
                    'Update trailing submatrix.
                    '
                    i1_ = (offs + j + 1) - (0)
                    For i_ = 0 To m - j - 2
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    i1_ = (offs + j + 1) - (m)
                    For i_ = m To m + n - j - 2
                        tmp(i_) = -a(offs + j, i_ + i1_)
                    Next
                    ablas.cmatrixrank1(m - j - 1, n - j - 1, a, offs + j + 1, offs + j + 1, tmp, _
                        0, tmp, m)
                End If
            Next
        End Sub


        '************************************************************************
        '        Real PLU kernel
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             June 30, 1992
        '        ************************************************************************

        Private Shared Sub rmatrixplu2(ByRef a As Double(,), offs As Integer, m As Integer, n As Integer, ByRef pivots As Integer(), ByRef tmp As Double())
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim jp As Integer = 0
            Dim s As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0


            '
            ' Quick return if possible
            '
            If m = 0 OrElse n = 0 Then
                Return
            End If
            For j = 0 To System.Math.Min(m - 1, n - 1)

                '
                ' Find pivot and test for singularity.
                '
                jp = j
                For i = j + 1 To m - 1
                    If CDbl(System.Math.Abs(a(offs + i, offs + j))) > CDbl(System.Math.Abs(a(offs + jp, offs + j))) Then
                        jp = i
                    End If
                Next
                pivots(offs + j) = offs + jp
                If CDbl(a(offs + jp, offs + j)) <> CDbl(0) Then

                    '
                    'Apply the interchange to rows
                    '
                    If jp <> j Then
                        For i = 0 To n - 1
                            s = a(offs + j, offs + i)
                            a(offs + j, offs + i) = a(offs + jp, offs + i)
                            a(offs + jp, offs + i) = s
                        Next
                    End If

                    '
                    'Compute elements J+1:M of J-th column.
                    '
                    If j + 1 <= m - 1 Then
                        s = 1 / a(offs + j, offs + j)
                        For i_ = offs + j + 1 To offs + m - 1
                            a(i_, offs + j) = s * a(i_, offs + j)
                        Next
                    End If
                End If
                If j < System.Math.Min(m, n) - 1 Then

                    '
                    'Update trailing submatrix.
                    '
                    i1_ = (offs + j + 1) - (0)
                    For i_ = 0 To m - j - 2
                        tmp(i_) = a(i_ + i1_, offs + j)
                    Next
                    i1_ = (offs + j + 1) - (m)
                    For i_ = m To m + n - j - 2
                        tmp(i_) = -a(offs + j, i_ + i1_)
                    Next
                    ablas.rmatrixrank1(m - j - 1, n - j - 1, a, offs + j + 1, offs + j + 1, tmp, _
                        0, tmp, m)
                End If
            Next
        End Sub


        '************************************************************************
        '        Recursive computational subroutine for HPDMatrixCholesky
        '
        '          -- ALGLIB routine --
        '             15.12.2009
        '             Bochkanov Sergey
        '        ************************************************************************

        Private Shared Function hpdmatrixcholeskyrec(ByRef a As complex(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As complex()) As Boolean
            Dim result As New Boolean()
            Dim n1 As Integer = 0
            Dim n2 As Integer = 0


            '
            ' check N
            '
            If n < 1 Then
                result = False
                Return result
            End If

            '
            ' Prepare buffer
            '
            If alglib.ap.len(tmp) < 2 * n Then
                tmp = New complex(2 * n - 1) {}
            End If

            '
            ' special cases
            '
            ' NOTE: we do not use MKL for basecases because their price is only
            '       minor part of overall running time for N>256.
            '
            If n = 1 Then
                If CDbl(a(offs, offs).x) > CDbl(0) Then
                    a(offs, offs) = System.Math.sqrt(a(offs, offs).x)
                    result = True
                Else
                    result = False
                End If
                Return result
            End If
            If n <= ablas.ablascomplexblocksize(a) Then
                result = hpdmatrixcholesky2(a, offs, n, isupper, tmp)
                Return result
            End If

            '
            ' general case: split task in cache-oblivious manner
            '
            result = True
            ablas.ablascomplexsplitlength(a, n, n1, n2)
            result = hpdmatrixcholeskyrec(a, offs, n1, isupper, tmp)
            If Not result Then
                Return result
            End If
            If n2 > 0 Then
                If isupper Then
                    ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
                        False, 2, a, offs, offs + n1)
                    ablas.cmatrixherk(n2, n1, -1.0, a, offs, offs + n1, _
                        2, 1.0, a, offs + n1, offs + n1, isupper)
                Else
                    ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
                        False, 2, a, offs + n1, offs)
                    ablas.cmatrixherk(n2, n1, -1.0, a, offs + n1, offs, _
                        0, 1.0, a, offs + n1, offs + n1, isupper)
                End If
                result = hpdmatrixcholeskyrec(a, offs + n1, n2, isupper, tmp)
                If Not result Then
                    Return result
                End If
            End If
            Return result
        End Function


        '************************************************************************
        '        Level-2 Hermitian Cholesky subroutine.
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Function hpdmatrixcholesky2(ByRef aaa As complex(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As complex()) As Boolean
            Dim result As New Boolean()
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim ajj As Double = 0
            Dim v As complex = 0
            Dim r As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            result = True
            If n < 0 Then
                result = False
                Return result
            End If

            '
            ' Quick return if possible
            '
            If n = 0 Then
                Return result
            End If
            If isupper Then

                '
                ' Compute the Cholesky factorization A = U'*U.
                '
                For j = 0 To n - 1

                    '
                    ' Compute U(J,J) and test for non-positive-definiteness.
                    '
                    v = 0.0
                    For i_ = offs To offs + j - 1
                        v += Math.conj(aaa(i_, offs + j)) * aaa(i_, offs + j)
                    Next
                    ajj = (aaa(offs + j, offs + j) - v).x
                    If CDbl(ajj) <= CDbl(0) Then
                        aaa(offs + j, offs + j) = ajj
                        result = False
                        Return result
                    End If
                    ajj = System.Math.sqrt(ajj)
                    aaa(offs + j, offs + j) = ajj

                    '
                    ' Compute elements J+1:N-1 of row J.
                    '
                    If j < n - 1 Then
                        If j > 0 Then
                            i1_ = (offs) - (0)
                            For i_ = 0 To j - 1
                                tmp(i_) = -Math.conj(aaa(i_ + i1_, offs + j))
                            Next
                            ablas.cmatrixmv(n - j - 1, j, aaa, offs, offs + j + 1, 1, _
                                tmp, 0, tmp, n)
                            i1_ = (n) - (offs + j + 1)
                            For i_ = offs + j + 1 To offs + n - 1
                                aaa(offs + j, i_) = aaa(offs + j, i_) + tmp(i_ + i1_)
                            Next
                        End If
                        r = 1 / ajj
                        For i_ = offs + j + 1 To offs + n - 1
                            aaa(offs + j, i_) = r * aaa(offs + j, i_)
                        Next
                    End If
                Next
            Else

                '
                ' Compute the Cholesky factorization A = L*L'.
                '
                For j = 0 To n - 1

                    '
                    ' Compute L(J+1,J+1) and test for non-positive-definiteness.
                    '
                    v = 0.0
                    For i_ = offs To offs + j - 1
                        v += Math.conj(aaa(offs + j, i_)) * aaa(offs + j, i_)
                    Next
                    ajj = (aaa(offs + j, offs + j) - v).x
                    If CDbl(ajj) <= CDbl(0) Then
                        aaa(offs + j, offs + j) = ajj
                        result = False
                        Return result
                    End If
                    ajj = System.Math.sqrt(ajj)
                    aaa(offs + j, offs + j) = ajj

                    '
                    ' Compute elements J+1:N of column J.
                    '
                    If j < n - 1 Then
                        If j > 0 Then
                            i1_ = (offs) - (0)
                            For i_ = 0 To j - 1
                                tmp(i_) = Math.conj(aaa(offs + j, i_ + i1_))
                            Next
                            ablas.cmatrixmv(n - j - 1, j, aaa, offs + j + 1, offs, 0, _
                                tmp, 0, tmp, n)
                            For i = 0 To n - j - 2
                                aaa(offs + j + 1 + i, offs + j) = (aaa(offs + j + 1 + i, offs + j) - tmp(n + i)) / ajj
                            Next
                        Else
                            For i = 0 To n - j - 2
                                aaa(offs + j + 1 + i, offs + j) = aaa(offs + j + 1 + i, offs + j) / ajj
                            Next
                        End If
                    End If
                Next
            End If
            Return result
        End Function


        '************************************************************************
        '        Level-2 Cholesky subroutine
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Function spdmatrixcholesky2(ByRef aaa As Double(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As Double()) As Boolean
            Dim result As New Boolean()
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim ajj As Double = 0
            Dim v As Double = 0
            Dim r As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            result = True
            If n < 0 Then
                result = False
                Return result
            End If

            '
            ' Quick return if possible
            '
            If n = 0 Then
                Return result
            End If
            If isupper Then

                '
                ' Compute the Cholesky factorization A = U'*U.
                '
                For j = 0 To n - 1

                    '
                    ' Compute U(J,J) and test for non-positive-definiteness.
                    '
                    v = 0.0
                    For i_ = offs To offs + j - 1
                        v += aaa(i_, offs + j) * aaa(i_, offs + j)
                    Next
                    ajj = aaa(offs + j, offs + j) - v
                    If CDbl(ajj) <= CDbl(0) Then
                        aaa(offs + j, offs + j) = ajj
                        result = False
                        Return result
                    End If
                    ajj = System.Math.sqrt(ajj)
                    aaa(offs + j, offs + j) = ajj

                    '
                    ' Compute elements J+1:N-1 of row J.
                    '
                    If j < n - 1 Then
                        If j > 0 Then
                            i1_ = (offs) - (0)
                            For i_ = 0 To j - 1
                                tmp(i_) = -aaa(i_ + i1_, offs + j)
                            Next
                            ablas.rmatrixmv(n - j - 1, j, aaa, offs, offs + j + 1, 1, _
                                tmp, 0, tmp, n)
                            i1_ = (n) - (offs + j + 1)
                            For i_ = offs + j + 1 To offs + n - 1
                                aaa(offs + j, i_) = aaa(offs + j, i_) + tmp(i_ + i1_)
                            Next
                        End If
                        r = 1 / ajj
                        For i_ = offs + j + 1 To offs + n - 1
                            aaa(offs + j, i_) = r * aaa(offs + j, i_)
                        Next
                    End If
                Next
            Else

                '
                ' Compute the Cholesky factorization A = L*L'.
                '
                For j = 0 To n - 1

                    '
                    ' Compute L(J+1,J+1) and test for non-positive-definiteness.
                    '
                    v = 0.0
                    For i_ = offs To offs + j - 1
                        v += aaa(offs + j, i_) * aaa(offs + j, i_)
                    Next
                    ajj = aaa(offs + j, offs + j) - v
                    If CDbl(ajj) <= CDbl(0) Then
                        aaa(offs + j, offs + j) = ajj
                        result = False
                        Return result
                    End If
                    ajj = System.Math.sqrt(ajj)
                    aaa(offs + j, offs + j) = ajj

                    '
                    ' Compute elements J+1:N of column J.
                    '
                    If j < n - 1 Then
                        If j > 0 Then
                            i1_ = (offs) - (0)
                            For i_ = 0 To j - 1
                                tmp(i_) = aaa(offs + j, i_ + i1_)
                            Next
                            ablas.rmatrixmv(n - j - 1, j, aaa, offs + j + 1, offs, 0, _
                                tmp, 0, tmp, n)
                            For i = 0 To n - j - 2
                                aaa(offs + j + 1 + i, offs + j) = (aaa(offs + j + 1 + i, offs + j) - tmp(n + i)) / ajj
                            Next
                        Else
                            For i = 0 To n - j - 2
                                aaa(offs + j + 1 + i, offs + j) = aaa(offs + j + 1 + i, offs + j) / ajj
                            Next
                        End If
                    End If
                Next
            End If
            Return result
        End Function


    End Class
    Public Class rcond
        '************************************************************************
        '        Estimate of a matrix condition number (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixrcond1(a As Double(,), n As Integer) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim t As Double() = New Double(-1) {}

            a = DirectCast(a.Clone(), Double(,))

            alglib.ap.assert(n >= 1, "RMatrixRCond1: N<1!")
            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                For j = 0 To n - 1
                    t(j) = t(j) + System.Math.Abs(a(i, j))
                Next
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            trfac.rmatrixlu(a, n, n, pivots)
            rmatrixrcondluinternal(a, n, True, True, nrm, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of a matrix condition number (infinity-norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixrcondinf(a As Double(,), n As Integer) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}

            a = DirectCast(a.Clone(), Double(,))

            alglib.ap.assert(n >= 1, "RMatrixRCondInf: N<1!")
            nrm = 0
            For i = 0 To n - 1
                v = 0
                For j = 0 To n - 1
                    v = v + System.Math.Abs(a(i, j))
                Next
                nrm = System.Math.Max(nrm, v)
            Next
            trfac.rmatrixlu(a, n, n, pivots)
            rmatrixrcondluinternal(a, n, False, True, nrm, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Condition number estimate of a symmetric positive definite matrix.
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        It should be noted that 1-norm and inf-norm of condition numbers of symmetric
        '        matrices are equal, so the algorithm doesn't take into account the
        '        differences between these types of norms.
        '
        '        Input parameters:
        '            A       -   symmetric positive definite matrix which is given by its
        '                        upper or lower triangle depending on the value of
        '                        IsUpper. Array with elements [0..N-1, 0..N-1].
        '            N       -   size of matrix A.
        '            IsUpper -   storage format.
        '
        '        Result:
        '            1/LowerBound(cond(A)), if matrix A is positive definite,
        '           -1, if matrix A is not positive definite, and its condition number
        '            could not be found by this algorithm.
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function spdmatrixrcond(a As Double(,), n As Integer, isupper As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim t As Double() = New Double(-1) {}

            a = DirectCast(a.Clone(), Double(,))

            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                If isupper Then
                    j1 = i
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i
                End If
                For j = j1 To j2
                    If i = j Then
                        t(i) = t(i) + System.Math.Abs(a(i, i))
                    Else
                        t(i) = t(i) + System.Math.Abs(a(i, j))
                        t(j) = t(j) + System.Math.Abs(a(i, j))
                    End If
                Next
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            If trfac.spdmatrixcholesky(a, n, isupper) Then
                spdmatrixrcondcholeskyinternal(a, n, isupper, True, nrm, v)
                result = v
            Else
                result = -1
            End If
            Return result
        End Function


        '************************************************************************
        '        Triangular matrix: estimate of a condition number (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A       -   matrix. Array[0..N-1, 0..N-1].
        '            N       -   size of A.
        '            IsUpper -   True, if the matrix is upper triangular.
        '            IsUnit  -   True, if the matrix has a unit diagonal.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixtrrcond1(a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim t As Double() = New Double(-1) {}
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0

            alglib.ap.assert(n >= 1, "RMatrixTRRCond1: N<1!")
            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                For j = j1 To j2
                    t(j) = t(j) + System.Math.Abs(a(i, j))
                Next
                If isunit Then
                    t(i) = t(i) + 1
                Else
                    t(i) = t(i) + System.Math.Abs(a(i, i))
                End If
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            rmatrixrcondtrinternal(a, n, isupper, isunit, True, nrm, _
                v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Triangular matrix: estimate of a matrix condition number (infinity-norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '            IsUpper -   True, if the matrix is upper triangular.
        '            IsUnit  -   True, if the matrix has a unit diagonal.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixtrrcondinf(a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0

            alglib.ap.assert(n >= 1, "RMatrixTRRCondInf: N<1!")
            nrm = 0
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                v = 0
                For j = j1 To j2
                    v = v + System.Math.Abs(a(i, j))
                Next
                If isunit Then
                    v = v + 1
                Else
                    v = v + System.Math.Abs(a(i, i))
                End If
                nrm = System.Math.Max(nrm, v)
            Next
            rmatrixrcondtrinternal(a, n, isupper, isunit, False, nrm, _
                v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Condition number estimate of a Hermitian positive definite matrix.
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        It should be noted that 1-norm and inf-norm of condition numbers of symmetric
        '        matrices are equal, so the algorithm doesn't take into account the
        '        differences between these types of norms.
        '
        '        Input parameters:
        '            A       -   Hermitian positive definite matrix which is given by its
        '                        upper or lower triangle depending on the value of
        '                        IsUpper. Array with elements [0..N-1, 0..N-1].
        '            N       -   size of matrix A.
        '            IsUpper -   storage format.
        '
        '        Result:
        '            1/LowerBound(cond(A)), if matrix A is positive definite,
        '           -1, if matrix A is not positive definite, and its condition number
        '            could not be found by this algorithm.
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function hpdmatrixrcond(a As complex(,), n As Integer, isupper As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim t As Double() = New Double(-1) {}

            a = DirectCast(a.Clone(), complex(,))

            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                If isupper Then
                    j1 = i
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i
                End If
                For j = j1 To j2
                    If i = j Then
                        t(i) = t(i) + Math.abscomplex(a(i, i))
                    Else
                        t(i) = t(i) + Math.abscomplex(a(i, j))
                        t(j) = t(j) + Math.abscomplex(a(i, j))
                    End If
                Next
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            If trfac.hpdmatrixcholesky(a, n, isupper) Then
                hpdmatrixrcondcholeskyinternal(a, n, isupper, True, nrm, v)
                result = v
            Else
                result = -1
            End If
            Return result
        End Function


        '************************************************************************
        '        Estimate of a matrix condition number (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixrcond1(a As complex(,), n As Integer) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim t As Double() = New Double(-1) {}

            a = DirectCast(a.Clone(), complex(,))

            alglib.ap.assert(n >= 1, "CMatrixRCond1: N<1!")
            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                For j = 0 To n - 1
                    t(j) = t(j) + Math.abscomplex(a(i, j))
                Next
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            trfac.cmatrixlu(a, n, n, pivots)
            cmatrixrcondluinternal(a, n, True, True, nrm, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of a matrix condition number (infinity-norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixrcondinf(a As complex(,), n As Integer) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}

            a = DirectCast(a.Clone(), complex(,))

            alglib.ap.assert(n >= 1, "CMatrixRCondInf: N<1!")
            nrm = 0
            For i = 0 To n - 1
                v = 0
                For j = 0 To n - 1
                    v = v + Math.abscomplex(a(i, j))
                Next
                nrm = System.Math.Max(nrm, v)
            Next
            trfac.cmatrixlu(a, n, n, pivots)
            cmatrixrcondluinternal(a, n, False, True, nrm, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            LUA         -   LU decomposition of a matrix in compact form. Output of
        '                            the RMatrixLU subroutine.
        '            N           -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixlurcond1(lua As Double(,), n As Integer) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            rmatrixrcondluinternal(lua, n, True, False, 0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of the condition number of a matrix given by its LU decomposition
        '        (infinity norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            LUA     -   LU decomposition of a matrix in compact form. Output of
        '                        the RMatrixLU subroutine.
        '            N       -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function rmatrixlurcondinf(lua As Double(,), n As Integer) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            rmatrixrcondluinternal(lua, n, False, False, 0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Condition number estimate of a symmetric positive definite matrix given by
        '        Cholesky decomposition.
        '
        '        The algorithm calculates a lower bound of the condition number. In this
        '        case, the algorithm does not return a lower bound of the condition number,
        '        but an inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        It should be noted that 1-norm and inf-norm condition numbers of symmetric
        '        matrices are equal, so the algorithm doesn't take into account the
        '        differences between these types of norms.
        '
        '        Input parameters:
        '            CD  - Cholesky decomposition of matrix A,
        '                  output of SMatrixCholesky subroutine.
        '            N   - size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function spdmatrixcholeskyrcond(a As Double(,), n As Integer, isupper As Boolean) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            spdmatrixrcondcholeskyinternal(a, n, isupper, False, 0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Condition number estimate of a Hermitian positive definite matrix given by
        '        Cholesky decomposition.
        '
        '        The algorithm calculates a lower bound of the condition number. In this
        '        case, the algorithm does not return a lower bound of the condition number,
        '        but an inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        It should be noted that 1-norm and inf-norm condition numbers of symmetric
        '        matrices are equal, so the algorithm doesn't take into account the
        '        differences between these types of norms.
        '
        '        Input parameters:
        '            CD  - Cholesky decomposition of matrix A,
        '                  output of SMatrixCholesky subroutine.
        '            N   - size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function hpdmatrixcholeskyrcond(a As complex(,), n As Integer, isupper As Boolean) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            hpdmatrixrcondcholeskyinternal(a, n, isupper, False, 0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            LUA         -   LU decomposition of a matrix in compact form. Output of
        '                            the CMatrixLU subroutine.
        '            N           -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixlurcond1(lua As complex(,), n As Integer) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            alglib.ap.assert(n >= 1, "CMatrixLURCond1: N<1!")
            cmatrixrcondluinternal(lua, n, True, False, 0.0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Estimate of the condition number of a matrix given by its LU decomposition
        '        (infinity norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            LUA     -   LU decomposition of a matrix in compact form. Output of
        '                        the CMatrixLU subroutine.
        '            N       -   size of matrix A.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixlurcondinf(lua As complex(,), n As Integer) As Double
            Dim result As Double = 0
            Dim v As Double = 0

            alglib.ap.assert(n >= 1, "CMatrixLURCondInf: N<1!")
            cmatrixrcondluinternal(lua, n, False, False, 0.0, v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Triangular matrix: estimate of a condition number (1-norm)
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A       -   matrix. Array[0..N-1, 0..N-1].
        '            N       -   size of A.
        '            IsUpper -   True, if the matrix is upper triangular.
        '            IsUnit  -   True, if the matrix has a unit diagonal.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixtrrcond1(a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim t As Double() = New Double(-1) {}
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0

            alglib.ap.assert(n >= 1, "RMatrixTRRCond1: N<1!")
            t = New Double(n - 1) {}
            For i = 0 To n - 1
                t(i) = 0
            Next
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                For j = j1 To j2
                    t(j) = t(j) + Math.abscomplex(a(i, j))
                Next
                If isunit Then
                    t(i) = t(i) + 1
                Else
                    t(i) = t(i) + Math.abscomplex(a(i, i))
                End If
            Next
            nrm = 0
            For i = 0 To n - 1
                nrm = System.Math.Max(nrm, t(i))
            Next
            cmatrixrcondtrinternal(a, n, isupper, isunit, True, nrm, _
                v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Triangular matrix: estimate of a matrix condition number (infinity-norm).
        '
        '        The algorithm calculates a lower bound of the condition number. In this case,
        '        the algorithm does not return a lower bound of the condition number, but an
        '        inverse number (to avoid an overflow in case of a singular matrix).
        '
        '        Input parameters:
        '            A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
        '            N   -   size of matrix A.
        '            IsUpper -   True, if the matrix is upper triangular.
        '            IsUnit  -   True, if the matrix has a unit diagonal.
        '
        '        Result: 1/LowerBound(cond(A))
        '
        '        NOTE:
        '            if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
        '            0.0 is returned in such cases.
        '        ************************************************************************

        Public Shared Function cmatrixtrrcondinf(a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean) As Double
            Dim result As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim v As Double = 0
            Dim nrm As Double = 0
            Dim pivots As Integer() = New Integer(-1) {}
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0

            alglib.ap.assert(n >= 1, "RMatrixTRRCondInf: N<1!")
            nrm = 0
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                v = 0
                For j = j1 To j2
                    v = v + Math.abscomplex(a(i, j))
                Next
                If isunit Then
                    v = v + 1
                Else
                    v = v + Math.abscomplex(a(i, i))
                End If
                nrm = System.Math.Max(nrm, v)
            Next
            cmatrixrcondtrinternal(a, n, isupper, isunit, False, nrm, _
                v)
            result = v
            Return result
        End Function


        '************************************************************************
        '        Threshold for rcond: matrices with condition number beyond this  threshold
        '        are considered singular.
        '
        '        Threshold must be far enough from underflow, at least Sqr(Threshold)  must
        '        be greater than underflow.
        '        ************************************************************************

        Public Shared Function rcondthreshold() As Double
            Dim result As Double = 0

            result = System.Math.sqrt(System.Math.sqrt(Math.minrealnumber))
            Return result
        End Function


        '************************************************************************
        '        Internal subroutine for condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Sub rmatrixrcondtrinternal(a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean, onenorm As Boolean, anorm As Double, _
            ByRef rc As Double)
            Dim ex As Double() = New Double(-1) {}
            Dim ev As Double() = New Double(-1) {}
            Dim iwork As Integer() = New Integer(-1) {}
            Dim tmp As Double() = New Double(-1) {}
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim kase As Integer = 0
            Dim kase1 As Integer = 0
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0
            Dim ainvnm As Double = 0
            Dim maxgrowth As Double = 0
            Dim s As Double = 0

            rc = 0


            '
            ' RC=0 if something happens
            '
            rc = 0

            '
            ' init
            '
            If onenorm Then
                kase1 = 1
            Else
                kase1 = 2
            End If
            iwork = New Integer(n) {}
            tmp = New Double(n - 1) {}

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            s = 0
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                For j = j1 To j2
                    s = System.Math.Max(s, System.Math.Abs(a(i, j)))
                Next
                If isunit Then
                    s = System.Math.Max(s, 1)
                Else
                    s = System.Math.Max(s, System.Math.Abs(a(i, i)))
                End If
            Next
            If CDbl(s) = CDbl(0) Then
                s = 1
            End If
            s = 1 / s

            '
            ' Scale according to S
            '
            anorm = anorm * s

            '
            ' Quick return if possible
            ' We assume that ANORM<>0 after this block
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If
            If n = 1 Then
                rc = 1
                Return
            End If

            '
            ' Estimate the norm of inv(A).
            '
            ainvnm = 0
            kase = 0
            While True
                rmatrixestimatenorm(n, ev, ex, iwork, ainvnm, kase)
                If kase = 0 Then
                    Exit While
                End If

                '
                ' from 1-based array to 0-based
                '
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next

                '
                ' multiply by inv(A) or inv(A')
                '
                If kase = kase1 Then

                    '
                    ' multiply by inv(A)
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(a, s, n, ex, isupper, 0, _
                        isunit, maxgrowth) Then
                        Return
                    End If
                Else

                    '
                    ' multiply by inv(A')
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(a, s, n, ex, isupper, 1, _
                        isunit, maxgrowth) Then
                        Return
                    End If
                End If

                '
                ' from 0-based array to 1-based
                '
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                rc = 1 / ainvnm
                rc = rc / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             March 31, 1993
        '        ************************************************************************

        Private Shared Sub cmatrixrcondtrinternal(a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean, onenorm As Boolean, anorm As Double, _
            ByRef rc As Double)
            Dim ex As complex() = New complex(-1) {}
            Dim cwork2 As complex() = New complex(-1) {}
            Dim cwork3 As complex() = New complex(-1) {}
            Dim cwork4 As complex() = New complex(-1) {}
            Dim isave As Integer() = New Integer(-1) {}
            Dim rsave As Double() = New Double(-1) {}
            Dim kase As Integer = 0
            Dim kase1 As Integer = 0
            Dim ainvnm As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim j1 As Integer = 0
            Dim j2 As Integer = 0
            Dim s As Double = 0
            Dim maxgrowth As Double = 0

            rc = 0


            '
            ' RC=0 if something happens
            '
            rc = 0

            '
            ' init
            '
            If n <= 0 Then
                Return
            End If
            If n = 0 Then
                rc = 1
                Return
            End If
            cwork2 = New complex(n) {}

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            s = 0
            For i = 0 To n - 1
                If isupper Then
                    j1 = i + 1
                    j2 = n - 1
                Else
                    j1 = 0
                    j2 = i - 1
                End If
                For j = j1 To j2
                    s = System.Math.Max(s, Math.abscomplex(a(i, j)))
                Next
                If isunit Then
                    s = System.Math.Max(s, 1)
                Else
                    s = System.Math.Max(s, Math.abscomplex(a(i, i)))
                End If
            Next
            If CDbl(s) = CDbl(0) Then
                s = 1
            End If
            s = 1 / s

            '
            ' Scale according to S
            '
            anorm = anorm * s

            '
            ' Quick return if possible
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If

            '
            ' Estimate the norm of inv(A).
            '
            ainvnm = 0
            If onenorm Then
                kase1 = 1
            Else
                kase1 = 2
            End If
            kase = 0
            While True
                cmatrixestimatenorm(n, cwork4, ex, ainvnm, kase, isave, _
                    rsave)
                If kase = 0 Then
                    Exit While
                End If

                '
                ' From 1-based to 0-based
                '
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next

                '
                ' multiply by inv(A) or inv(A')
                '
                If kase = kase1 Then

                    '
                    ' multiply by inv(A)
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(a, s, n, ex, isupper, 0, _
                        isunit, maxgrowth) Then
                        Return
                    End If
                Else

                    '
                    ' multiply by inv(A')
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(a, s, n, ex, isupper, 2, _
                        isunit, maxgrowth) Then
                        Return
                    End If
                End If

                '
                ' from 0-based to 1-based
                '
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                rc = 1 / ainvnm
                rc = rc / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Internal subroutine for condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Sub spdmatrixrcondcholeskyinternal(cha As Double(,), n As Integer, isupper As Boolean, isnormprovided As Boolean, anorm As Double, ByRef rc As Double)
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim kase As Integer = 0
            Dim ainvnm As Double = 0
            Dim ex As Double() = New Double(-1) {}
            Dim ev As Double() = New Double(-1) {}
            Dim tmp As Double() = New Double(-1) {}
            Dim iwork As Integer() = New Integer(-1) {}
            Dim sa As Double = 0
            Dim v As Double = 0
            Dim maxgrowth As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            rc = 0

            alglib.ap.assert(n >= 1)
            tmp = New Double(n - 1) {}

            '
            ' RC=0 if something happens
            '
            rc = 0

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            sa = 0
            If isupper Then
                For i = 0 To n - 1
                    For j = i To n - 1
                        sa = System.Math.Max(sa, Math.abscomplex(cha(i, j)))
                    Next
                Next
            Else
                For i = 0 To n - 1
                    For j = 0 To i
                        sa = System.Math.Max(sa, Math.abscomplex(cha(i, j)))
                    Next
                Next
            End If
            If CDbl(sa) = CDbl(0) Then
                sa = 1
            End If
            sa = 1 / sa

            '
            ' Estimate the norm of A.
            '
            If Not isnormprovided Then
                kase = 0
                anorm = 0
                While True
                    rmatrixestimatenorm(n, ev, ex, iwork, anorm, kase)
                    If kase = 0 Then
                        Exit While
                    End If
                    If isupper Then

                        '
                        ' Multiply by U
                        '
                        For i = 1 To n
                            i1_ = (i) - (i - 1)
                            v = 0.0
                            For i_ = i - 1 To n - 1
                                v += cha(i - 1, i_) * ex(i_ + i1_)
                            Next
                            ex(i) = v
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next

                        '
                        ' Multiply by U'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            For i_ = i To n - 1
                                tmp(i_) = tmp(i_) + v * cha(i, i_)
                            Next
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next
                    Else

                        '
                        ' Multiply by L'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            For i_ = 0 To i
                                tmp(i_) = tmp(i_) + v * cha(i, i_)
                            Next
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next

                        '
                        ' Multiply by L
                        '
                        For i = n To 1 Step -1
                            i1_ = (1) - (0)
                            v = 0.0
                            For i_ = 0 To i - 1
                                v += cha(i - 1, i_) * ex(i_ + i1_)
                            Next
                            ex(i) = v
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next
                    End If
                End While
            End If

            '
            ' Quick return if possible
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If
            If n = 1 Then
                rc = 1
                Return
            End If

            '
            ' Estimate the 1-norm of inv(A).
            '
            kase = 0
            While True
                rmatrixestimatenorm(n, ev, ex, iwork, ainvnm, kase)
                If kase = 0 Then
                    Exit While
                End If
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next
                If isupper Then

                    '
                    ' Multiply by inv(U').
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 1, _
                        False, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(U).
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 0, _
                        False, maxgrowth) Then
                        Return
                    End If
                Else

                    '
                    ' Multiply by inv(L).
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 0, _
                        False, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(L').
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 1, _
                        False, maxgrowth) Then
                        Return
                    End If
                End If
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                v = 1 / ainvnm
                rc = v / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Internal subroutine for condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Sub hpdmatrixrcondcholeskyinternal(cha As complex(,), n As Integer, isupper As Boolean, isnormprovided As Boolean, anorm As Double, ByRef rc As Double)
            Dim isave As Integer() = New Integer(-1) {}
            Dim rsave As Double() = New Double(-1) {}
            Dim ex As complex() = New complex(-1) {}
            Dim ev As complex() = New complex(-1) {}
            Dim tmp As complex() = New complex(-1) {}
            Dim kase As Integer = 0
            Dim ainvnm As Double = 0
            Dim v As complex = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim sa As Double = 0
            Dim maxgrowth As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            rc = 0

            alglib.ap.assert(n >= 1)
            tmp = New complex(n - 1) {}

            '
            ' RC=0 if something happens
            '
            rc = 0

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            sa = 0
            If isupper Then
                For i = 0 To n - 1
                    For j = i To n - 1
                        sa = System.Math.Max(sa, Math.abscomplex(cha(i, j)))
                    Next
                Next
            Else
                For i = 0 To n - 1
                    For j = 0 To i
                        sa = System.Math.Max(sa, Math.abscomplex(cha(i, j)))
                    Next
                Next
            End If
            If CDbl(sa) = CDbl(0) Then
                sa = 1
            End If
            sa = 1 / sa

            '
            ' Estimate the norm of A
            '
            If Not isnormprovided Then
                anorm = 0
                kase = 0
                While True
                    cmatrixestimatenorm(n, ev, ex, anorm, kase, isave, _
                        rsave)
                    If kase = 0 Then
                        Exit While
                    End If
                    If isupper Then

                        '
                        ' Multiply by U
                        '
                        For i = 1 To n
                            i1_ = (i) - (i - 1)
                            v = 0.0
                            For i_ = i - 1 To n - 1
                                v += cha(i - 1, i_) * ex(i_ + i1_)
                            Next
                            ex(i) = v
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next

                        '
                        ' Multiply by U'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            For i_ = i To n - 1
                                tmp(i_) = tmp(i_) + v * Math.conj(cha(i, i_))
                            Next
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next
                    Else

                        '
                        ' Multiply by L'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            For i_ = 0 To i
                                tmp(i_) = tmp(i_) + v * Math.conj(cha(i, i_))
                            Next
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next

                        '
                        ' Multiply by L
                        '
                        For i = n To 1 Step -1
                            i1_ = (1) - (0)
                            v = 0.0
                            For i_ = 0 To i - 1
                                v += cha(i - 1, i_) * ex(i_ + i1_)
                            Next
                            ex(i) = v
                        Next
                        For i_ = 1 To n
                            ex(i_) = sa * ex(i_)
                        Next
                    End If
                End While
            End If

            '
            ' Quick return if possible
            ' After this block we assume that ANORM<>0
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If
            If n = 1 Then
                rc = 1
                Return
            End If

            '
            ' Estimate the norm of inv(A).
            '
            ainvnm = 0
            kase = 0
            While True
                cmatrixestimatenorm(n, ev, ex, ainvnm, kase, isave, _
                    rsave)
                If kase = 0 Then
                    Exit While
                End If
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next
                If isupper Then

                    '
                    ' Multiply by inv(U').
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 2, _
                        False, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(U).
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 0, _
                        False, maxgrowth) Then
                        Return
                    End If
                Else

                    '
                    ' Multiply by inv(L).
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 0, _
                        False, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(L').
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(cha, sa, n, ex, isupper, 2, _
                        False, maxgrowth) Then
                        Return
                    End If
                End If
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                rc = 1 / ainvnm
                rc = rc / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Internal subroutine for condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Sub rmatrixrcondluinternal(lua As Double(,), n As Integer, onenorm As Boolean, isanormprovided As Boolean, anorm As Double, ByRef rc As Double)
            Dim ex As Double() = New Double(-1) {}
            Dim ev As Double() = New Double(-1) {}
            Dim iwork As Integer() = New Integer(-1) {}
            Dim tmp As Double() = New Double(-1) {}
            Dim v As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim kase As Integer = 0
            Dim kase1 As Integer = 0
            Dim ainvnm As Double = 0
            Dim maxgrowth As Double = 0
            Dim su As Double = 0
            Dim sl As Double = 0
            Dim mupper As New Boolean()
            Dim munit As New Boolean()
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            rc = 0


            '
            ' RC=0 if something happens
            '
            rc = 0

            '
            ' init
            '
            If onenorm Then
                kase1 = 1
            Else
                kase1 = 2
            End If
            mupper = True
            munit = True
            iwork = New Integer(n) {}
            tmp = New Double(n - 1) {}

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            su = 0
            sl = 1
            For i = 0 To n - 1
                For j = 0 To i - 1
                    sl = System.Math.Max(sl, System.Math.Abs(lua(i, j)))
                Next
                For j = i To n - 1
                    su = System.Math.Max(su, System.Math.Abs(lua(i, j)))
                Next
            Next
            If CDbl(su) = CDbl(0) Then
                su = 1
            End If
            su = 1 / su
            sl = 1 / sl

            '
            ' Estimate the norm of A.
            '
            If Not isanormprovided Then
                kase = 0
                anorm = 0
                While True
                    rmatrixestimatenorm(n, ev, ex, iwork, anorm, kase)
                    If kase = 0 Then
                        Exit While
                    End If
                    If kase = kase1 Then

                        '
                        ' Multiply by U
                        '
                        For i = 1 To n
                            i1_ = (i) - (i - 1)
                            v = 0.0
                            For i_ = i - 1 To n - 1
                                v += lua(i - 1, i_) * ex(i_ + i1_)
                            Next
                            ex(i) = v
                        Next

                        '
                        ' Multiply by L
                        '
                        For i = n To 1 Step -1
                            If i > 1 Then
                                i1_ = (1) - (0)
                                v = 0.0
                                For i_ = 0 To i - 2
                                    v += lua(i - 1, i_) * ex(i_ + i1_)
                                Next
                            Else
                                v = 0
                            End If
                            ex(i) = ex(i) + v
                        Next
                    Else

                        '
                        ' Multiply by L'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            If i >= 1 Then
                                For i_ = 0 To i - 1
                                    tmp(i_) = tmp(i_) + v * lua(i, i_)
                                Next
                            End If
                            tmp(i) = tmp(i) + v
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next

                        '
                        ' Multiply by U'
                        '
                        For i = 0 To n - 1
                            tmp(i) = 0
                        Next
                        For i = 0 To n - 1
                            v = ex(i + 1)
                            For i_ = i To n - 1
                                tmp(i_) = tmp(i_) + v * lua(i, i_)
                            Next
                        Next
                        i1_ = (0) - (1)
                        For i_ = 1 To n
                            ex(i_) = tmp(i_ + i1_)
                        Next
                    End If
                End While
            End If

            '
            ' Scale according to SU/SL
            '
            anorm = anorm * su * sl

            '
            ' Quick return if possible
            ' We assume that ANORM<>0 after this block
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If
            If n = 1 Then
                rc = 1
                Return
            End If

            '
            ' Estimate the norm of inv(A).
            '
            ainvnm = 0
            kase = 0
            While True
                rmatrixestimatenorm(n, ev, ex, iwork, ainvnm, kase)
                If kase = 0 Then
                    Exit While
                End If

                '
                ' from 1-based array to 0-based
                '
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next

                '
                ' multiply by inv(A) or inv(A')
                '
                If kase = kase1 Then

                    '
                    ' Multiply by inv(L).
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(lua, sl, n, ex, Not mupper, 0, _
                        munit, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(U).
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(lua, su, n, ex, mupper, 0, _
                        Not munit, maxgrowth) Then
                        Return
                    End If
                Else

                    '
                    ' Multiply by inv(U').
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(lua, su, n, ex, mupper, 1, _
                        Not munit, maxgrowth) Then
                        Return
                    End If

                    '
                    ' Multiply by inv(L').
                    '
                    If Not safesolve.rmatrixscaledtrsafesolve(lua, sl, n, ex, Not mupper, 1, _
                        munit, maxgrowth) Then
                        Return
                    End If
                End If

                '
                ' from 0-based array to 1-based
                '
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                rc = 1 / ainvnm
                rc = rc / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Condition number estimation
        '
        '          -- LAPACK routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             March 31, 1993
        '        ************************************************************************

        Private Shared Sub cmatrixrcondluinternal(lua As complex(,), n As Integer, onenorm As Boolean, isanormprovided As Boolean, anorm As Double, ByRef rc As Double)
            Dim ex As complex() = New complex(-1) {}
            Dim cwork2 As complex() = New complex(-1) {}
            Dim cwork3 As complex() = New complex(-1) {}
            Dim cwork4 As complex() = New complex(-1) {}
            Dim isave As Integer() = New Integer(-1) {}
            Dim rsave As Double() = New Double(-1) {}
            Dim kase As Integer = 0
            Dim kase1 As Integer = 0
            Dim ainvnm As Double = 0
            Dim v As complex = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim su As Double = 0
            Dim sl As Double = 0
            Dim maxgrowth As Double = 0
            Dim i_ As Integer = 0
            Dim i1_ As Integer = 0

            rc = 0

            If n <= 0 Then
                Return
            End If
            cwork2 = New complex(n) {}
            rc = 0
            If n = 0 Then
                rc = 1
                Return
            End If

            '
            ' prepare parameters for triangular solver
            '
            maxgrowth = 1 / rcondthreshold()
            su = 0
            sl = 1
            For i = 0 To n - 1
                For j = 0 To i - 1
                    sl = System.Math.Max(sl, Math.abscomplex(lua(i, j)))
                Next
                For j = i To n - 1
                    su = System.Math.Max(su, Math.abscomplex(lua(i, j)))
                Next
            Next
            If CDbl(su) = CDbl(0) Then
                su = 1
            End If
            su = 1 / su
            sl = 1 / sl

            '
            ' Estimate the norm of SU*SL*A.
            '
            If Not isanormprovided Then
                anorm = 0
                If onenorm Then
                    kase1 = 1
                Else
                    kase1 = 2
                End If
                kase = 0
                Do
                    cmatrixestimatenorm(n, cwork4, ex, anorm, kase, isave, _
                        rsave)
                    If kase <> 0 Then
                        If kase = kase1 Then

                            '
                            ' Multiply by U
                            '
                            For i = 1 To n
                                i1_ = (i) - (i - 1)
                                v = 0.0
                                For i_ = i - 1 To n - 1
                                    v += lua(i - 1, i_) * ex(i_ + i1_)
                                Next
                                ex(i) = v
                            Next

                            '
                            ' Multiply by L
                            '
                            For i = n To 1 Step -1
                                v = 0
                                If i > 1 Then
                                    i1_ = (1) - (0)
                                    v = 0.0
                                    For i_ = 0 To i - 2
                                        v += lua(i - 1, i_) * ex(i_ + i1_)
                                    Next
                                End If
                                ex(i) = v + ex(i)
                            Next
                        Else

                            '
                            ' Multiply by L'
                            '
                            For i = 1 To n
                                cwork2(i) = 0
                            Next
                            For i = 1 To n
                                v = ex(i)
                                If i > 1 Then
                                    i1_ = (0) - (1)
                                    For i_ = 1 To i - 1
                                        cwork2(i_) = cwork2(i_) + v * Math.conj(lua(i - 1, i_ + i1_))
                                    Next
                                End If
                                cwork2(i) = cwork2(i) + v
                            Next

                            '
                            ' Multiply by U'
                            '
                            For i = 1 To n
                                ex(i) = 0
                            Next
                            For i = 1 To n
                                v = cwork2(i)
                                i1_ = (i - 1) - (i)
                                For i_ = i To n
                                    ex(i_) = ex(i_) + v * Math.conj(lua(i - 1, i_ + i1_))
                                Next
                            Next
                        End If
                    End If
                Loop While kase <> 0
            End If

            '
            ' Scale according to SU/SL
            '
            anorm = anorm * su * sl

            '
            ' Quick return if possible
            '
            If CDbl(anorm) = CDbl(0) Then
                Return
            End If

            '
            ' Estimate the norm of inv(A).
            '
            ainvnm = 0
            If onenorm Then
                kase1 = 1
            Else
                kase1 = 2
            End If
            kase = 0
            While True
                cmatrixestimatenorm(n, cwork4, ex, ainvnm, kase, isave, _
                    rsave)
                If kase = 0 Then
                    Exit While
                End If

                '
                ' From 1-based to 0-based
                '
                For i = 0 To n - 1
                    ex(i) = ex(i + 1)
                Next

                '
                ' multiply by inv(A) or inv(A')
                '
                If kase = kase1 Then

                    '
                    ' Multiply by inv(L).
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(lua, sl, n, ex, False, 0, _
                        True, maxgrowth) Then
                        rc = 0
                        Return
                    End If

                    '
                    ' Multiply by inv(U).
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(lua, su, n, ex, True, 0, _
                        False, maxgrowth) Then
                        rc = 0
                        Return
                    End If
                Else

                    '
                    ' Multiply by inv(U').
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(lua, su, n, ex, True, 2, _
                        False, maxgrowth) Then
                        rc = 0
                        Return
                    End If

                    '
                    ' Multiply by inv(L').
                    '
                    If Not safesolve.cmatrixscaledtrsafesolve(lua, sl, n, ex, False, 2, _
                        True, maxgrowth) Then
                        rc = 0
                        Return
                    End If
                End If

                '
                ' from 0-based to 1-based
                '
                For i = n - 1 To 0 Step -1
                    ex(i + 1) = ex(i)
                Next
            End While

            '
            ' Compute the estimate of the reciprocal condition number.
            '
            If CDbl(ainvnm) <> CDbl(0) Then
                rc = 1 / ainvnm
                rc = rc / anorm
                If CDbl(rc) < CDbl(rcondthreshold()) Then
                    rc = 0
                End If
            End If
        End Sub


        '************************************************************************
        '        Internal subroutine for matrix norm estimation
        '
        '          -- LAPACK auxiliary routine (version 3.0) --
        '             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
        '             Courant Institute, Argonne National Lab, and Rice University
        '             February 29, 1992
        '        ************************************************************************

        Private Shared Sub rmatrixestimatenorm(n As Integer, ByRef v As Double(), ByRef x As Double(), ByRef isgn As Integer(), ByRef est As Double, ByRef kase As Integer)
            Dim itmax As Integer = 0
            Dim i As Integer = 0
            Dim t As Double = 0
            Dim flg As New Boolean()
            Dim positer As Integer = 0
            Dim posj As Integer = 0
            Dim posjlast As Integer = 0
            Dim posjump As Integer = 0
            Dim posaltsgn As Integer = 0
            Dim posestold As Integer = 0
            Dim postemp As Integer = 0
            Dim i_ As Integer = 0

            itmax = 5
            posaltsgn = n + 1
            posestold = n + 2
            postemp = n + 3
            positer = n + 1
            posj = n + 2
            posjlast = n + 3
            posjump = n + 4
            If kase = 0 Then
                v = New Double(n + 3) {}
                x = New Double(n) {}
                isgn = New Integer(n + 4) {}
                t = CDbl(1) / CDbl(n)
                For i = 1 To n
                    x(i) = t
                Next
                kase = 1
                isgn(posjump) = 1
                Return
            End If

            '
            '     ................ ENTRY   (JUMP = 1)
            '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
            '
            If isgn(posjump) = 1 Then
                If n = 1 Then
                    v(1) = x(1)
                    est = System.Math.Abs(v(1))
                    kase = 0
                    Return
                End If
                est = 0
                For i = 1 To n
                    est = est + System.Math.Abs(x(i))
                Next
                For i = 1 To n
                    If CDbl(x(i)) >= CDbl(0) Then
                        x(i) = 1
                    Else
                        x(i) = -1
                    End If
                    isgn(i) = System.Math.Sign(x(i))
                Next
                kase = 2
                isgn(posjump) = 2
                Return
            End If

            '
            '     ................ ENTRY   (JUMP = 2)
            '     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
            '
            If isgn(posjump) = 2 Then
                isgn(posj) = 1
                For i = 2 To n
                    If CDbl(System.Math.Abs(x(i))) > CDbl(System.Math.Abs(x(isgn(posj)))) Then
                        isgn(posj) = i
                    End If
                Next
                isgn(positer) = 2

                '
                ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
                '
                For i = 1 To n
                    x(i) = 0
                Next
                x(isgn(posj)) = 1
                kase = 1
                isgn(posjump) = 3
                Return
            End If

            '
            '     ................ ENTRY   (JUMP = 3)
            '     X HAS BEEN OVERWRITTEN BY A*X.
            '
            If isgn(posjump) = 3 Then
                For i_ = 1 To n
                    v(i_) = x(i_)
                Next
                v(posestold) = est
                est = 0
                For i = 1 To n
                    est = est + System.Math.Abs(v(i))
                Next
                flg = False
                For i = 1 To n
                    If (CDbl(x(i)) >= CDbl(0) AndAlso isgn(i) < 0) OrElse (CDbl(x(i)) < CDbl(0) AndAlso isgn(i) >= 0) Then
                        flg = True
                    End If
                Next

                '
                ' REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
                ' OR MAY BE CYCLING.
                '
                If Not flg OrElse CDbl(est) <= CDbl(v(posestold)) Then
                    v(posaltsgn) = 1
                    For i = 1 To n
                        x(i) = v(posaltsgn) * (1 + CDbl(i - 1) / CDbl(n - 1))
                        v(posaltsgn) = -v(posaltsgn)
                    Next
                    kase = 1
                    isgn(posjump) = 5
                    Return
                End If
                For i = 1 To n
                    If CDbl(x(i)) >= CDbl(0) Then
                        x(i) = 1
                        isgn(i) = 1
                    Else
                        x(i) = -1
                        isgn(i) = -1
                    End If
                Next
                kase = 2
                isgn(posjump) = 4
                Return
            End If

            '
            '     ................ ENTRY   (JUMP = 4)
            '     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X.
            '
            If isgn(posjump) = 4 Then
                isgn(posjlast) = isgn(posj)
                isgn(posj) = 1
                For i = 2 To n
                    If CDbl(System.Math.Abs(x(i))) > CDbl(System.Math.Abs(x(isgn(posj)))) Then
                        isgn(posj) = i
                    End If
                Next
                If CDbl(x(isgn(posjlast))) <> CDbl(System.Math.Abs(x(isgn(posj)))) AndAlso isgn(positer) < itmax Then
                    isgn(positer) = isgn(positer) + 1
                    For i = 1 To n
                        x(i) = 0
                    Next
                    x(isgn(posj)) = 1
                    kase = 1
                    isgn(posjump) = 3
                    Return
                End If

                '
                ' ITERATION COMPLETE.  FINAL STAGE.
                '
                v(posaltsgn) = 1
                For i = 1 To n
                    x(i) = v(posaltsgn) * (1 + CDbl(i - 1) / CDbl(n - 1))
                    v(posaltsgn) = -v(posaltsgn)
                Next
                kase = 1
                isgn(posjump) = 5
                Return
            End If

            '
            '     ................ ENTRY   (JUMP = 5)
            '     X HAS BEEN OVERWRITTEN BY A*X.
            '
            If isgn(posjump) = 5 Then
                v(postemp) = 0
                For i = 1 To n
                    v(postemp) = v(postemp) + System.Math.Abs(x(i))
                Next
                v(postemp) = 2 * v(postemp) / (3 * n)
                If CDbl(v(postemp)) > CDbl(est) Then
                    For i_ = 1 To n
                        v(i_) = x(i_)
                    Next
                    est = v(postemp)
                End If
                kase = 0
                Return
            End If
        End Sub


        Private Shared Sub cmatrixestimatenorm(n As Integer, ByRef v As complex(), ByRef x As complex(), ByRef est As Double, ByRef kase As Integer, ByRef isave As Integer(), _
            ByRef rsave As Double())
            Dim itmax As Integer = 0
            Dim i As Integer = 0
            Dim iter As Integer = 0
            Dim j As Integer = 0
            Dim jlast As Integer = 0
            Dim jump As Integer = 0
            Dim absxi As Double = 0
            Dim altsgn As Double = 0
            Dim estold As Double = 0
            Dim safmin As Double = 0
            Dim temp As Double = 0
            Dim i_ As Integer = 0


            '
            'Executable Statements ..
            '
            itmax = 5
            safmin = Math.minrealnumber
            If kase = 0 Then
                v = New complex(n) {}
                x = New complex(n) {}
                isave = New Integer(4) {}
                rsave = New Double(3) {}
                For i = 1 To n
                    x(i) = CDbl(1) / CDbl(n)
                Next
                kase = 1
                jump = 1
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If
            internalcomplexrcondloadall(isave, rsave, i, iter, j, jlast, _
                jump, absxi, altsgn, estold, temp)

            '
            ' ENTRY   (JUMP = 1)
            ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
            '
            If jump = 1 Then
                If n = 1 Then
                    v(1) = x(1)
                    est = Math.abscomplex(v(1))
                    kase = 0
                    internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                        jump, absxi, altsgn, estold, temp)
                    Return
                End If
                est = internalcomplexrcondscsum1(x, n)
                For i = 1 To n
                    absxi = Math.abscomplex(x(i))
                    If CDbl(absxi) > CDbl(safmin) Then
                        x(i) = x(i) / absxi
                    Else
                        x(i) = 1
                    End If
                Next
                kase = 2
                jump = 2
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If

            '
            ' ENTRY   (JUMP = 2)
            ' FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
            '
            If jump = 2 Then
                j = internalcomplexrcondicmax1(x, n)
                iter = 2

                '
                ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
                '
                For i = 1 To n
                    x(i) = 0
                Next
                x(j) = 1
                kase = 1
                jump = 3
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If

            '
            ' ENTRY   (JUMP = 3)
            ' X HAS BEEN OVERWRITTEN BY A*X.
            '
            If jump = 3 Then
                For i_ = 1 To n
                    v(i_) = x(i_)
                Next
                estold = est
                est = internalcomplexrcondscsum1(v, n)

                '
                ' TEST FOR CYCLING.
                '
                If CDbl(est) <= CDbl(estold) Then

                    '
                    ' ITERATION COMPLETE.  FINAL STAGE.
                    '
                    altsgn = 1
                    For i = 1 To n
                        x(i) = altsgn * (1 + CDbl(i - 1) / CDbl(n - 1))
                        altsgn = -altsgn
                    Next
                    kase = 1
                    jump = 5
                    internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                        jump, absxi, altsgn, estold, temp)
                    Return
                End If
                For i = 1 To n
                    absxi = Math.abscomplex(x(i))
                    If CDbl(absxi) > CDbl(safmin) Then
                        x(i) = x(i) / absxi
                    Else
                        x(i) = 1
                    End If
                Next
                kase = 2
                jump = 4
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If

            '
            ' ENTRY   (JUMP = 4)
            ' X HAS BEEN OVERWRITTEN BY CTRANS(A)*X.
            '
            If jump = 4 Then
                jlast = j
                j = internalcomplexrcondicmax1(x, n)
                If CDbl(Math.abscomplex(x(jlast))) <> CDbl(Math.abscomplex(x(j))) AndAlso iter < itmax Then
                    iter = iter + 1

                    '
                    ' MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
                    '
                    For i = 1 To n
                        x(i) = 0
                    Next
                    x(j) = 1
                    kase = 1
                    jump = 3
                    internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                        jump, absxi, altsgn, estold, temp)
                    Return
                End If

                '
                ' ITERATION COMPLETE.  FINAL STAGE.
                '
                altsgn = 1
                For i = 1 To n
                    x(i) = altsgn * (1 + CDbl(i - 1) / CDbl(n - 1))
                    altsgn = -altsgn
                Next
                kase = 1
                jump = 5
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If

            '
            ' ENTRY   (JUMP = 5)
            ' X HAS BEEN OVERWRITTEN BY A*X.
            '
            If jump = 5 Then
                temp = 2 * (internalcomplexrcondscsum1(x, n) / (3 * n))
                If CDbl(temp) > CDbl(est) Then
                    For i_ = 1 To n
                        v(i_) = x(i_)
                    Next
                    est = temp
                End If
                kase = 0
                internalcomplexrcondsaveall(isave, rsave, i, iter, j, jlast, _
                    jump, absxi, altsgn, estold, temp)
                Return
            End If
        End Sub


        Private Shared Function internalcomplexrcondscsum1(x As complex(), n As Integer) As Double
            Dim result As Double = 0
            Dim i As Integer = 0

            result = 0
            For i = 1 To n
                result = result + Math.abscomplex(x(i))
            Next
            Return result
        End Function


        Private Shared Function internalcomplexrcondicmax1(x As complex(), n As Integer) As Integer
            Dim result As Integer = 0
            Dim i As Integer = 0
            Dim m As Double = 0

            result = 1
            m = Math.abscomplex(x(1))
            For i = 2 To n
                If CDbl(Math.abscomplex(x(i))) > CDbl(m) Then
                    result = i
                    m = Math.abscomplex(x(i))
                End If
            Next
            Return result
        End Function


        Private Shared Sub internalcomplexrcondsaveall(ByRef isave As Integer(), ByRef rsave As Double(), ByRef i As Integer, ByRef iter As Integer, ByRef j As Integer, ByRef jlast As Integer, _
            ByRef jump As Integer, ByRef absxi As Double, ByRef altsgn As Double, ByRef estold As Double, ByRef temp As Double)
            isave(0) = i
            isave(1) = iter
            isave(2) = j
            isave(3) = jlast
            isave(4) = jump
            rsave(0) = absxi
            rsave(1) = altsgn
            rsave(2) = estold
            rsave(3) = temp
        End Sub


        Private Shared Sub internalcomplexrcondloadall(ByRef isave As Integer(), ByRef rsave As Double(), ByRef i As Integer, ByRef iter As Integer, ByRef j As Integer, ByRef jlast As Integer, _
            ByRef jump As Integer, ByRef absxi As Double, ByRef altsgn As Double, ByRef estold As Double, ByRef temp As Double)
            i = isave(0)
            iter = isave(1)
            j = isave(2)
            jlast = isave(3)
            jump = isave(4)
            absxi = rsave(0)
            altsgn = rsave(1)
            estold = rsave(2)
            temp = rsave(3)
        End Sub


    End Class
	Public Class matinv
		'************************************************************************
'        Matrix inverse report:
'        * R1    reciprocal of condition number in 1-norm
'        * RInf  reciprocal of condition number in inf-norm
'        ************************************************************************

		Public Class matinvreport
			Inherits apobject
			Public r1 As Double
			Public rinf As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New matinvreport()
				_result.r1 = r1
				_result.rinf = rinf
				Return _result
			End Function
		End Class




		Public Const parallelsize As Integer = 64


		'************************************************************************
'        Inversion of a matrix given by its LU decomposition.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that matrix inversion  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            A       -   LU decomposition of the matrix
'                        (output of RMatrixLU subroutine).
'            Pivots  -   table of permutations
'                        (the output of RMatrixLU subroutine).
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'
'        OUTPUT PARAMETERS:
'            Info    -   return code:
'                        * -3    A is singular, or VERY close to singular.
'                                it is filled by zeros in such cases.
'                        *  1    task is solved (but matrix A may be ill-conditioned,
'                                check R1/RInf parameters for condition numbers).
'            Rep     -   solver report, see below for more info
'            A       -   inverse of matrix A.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'
'        SOLVER REPORT
'
'        Subroutine sets following fields of the Rep structure:
'        * R1        reciprocal of condition number: 1/cond(A), 1-norm.
'        * RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'          -- ALGLIB routine --
'             05.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), n As Integer, ByRef info As Integer, rep As matinvreport)
			Dim work As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim sinfo As New apserv.sinteger()

			info = 0

			alglib.ap.assert(n > 0, "RMatrixLUInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixLUInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixLUInverse: rows(A)<N!")
			alglib.ap.assert(alglib.ap.len(pivots) >= n, "RMatrixLUInverse: len(Pivots)<N!")
			alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixLUInverse: A contains infinite or NaN values!")
			info = 1
			For i = 0 To n - 1
				If pivots(i) > n - 1 OrElse pivots(i) < i Then
					info = -1
				End If
			Next
			alglib.ap.assert(info > 0, "RMatrixLUInverse: incorrect Pivots array!")

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.rmatrixlurcond1(a, n)
			rep.rinf = rcond.rmatrixlurcondinf(a, n)
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				For i = 0 To n - 1
					For j = 0 To n - 1
						a(i, j) = 0
					Next
				Next
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Call cache-oblivious code
			'
			work = New Double(n - 1) {}
			sinfo.val = 1
			rmatrixluinverserec(a, 0, n, work, sinfo, rep)
			info = sinfo.val

			'
			' apply permutations
			'
			For i = 0 To n - 1
				For j = n - 2 To 0 Step -1
					k = pivots(j)
					v = a(i, j)
					a(i, j) = a(i, k)
					a(i, k) = v
				Next
			Next
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixluinverse(ByRef a As Double(,), pivots As Integer(), n As Integer, ByRef info As Integer, rep As matinvreport)
			rmatrixluinverse(a, pivots, n, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a general matrix.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that matrix inversion  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix.
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'        Result:
'            True, if the matrix is not singular.
'            False, if the matrix is singular.
'
'          -- ALGLIB --
'             Copyright 2005-2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixinverse(ByRef a As Double(,), n As Integer, ByRef info As Integer, rep As matinvreport)
			Dim pivots As Integer() = New Integer(-1) {}

			info = 0

			alglib.ap.assert(n > 0, "RMatrixInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixInverse: rows(A)<N!")
			alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixInverse: A contains infinite or NaN values!")
			trfac.rmatrixlu(a, n, n, pivots)
			rmatrixluinverse(a, pivots, n, info, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixinverse(ByRef a As Double(,), n As Integer, ByRef info As Integer, rep As matinvreport)
			rmatrixinverse(a, n, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a matrix given by its LU decomposition.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that matrix inversion  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            A       -   LU decomposition of the matrix
'                        (output of CMatrixLU subroutine).
'            Pivots  -   table of permutations
'                        (the output of CMatrixLU subroutine).
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'
'        OUTPUT PARAMETERS:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB routine --
'             05.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), n As Integer, ByRef info As Integer, rep As matinvreport)
			Dim work As complex() = New complex(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As complex = 0

			info = 0

			alglib.ap.assert(n > 0, "CMatrixLUInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixLUInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixLUInverse: rows(A)<N!")
			alglib.ap.assert(alglib.ap.len(pivots) >= n, "CMatrixLUInverse: len(Pivots)<N!")
			alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixLUInverse: A contains infinite or NaN values!")
			info = 1
			For i = 0 To n - 1
				If pivots(i) > n - 1 OrElse pivots(i) < i Then
					info = -1
				End If
			Next
			alglib.ap.assert(info > 0, "CMatrixLUInverse: incorrect Pivots array!")

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.cmatrixlurcond1(a, n)
			rep.rinf = rcond.cmatrixlurcondinf(a, n)
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				For i = 0 To n - 1
					For j = 0 To n - 1
						a(i, j) = 0
					Next
				Next
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Call cache-oblivious code
			'
			work = New complex(n - 1) {}
			cmatrixluinverserec(a, 0, n, work, info, rep)

			'
			' apply permutations
			'
			For i = 0 To n - 1
				For j = n - 2 To 0 Step -1
					k = pivots(j)
					v = a(i, j)
					a(i, j) = a(i, k)
					a(i, k) = v
				Next
			Next
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixluinverse(ByRef a As complex(,), pivots As Integer(), n As Integer, ByRef info As Integer, rep As matinvreport)
			cmatrixluinverse(a, pivots, n, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a general matrix.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that matrix inversion  is  harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixinverse(ByRef a As complex(,), n As Integer, ByRef info As Integer, rep As matinvreport)
			Dim pivots As Integer() = New Integer(-1) {}

			info = 0

			alglib.ap.assert(n > 0, "CRMatrixInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "CRMatrixInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "CRMatrixInverse: rows(A)<N!")
			alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixInverse: A contains infinite or NaN values!")
			trfac.cmatrixlu(a, n, n, pivots)
			cmatrixluinverse(a, pivots, n, info, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixinverse(ByRef a As complex(,), n As Integer, ByRef info As Integer, rep As matinvreport)
			cmatrixinverse(a, n, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a symmetric positive definite matrix which is given
'        by Cholesky decomposition.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'          ! algorithm  -  it  has  lots  of  internal synchronization points which
'          ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'          ! problems (N=thousands) can be efficiently parallelized.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   Cholesky decomposition of the matrix to be inverted:
'                        A=U?U or A = L*L'.
'                        Output of  SPDMatrixCholesky subroutine.
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   storage type (optional):
'                        * if True, symmetric  matrix  A  is  given  by  its  upper
'                          triangle, and the lower triangle isn  used/changed  by
'                          function
'                        * if False,  symmetric matrix  A  is  given  by  its lower
'                          triangle, and the  upper triangle isn used/changed  by
'                          function
'                        * if not given, lower half is used.
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim tmp As Double() = New Double(-1) {}
			Dim rep2 As New matinvreport()
			Dim f As New Boolean()

			info = 0

			alglib.ap.assert(n > 0, "SPDMatrixCholeskyInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyInverse: rows(A)<N!")
			info = 1
			f = True
			For i = 0 To n - 1
				f = f AndAlso Math.isfinite(a(i, i))
			Next
			alglib.ap.assert(f, "SPDMatrixCholeskyInverse: A contains infinite or NaN values!")

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.spdmatrixcholeskyrcond(a, n, isupper)
			rep.rinf = rep.r1
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				If isupper Then
					For i = 0 To n - 1
						For j = i To n - 1
							a(i, j) = 0
						Next
					Next
				Else
					For i = 0 To n - 1
						For j = 0 To i
							a(i, j) = 0
						Next
					Next
				End If
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Inverse
			'
			tmp = New Double(n - 1) {}
			spdmatrixcholeskyinverserec(a, 0, n, isupper, tmp)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spdmatrixcholeskyinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			spdmatrixcholeskyinverse(a, n, isupper, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a symmetric positive definite matrix.
'
'        Given an upper or lower triangle of a symmetric positive definite matrix,
'        the algorithm generates matrix A^-1 and saves the upper or lower triangle
'        depending on the input.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'          ! algorithm  -  it  has  lots  of  internal synchronization points which
'          ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'          ! problems (N=thousands) can be efficiently parallelized.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix to be inverted (upper or lower triangle).
'                        Array with elements [0..N-1,0..N-1].
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   storage type (optional):
'                        * if True, symmetric  matrix  A  is  given  by  its  upper
'                          triangle, and the lower triangle isn  used/changed  by
'                          function
'                        * if False,  symmetric matrix  A  is  given  by  its lower
'                          triangle, and the  upper triangle isn used/changed  by
'                          function
'                        * if not given,  both lower and upper  triangles  must  be
'                          filled.
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spdmatrixinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			info = 0

			alglib.ap.assert(n > 0, "SPDMatrixInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixInverse: rows(A)<N!")
			alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "SPDMatrixInverse: A contains infinite or NaN values!")
			info = 1
			If trfac.spdmatrixcholesky(a, n, isupper) Then
				spdmatrixcholeskyinverse(a, n, isupper, info, rep)
			Else
				info = -3
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spdmatrixinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			spdmatrixinverse(a, n, isupper, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a Hermitian positive definite matrix which is given
'        by Cholesky decomposition.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'          ! algorithm  -  it  has  lots  of  internal synchronization points which
'          ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'          ! problems (N=thousands) can be efficiently parallelized.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   Cholesky decomposition of the matrix to be inverted:
'                        A=U?U or A = L*L'.
'                        Output of  HPDMatrixCholesky subroutine.
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   storage type (optional):
'                        * if True, symmetric  matrix  A  is  given  by  its  upper
'                          triangle, and the lower triangle isn  used/changed  by
'                          function
'                        * if False,  symmetric matrix  A  is  given  by  its lower
'                          triangle, and the  upper triangle isn used/changed  by
'                          function
'                        * if not given, lower half is used.
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub hpdmatrixcholeskyinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim rep2 As New matinvreport()
			Dim tmp As complex() = New complex(-1) {}
			Dim f As New Boolean()

			info = 0

			alglib.ap.assert(n > 0, "HPDMatrixCholeskyInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "HPDMatrixCholeskyInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "HPDMatrixCholeskyInverse: rows(A)<N!")
			f = True
			For i = 0 To n - 1
				f = (f AndAlso Math.isfinite(a(i, i).x)) AndAlso Math.isfinite(a(i, i).y)
			Next
			alglib.ap.assert(f, "HPDMatrixCholeskyInverse: A contains infinite or NaN values!")
			info = 1

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.hpdmatrixcholeskyrcond(a, n, isupper)
			rep.rinf = rep.r1
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				If isupper Then
					For i = 0 To n - 1
						For j = i To n - 1
							a(i, j) = 0
						Next
					Next
				Else
					For i = 0 To n - 1
						For j = 0 To i
							a(i, j) = 0
						Next
					Next
				End If
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Inverse
			'
			tmp = New complex(n - 1) {}
			hpdmatrixcholeskyinverserec(a, 0, n, isupper, tmp)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_hpdmatrixcholeskyinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			hpdmatrixcholeskyinverse(a, n, isupper, info, rep)
		End Sub


		'************************************************************************
'        Inversion of a Hermitian positive definite matrix.
'
'        Given an upper or lower triangle of a Hermitian positive definite matrix,
'        the algorithm generates matrix A^-1 and saves the upper or lower triangle
'        depending on the input.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of  this  function.  However,  Cholesky  inversion  is  a  "difficult"
'          ! algorithm  -  it  has  lots  of  internal synchronization points which
'          ! prevents efficient  parallelization  of  algorithm.  Only  very  large
'          ! problems (N=thousands) can be efficiently parallelized.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'          
'        Input parameters:
'            A       -   matrix to be inverted (upper or lower triangle).
'                        Array with elements [0..N-1,0..N-1].
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   storage type (optional):
'                        * if True, symmetric  matrix  A  is  given  by  its  upper
'                          triangle, and the lower triangle isn  used/changed  by
'                          function
'                        * if False,  symmetric matrix  A  is  given  by  its lower
'                          triangle, and the  upper triangle isn used/changed  by
'                          function
'                        * if not given,  both lower and upper  triangles  must  be
'                          filled.
'
'        Output parameters:
'            Info    -   return code, same as in RMatrixLUInverse
'            Rep     -   solver report, same as in RMatrixLUInverse
'            A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub hpdmatrixinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			info = 0

			alglib.ap.assert(n > 0, "HPDMatrixInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "HPDMatrixInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "HPDMatrixInverse: rows(A)<N!")
			alglib.ap.assert(apserv.apservisfinitectrmatrix(a, n, isupper), "HPDMatrixInverse: A contains infinite or NaN values!")
			info = 1
			If trfac.hpdmatrixcholesky(a, n, isupper) Then
				hpdmatrixcholeskyinverse(a, n, isupper, info, rep)
			Else
				info = -3
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_hpdmatrixinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, ByRef info As Integer, rep As matinvreport)
			hpdmatrixinverse(a, n, isupper, info, rep)
		End Sub


		'************************************************************************
'        Triangular matrix inverse (real)
'
'        The subroutine inverts the following types of matrices:
'            * upper triangular
'            * upper triangular with unit diagonal
'            * lower triangular
'            * lower triangular with unit diagonal
'
'        In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'        also be upper (lower) triangular, and after the end of the algorithm,  the
'        inverse matrix replaces the source matrix. The elements  below (above) the
'        main diagonal are not changed by the algorithm.
'
'        If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'        diagonal, and the diagonal elements are not passed to the algorithm.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that triangular inverse is harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'          
'        Input parameters:
'            A       -   matrix, array[0..N-1, 0..N-1].
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   True, if the matrix is upper triangular.
'            IsUnit  -   diagonal type (optional):
'                        * if True, matrix has unit diagonal (a[i,i] are NOT used)
'                        * if False, matrix diagonal is arbitrary
'                        * if not given, False is assumed
'
'        Output parameters:
'            Info    -   same as for RMatrixLUInverse
'            Rep     -   same as for RMatrixLUInverse
'            A       -   same as for RMatrixLUInverse.
'
'          -- ALGLIB --
'             Copyright 05.02.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixtrinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim tmp As Double() = New Double(-1) {}
			Dim sinfo As New apserv.sinteger()

			info = 0

			alglib.ap.assert(n > 0, "RMatrixTRInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixTRInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixTRInverse: rows(A)<N!")
			alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "RMatrixTRInverse: A contains infinite or NaN values!")

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.rmatrixtrrcond1(a, n, isupper, isunit)
			rep.rinf = rcond.rmatrixtrrcondinf(a, n, isupper, isunit)
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				For i = 0 To n - 1
					For j = 0 To n - 1
						a(i, j) = 0
					Next
				Next
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Invert
			'
			tmp = New Double(n - 1) {}
			sinfo.val = 1
			rmatrixtrinverserec(a, 0, n, isupper, isunit, tmp, _
				sinfo, rep)
			info = sinfo.val
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_rmatrixtrinverse(ByRef a As Double(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, rep As matinvreport)
			rmatrixtrinverse(a, n, isupper, isunit, info, rep)
		End Sub


		'************************************************************************
'        Triangular matrix inverse (complex)
'
'        The subroutine inverts the following types of matrices:
'            * upper triangular
'            * upper triangular with unit diagonal
'            * lower triangular
'            * lower triangular with unit diagonal
'
'        In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'        also be upper (lower) triangular, and after the end of the algorithm,  the
'        inverse matrix replaces the source matrix. The elements  below (above) the
'        main diagonal are not changed by the algorithm.
'
'        If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'        diagonal, and the diagonal elements are not passed to the algorithm.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multicore support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
'          ! * about 2-3x faster than ALGLIB for C++ without MKL
'          ! * about 7-10x faster than "pure C#" edition of ALGLIB
'          ! Difference in performance will be more striking  on  newer  CPU's with
'          ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
'          ! problem whose size is at least 128, with best  efficiency achieved for
'          ! N's larger than 512.
'          !
'          ! Commercial edition of ALGLIB also supports multithreaded  acceleration
'          ! of this function. We should note that triangular inverse is harder  to
'          ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
'          ! many internal synchronization points which can not be avoided. However
'          ! parallelism starts to be profitable starting  from  N=1024,  achieving
'          ! near-linear speedup for N=4096 or higher.
'          !
'          ! In order to use multicore features you have to:
'          ! * use commercial version of ALGLIB
'          ! * call  this  function  with  "smp_"  prefix,  which  indicates  that
'          !   multicore code will be used (for multicore support)
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        Input parameters:
'            A       -   matrix, array[0..N-1, 0..N-1].
'            N       -   size of matrix A (optional) :
'                        * if given, only principal NxN submatrix is processed  and
'                          overwritten. other elements are unchanged.
'                        * if not given,  size  is  automatically  determined  from
'                          matrix size (A must be square matrix)
'            IsUpper -   True, if the matrix is upper triangular.
'            IsUnit  -   diagonal type (optional):
'                        * if True, matrix has unit diagonal (a[i,i] are NOT used)
'                        * if False, matrix diagonal is arbitrary
'                        * if not given, False is assumed
'
'        Output parameters:
'            Info    -   same as for RMatrixLUInverse
'            Rep     -   same as for RMatrixLUInverse
'            A       -   same as for RMatrixLUInverse.
'
'          -- ALGLIB --
'             Copyright 05.02.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub cmatrixtrinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim tmp As complex() = New complex(-1) {}

			info = 0

			alglib.ap.assert(n > 0, "CMatrixTRInverse: N<=0!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixTRInverse: cols(A)<N!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixTRInverse: rows(A)<N!")
			alglib.ap.assert(apserv.apservisfinitectrmatrix(a, n, isupper), "CMatrixTRInverse: A contains infinite or NaN values!")
			info = 1

			'
			' calculate condition numbers
			'
			rep.r1 = rcond.cmatrixtrrcond1(a, n, isupper, isunit)
			rep.rinf = rcond.cmatrixtrrcondinf(a, n, isupper, isunit)
			If CDbl(rep.r1) < CDbl(rcond.rcondthreshold()) OrElse CDbl(rep.rinf) < CDbl(rcond.rcondthreshold()) Then
				For i = 0 To n - 1
					For j = 0 To n - 1
						a(i, j) = 0
					Next
				Next
				rep.r1 = 0
				rep.rinf = 0
				info = -3
				Return
			End If

			'
			' Invert
			'
			tmp = New complex(n - 1) {}
			cmatrixtrinverserec(a, 0, n, isupper, isunit, tmp, _
				info, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_cmatrixtrinverse(ByRef a As complex(,), n As Integer, isupper As Boolean, isunit As Boolean, ByRef info As Integer, rep As matinvreport)
			cmatrixtrinverse(a, n, isupper, isunit, info, rep)
		End Sub


		'************************************************************************
'        Recursive subroutine for SPD inversion.
'
'        NOTE: this function expects that matris is strictly positive-definite.
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spdmatrixcholeskyinverserec(ByRef a As Double(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim sinfo2 As New apserv.sinteger()
			Dim rep2 As New matinvreport()
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If n < 1 Then
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablasblocksize(a) Then
				sinfo2.val = 1
				rmatrixtrinverserec(a, offs, n, isupper, False, tmp, _
					sinfo2, rep2)
				alglib.ap.assert(sinfo2.val > 0, "SPDMatrixCholeskyInverseRec: integrity check failed")
				If isupper Then

					'
					' Compute the product U * U'.
					' NOTE: we never assume that diagonal of U is real
					'
					For i = 0 To n - 1
						If i = 0 Then

							'
							' 1x1 matrix
							'
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i))
						Else

							'
							' (I+1)x(I+1) matrix,
							'
							' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
							' (          ) * (              ) = (                                )
							' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
							'
							' A11 is IxI, A22 is 1x1.
							'
							i1_ = (offs) - (0)
							For i_ = 0 To i - 1
								tmp(i_) = a(i_ + i1_, offs + i)
							Next
							For j = 0 To i - 1
								v = a(offs + j, offs + i)
								i1_ = (j) - (offs + j)
								For i_ = offs + j To offs + i - 1
									a(offs + j, i_) = a(offs + j, i_) + v * tmp(i_ + i1_)
								Next
							Next
							v = a(offs + i, offs + i)
							For i_ = offs To offs + i - 1
								a(i_, offs + i) = v * a(i_, offs + i)
							Next
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i))
						End If
					Next
				Else

					'
					' Compute the product L' * L
					' NOTE: we never assume that diagonal of L is real
					'
					For i = 0 To n - 1
						If i = 0 Then

							'
							' 1x1 matrix
							'
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i))
						Else

							'
							' (I+1)x(I+1) matrix,
							'
							' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
							' (              ) * (          ) = (                                )
							' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
							'
							' A11 is IxI, A22 is 1x1.
							'
							i1_ = (offs) - (0)
							For i_ = 0 To i - 1
								tmp(i_) = a(offs + i, i_ + i1_)
							Next
							For j = 0 To i - 1
								v = a(offs + i, offs + j)
								i1_ = (0) - (offs)
								For i_ = offs To offs + j
									a(offs + j, i_) = a(offs + j, i_) + v * tmp(i_ + i1_)
								Next
							Next
							v = a(offs + i, offs + i)
							For i_ = offs To offs + i - 1
								a(offs + i, i_) = v * a(offs + i, i_)
							Next
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i))
						End If
					Next
				End If
				Return
			End If

			'
			' Recursive code: triangular factor inversion merged with
			' UU' or L'L multiplication
			'
			ablas.ablassplitlength(a, n, n1, n2)

			'
			' form off-diagonal block of trangular inverse
			'
			If isupper Then
				For i = 0 To n1 - 1
					For i_ = offs + n1 To offs + n - 1
						a(offs + i, i_) = -1 * a(offs + i, i_)
					Next
				Next
				ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
					False, 0, a, offs, offs + n1)
				ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
					False, 0, a, offs, offs + n1)
			Else
				For i = 0 To n2 - 1
					For i_ = offs To offs + n1 - 1
						a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
					Next
				Next
				ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
					False, 0, a, offs + n1, offs)
				ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
					False, 0, a, offs + n1, offs)
			End If

			'
			' invert first diagonal block
			'
			spdmatrixcholeskyinverserec(a, offs, n1, isupper, tmp)

			'
			' update first diagonal block with off-diagonal block,
			' update off-diagonal block
			'
			If isupper Then
				ablas.rmatrixsyrk(n1, n2, 1.0, a, offs, offs + n1, _
					0, 1.0, a, offs, offs, isupper)
				ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
					False, 1, a, offs, offs + n1)
			Else
				ablas.rmatrixsyrk(n1, n2, 1.0, a, offs + n1, offs, _
					1, 1.0, a, offs, offs, isupper)
				ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
					False, 1, a, offs + n1, offs)
			End If

			'
			' invert second diagonal block
			'
			spdmatrixcholeskyinverserec(a, offs + n1, n2, isupper, tmp)
		End Sub


		'************************************************************************
'        Triangular matrix inversion, recursive subroutine
'
'        NOTE: this function sets Info on failure, leaves it unchanged on success.
'
'        NOTE: only Tmp[Offs:Offs+N-1] is modified, other entries of the temporary array are not modified
'
'          -- ALGLIB --
'             05.02.2010, Bochkanov Sergey.
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             February 29, 1992.
'        ************************************************************************

		Private Shared Sub rmatrixtrinverserec(a As Double(,), offs As Integer, n As Integer, isupper As Boolean, isunit As Boolean, tmp As Double(), _
			info As apserv.sinteger, rep As matinvreport)
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim ajj As Double = 0
			Dim i_ As Integer = 0

			If n < 1 Then
				info.val = -1
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablasblocksize(a) Then
				If isupper Then

					'
					' Compute inverse of upper triangular matrix.
					'
					For j = 0 To n - 1
						If Not isunit Then
							If CDbl(a(offs + j, offs + j)) = CDbl(0) Then
								info.val = -3
								Return
							End If
							a(offs + j, offs + j) = 1 / a(offs + j, offs + j)
							ajj = -a(offs + j, offs + j)
						Else
							ajj = -1
						End If

						'
						' Compute elements 1:j-1 of j-th column.
						'
						If j > 0 Then
							For i_ = offs + 0 To offs + j - 1
								tmp(i_) = a(i_, offs + j)
							Next
							For i = 0 To j - 1
								If i < j - 1 Then
									v = 0.0
									For i_ = offs + i + 1 To offs + j - 1
										v += a(offs + i, i_) * tmp(i_)
									Next
								Else
									v = 0
								End If
								If Not isunit Then
									a(offs + i, offs + j) = v + a(offs + i, offs + i) * tmp(offs + i)
								Else
									a(offs + i, offs + j) = v + tmp(offs + i)
								End If
							Next
							For i_ = offs + 0 To offs + j - 1
								a(i_, offs + j) = ajj * a(i_, offs + j)
							Next
						End If
					Next
				Else

					'
					' Compute inverse of lower triangular matrix.
					'
					For j = n - 1 To 0 Step -1
						If Not isunit Then
							If CDbl(a(offs + j, offs + j)) = CDbl(0) Then
								info.val = -3
								Return
							End If
							a(offs + j, offs + j) = 1 / a(offs + j, offs + j)
							ajj = -a(offs + j, offs + j)
						Else
							ajj = -1
						End If
						If j < n - 1 Then

							'
							' Compute elements j+1:n of j-th column.
							'
							For i_ = offs + j + 1 To offs + n - 1
								tmp(i_) = a(i_, offs + j)
							Next
							For i = j + 1 To n - 1
								If i > j + 1 Then
									v = 0.0
									For i_ = offs + j + 1 To offs + i - 1
										v += a(offs + i, i_) * tmp(i_)
									Next
								Else
									v = 0
								End If
								If Not isunit Then
									a(offs + i, offs + j) = v + a(offs + i, offs + i) * tmp(offs + i)
								Else
									a(offs + i, offs + j) = v + tmp(offs + i)
								End If
							Next
							For i_ = offs + j + 1 To offs + n - 1
								a(i_, offs + j) = ajj * a(i_, offs + j)
							Next
						End If
					Next
				End If
				Return
			End If

			'
			' Recursive case
			'
			ablas.ablassplitlength(a, n, n1, n2)
			If n2 > 0 Then
				If isupper Then
					For i = 0 To n1 - 1
						For i_ = offs + n1 To offs + n - 1
							a(offs + i, i_) = -1 * a(offs + i, i_)
						Next
					Next
					ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
						isunit, 0, a, offs, offs + n1)
					ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
						isunit, 0, a, offs, offs + n1)
					rmatrixtrinverserec(a, offs + n1, n2, isupper, isunit, tmp, _
						info, rep)
				Else
					For i = 0 To n2 - 1
						For i_ = offs To offs + n1 - 1
							a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
						Next
					Next
					ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
						isunit, 0, a, offs + n1, offs)
					ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
						isunit, 0, a, offs + n1, offs)
					rmatrixtrinverserec(a, offs + n1, n2, isupper, isunit, tmp, _
						info, rep)
				End If
			End If
			rmatrixtrinverserec(a, offs, n1, isupper, isunit, tmp, _
				info, rep)
		End Sub


		'************************************************************************
'        Triangular matrix inversion, recursive subroutine
'
'          -- ALGLIB --
'             05.02.2010, Bochkanov Sergey.
'             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'             Courant Institute, Argonne National Lab, and Rice University
'             February 29, 1992.
'        ************************************************************************

		Private Shared Sub cmatrixtrinverserec(ByRef a As complex(,), offs As Integer, n As Integer, isupper As Boolean, isunit As Boolean, ByRef tmp As complex(), _
			ByRef info As Integer, rep As matinvreport)
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As complex = 0
			Dim ajj As complex = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If n < 1 Then
				info = -1
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablascomplexblocksize(a) Then
				If isupper Then

					'
					' Compute inverse of upper triangular matrix.
					'
					For j = 0 To n - 1
						If Not isunit Then
							If a(offs + j, offs + j) = 0 Then
								info = -3
								Return
							End If
							a(offs + j, offs + j) = 1 / a(offs + j, offs + j)
							ajj = -a(offs + j, offs + j)
						Else
							ajj = -1
						End If

						'
						' Compute elements 1:j-1 of j-th column.
						'
						If j > 0 Then
							i1_ = (offs + 0) - (0)
							For i_ = 0 To j - 1
								tmp(i_) = a(i_ + i1_, offs + j)
							Next
							For i = 0 To j - 1
								If i < j - 1 Then
									i1_ = (i + 1) - (offs + i + 1)
									v = 0.0
									For i_ = offs + i + 1 To offs + j - 1
										v += a(offs + i, i_) * tmp(i_ + i1_)
									Next
								Else
									v = 0
								End If
								If Not isunit Then
									a(offs + i, offs + j) = v + a(offs + i, offs + i) * tmp(i)
								Else
									a(offs + i, offs + j) = v + tmp(i)
								End If
							Next
							For i_ = offs + 0 To offs + j - 1
								a(i_, offs + j) = ajj * a(i_, offs + j)
							Next
						End If
					Next
				Else

					'
					' Compute inverse of lower triangular matrix.
					'
					For j = n - 1 To 0 Step -1
						If Not isunit Then
							If a(offs + j, offs + j) = 0 Then
								info = -3
								Return
							End If
							a(offs + j, offs + j) = 1 / a(offs + j, offs + j)
							ajj = -a(offs + j, offs + j)
						Else
							ajj = -1
						End If
						If j < n - 1 Then

							'
							' Compute elements j+1:n of j-th column.
							'
							i1_ = (offs + j + 1) - (j + 1)
							For i_ = j + 1 To n - 1
								tmp(i_) = a(i_ + i1_, offs + j)
							Next
							For i = j + 1 To n - 1
								If i > j + 1 Then
									i1_ = (j + 1) - (offs + j + 1)
									v = 0.0
									For i_ = offs + j + 1 To offs + i - 1
										v += a(offs + i, i_) * tmp(i_ + i1_)
									Next
								Else
									v = 0
								End If
								If Not isunit Then
									a(offs + i, offs + j) = v + a(offs + i, offs + i) * tmp(i)
								Else
									a(offs + i, offs + j) = v + tmp(i)
								End If
							Next
							For i_ = offs + j + 1 To offs + n - 1
								a(i_, offs + j) = ajj * a(i_, offs + j)
							Next
						End If
					Next
				End If
				Return
			End If

			'
			' Recursive case
			'
			ablas.ablascomplexsplitlength(a, n, n1, n2)
			If n2 > 0 Then
				If isupper Then
					For i = 0 To n1 - 1
						For i_ = offs + n1 To offs + n - 1
							a(offs + i, i_) = -1 * a(offs + i, i_)
						Next
					Next
					ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
						isunit, 0, a, offs, offs + n1)
					ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
						isunit, 0, a, offs, offs + n1)
				Else
					For i = 0 To n2 - 1
						For i_ = offs To offs + n1 - 1
							a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
						Next
					Next
					ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
						isunit, 0, a, offs + n1, offs)
					ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
						isunit, 0, a, offs + n1, offs)
				End If
				cmatrixtrinverserec(a, offs + n1, n2, isupper, isunit, tmp, _
					info, rep)
			End If
			cmatrixtrinverserec(a, offs, n1, isupper, isunit, tmp, _
				info, rep)
		End Sub


		Private Shared Sub rmatrixluinverserec(ByRef a As Double(,), offs As Integer, n As Integer, ByRef work As Double(), info As apserv.sinteger, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If n < 1 Then
				info.val = -1
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablasblocksize(a) Then

				'
				' Form inv(U)
				'
				rmatrixtrinverserec(a, offs, n, True, False, work, _
					info, rep)
				If info.val <= 0 Then
					Return
				End If

				'
				' Solve the equation inv(A)*L = inv(U) for inv(A).
				'
				For j = n - 1 To 0 Step -1

					'
					' Copy current column of L to WORK and replace with zeros.
					'
					For i = j + 1 To n - 1
						work(i) = a(offs + i, offs + j)
						a(offs + i, offs + j) = 0
					Next

					'
					' Compute current column of inv(A).
					'
					If j < n - 1 Then
						For i = 0 To n - 1
							i1_ = (j + 1) - (offs + j + 1)
							v = 0.0
							For i_ = offs + j + 1 To offs + n - 1
								v += a(offs + i, i_) * work(i_ + i1_)
							Next
							a(offs + i, offs + j) = a(offs + i, offs + j) - v
						Next
					End If
				Next
				Return
			End If

			'
			' Recursive code:
			'
			'         ( L1      )   ( U1  U12 )
			' A    =  (         ) * (         )
			'         ( L12  L2 )   (     U2  )
			'
			'         ( W   X )
			' A^-1 =  (       )
			'         ( Y   Z )
			'
			ablas.ablassplitlength(a, n, n1, n2)
			alglib.ap.assert(n2 > 0, "LUInverseRec: internal error!")

			'
			' X := inv(U1)*U12*inv(U2)
			'
			ablas.rmatrixlefttrsm(n1, n2, a, offs, offs, True, _
				False, 0, a, offs, offs + n1)
			ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, True, _
				False, 0, a, offs, offs + n1)

			'
			' Y := inv(L2)*L12*inv(L1)
			'
			ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, False, _
				True, 0, a, offs + n1, offs)
			ablas.rmatrixrighttrsm(n2, n1, a, offs, offs, False, _
				True, 0, a, offs + n1, offs)

			'
			' W := inv(L1*U1)+X*Y
			'
			rmatrixluinverserec(a, offs, n1, work, info, rep)
			If info.val <= 0 Then
				Return
			End If
			ablas.rmatrixgemm(n1, n1, n2, 1.0, a, offs, _
				offs + n1, 0, a, offs + n1, offs, 0, _
				1.0, a, offs, offs)

			'
			' X := -X*inv(L2)
			' Y := -inv(U2)*Y
			'
			ablas.rmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, False, _
				True, 0, a, offs, offs + n1)
			For i = 0 To n1 - 1
				For i_ = offs + n1 To offs + n - 1
					a(offs + i, i_) = -1 * a(offs + i, i_)
				Next
			Next
			ablas.rmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, True, _
				False, 0, a, offs + n1, offs)
			For i = 0 To n2 - 1
				For i_ = offs To offs + n1 - 1
					a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
				Next
			Next

			'
			' Z := inv(L2*U2)
			'
			rmatrixluinverserec(a, offs + n1, n2, work, info, rep)
		End Sub


		Private Shared Sub cmatrixluinverserec(ByRef a As complex(,), offs As Integer, n As Integer, ByRef work As complex(), ByRef info As Integer, rep As matinvreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As complex = 0
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If n < 1 Then
				info = -1
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablascomplexblocksize(a) Then

				'
				' Form inv(U)
				'
				cmatrixtrinverserec(a, offs, n, True, False, work, _
					info, rep)
				If info <= 0 Then
					Return
				End If

				'
				' Solve the equation inv(A)*L = inv(U) for inv(A).
				'
				For j = n - 1 To 0 Step -1

					'
					' Copy current column of L to WORK and replace with zeros.
					'
					For i = j + 1 To n - 1
						work(i) = a(offs + i, offs + j)
						a(offs + i, offs + j) = 0
					Next

					'
					' Compute current column of inv(A).
					'
					If j < n - 1 Then
						For i = 0 To n - 1
							i1_ = (j + 1) - (offs + j + 1)
							v = 0.0
							For i_ = offs + j + 1 To offs + n - 1
								v += a(offs + i, i_) * work(i_ + i1_)
							Next
							a(offs + i, offs + j) = a(offs + i, offs + j) - v
						Next
					End If
				Next
				Return
			End If

			'
			' Recursive code:
			'
			'         ( L1      )   ( U1  U12 )
			' A    =  (         ) * (         )
			'         ( L12  L2 )   (     U2  )
			'
			'         ( W   X )
			' A^-1 =  (       )
			'         ( Y   Z )
			'
			ablas.ablascomplexsplitlength(a, n, n1, n2)
			alglib.ap.assert(n2 > 0, "LUInverseRec: internal error!")

			'
			' X := inv(U1)*U12*inv(U2)
			'
			ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, True, _
				False, 0, a, offs, offs + n1)
			ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, True, _
				False, 0, a, offs, offs + n1)

			'
			' Y := inv(L2)*L12*inv(L1)
			'
			ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, False, _
				True, 0, a, offs + n1, offs)
			ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, False, _
				True, 0, a, offs + n1, offs)

			'
			' W := inv(L1*U1)+X*Y
			'
			cmatrixluinverserec(a, offs, n1, work, info, rep)
			If info <= 0 Then
				Return
			End If
			ablas.cmatrixgemm(n1, n1, n2, 1.0, a, offs, _
				offs + n1, 0, a, offs + n1, offs, 0, _
				1.0, a, offs, offs)

			'
			' X := -X*inv(L2)
			' Y := -inv(U2)*Y
			'
			ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, False, _
				True, 0, a, offs, offs + n1)
			For i = 0 To n1 - 1
				For i_ = offs + n1 To offs + n - 1
					a(offs + i, i_) = -1 * a(offs + i, i_)
				Next
			Next
			ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, True, _
				False, 0, a, offs + n1, offs)
			For i = 0 To n2 - 1
				For i_ = offs To offs + n1 - 1
					a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
				Next
			Next

			'
			' Z := inv(L2*U2)
			'
			cmatrixluinverserec(a, offs + n1, n2, work, info, rep)
		End Sub


		'************************************************************************
'        Recursive subroutine for HPD inversion.
'
'          -- ALGLIB routine --
'             10.02.2010
'             Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub hpdmatrixcholeskyinverserec(ByRef a As complex(,), offs As Integer, n As Integer, isupper As Boolean, ByRef tmp As complex())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As complex = 0
			Dim n1 As Integer = 0
			Dim n2 As Integer = 0
			Dim info2 As Integer = 0
			Dim rep2 As New matinvreport()
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			If n < 1 Then
				Return
			End If

			'
			' Base case
			'
			If n <= ablas.ablascomplexblocksize(a) Then
				cmatrixtrinverserec(a, offs, n, isupper, False, tmp, _
					info2, rep2)
				If isupper Then

					'
					' Compute the product U * U'.
					' NOTE: we never assume that diagonal of U is real
					'
					For i = 0 To n - 1
						If i = 0 Then

							'
							' 1x1 matrix
							'
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i).x) + Math.sqr(a(offs + i, offs + i).y)
						Else

							'
							' (I+1)x(I+1) matrix,
							'
							' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
							' (          ) * (              ) = (                                )
							' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
							'
							' A11 is IxI, A22 is 1x1.
							'
							i1_ = (offs) - (0)
							For i_ = 0 To i - 1
								tmp(i_) = Math.conj(a(i_ + i1_, offs + i))
							Next
							For j = 0 To i - 1
								v = a(offs + j, offs + i)
								i1_ = (j) - (offs + j)
								For i_ = offs + j To offs + i - 1
									a(offs + j, i_) = a(offs + j, i_) + v * tmp(i_ + i1_)
								Next
							Next
							v = Math.conj(a(offs + i, offs + i))
							For i_ = offs To offs + i - 1
								a(i_, offs + i) = v * a(i_, offs + i)
							Next
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i).x) + Math.sqr(a(offs + i, offs + i).y)
						End If
					Next
				Else

					'
					' Compute the product L' * L
					' NOTE: we never assume that diagonal of L is real
					'
					For i = 0 To n - 1
						If i = 0 Then

							'
							' 1x1 matrix
							'
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i).x) + Math.sqr(a(offs + i, offs + i).y)
						Else

							'
							' (I+1)x(I+1) matrix,
							'
							' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
							' (              ) * (          ) = (                                )
							' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
							'
							' A11 is IxI, A22 is 1x1.
							'
							i1_ = (offs) - (0)
							For i_ = 0 To i - 1
								tmp(i_) = a(offs + i, i_ + i1_)
							Next
							For j = 0 To i - 1
								v = Math.conj(a(offs + i, offs + j))
								i1_ = (0) - (offs)
								For i_ = offs To offs + j
									a(offs + j, i_) = a(offs + j, i_) + v * tmp(i_ + i1_)
								Next
							Next
							v = Math.conj(a(offs + i, offs + i))
							For i_ = offs To offs + i - 1
								a(offs + i, i_) = v * a(offs + i, i_)
							Next
							a(offs + i, offs + i) = Math.sqr(a(offs + i, offs + i).x) + Math.sqr(a(offs + i, offs + i).y)
						End If
					Next
				End If
				Return
			End If

			'
			' Recursive code: triangular factor inversion merged with
			' UU' or L'L multiplication
			'
			ablas.ablascomplexsplitlength(a, n, n1, n2)

			'
			' form off-diagonal block of trangular inverse
			'
			If isupper Then
				For i = 0 To n1 - 1
					For i_ = offs + n1 To offs + n - 1
						a(offs + i, i_) = -1 * a(offs + i, i_)
					Next
				Next
				ablas.cmatrixlefttrsm(n1, n2, a, offs, offs, isupper, _
					False, 0, a, offs, offs + n1)
				ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
					False, 0, a, offs, offs + n1)
			Else
				For i = 0 To n2 - 1
					For i_ = offs To offs + n1 - 1
						a(offs + n1 + i, i_) = -1 * a(offs + n1 + i, i_)
					Next
				Next
				ablas.cmatrixrighttrsm(n2, n1, a, offs, offs, isupper, _
					False, 0, a, offs + n1, offs)
				ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
					False, 0, a, offs + n1, offs)
			End If

			'
			' invert first diagonal block
			'
			hpdmatrixcholeskyinverserec(a, offs, n1, isupper, tmp)

			'
			' update first diagonal block with off-diagonal block,
			' update off-diagonal block
			'
			If isupper Then
				ablas.cmatrixherk(n1, n2, 1.0, a, offs, offs + n1, _
					0, 1.0, a, offs, offs, isupper)
				ablas.cmatrixrighttrsm(n1, n2, a, offs + n1, offs + n1, isupper, _
					False, 2, a, offs, offs + n1)
			Else
				ablas.cmatrixherk(n1, n2, 1.0, a, offs + n1, offs, _
					2, 1.0, a, offs, offs, isupper)
				ablas.cmatrixlefttrsm(n2, n1, a, offs + n1, offs + n1, isupper, _
					False, 2, a, offs + n1, offs)
			End If

			'
			' invert second diagonal block
			'
			hpdmatrixcholeskyinverserec(a, offs + n1, n2, isupper, tmp)
		End Sub


	End Class
	Public Class fbls
		'************************************************************************
'        Structure which stores state of linear CG solver between subsequent calls
'        of FBLSCgIteration(). Initialized with FBLSCGCreate().
'
'        USAGE:
'        1. call to FBLSCGCreate()
'        2. F:=FBLSCgIteration(State)
'        3. if F is False, iterations are over
'        4. otherwise, fill State.AX with A*x, State.XAX with x'*A*x
'        5. goto 2
'
'        If you want to rerminate iterations, pass zero or negative value to XAX.
'
'        FIELDS:
'            E1      -   2-norm of residual at the start
'            E2      -   2-norm of residual at the end
'            X       -   on return from FBLSCgIteration() it contains vector for
'                        matrix-vector product
'            AX      -   must be filled with A*x if FBLSCgIteration() returned True
'            XAX     -   must be filled with x'*A*x
'            XK      -   contains result (if FBLSCgIteration() returned False)
'            
'        Other fields are private and should not be used by outsiders.
'        ************************************************************************

		Public Class fblslincgstate
			Inherits apobject
			Public e1 As Double
			Public e2 As Double
			Public x As Double()
			Public ax As Double()
			Public xax As Double
			Public n As Integer
			Public rk As Double()
			Public rk1 As Double()
			Public xk As Double()
			Public xk1 As Double()
			Public pk As Double()
			Public pk1 As Double()
			Public b As Double()
			Public rstate As rcommstate
			Public tmp2 As Double()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x = New Double(-1) {}
				ax = New Double(-1) {}
				rk = New Double(-1) {}
				rk1 = New Double(-1) {}
				xk = New Double(-1) {}
				xk1 = New Double(-1) {}
				pk = New Double(-1) {}
				pk1 = New Double(-1) {}
				b = New Double(-1) {}
				rstate = New rcommstate()
				tmp2 = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New fblslincgstate()
				_result.e1 = e1
				_result.e2 = e2
				_result.x = DirectCast(x.Clone(), Double())
				_result.ax = DirectCast(ax.Clone(), Double())
				_result.xax = xax
				_result.n = n
				_result.rk = DirectCast(rk.Clone(), Double())
				_result.rk1 = DirectCast(rk1.Clone(), Double())
				_result.xk = DirectCast(xk.Clone(), Double())
				_result.xk1 = DirectCast(xk1.Clone(), Double())
				_result.pk = DirectCast(pk.Clone(), Double())
				_result.pk1 = DirectCast(pk1.Clone(), Double())
				_result.b = DirectCast(b.Clone(), Double())
				_result.rstate = DirectCast(rstate.make_copy(), rcommstate)
				_result.tmp2 = DirectCast(tmp2.Clone(), Double())
				Return _result
			End Function
		End Class




		'************************************************************************
'        Basic Cholesky solver for ScaleA*Cholesky(A)'*x = y.
'
'        This subroutine assumes that:
'        * A*ScaleA is well scaled
'        * A is well-conditioned, so no zero divisions or overflow may occur
'
'        INPUT PARAMETERS:
'            CHA     -   Cholesky decomposition of A
'            SqrtScaleA- square root of scale factor ScaleA
'            N       -   matrix size, N>=0.
'            IsUpper -   storage type
'            XB      -   right part
'            Tmp     -   buffer; function automatically allocates it, if it is  too
'                        small.  It  can  be  reused  if function is called several
'                        times.
'                        
'        OUTPUT PARAMETERS:
'            XB      -   solution
'
'        NOTE 1: no assertion or tests are done during algorithm operation
'        NOTE 2: N=0 will force algorithm to silently return
'
'          -- ALGLIB --
'             Copyright 13.10.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub fblscholeskysolve(cha As Double(,), sqrtscalea As Double, n As Integer, isupper As Boolean, xb As Double(), ByRef tmp As Double())
			Dim i As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			If n = 0 Then
				Return
			End If
			If alglib.ap.len(tmp) < n Then
				tmp = New Double(n - 1) {}
			End If

			'
			' A = L*L' or A=U'*U
			'
			If isupper Then

				'
				' Solve U'*y=b first.
				'
				For i = 0 To n - 1
					xb(i) = xb(i) / (sqrtscalea * cha(i, i))
					If i < n - 1 Then
						v = xb(i)
						For i_ = i + 1 To n - 1
							tmp(i_) = sqrtscalea * cha(i, i_)
						Next
						For i_ = i + 1 To n - 1
							xb(i_) = xb(i_) - v * tmp(i_)
						Next
					End If
				Next

				'
				' Solve U*x=y then.
				'
				For i = n - 1 To 0 Step -1
					If i < n - 1 Then
						For i_ = i + 1 To n - 1
							tmp(i_) = sqrtscalea * cha(i, i_)
						Next
						v = 0.0
						For i_ = i + 1 To n - 1
							v += tmp(i_) * xb(i_)
						Next
						xb(i) = xb(i) - v
					End If
					xb(i) = xb(i) / (sqrtscalea * cha(i, i))
				Next
			Else

				'
				' Solve L*y=b first
				'
				For i = 0 To n - 1
					If i > 0 Then
						For i_ = 0 To i - 1
							tmp(i_) = sqrtscalea * cha(i, i_)
						Next
						v = 0.0
						For i_ = 0 To i - 1
							v += tmp(i_) * xb(i_)
						Next
						xb(i) = xb(i) - v
					End If
					xb(i) = xb(i) / (sqrtscalea * cha(i, i))
				Next

				'
				' Solve L'*x=y then.
				'
				For i = n - 1 To 0 Step -1
					xb(i) = xb(i) / (sqrtscalea * cha(i, i))
					If i > 0 Then
						v = xb(i)
						For i_ = 0 To i - 1
							tmp(i_) = sqrtscalea * cha(i, i_)
						Next
						For i_ = 0 To i - 1
							xb(i_) = xb(i_) - v * tmp(i_)
						Next
					End If
				Next
			End If
		End Sub


		'************************************************************************
'        Fast basic linear solver: linear SPD CG
'
'        Solves (A^T*A + alpha*I)*x = b where:
'        * A is MxN matrix
'        * alpha>0 is a scalar
'        * I is NxN identity matrix
'        * b is Nx1 vector
'        * X is Nx1 unknown vector.
'
'        N iterations of linear conjugate gradient are used to solve problem.
'
'        INPUT PARAMETERS:
'            A   -   array[M,N], matrix
'            M   -   number of rows
'            N   -   number of unknowns
'            B   -   array[N], right part
'            X   -   initial approxumation, array[N]
'            Buf -   buffer; function automatically allocates it, if it is too
'                    small. It can be reused if function is called several times
'                    with same M and N.
'                    
'        OUTPUT PARAMETERS:
'            X   -   improved solution
'            
'        NOTES:
'        *   solver checks quality of improved solution. If (because of problem
'            condition number, numerical noise, etc.) new solution is WORSE than
'            original approximation, then original approximation is returned.
'        *   solver assumes that both A, B, Alpha are well scaled (i.e. they are
'            less than sqrt(overflow) and greater than sqrt(underflow)).
'            
'          -- ALGLIB --
'             Copyright 20.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub fblssolvecgx(a As Double(,), m As Integer, n As Integer, alpha As Double, b As Double(), ByRef x As Double(), _
			ByRef buf As Double())
			Dim k As Integer = 0
			Dim offsrk As Integer = 0
			Dim offsrk1 As Integer = 0
			Dim offsxk As Integer = 0
			Dim offsxk1 As Integer = 0
			Dim offspk As Integer = 0
			Dim offspk1 As Integer = 0
			Dim offstmp1 As Integer = 0
			Dim offstmp2 As Integer = 0
			Dim bs As Integer = 0
			Dim e1 As Double = 0
			Dim e2 As Double = 0
			Dim rk2 As Double = 0
			Dim rk12 As Double = 0
			Dim pap As Double = 0
			Dim s As Double = 0
			Dim betak As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0


			'
			' Test for special case: B=0
			'
			v1 = 0.0
			For i_ = 0 To n - 1
				v1 += b(i_) * b(i_)
			Next
			If CDbl(v1) = CDbl(0) Then
				For k = 0 To n - 1
					x(k) = 0
				Next
				Return
			End If

			'
			' Offsets inside Buf for:
			' * R[K], R[K+1]
			' * X[K], X[K+1]
			' * P[K], P[K+1]
			' * Tmp1 - array[M], Tmp2 - array[N]
			'
			offsrk = 0
			offsrk1 = offsrk + n
			offsxk = offsrk1 + n
			offsxk1 = offsxk + n
			offspk = offsxk1 + n
			offspk1 = offspk + n
			offstmp1 = offspk1 + n
			offstmp2 = offstmp1 + m
			bs = offstmp2 + n
			If alglib.ap.len(buf) < bs Then
				buf = New Double(bs - 1) {}
			End If

			'
			' x(0) = x
			'
			i1_ = (0) - (offsxk)
			For i_ = offsxk To offsxk + n - 1
				buf(i_) = x(i_ + i1_)
			Next

			'
			' r(0) = b-A*x(0)
			' RK2 = r(0)'*r(0)
			'
			ablas.rmatrixmv(m, n, a, 0, 0, 0, _
				buf, offsxk, buf, offstmp1)
			ablas.rmatrixmv(n, m, a, 0, 0, 1, _
				buf, offstmp1, buf, offstmp2)
			i1_ = (offsxk) - (offstmp2)
			For i_ = offstmp2 To offstmp2 + n - 1
				buf(i_) = buf(i_) + alpha * buf(i_ + i1_)
			Next
			i1_ = (0) - (offsrk)
			For i_ = offsrk To offsrk + n - 1
				buf(i_) = b(i_ + i1_)
			Next
			i1_ = (offstmp2) - (offsrk)
			For i_ = offsrk To offsrk + n - 1
				buf(i_) = buf(i_) - buf(i_ + i1_)
			Next
			rk2 = 0.0
			For i_ = offsrk To offsrk + n - 1
				rk2 += buf(i_) * buf(i_)
			Next
			i1_ = (offsrk) - (offspk)
			For i_ = offspk To offspk + n - 1
				buf(i_) = buf(i_ + i1_)
			Next
			e1 = System.Math.sqrt(rk2)

			'
			' Cycle
			'
			For k = 0 To n - 1

				'
				' Calculate A*p(k) - store in Buf[OffsTmp2:OffsTmp2+N-1]
				' and p(k)'*A*p(k)  - store in PAP
				'
				' If PAP=0, break (iteration is over)
				'
				ablas.rmatrixmv(m, n, a, 0, 0, 0, _
					buf, offspk, buf, offstmp1)
				v1 = 0.0
				For i_ = offstmp1 To offstmp1 + m - 1
					v1 += buf(i_) * buf(i_)
				Next
				v2 = 0.0
				For i_ = offspk To offspk + n - 1
					v2 += buf(i_) * buf(i_)
				Next
				pap = v1 + alpha * v2
				ablas.rmatrixmv(n, m, a, 0, 0, 1, _
					buf, offstmp1, buf, offstmp2)
				i1_ = (offspk) - (offstmp2)
				For i_ = offstmp2 To offstmp2 + n - 1
					buf(i_) = buf(i_) + alpha * buf(i_ + i1_)
				Next
				If CDbl(pap) = CDbl(0) Then
					Exit For
				End If

				'
				' S = (r(k)'*r(k))/(p(k)'*A*p(k))
				'
				s = rk2 / pap

				'
				' x(k+1) = x(k) + S*p(k)
				'
				i1_ = (offsxk) - (offsxk1)
				For i_ = offsxk1 To offsxk1 + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				i1_ = (offspk) - (offsxk1)
				For i_ = offsxk1 To offsxk1 + n - 1
					buf(i_) = buf(i_) + s * buf(i_ + i1_)
				Next

				'
				' r(k+1) = r(k) - S*A*p(k)
				' RK12 = r(k+1)'*r(k+1)
				'
				' Break if r(k+1) small enough (when compared to r(k))
				'
				i1_ = (offsrk) - (offsrk1)
				For i_ = offsrk1 To offsrk1 + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				i1_ = (offstmp2) - (offsrk1)
				For i_ = offsrk1 To offsrk1 + n - 1
					buf(i_) = buf(i_) - s * buf(i_ + i1_)
				Next
				rk12 = 0.0
				For i_ = offsrk1 To offsrk1 + n - 1
					rk12 += buf(i_) * buf(i_)
				Next
				If CDbl(System.Math.sqrt(rk12)) <= CDbl(100 * Math.machineepsilon * System.Math.sqrt(rk2)) Then

					'
					' X(k) = x(k+1) before exit -
					' - because we expect to find solution at x(k)
					'
					i1_ = (offsxk1) - (offsxk)
					For i_ = offsxk To offsxk + n - 1
						buf(i_) = buf(i_ + i1_)
					Next
					Exit For
				End If

				'
				' BetaK = RK12/RK2
				' p(k+1) = r(k+1)+betak*p(k)
				'
				betak = rk12 / rk2
				i1_ = (offsrk1) - (offspk1)
				For i_ = offspk1 To offspk1 + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				i1_ = (offspk) - (offspk1)
				For i_ = offspk1 To offspk1 + n - 1
					buf(i_) = buf(i_) + betak * buf(i_ + i1_)
				Next

				'
				' r(k) := r(k+1)
				' x(k) := x(k+1)
				' p(k) := p(k+1)
				'
				i1_ = (offsrk1) - (offsrk)
				For i_ = offsrk To offsrk + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				i1_ = (offsxk1) - (offsxk)
				For i_ = offsxk To offsxk + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				i1_ = (offspk1) - (offspk)
				For i_ = offspk To offspk + n - 1
					buf(i_) = buf(i_ + i1_)
				Next
				rk2 = rk12
			Next

			'
			' Calculate E2
			'
			ablas.rmatrixmv(m, n, a, 0, 0, 0, _
				buf, offsxk, buf, offstmp1)
			ablas.rmatrixmv(n, m, a, 0, 0, 1, _
				buf, offstmp1, buf, offstmp2)
			i1_ = (offsxk) - (offstmp2)
			For i_ = offstmp2 To offstmp2 + n - 1
				buf(i_) = buf(i_) + alpha * buf(i_ + i1_)
			Next
			i1_ = (0) - (offsrk)
			For i_ = offsrk To offsrk + n - 1
				buf(i_) = b(i_ + i1_)
			Next
			i1_ = (offstmp2) - (offsrk)
			For i_ = offsrk To offsrk + n - 1
				buf(i_) = buf(i_) - buf(i_ + i1_)
			Next
			v1 = 0.0
			For i_ = offsrk To offsrk + n - 1
				v1 += buf(i_) * buf(i_)
			Next
			e2 = System.Math.sqrt(v1)

			'
			' Output result (if it was improved)
			'
			If CDbl(e2) < CDbl(e1) Then
				i1_ = (offsxk) - (0)
				For i_ = 0 To n - 1
					x(i_) = buf(i_ + i1_)
				Next
			End If
		End Sub


		'************************************************************************
'        Construction of linear conjugate gradient solver.
'
'        State parameter passed using "var" semantics (i.e. previous state  is  NOT
'        erased). When it is already initialized, we can reause prevously allocated
'        memory.
'
'        INPUT PARAMETERS:
'            X       -   initial solution
'            B       -   right part
'            N       -   system size
'            State   -   structure; may be preallocated, if we want to reuse memory
'
'        OUTPUT PARAMETERS:
'            State   -   structure which is used by FBLSCGIteration() to store
'                        algorithm state between subsequent calls.
'
'        NOTE: no error checking is done; caller must check all parameters, prevent
'              overflows, and so on.
'
'          -- ALGLIB --
'             Copyright 22.10.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub fblscgcreate(x As Double(), b As Double(), n As Integer, state As fblslincgstate)
			Dim i_ As Integer = 0

			If alglib.ap.len(state.b) < n Then
				state.b = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.rk) < n Then
				state.rk = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.rk1) < n Then
				state.rk1 = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.xk) < n Then
				state.xk = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.xk1) < n Then
				state.xk1 = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.pk) < n Then
				state.pk = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.pk1) < n Then
				state.pk1 = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.tmp2) < n Then
				state.tmp2 = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.x) < n Then
				state.x = New Double(n - 1) {}
			End If
			If alglib.ap.len(state.ax) < n Then
				state.ax = New Double(n - 1) {}
			End If
			state.n = n
			For i_ = 0 To n - 1
				state.xk(i_) = x(i_)
			Next
			For i_ = 0 To n - 1
				state.b(i_) = b(i_)
			Next
			state.rstate.ia = New Integer(1) {}
			state.rstate.ra = New Double(6) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Linear CG solver, function relying on reverse communication to calculate
'        matrix-vector products.
'
'        See comments for FBLSLinCGState structure for more info.
'
'          -- ALGLIB --
'             Copyright 22.10.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function fblscgiteration(state As fblslincgstate) As Boolean
			Dim result As New Boolean()
			Dim n As Integer = 0
			Dim k As Integer = 0
			Dim rk2 As Double = 0
			Dim rk12 As Double = 0
			Dim pap As Double = 0
			Dim s As Double = 0
			Dim betak As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0
			Dim i_ As Integer = 0


			'
			' Reverse communication preparations
			' I know it looks ugly, but it works the same way
			' anywhere from C++ to Python.
			'
			' This code initializes locals by:
			' * random values determined during code
			'   generation - on first subroutine call
			' * values from previous call - on subsequent calls
			'
			If state.rstate.stage >= 0 Then
				n = state.rstate.ia(0)
				k = state.rstate.ia(1)
				rk2 = state.rstate.ra(0)
				rk12 = state.rstate.ra(1)
				pap = state.rstate.ra(2)
				s = state.rstate.ra(3)
				betak = state.rstate.ra(4)
				v1 = state.rstate.ra(5)
				v2 = state.rstate.ra(6)
			Else
				n = -983
				k = -989
				rk2 = -834
				rk12 = 900
				pap = -287
				s = 364
				betak = 214
				v1 = -338
				v2 = -686
			End If
			If state.rstate.stage = 0 Then
				GoTo lbl_0
			End If
			If state.rstate.stage = 1 Then
				GoTo lbl_1
			End If
			If state.rstate.stage = 2 Then
				GoTo lbl_2
			End If

			'
			' Routine body
			'

			'
			' prepare locals
			'
			n = state.n

			'
			' Test for special case: B=0
			'
			v1 = 0.0
			For i_ = 0 To n - 1
				v1 += state.b(i_) * state.b(i_)
			Next
			If CDbl(v1) = CDbl(0) Then
				For k = 0 To n - 1
					state.xk(k) = 0
				Next
				result = False
				Return result
			End If

			'
			' r(0) = b-A*x(0)
			' RK2 = r(0)'*r(0)
			'
			For i_ = 0 To n - 1
				state.x(i_) = state.xk(i_)
			Next
			state.rstate.stage = 0
			GoTo lbl_rcomm
			lbl_0:
			For i_ = 0 To n - 1
				state.rk(i_) = state.b(i_)
			Next
			For i_ = 0 To n - 1
				state.rk(i_) = state.rk(i_) - state.ax(i_)
			Next
			rk2 = 0.0
			For i_ = 0 To n - 1
				rk2 += state.rk(i_) * state.rk(i_)
			Next
			For i_ = 0 To n - 1
				state.pk(i_) = state.rk(i_)
			Next
			state.e1 = System.Math.sqrt(rk2)

			'
			' Cycle
			'
			k = 0
			lbl_3:
			If k > n - 1 Then
				GoTo lbl_5
			End If

			'
			' Calculate A*p(k) - store in State.Tmp2
			' and p(k)'*A*p(k)  - store in PAP
			'
			' If PAP=0, break (iteration is over)
			'
			For i_ = 0 To n - 1
				state.x(i_) = state.pk(i_)
			Next
			state.rstate.stage = 1
			GoTo lbl_rcomm
			lbl_1:
			For i_ = 0 To n - 1
				state.tmp2(i_) = state.ax(i_)
			Next
			pap = state.xax
			If Not Math.isfinite(pap) Then
				GoTo lbl_5
			End If
			If CDbl(pap) <= CDbl(0) Then
				GoTo lbl_5
			End If

			'
			' S = (r(k)'*r(k))/(p(k)'*A*p(k))
			'
			s = rk2 / pap

			'
			' x(k+1) = x(k) + S*p(k)
			'
			For i_ = 0 To n - 1
				state.xk1(i_) = state.xk(i_)
			Next
			For i_ = 0 To n - 1
				state.xk1(i_) = state.xk1(i_) + s * state.pk(i_)
			Next

			'
			' r(k+1) = r(k) - S*A*p(k)
			' RK12 = r(k+1)'*r(k+1)
			'
			' Break if r(k+1) small enough (when compared to r(k))
			'
			For i_ = 0 To n - 1
				state.rk1(i_) = state.rk(i_)
			Next
			For i_ = 0 To n - 1
				state.rk1(i_) = state.rk1(i_) - s * state.tmp2(i_)
			Next
			rk12 = 0.0
			For i_ = 0 To n - 1
				rk12 += state.rk1(i_) * state.rk1(i_)
			Next
			If CDbl(System.Math.sqrt(rk12)) <= CDbl(100 * Math.machineepsilon * state.e1) Then

				'
				' X(k) = x(k+1) before exit -
				' - because we expect to find solution at x(k)
				'
				For i_ = 0 To n - 1
					state.xk(i_) = state.xk1(i_)
				Next
				GoTo lbl_5
			End If

			'
			' BetaK = RK12/RK2
			' p(k+1) = r(k+1)+betak*p(k)
			'
			' NOTE: we expect that BetaK won't overflow because of
			' "Sqrt(RK12)<=100*MachineEpsilon*E1" test above.
			'
			betak = rk12 / rk2
			For i_ = 0 To n - 1
				state.pk1(i_) = state.rk1(i_)
			Next
			For i_ = 0 To n - 1
				state.pk1(i_) = state.pk1(i_) + betak * state.pk(i_)
			Next

			'
			' r(k) := r(k+1)
			' x(k) := x(k+1)
			' p(k) := p(k+1)
			'
			For i_ = 0 To n - 1
				state.rk(i_) = state.rk1(i_)
			Next
			For i_ = 0 To n - 1
				state.xk(i_) = state.xk1(i_)
			Next
			For i_ = 0 To n - 1
				state.pk(i_) = state.pk1(i_)
			Next
			rk2 = rk12
			k = k + 1
			GoTo lbl_3
			lbl_5:

			'
			' Calculate E2
			'
			For i_ = 0 To n - 1
				state.x(i_) = state.xk(i_)
			Next
			state.rstate.stage = 2
			GoTo lbl_rcomm
			lbl_2:
			For i_ = 0 To n - 1
				state.rk(i_) = state.b(i_)
			Next
			For i_ = 0 To n - 1
				state.rk(i_) = state.rk(i_) - state.ax(i_)
			Next
			v1 = 0.0
			For i_ = 0 To n - 1
				v1 += state.rk(i_) * state.rk(i_)
			Next
			state.e2 = System.Math.sqrt(v1)
			result = False
			Return result
			lbl_rcomm:

			'
			' Saving state
			'
			result = True
			state.rstate.ia(0) = n
			state.rstate.ia(1) = k
			state.rstate.ra(0) = rk2
			state.rstate.ra(1) = rk12
			state.rstate.ra(2) = pap
			state.rstate.ra(3) = s
			state.rstate.ra(4) = betak
			state.rstate.ra(5) = v1
			state.rstate.ra(6) = v2
			Return result
		End Function


		'************************************************************************
'        Fast  least  squares  solver,  solves  well  conditioned  system   without
'        performing  any  checks  for  degeneracy,  and using user-provided buffers
'        (which are automatically reallocated if too small).
'
'        This  function  is  intended  for solution of moderately sized systems. It
'        uses factorization algorithms based on Level 2 BLAS  operations,  thus  it
'        won't work efficiently on large scale systems.
'
'        INPUT PARAMETERS:
'            A       -   array[M,N], system matrix.
'                        Contents of A is destroyed during solution.
'            B       -   array[M], right part
'            M       -   number of equations
'            N       -   number of variables, N<=M
'            Tmp0, Tmp1, Tmp2-
'                        buffers; function automatically allocates them, if they are
'                        too  small. They can  be  reused  if  function  is   called 
'                        several times.
'                        
'        OUTPUT PARAMETERS:
'            B       -   solution (first N components, next M-N are zero)
'
'          -- ALGLIB --
'             Copyright 20.01.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub fblssolvels(ByRef a As Double(,), ByRef b As Double(), m As Integer, n As Integer, ByRef tmp0 As Double(), ByRef tmp1 As Double(), _
			ByRef tmp2 As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n > 0, "FBLSSolveLS: N<=0")
			alglib.ap.assert(m >= n, "FBLSSolveLS: M<N")
			alglib.ap.assert(alglib.ap.rows(a) >= m, "FBLSSolveLS: Rows(A)<M")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "FBLSSolveLS: Cols(A)<N")
			alglib.ap.assert(alglib.ap.len(b) >= m, "FBLSSolveLS: Length(B)<M")

			'
			' Allocate temporaries
			'
			apserv.rvectorsetlengthatleast(tmp0, System.Math.Max(m, n) + 1)
			apserv.rvectorsetlengthatleast(tmp1, System.Math.Max(m, n) + 1)
			apserv.rvectorsetlengthatleast(tmp2, System.Math.Min(m, n))

			'
			' Call basecase QR
			'
			ortfac.rmatrixqrbasecase(a, m, n, tmp0, tmp1, tmp2)

			'
			' Multiply B by Q'
			'
			For k = 0 To n - 1
				For i = 0 To k - 1
					tmp0(i) = 0
				Next
				For i_ = k To m - 1
					tmp0(i_) = a(i_, k)
				Next
				tmp0(k) = 1
				v = 0.0
				For i_ = k To m - 1
					v += tmp0(i_) * b(i_)
				Next
				v = v * tmp2(k)
				For i_ = k To m - 1
					b(i_) = b(i_) - v * tmp0(i_)
				Next
			Next

			'
			' Solve triangular system
			'
			b(n - 1) = b(n - 1) / a(n - 1, n - 1)
			For i = n - 2 To 0 Step -1
				v = 0.0
				For i_ = i + 1 To n - 1
					v += a(i, i_) * b(i_)
				Next
				b(i) = (b(i) - v) / a(i, i)
			Next
			For i = n To m - 1
				b(i) = 0.0
			Next
		End Sub


	End Class
	Public Class normestimator
		'************************************************************************
'        This object stores state of the iterative norm estimation algorithm.
'
'        You should use ALGLIB functions to work with this object.
'        ************************************************************************

		Public Class normestimatorstate
			Inherits apobject
			Public n As Integer
			Public m As Integer
			Public nstart As Integer
			Public nits As Integer
			Public seedval As Integer
			Public x0 As Double()
			Public x1 As Double()
			Public t As Double()
			Public xbest As Double()
			Public r As hqrnd.hqrndstate
			Public x As Double()
			Public mv As Double()
			Public mtv As Double()
			Public needmv As Boolean
			Public needmtv As Boolean
			Public repnorm As Double
			Public rstate As rcommstate
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x0 = New Double(-1) {}
				x1 = New Double(-1) {}
				t = New Double(-1) {}
				xbest = New Double(-1) {}
				r = New hqrnd.hqrndstate()
				x = New Double(-1) {}
				mv = New Double(-1) {}
				mtv = New Double(-1) {}
				rstate = New rcommstate()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New normestimatorstate()
				_result.n = n
				_result.m = m
				_result.nstart = nstart
				_result.nits = nits
				_result.seedval = seedval
				_result.x0 = DirectCast(x0.Clone(), Double())
				_result.x1 = DirectCast(x1.Clone(), Double())
				_result.t = DirectCast(t.Clone(), Double())
				_result.xbest = DirectCast(xbest.Clone(), Double())
				_result.r = DirectCast(r.make_copy(), hqrnd.hqrndstate)
				_result.x = DirectCast(x.Clone(), Double())
				_result.mv = DirectCast(mv.Clone(), Double())
				_result.mtv = DirectCast(mtv.Clone(), Double())
				_result.needmv = needmv
				_result.needmtv = needmtv
				_result.repnorm = repnorm
				_result.rstate = DirectCast(rstate.make_copy(), rcommstate)
				Return _result
			End Function
		End Class




		'************************************************************************
'        This procedure initializes matrix norm estimator.
'
'        USAGE:
'        1. User initializes algorithm state with NormEstimatorCreate() call
'        2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())
'        3. User calls NormEstimatorResults() to get solution.
'           
'        INPUT PARAMETERS:
'            M       -   number of rows in the matrix being estimated, M>0
'            N       -   number of columns in the matrix being estimated, N>0
'            NStart  -   number of random starting vectors
'                        recommended value - at least 5.
'            NIts    -   number of iterations to do with best starting vector
'                        recommended value - at least 5.
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'            
'        NOTE: this algorithm is effectively deterministic, i.e. it always  returns
'        same result when repeatedly called for the same matrix. In fact, algorithm
'        uses randomized starting vectors, but internal  random  numbers  generator
'        always generates same sequence of the random values (it is a  feature, not
'        bug).
'
'        Algorithm can be made non-deterministic with NormEstimatorSetSeed(0) call.
'
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub normestimatorcreate(m As Integer, n As Integer, nstart As Integer, nits As Integer, state As normestimatorstate)
			alglib.ap.assert(m > 0, "NormEstimatorCreate: M<=0")
			alglib.ap.assert(n > 0, "NormEstimatorCreate: N<=0")
			alglib.ap.assert(nstart > 0, "NormEstimatorCreate: NStart<=0")
			alglib.ap.assert(nits > 0, "NormEstimatorCreate: NIts<=0")
			state.m = m
			state.n = n
			state.nstart = nstart
			state.nits = nits
			state.seedval = 11
			hqrnd.hqrndrandomize(state.r)
			state.x0 = New Double(state.n - 1) {}
			state.t = New Double(state.m - 1) {}
			state.x1 = New Double(state.n - 1) {}
			state.xbest = New Double(state.n - 1) {}
			state.x = New Double(System.Math.Max(state.n, state.m) - 1) {}
			state.mv = New Double(state.m - 1) {}
			state.mtv = New Double(state.n - 1) {}
			state.rstate.ia = New Integer(3) {}
			state.rstate.ra = New Double(2) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        This function changes seed value used by algorithm. In some cases we  need
'        deterministic processing, i.e. subsequent calls must return equal results,
'        in other cases we need non-deterministic algorithm which returns different
'        results for the same matrix on every pass.
'
'        Setting zero seed will lead to non-deterministic algorithm, while non-zero 
'        value will make our algorithm deterministic.
'
'        INPUT PARAMETERS:
'            State       -   norm estimator state, must be initialized with a  call
'                            to NormEstimatorCreate()
'            SeedVal     -   seed value, >=0. Zero value = non-deterministic algo.
'
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub normestimatorsetseed(state As normestimatorstate, seedval As Integer)
			alglib.ap.assert(seedval >= 0, "NormEstimatorSetSeed: SeedVal<0")
			state.seedval = seedval
		End Sub


		'************************************************************************
'
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function normestimatoriteration(state As normestimatorstate) As Boolean
			Dim result As New Boolean()
			Dim n As Integer = 0
			Dim m As Integer = 0
			Dim i As Integer = 0
			Dim itcnt As Integer = 0
			Dim v As Double = 0
			Dim growth As Double = 0
			Dim bestgrowth As Double = 0
			Dim i_ As Integer = 0


			'
			' Reverse communication preparations
			' I know it looks ugly, but it works the same way
			' anywhere from C++ to Python.
			'
			' This code initializes locals by:
			' * random values determined during code
			'   generation - on first subroutine call
			' * values from previous call - on subsequent calls
			'
			If state.rstate.stage >= 0 Then
				n = state.rstate.ia(0)
				m = state.rstate.ia(1)
				i = state.rstate.ia(2)
				itcnt = state.rstate.ia(3)
				v = state.rstate.ra(0)
				growth = state.rstate.ra(1)
				bestgrowth = state.rstate.ra(2)
			Else
				n = -983
				m = -989
				i = -834
				itcnt = 900
				v = -287
				growth = 364
				bestgrowth = 214
			End If
			If state.rstate.stage = 0 Then
				GoTo lbl_0
			End If
			If state.rstate.stage = 1 Then
				GoTo lbl_1
			End If
			If state.rstate.stage = 2 Then
				GoTo lbl_2
			End If
			If state.rstate.stage = 3 Then
				GoTo lbl_3
			End If

			'
			' Routine body
			'
			n = state.n
			m = state.m
			If state.seedval > 0 Then
				hqrnd.hqrndseed(state.seedval, state.seedval + 2, state.r)
			End If
			bestgrowth = 0
			state.xbest(0) = 1
			For i = 1 To n - 1
				state.xbest(i) = 0
			Next
			itcnt = 0
			lbl_4:
			If itcnt > state.nstart - 1 Then
				GoTo lbl_6
			End If
			Do
				v = 0
				For i = 0 To n - 1
					state.x0(i) = hqrnd.hqrndnormal(state.r)
					v = v + Math.sqr(state.x0(i))
				Next
			Loop While CDbl(v) = CDbl(0)
			v = 1 / System.Math.sqrt(v)
			For i_ = 0 To n - 1
				state.x0(i_) = v * state.x0(i_)
			Next
			For i_ = 0 To n - 1
				state.x(i_) = state.x0(i_)
			Next
			state.needmv = True
			state.needmtv = False
			state.rstate.stage = 0
			GoTo lbl_rcomm
			lbl_0:
			For i_ = 0 To m - 1
				state.x(i_) = state.mv(i_)
			Next
			state.needmv = False
			state.needmtv = True
			state.rstate.stage = 1
			GoTo lbl_rcomm
			lbl_1:
			For i_ = 0 To n - 1
				state.x1(i_) = state.mtv(i_)
			Next
			v = 0
			For i = 0 To n - 1
				v = v + Math.sqr(state.x1(i))
			Next
			growth = System.Math.sqrt(System.Math.sqrt(v))
			If CDbl(growth) > CDbl(bestgrowth) Then
				v = 1 / System.Math.sqrt(v)
				For i_ = 0 To n - 1
					state.xbest(i_) = v * state.x1(i_)
				Next
				bestgrowth = growth
			End If
			itcnt = itcnt + 1
			GoTo lbl_4
			lbl_6:
			For i_ = 0 To n - 1
				state.x0(i_) = state.xbest(i_)
			Next
			itcnt = 0
			lbl_7:
			If itcnt > state.nits - 1 Then
				GoTo lbl_9
			End If
			For i_ = 0 To n - 1
				state.x(i_) = state.x0(i_)
			Next
			state.needmv = True
			state.needmtv = False
			state.rstate.stage = 2
			GoTo lbl_rcomm
			lbl_2:
			For i_ = 0 To m - 1
				state.x(i_) = state.mv(i_)
			Next
			state.needmv = False
			state.needmtv = True
			state.rstate.stage = 3
			GoTo lbl_rcomm
			lbl_3:
			For i_ = 0 To n - 1
				state.x1(i_) = state.mtv(i_)
			Next
			v = 0
			For i = 0 To n - 1
				v = v + Math.sqr(state.x1(i))
			Next
			state.repnorm = System.Math.sqrt(System.Math.sqrt(v))
			If CDbl(v) <> CDbl(0) Then
				v = 1 / System.Math.sqrt(v)
				For i_ = 0 To n - 1
					state.x0(i_) = v * state.x1(i_)
				Next
			End If
			itcnt = itcnt + 1
			GoTo lbl_7
			lbl_9:
			result = False
			Return result
			lbl_rcomm:

			'
			' Saving state
			'
			result = True
			state.rstate.ia(0) = n
			state.rstate.ia(1) = m
			state.rstate.ia(2) = i
			state.rstate.ia(3) = itcnt
			state.rstate.ra(0) = v
			state.rstate.ra(1) = growth
			state.rstate.ra(2) = bestgrowth
			Return result
		End Function


		'************************************************************************
'        This function estimates norm of the sparse M*N matrix A.
'
'        INPUT PARAMETERS:
'            State       -   norm estimator state, must be initialized with a  call
'                            to NormEstimatorCreate()
'            A           -   sparse M*N matrix, must be converted to CRS format
'                            prior to calling this function.
'
'        After this function  is  over  you can call NormEstimatorResults() to get 
'        estimate of the norm(A).
'
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub normestimatorestimatesparse(state As normestimatorstate, a As sparse.sparsematrix)
			normestimatorrestart(state)
			While normestimatoriteration(state)
				If state.needmv Then
					sparse.sparsemv(a, state.x, state.mv)
					Continue While
				End If
				If state.needmtv Then
					sparse.sparsemtv(a, state.x, state.mtv)
					Continue While
				End If
			End While
		End Sub


		'************************************************************************
'        Matrix norm estimation results
'
'        INPUT PARAMETERS:
'            State   -   algorithm state
'
'        OUTPUT PARAMETERS:
'            Nrm     -   estimate of the matrix norm, Nrm>=0
'
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub normestimatorresults(state As normestimatorstate, ByRef nrm As Double)
			nrm = 0

			nrm = state.repnorm
		End Sub


		'************************************************************************
'        This  function  restarts estimator and prepares it for the next estimation
'        round.
'
'        INPUT PARAMETERS:
'            State   -   algorithm state
'          -- ALGLIB --
'             Copyright 06.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub normestimatorrestart(state As normestimatorstate)
			state.rstate.ia = New Integer(3) {}
			state.rstate.ra = New Double(2) {}
			state.rstate.stage = -1
		End Sub


	End Class
	Public Class matdet
		'************************************************************************
'        Determinant calculation of the matrix given by its LU decomposition.
'
'        Input parameters:
'            A       -   LU decomposition of the matrix (output of
'                        RMatrixLU subroutine).
'            Pivots  -   table of permutations which were made during
'                        the LU decomposition.
'                        Output of RMatrixLU subroutine.
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'
'        Result: matrix determinant.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function rmatrixludet(a As Double(,), pivots As Integer(), n As Integer) As Double
			Dim result As Double = 0
			Dim i As Integer = 0
			Dim s As Integer = 0

			alglib.ap.assert(n >= 1, "RMatrixLUDet: N<1!")
			alglib.ap.assert(alglib.ap.len(pivots) >= n, "RMatrixLUDet: Pivots array is too short!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixLUDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixLUDet: cols(A)<N!")
			alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixLUDet: A contains infinite or NaN values!")
			result = 1
			s = 1
			For i = 0 To n - 1
				result = result * a(i, i)
				If pivots(i) <> i Then
					s = -s
				End If
			Next
			result = result * s
			Return result
		End Function


		'************************************************************************
'        Calculation of the determinant of a general matrix
'
'        Input parameters:
'            A       -   matrix, array[0..N-1, 0..N-1]
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'
'        Result: determinant of matrix A.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function rmatrixdet(a As Double(,), n As Integer) As Double
			Dim result As Double = 0
			Dim pivots As Integer() = New Integer(-1) {}

			a = DirectCast(a.Clone(), Double(,))

			alglib.ap.assert(n >= 1, "RMatrixDet: N<1!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "RMatrixDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "RMatrixDet: cols(A)<N!")
			alglib.ap.assert(apserv.apservisfinitematrix(a, n, n), "RMatrixDet: A contains infinite or NaN values!")
			trfac.rmatrixlu(a, n, n, pivots)
			result = rmatrixludet(a, pivots, n)
			Return result
		End Function


		'************************************************************************
'        Determinant calculation of the matrix given by its LU decomposition.
'
'        Input parameters:
'            A       -   LU decomposition of the matrix (output of
'                        RMatrixLU subroutine).
'            Pivots  -   table of permutations which were made during
'                        the LU decomposition.
'                        Output of RMatrixLU subroutine.
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'
'        Result: matrix determinant.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function cmatrixludet(a As complex(,), pivots As Integer(), n As Integer) As complex
			Dim result As complex = 0
			Dim i As Integer = 0
			Dim s As Integer = 0

			alglib.ap.assert(n >= 1, "CMatrixLUDet: N<1!")
			alglib.ap.assert(alglib.ap.len(pivots) >= n, "CMatrixLUDet: Pivots array is too short!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixLUDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixLUDet: cols(A)<N!")
			alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixLUDet: A contains infinite or NaN values!")
			result = 1
			s = 1
			For i = 0 To n - 1
				result = result * a(i, i)
				If pivots(i) <> i Then
					s = -s
				End If
			Next
			result = result * s
			Return result
		End Function


		'************************************************************************
'        Calculation of the determinant of a general matrix
'
'        Input parameters:
'            A       -   matrix, array[0..N-1, 0..N-1]
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'
'        Result: determinant of matrix A.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function cmatrixdet(a As complex(,), n As Integer) As complex
			Dim result As complex = 0
			Dim pivots As Integer() = New Integer(-1) {}

			a = DirectCast(a.Clone(), complex(,))

			alglib.ap.assert(n >= 1, "CMatrixDet: N<1!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "CMatrixDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "CMatrixDet: cols(A)<N!")
			alglib.ap.assert(apserv.apservisfinitecmatrix(a, n, n), "CMatrixDet: A contains infinite or NaN values!")
			trfac.cmatrixlu(a, n, n, pivots)
			result = cmatrixludet(a, pivots, n)
			Return result
		End Function


		'************************************************************************
'        Determinant calculation of the matrix given by the Cholesky decomposition.
'
'        Input parameters:
'            A       -   Cholesky decomposition,
'                        output of SMatrixCholesky subroutine.
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'
'        As the determinant is equal to the product of squares of diagonal elements,
'        it not necessary to specify which triangle - lower or upper - the matrix
'        is stored in.
'
'        Result:
'            matrix determinant.
'
'          -- ALGLIB --
'             Copyright 2005-2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spdmatrixcholeskydet(a As Double(,), n As Integer) As Double
			Dim result As Double = 0
			Dim i As Integer = 0
			Dim f As New Boolean()

			alglib.ap.assert(n >= 1, "SPDMatrixCholeskyDet: N<1!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixCholeskyDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixCholeskyDet: cols(A)<N!")
			f = True
			For i = 0 To n - 1
				f = f AndAlso Math.isfinite(a(i, i))
			Next
			alglib.ap.assert(f, "SPDMatrixCholeskyDet: A contains infinite or NaN values!")
			result = 1
			For i = 0 To n - 1
				result = result * Math.sqr(a(i, i))
			Next
			Return result
		End Function


		'************************************************************************
'        Determinant calculation of the symmetric positive definite matrix.
'
'        Input parameters:
'            A       -   matrix. Array with elements [0..N-1, 0..N-1].
'            N       -   (optional) size of matrix A:
'                        * if given, only principal NxN submatrix is processed and
'                          overwritten. other elements are unchanged.
'                        * if not given, automatically determined from matrix size
'                          (A must be square matrix)
'            IsUpper -   (optional) storage type:
'                        * if True, symmetric matrix  A  is  given  by  its  upper
'                          triangle, and the lower triangle isn used/changed  by
'                          function
'                        * if False, symmetric matrix  A  is  given  by  its lower
'                          triangle, and the upper triangle isn used/changed  by
'                          function
'                        * if not given, both lower and upper  triangles  must  be
'                          filled.
'
'        Result:
'            determinant of matrix A.
'            If matrix A is not positive definite, exception is thrown.
'
'          -- ALGLIB --
'             Copyright 2005-2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spdmatrixdet(a As Double(,), n As Integer, isupper As Boolean) As Double
			Dim result As Double = 0
			Dim b As New Boolean()

			a = DirectCast(a.Clone(), Double(,))

			alglib.ap.assert(n >= 1, "SPDMatrixDet: N<1!")
			alglib.ap.assert(alglib.ap.rows(a) >= n, "SPDMatrixDet: rows(A)<N!")
			alglib.ap.assert(alglib.ap.cols(a) >= n, "SPDMatrixDet: cols(A)<N!")
			alglib.ap.assert(apserv.isfinitertrmatrix(a, n, isupper), "SPDMatrixDet: A contains infinite or NaN values!")
			b = trfac.spdmatrixcholesky(a, n, isupper)
			alglib.ap.assert(b, "SPDMatrixDet: A is not SPD!")
			result = spdmatrixcholeskydet(a, n)
			Return result
		End Function


	End Class
	Public Class spdgevd
		'************************************************************************
'        Algorithm for solving the following generalized symmetric positive-definite
'        eigenproblem:
'            A*x = lambda*B*x (1) or
'            A*B*x = lambda*x (2) or
'            B*A*x = lambda*x (3).
'        where A is a symmetric matrix, B - symmetric positive-definite matrix.
'        The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
'        problem.
'
'        Input parameters:
'            A           -   symmetric matrix which is given by its upper or lower
'                            triangular part.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            N           -   size of matrices A and B.
'            IsUpperA    -   storage format of matrix A.
'            B           -   symmetric positive-definite matrix which is given by
'                            its upper or lower triangular part.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            IsUpperB    -   storage format of matrix B.
'            ZNeeded     -   if ZNeeded is equal to:
'                             * 0, the eigenvectors are not returned;
'                             * 1, the eigenvectors are returned.
'            ProblemType -   if ProblemType is equal to:
'                             * 1, the following problem is solved: A*x = lambda*B*x;
'                             * 2, the following problem is solved: A*B*x = lambda*x;
'                             * 3, the following problem is solved: B*A*x = lambda*x.
'
'        Output parameters:
'            D           -   eigenvalues in ascending order.
'                            Array whose index ranges within [0..N-1].
'            Z           -   if ZNeeded is equal to:
'                             * 0, Z hasn changed;
'                             * 1, Z contains eigenvectors.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'                            The eigenvectors are stored in matrix columns. It should
'                            be noted that the eigenvectors in such problems do not
'                            form an orthogonal system.
'
'        Result:
'            True, if the problem was solved successfully.
'            False, if the error occurred during the Cholesky decomposition of matrix
'            B (the matrix isn positive-definite) or during the work of the iterative
'            algorithm for solving the symmetric eigenproblem.
'
'        See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.
'
'          -- ALGLIB --
'             Copyright 1.28.2006 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixgevd(a As Double(,), n As Integer, isuppera As Boolean, b As Double(,), isupperb As Boolean, zneeded As Integer, _
			problemtype As Integer, ByRef d As Double(), ByRef z As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim r As Double(,) = New Double(-1, -1) {}
			Dim t As Double(,) = New Double(-1, -1) {}
			Dim isupperr As New Boolean()
			Dim j1 As Integer = 0
			Dim j2 As Integer = 0
			Dim j1inc As Integer = 0
			Dim j2inc As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			a = DirectCast(a.Clone(), Double(,))
			d = New Double(-1) {}
			z = New Double(-1, -1) {}


			'
			' Reduce and solve
			'
			result = smatrixgevdreduce(a, n, isuppera, b, isupperb, problemtype, _
				r, isupperr)
			If Not result Then
				Return result
			End If
			result = evd.smatrixevd(a, n, zneeded, isuppera, d, t)
			If Not result Then
				Return result
			End If

			'
			' Transform eigenvectors if needed
			'
			If zneeded <> 0 Then

				'
				' fill Z with zeros
				'
				z = New Double(n - 1, n - 1) {}
				For j = 0 To n - 1
					z(0, j) = 0.0
				Next
				For i = 1 To n - 1
					For i_ = 0 To n - 1
						z(i, i_) = z(0, i_)
					Next
				Next

				'
				' Setup R properties
				'
				If isupperr Then
					j1 = 0
					j2 = n - 1
					j1inc = 1
					j2inc = 0
				Else
					j1 = 0
					j2 = 0
					j1inc = 0
					j2inc = 1
				End If

				'
				' Calculate R*Z
				'
				For i = 0 To n - 1
					For j = j1 To j2
						v = r(i, j)
						For i_ = 0 To n - 1
							z(i, i_) = z(i, i_) + v * t(j, i_)
						Next
					Next
					j1 = j1 + j1inc
					j2 = j2 + j2inc
				Next
			End If
			Return result
		End Function


		'************************************************************************
'        Algorithm for reduction of the following generalized symmetric positive-
'        definite eigenvalue problem:
'            A*x = lambda*B*x (1) or
'            A*B*x = lambda*x (2) or
'            B*A*x = lambda*x (3)
'        to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
'        the given problems are the same, and the eigenvectors of the given problem
'        could be obtained by multiplying the obtained eigenvectors by the
'        transformation matrix x = R*y).
'
'        Here A is a symmetric matrix, B - symmetric positive-definite matrix.
'
'        Input parameters:
'            A           -   symmetric matrix which is given by its upper or lower
'                            triangular part.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            N           -   size of matrices A and B.
'            IsUpperA    -   storage format of matrix A.
'            B           -   symmetric positive-definite matrix which is given by
'                            its upper or lower triangular part.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            IsUpperB    -   storage format of matrix B.
'            ProblemType -   if ProblemType is equal to:
'                             * 1, the following problem is solved: A*x = lambda*B*x;
'                             * 2, the following problem is solved: A*B*x = lambda*x;
'                             * 3, the following problem is solved: B*A*x = lambda*x.
'
'        Output parameters:
'            A           -   symmetric matrix which is given by its upper or lower
'                            triangle depending on IsUpperA. Contains matrix C.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            R           -   upper triangular or low triangular transformation matrix
'                            which is used to obtain the eigenvectors of a given problem
'                            as the product of eigenvectors of C (from the right) and
'                            matrix R (from the left). If the matrix is upper
'                            triangular, the elements below the main diagonal
'                            are equal to 0 (and vice versa). Thus, we can perform
'                            the multiplication without taking into account the
'                            internal structure (which is an easier though less
'                            effective way).
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            IsUpperR    -   type of matrix R (upper or lower triangular).
'
'        Result:
'            True, if the problem was reduced successfully.
'            False, if the error occurred during the Cholesky decomposition of
'                matrix B (the matrix is not positive-definite).
'
'          -- ALGLIB --
'             Copyright 1.28.2006 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function smatrixgevdreduce(ByRef a As Double(,), n As Integer, isuppera As Boolean, b As Double(,), isupperb As Boolean, problemtype As Integer, _
			ByRef r As Double(,), ByRef isupperr As Boolean) As Boolean
			Dim result As New Boolean()
			Dim t As Double(,) = New Double(-1, -1) {}
			Dim w1 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim w3 As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim rep As New matinv.matinvreport()
			Dim info As Integer = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			r = New Double(-1, -1) {}
			isupperr = New Boolean()

			alglib.ap.assert(n > 0, "SMatrixGEVDReduce: N<=0!")
			alglib.ap.assert((problemtype = 1 OrElse problemtype = 2) OrElse problemtype = 3, "SMatrixGEVDReduce: incorrect ProblemType!")
			result = True

			'
			' Problem 1:  A*x = lambda*B*x
			'
			' Reducing to:
			'     C*y = lambda*y
			'     C = L^(-1) * A * L^(-T)
			'     x = L^(-T) * y
			'
			If problemtype = 1 Then

				'
				' Factorize B in T: B = LL'
				'
				t = New Double(n - 1, n - 1) {}
				If isupperb Then
					For i = 0 To n - 1
						For i_ = i To n - 1
							t(i_, i) = b(i, i_)
						Next
					Next
				Else
					For i = 0 To n - 1
						For i_ = 0 To i
							t(i, i_) = b(i, i_)
						Next
					Next
				End If
				If Not trfac.spdmatrixcholesky(t, n, False) Then
					result = False
					Return result
				End If

				'
				' Invert L in T
				'
				matinv.rmatrixtrinverse(t, n, False, False, info, rep)
				If info <= 0 Then
					result = False
					Return result
				End If

				'
				' Build L^(-1) * A * L^(-T) in R
				'
				w1 = New Double(n) {}
				w2 = New Double(n) {}
				r = New Double(n - 1, n - 1) {}
				For j = 1 To n

					'
					' Form w2 = A * l'(j) (here l'(j) is j-th column of L^(-T))
					'
					i1_ = (0) - (1)
					For i_ = 1 To j
						w1(i_) = t(j - 1, i_ + i1_)
					Next
					sblas.symmetricmatrixvectormultiply(a, isuppera, 0, j - 1, w1, 1.0, _
						w2)
					If isuppera Then
						blas.matrixvectormultiply(a, 0, j - 1, j, n - 1, True, _
							w1, 1, j, 1.0, w2, j + 1, _
							n, 0.0)
					Else
						blas.matrixvectormultiply(a, j, n - 1, 0, j - 1, False, _
							w1, 1, j, 1.0, w2, j + 1, _
							n, 0.0)
					End If

					'
					' Form l(i)*w2 (here l(i) is i-th row of L^(-1))
					'
					For i = 1 To n
						i1_ = (1) - (0)
						v = 0.0
						For i_ = 0 To i - 1
							v += t(i - 1, i_) * w2(i_ + i1_)
						Next
						r(i - 1, j - 1) = v
					Next
				Next

				'
				' Copy R to A
				'
				For i = 0 To n - 1
					For i_ = 0 To n - 1
						a(i, i_) = r(i, i_)
					Next
				Next

				'
				' Copy L^(-1) from T to R and transpose
				'
				isupperr = True
				For i = 0 To n - 1
					For j = 0 To i - 1
						r(i, j) = 0
					Next
				Next
				For i = 0 To n - 1
					For i_ = i To n - 1
						r(i, i_) = t(i_, i)
					Next
				Next
				Return result
			End If

			'
			' Problem 2:  A*B*x = lambda*x
			' or
			' problem 3:  B*A*x = lambda*x
			'
			' Reducing to:
			'     C*y = lambda*y
			'     C = U * A * U'
			'     B = U'* U
			'
			If problemtype = 2 OrElse problemtype = 3 Then

				'
				' Factorize B in T: B = U'*U
				'
				t = New Double(n - 1, n - 1) {}
				If isupperb Then
					For i = 0 To n - 1
						For i_ = i To n - 1
							t(i, i_) = b(i, i_)
						Next
					Next
				Else
					For i = 0 To n - 1
						For i_ = i To n - 1
							t(i, i_) = b(i_, i)
						Next
					Next
				End If
				If Not trfac.spdmatrixcholesky(t, n, True) Then
					result = False
					Return result
				End If

				'
				' Build U * A * U' in R
				'
				w1 = New Double(n) {}
				w2 = New Double(n) {}
				w3 = New Double(n) {}
				r = New Double(n - 1, n - 1) {}
				For j = 1 To n

					'
					' Form w2 = A * u'(j) (here u'(j) is j-th column of U')
					'
					i1_ = (j - 1) - (1)
					For i_ = 1 To n - j + 1
						w1(i_) = t(j - 1, i_ + i1_)
					Next
					sblas.symmetricmatrixvectormultiply(a, isuppera, j - 1, n - 1, w1, 1.0, _
						w3)
					i1_ = (1) - (j)
					For i_ = j To n
						w2(i_) = w3(i_ + i1_)
					Next
					i1_ = (j - 1) - (j)
					For i_ = j To n
						w1(i_) = t(j - 1, i_ + i1_)
					Next
					If isuppera Then
						blas.matrixvectormultiply(a, 0, j - 2, j - 1, n - 1, False, _
							w1, j, n, 1.0, w2, 1, _
							j - 1, 0.0)
					Else
						blas.matrixvectormultiply(a, j - 1, n - 1, 0, j - 2, True, _
							w1, j, n, 1.0, w2, 1, _
							j - 1, 0.0)
					End If

					'
					' Form u(i)*w2 (here u(i) is i-th row of U)
					'
					For i = 1 To n
						i1_ = (i) - (i - 1)
						v = 0.0
						For i_ = i - 1 To n - 1
							v += t(i - 1, i_) * w2(i_ + i1_)
						Next
						r(i - 1, j - 1) = v
					Next
				Next

				'
				' Copy R to A
				'
				For i = 0 To n - 1
					For i_ = 0 To n - 1
						a(i, i_) = r(i, i_)
					Next
				Next
				If problemtype = 2 Then

					'
					' Invert U in T
					'
					matinv.rmatrixtrinverse(t, n, True, False, info, rep)
					If info <= 0 Then
						result = False
						Return result
					End If

					'
					' Copy U^-1 from T to R
					'
					isupperr = True
					For i = 0 To n - 1
						For j = 0 To i - 1
							r(i, j) = 0
						Next
					Next
					For i = 0 To n - 1
						For i_ = i To n - 1
							r(i, i_) = t(i, i_)
						Next
					Next
				Else

					'
					' Copy U from T to R and transpose
					'
					isupperr = False
					For i = 0 To n - 1
						For j = i + 1 To n - 1
							r(i, j) = 0
						Next
					Next
					For i = 0 To n - 1
						For i_ = i To n - 1
							r(i_, i) = t(i, i_)
						Next
					Next
				End If
			End If
			Return result
		End Function


	End Class
	Public Class inverseupdate
		'************************************************************************
'        Inverse matrix update by the Sherman-Morrison formula
'
'        The algorithm updates matrix A^-1 when adding a number to an element
'        of matrix A.
'
'        Input parameters:
'            InvA    -   inverse of matrix A.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            UpdRow  -   row where the element to be updated is stored.
'            UpdColumn - column where the element to be updated is stored.
'            UpdVal  -   a number to be added to the element.
'
'
'        Output parameters:
'            InvA    -   inverse of modified matrix A.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixinvupdatesimple(ByRef inva As Double(,), n As Integer, updrow As Integer, updcolumn As Integer, updval As Double)
			Dim t1 As Double() = New Double(-1) {}
			Dim t2 As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim lambdav As Double = 0
			Dim vt As Double = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(updrow >= 0 AndAlso updrow < n, "RMatrixInvUpdateSimple: incorrect UpdRow!")
			alglib.ap.assert(updcolumn >= 0 AndAlso updcolumn < n, "RMatrixInvUpdateSimple: incorrect UpdColumn!")
			t1 = New Double(n - 1) {}
			t2 = New Double(n - 1) {}

			'
			' T1 = InvA * U
			'
			For i_ = 0 To n - 1
				t1(i_) = inva(i_, updrow)
			Next

			'
			' T2 = v*InvA
			'
			For i_ = 0 To n - 1
				t2(i_) = inva(updcolumn, i_)
			Next

			'
			' Lambda = v * InvA * U
			'
			lambdav = updval * inva(updcolumn, updrow)

			'
			' InvA = InvA - correction
			'
			For i = 0 To n - 1
				vt = updval * t1(i)
				vt = vt / (1 + lambdav)
				For i_ = 0 To n - 1
					inva(i, i_) = inva(i, i_) - vt * t2(i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Inverse matrix update by the Sherman-Morrison formula
'
'        The algorithm updates matrix A^-1 when adding a vector to a row
'        of matrix A.
'
'        Input parameters:
'            InvA    -   inverse of matrix A.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            UpdRow  -   the row of A whose vector V was added.
'                        0 <= Row <= N-1
'            V       -   the vector to be added to a row.
'                        Array whose index ranges within [0..N-1].
'
'        Output parameters:
'            InvA    -   inverse of modified matrix A.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixinvupdaterow(ByRef inva As Double(,), n As Integer, updrow As Integer, v As Double())
			Dim t1 As Double() = New Double(-1) {}
			Dim t2 As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lambdav As Double = 0
			Dim vt As Double = 0
			Dim i_ As Integer = 0

			t1 = New Double(n - 1) {}
			t2 = New Double(n - 1) {}

			'
			' T1 = InvA * U
			'
			For i_ = 0 To n - 1
				t1(i_) = inva(i_, updrow)
			Next

			'
			' T2 = v*InvA
			' Lambda = v * InvA * U
			'
			For j = 0 To n - 1
				vt = 0.0
				For i_ = 0 To n - 1
					vt += v(i_) * inva(i_, j)
				Next
				t2(j) = vt
			Next
			lambdav = t2(updrow)

			'
			' InvA = InvA - correction
			'
			For i = 0 To n - 1
				vt = t1(i) / (1 + lambdav)
				For i_ = 0 To n - 1
					inva(i, i_) = inva(i, i_) - vt * t2(i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Inverse matrix update by the Sherman-Morrison formula
'
'        The algorithm updates matrix A^-1 when adding a vector to a column
'        of matrix A.
'
'        Input parameters:
'            InvA        -   inverse of matrix A.
'                            Array whose indexes range within [0..N-1, 0..N-1].
'            N           -   size of matrix A.
'            UpdColumn   -   the column of A whose vector U was added.
'                            0 <= UpdColumn <= N-1
'            U           -   the vector to be added to a column.
'                            Array whose index ranges within [0..N-1].
'
'        Output parameters:
'            InvA        -   inverse of modified matrix A.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixinvupdatecolumn(ByRef inva As Double(,), n As Integer, updcolumn As Integer, u As Double())
			Dim t1 As Double() = New Double(-1) {}
			Dim t2 As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim lambdav As Double = 0
			Dim vt As Double = 0
			Dim i_ As Integer = 0

			t1 = New Double(n - 1) {}
			t2 = New Double(n - 1) {}

			'
			' T1 = InvA * U
			' Lambda = v * InvA * U
			'
			For i = 0 To n - 1
				vt = 0.0
				For i_ = 0 To n - 1
					vt += inva(i, i_) * u(i_)
				Next
				t1(i) = vt
			Next
			lambdav = t1(updcolumn)

			'
			' T2 = v*InvA
			'
			For i_ = 0 To n - 1
				t2(i_) = inva(updcolumn, i_)
			Next

			'
			' InvA = InvA - correction
			'
			For i = 0 To n - 1
				vt = t1(i) / (1 + lambdav)
				For i_ = 0 To n - 1
					inva(i, i_) = inva(i, i_) - vt * t2(i_)
				Next
			Next
		End Sub


		'************************************************************************
'        Inverse matrix update by the Sherman-Morrison formula
'
'        The algorithm computes the inverse of matrix A+u*v?by using the given matrix
'        A^-1 and the vectors u and v.
'
'        Input parameters:
'            InvA    -   inverse of matrix A.
'                        Array whose indexes range within [0..N-1, 0..N-1].
'            N       -   size of matrix A.
'            U       -   the vector modifying the matrix.
'                        Array whose index ranges within [0..N-1].
'            V       -   the vector modifying the matrix.
'                        Array whose index ranges within [0..N-1].
'
'        Output parameters:
'            InvA - inverse of matrix A + u*v'.
'
'          -- ALGLIB --
'             Copyright 2005 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rmatrixinvupdateuv(ByRef inva As Double(,), n As Integer, u As Double(), v As Double())
			Dim t1 As Double() = New Double(-1) {}
			Dim t2 As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lambdav As Double = 0
			Dim vt As Double = 0
			Dim i_ As Integer = 0

			t1 = New Double(n - 1) {}
			t2 = New Double(n - 1) {}

			'
			' T1 = InvA * U
			' Lambda = v * T1
			'
			For i = 0 To n - 1
				vt = 0.0
				For i_ = 0 To n - 1
					vt += inva(i, i_) * u(i_)
				Next
				t1(i) = vt
			Next
			lambdav = 0.0
			For i_ = 0 To n - 1
				lambdav += v(i_) * t1(i_)
			Next

			'
			' T2 = v*InvA
			'
			For j = 0 To n - 1
				vt = 0.0
				For i_ = 0 To n - 1
					vt += v(i_) * inva(i_, j)
				Next
				t2(j) = vt
			Next

			'
			' InvA = InvA - correction
			'
			For i = 0 To n - 1
				vt = t1(i) / (1 + lambdav)
				For i_ = 0 To n - 1
					inva(i, i_) = inva(i, i_) - vt * t2(i_)
				Next
			Next
		End Sub


	End Class
	Public Class schur
		'************************************************************************
'        Subroutine performing the Schur decomposition of a general matrix by using
'        the QR algorithm with multiple shifts.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes one  important  improvement   of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Multithreaded acceleration is NOT supported for this function.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        The source matrix A is represented as S'*A*S = T, where S is an orthogonal
'        matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
'        sizes 1x1 and 2x2 on the main diagonal).
'
'        Input parameters:
'            A   -   matrix to be decomposed.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'            N   -   size of A, N>=0.
'
'
'        Output parameters:
'            A   -   contains matrix T.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'            S   -   contains Schur vectors.
'                    Array whose indexes range within [0..N-1, 0..N-1].
'
'        Note 1:
'            The block structure of matrix T can be easily recognized: since all
'            the elements below the blocks are zeros, the elements a[i+1,i] which
'            are equal to 0 show the block border.
'
'        Note 2:
'            The algorithm performance depends on the value of the internal parameter
'            NS of the InternalSchurDecomposition subroutine which defines the number
'            of shifts in the QR algorithm (similarly to the block width in block-matrix
'            algorithms in linear algebra). If you require maximum performance on
'            your machine, it is recommended to adjust this parameter manually.
'
'        Result:
'            True,
'                if the algorithm has converged and parameters A and S contain the result.
'            False,
'                if the algorithm has not converged.
'
'        Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
'        ************************************************************************

		Public Shared Function rmatrixschur(ByRef a As Double(,), n As Integer, ByRef s As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tau As Double() = New Double(-1) {}
			Dim wi As Double() = New Double(-1) {}
			Dim wr As Double() = New Double(-1) {}
			Dim info As Integer = 0

			s = New Double(-1, -1) {}


			'
			' Upper Hessenberg form of the 0-based matrix
			'
			ortfac.rmatrixhessenberg(a, n, tau)
			ortfac.rmatrixhessenbergunpackq(a, n, tau, s)

			'
			' Schur decomposition
			'
			hsschur.rmatrixinternalschurdecomposition(a, n, 1, 1, wr, wi, _
				s, info)
			result = info = 0
			Return result
		End Function


	End Class
End Class

