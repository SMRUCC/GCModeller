'************************************************************************
'ALGLIB 3.9.0 (source code generated 2014-12-11)
'Copyright (c) Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the 
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'>>> END OF LICENSE >>>
'************************************************************************

'#Pragma warning disable 162
'#Pragma warning disable 219

Public Partial Class alglib


	'************************************************************************
'    IDW interpolant.
'    ************************************************************************

	Public Class idwinterpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New idwint.idwinterpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New idwinterpolant(DirectCast(_innerobj.make_copy(), idwint.idwinterpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As idwint.idwinterpolant
		Public ReadOnly Property innerobj() As idwint.idwinterpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As idwint.idwinterpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    IDW interpolation
'
'    INPUT PARAMETERS:
'        Z   -   IDW interpolant built with one of model building
'                subroutines.
'        X   -   array[0..NX-1], interpolation point
'
'    Result:
'        IDW interpolant Z(X)
'
'      -- ALGLIB --
'         Copyright 02.03.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function idwcalc(z As idwinterpolant, x As Double()) As Double

		Dim result As Double = idwint.idwcalc(z.innerobj, x)
		Return result
	End Function

	'************************************************************************
'    IDW interpolant using modified Shepard method for uniform point
'    distributions.
'
'    INPUT PARAMETERS:
'        XY  -   X and Y values, array[0..N-1,0..NX].
'                First NX columns contain X-values, last column contain
'                Y-values.
'        N   -   number of nodes, N>0.
'        NX  -   space dimension, NX>=1.
'        D   -   nodal function type, either:
'                * 0     constant  model.  Just  for  demonstration only, worst
'                        model ever.
'                * 1     linear model, least squares fitting. Simpe  model  for
'                        datasets too small for quadratic models
'                * 2     quadratic  model,  least  squares  fitting. Best model
'                        available (if your dataset is large enough).
'                * -1    "fast"  linear  model,  use  with  caution!!!   It  is
'                        significantly  faster than linear/quadratic and better
'                        than constant model. But it is less robust (especially
'                        in the presence of noise).
'        NQ  -   number of points used to calculate  nodal  functions  (ignored
'                for constant models). NQ should be LARGER than:
'                * max(1.5*(1+NX),2^NX+1) for linear model,
'                * max(3/4*(NX+2)*(NX+1),2^NX+1) for quadratic model.
'                Values less than this threshold will be silently increased.
'        NW  -   number of points used to calculate weights and to interpolate.
'                Required: >=2^NX+1, values less than this  threshold  will  be
'                silently increased.
'                Recommended value: about 2*NQ
'
'    OUTPUT PARAMETERS:
'        Z   -   IDW interpolant.
'
'    NOTES:
'      * best results are obtained with quadratic models, worst - with constant
'        models
'      * when N is large, NQ and NW must be significantly smaller than  N  both
'        to obtain optimal performance and to obtain optimal accuracy. In 2  or
'        3-dimensional tasks NQ=15 and NW=25 are good values to start with.
'      * NQ  and  NW  may  be  greater  than  N.  In  such  cases  they will be
'        automatically decreased.
'      * this subroutine is always succeeds (as long as correct parameters  are
'        passed).
'      * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
'        Robert J. Renka for more information on this algorithm.
'      * this subroutine assumes that point distribution is uniform at the small
'        scales.  If  it  isn't  -  for  example,  points are concentrated along
'        "lines", but "lines" distribution is uniform at the larger scale - then
'        you should use IDWBuildModifiedShepardR()
'
'
'      -- ALGLIB PROJECT --
'         Copyright 02.03.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub idwbuildmodifiedshepard(xy As Double(,), n As Integer, nx As Integer, d As Integer, nq As Integer, nw As Integer, _
		ByRef z As idwinterpolant)
		z = New idwinterpolant()
		idwint.idwbuildmodifiedshepard(xy, n, nx, d, nq, nw, _
			z.innerobj)
		Return
	End Sub

	'************************************************************************
'    IDW interpolant using modified Shepard method for non-uniform datasets.
'
'    This type of model uses  constant  nodal  functions and interpolates using
'    all nodes which are closer than user-specified radius R. It  may  be  used
'    when points distribution is non-uniform at the small scale, but it  is  at
'    the distances as large as R.
'
'    INPUT PARAMETERS:
'        XY  -   X and Y values, array[0..N-1,0..NX].
'                First NX columns contain X-values, last column contain
'                Y-values.
'        N   -   number of nodes, N>0.
'        NX  -   space dimension, NX>=1.
'        R   -   radius, R>0
'
'    OUTPUT PARAMETERS:
'        Z   -   IDW interpolant.
'
'    NOTES:
'    * if there is less than IDWKMin points within  R-ball,  algorithm  selects
'      IDWKMin closest ones, so that continuity properties of  interpolant  are
'      preserved even far from points.
'
'      -- ALGLIB PROJECT --
'         Copyright 11.04.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub idwbuildmodifiedshepardr(xy As Double(,), n As Integer, nx As Integer, r As Double, ByRef z As idwinterpolant)
		z = New idwinterpolant()
		idwint.idwbuildmodifiedshepardr(xy, n, nx, r, z.innerobj)
		Return
	End Sub

	'************************************************************************
'    IDW model for noisy data.
'
'    This subroutine may be used to handle noisy data, i.e. data with noise  in
'    OUTPUT values.  It differs from IDWBuildModifiedShepard() in the following
'    aspects:
'    * nodal functions are not constrained to pass through  nodes:  Qi(xi)<>yi,
'      i.e. we have fitting  instead  of  interpolation.
'    * weights which are used during least  squares fitting stage are all equal
'      to 1.0 (independently of distance)
'    * "fast"-linear or constant nodal functions are not supported (either  not
'      robust enough or too rigid)
'
'    This problem require far more complex tuning than interpolation  problems.
'    Below you can find some recommendations regarding this problem:
'    * focus on tuning NQ; it controls noise reduction. As for NW, you can just
'      make it equal to 2*NQ.
'    * you can use cross-validation to determine optimal NQ.
'    * optimal NQ is a result of complex tradeoff  between  noise  level  (more
'      noise = larger NQ required) and underlying  function  complexity  (given
'      fixed N, larger NQ means smoothing of compex features in the data).  For
'      example, NQ=N will reduce noise to the minimum level possible,  but  you
'      will end up with just constant/linear/quadratic (depending on  D)  least
'      squares model for the whole dataset.
'
'    INPUT PARAMETERS:
'        XY  -   X and Y values, array[0..N-1,0..NX].
'                First NX columns contain X-values, last column contain
'                Y-values.
'        N   -   number of nodes, N>0.
'        NX  -   space dimension, NX>=1.
'        D   -   nodal function degree, either:
'                * 1     linear model, least squares fitting. Simpe  model  for
'                        datasets too small for quadratic models (or  for  very
'                        noisy problems).
'                * 2     quadratic  model,  least  squares  fitting. Best model
'                        available (if your dataset is large enough).
'        NQ  -   number of points used to calculate nodal functions.  NQ should
'                be  significantly   larger   than  1.5  times  the  number  of
'                coefficients in a nodal function to overcome effects of noise:
'                * larger than 1.5*(1+NX) for linear model,
'                * larger than 3/4*(NX+2)*(NX+1) for quadratic model.
'                Values less than this threshold will be silently increased.
'        NW  -   number of points used to calculate weights and to interpolate.
'                Required: >=2^NX+1, values less than this  threshold  will  be
'                silently increased.
'                Recommended value: about 2*NQ or larger
'
'    OUTPUT PARAMETERS:
'        Z   -   IDW interpolant.
'
'    NOTES:
'      * best results are obtained with quadratic models, linear models are not
'        recommended to use unless you are pretty sure that it is what you want
'      * this subroutine is always succeeds (as long as correct parameters  are
'        passed).
'      * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
'        Robert J. Renka for more information on this algorithm.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 02.03.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub idwbuildnoisy(xy As Double(,), n As Integer, nx As Integer, d As Integer, nq As Integer, nw As Integer, _
		ByRef z As idwinterpolant)
		z = New idwinterpolant()
		idwint.idwbuildnoisy(xy, n, nx, d, nq, nw, _
			z.innerobj)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Barycentric interpolant.
'    ************************************************************************

	Public Class barycentricinterpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New ratint.barycentricinterpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New barycentricinterpolant(DirectCast(_innerobj.make_copy(), ratint.barycentricinterpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As ratint.barycentricinterpolant
		Public ReadOnly Property innerobj() As ratint.barycentricinterpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As ratint.barycentricinterpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    Rational interpolation using barycentric formula
'
'    F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'    Input parameters:
'        B   -   barycentric interpolant built with one of model building
'                subroutines.
'        T   -   interpolation point
'
'    Result:
'        barycentric interpolant F(t)
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function barycentriccalc(b As barycentricinterpolant, t As Double) As Double

		Dim result As Double = ratint.barycentriccalc(b.innerobj, t)
		Return result
	End Function

	'************************************************************************
'    Differentiation of barycentric interpolant: first derivative.
'
'    Algorithm used in this subroutine is very robust and should not fail until
'    provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
'    or greater will overflow).
'
'    INPUT PARAMETERS:
'        B   -   barycentric interpolant built with one of model building
'                subroutines.
'        T   -   interpolation point
'
'    OUTPUT PARAMETERS:
'        F   -   barycentric interpolant at T
'        DF  -   first derivative
'
'    NOTE
'
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricdiff1(b As barycentricinterpolant, t As Double, ByRef f As Double, ByRef df As Double)
		f = 0
		df = 0
		ratint.barycentricdiff1(b.innerobj, t, f, df)
		Return
	End Sub

	'************************************************************************
'    Differentiation of barycentric interpolant: first/second derivatives.
'
'    INPUT PARAMETERS:
'        B   -   barycentric interpolant built with one of model building
'                subroutines.
'        T   -   interpolation point
'
'    OUTPUT PARAMETERS:
'        F   -   barycentric interpolant at T
'        DF  -   first derivative
'        D2F -   second derivative
'
'    NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
'    whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
'    BarycentricDiff1() subroutine in such cases.
'
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricdiff2(b As barycentricinterpolant, t As Double, ByRef f As Double, ByRef df As Double, ByRef d2f As Double)
		f = 0
		df = 0
		d2f = 0
		ratint.barycentricdiff2(b.innerobj, t, f, df, d2f)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the argument.
'
'    INPUT PARAMETERS:
'        B       -   rational interpolant in barycentric form
'        CA, CB  -   transformation coefficients: x = CA*t + CB
'
'    OUTPUT PARAMETERS:
'        B       -   transformed interpolant with X replaced by T
'
'      -- ALGLIB PROJECT --
'         Copyright 19.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentriclintransx(b As barycentricinterpolant, ca As Double, cb As Double)

		ratint.barycentriclintransx(b.innerobj, ca, cb)
		Return
	End Sub

	'************************************************************************
'    This  subroutine   performs   linear  transformation  of  the  barycentric
'    interpolant.
'
'    INPUT PARAMETERS:
'        B       -   rational interpolant in barycentric form
'        CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
'
'    OUTPUT PARAMETERS:
'        B       -   transformed interpolant
'
'      -- ALGLIB PROJECT --
'         Copyright 19.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentriclintransy(b As barycentricinterpolant, ca As Double, cb As Double)

		ratint.barycentriclintransy(b.innerobj, ca, cb)
		Return
	End Sub

	'************************************************************************
'    Extracts X/Y/W arrays from rational interpolant
'
'    INPUT PARAMETERS:
'        B   -   barycentric interpolant
'
'    OUTPUT PARAMETERS:
'        N   -   nodes count, N>0
'        X   -   interpolation nodes, array[0..N-1]
'        F   -   function values, array[0..N-1]
'        W   -   barycentric weights, array[0..N-1]
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricunpack(b As barycentricinterpolant, ByRef n As Integer, ByRef x As Double(), ByRef y As Double(), ByRef w As Double())
		n = 0
		x = New Double(-1) {}
		y = New Double(-1) {}
		w = New Double(-1) {}
		ratint.barycentricunpack(b.innerobj, n, x, y, w)
		Return
	End Sub

	'************************************************************************
'    Rational interpolant from X/Y/W arrays
'
'    F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'    INPUT PARAMETERS:
'        X   -   interpolation nodes, array[0..N-1]
'        F   -   function values, array[0..N-1]
'        W   -   barycentric weights, array[0..N-1]
'        N   -   nodes count, N>0
'
'    OUTPUT PARAMETERS:
'        B   -   barycentric interpolant built from (X, Y, W)
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricbuildxyw(x As Double(), y As Double(), w As Double(), n As Integer, ByRef b As barycentricinterpolant)
		b = New barycentricinterpolant()
		ratint.barycentricbuildxyw(x, y, w, n, b.innerobj)
		Return
	End Sub

	'************************************************************************
'    Rational interpolant without poles
'
'    The subroutine constructs the rational interpolating function without real
'    poles  (see  'Barycentric rational interpolation with no  poles  and  high
'    rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
'    information on this subject).
'
'    Input parameters:
'        X   -   interpolation nodes, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        N   -   number of nodes, N>0.
'        D   -   order of the interpolation scheme, 0 <= D <= N-1.
'                D<0 will cause an error.
'                D>=N it will be replaced with D=N-1.
'                if you don't know what D to choose, use small value about 3-5.
'
'    Output parameters:
'        B   -   barycentric interpolant.
'
'    Note:
'        this algorithm always succeeds and calculates the weights  with  close
'        to machine precision.
'
'      -- ALGLIB PROJECT --
'         Copyright 17.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricbuildfloaterhormann(x As Double(), y As Double(), n As Integer, d As Integer, ByRef b As barycentricinterpolant)
		b = New barycentricinterpolant()
		ratint.barycentricbuildfloaterhormann(x, y, n, d, b.innerobj)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Conversion from barycentric representation to Chebyshev basis.
'    This function has O(N^2) complexity.
'
'    INPUT PARAMETERS:
'        P   -   polynomial in barycentric form
'        A,B -   base interval for Chebyshev polynomials (see below)
'                A<>B
'
'    OUTPUT PARAMETERS
'        T   -   coefficients of Chebyshev representation;
'                P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
'                where Ti - I-th Chebyshev polynomial.
'
'    NOTES:
'        barycentric interpolant passed as P may be either polynomial  obtained
'        from  polynomial  interpolation/ fitting or rational function which is
'        NOT polynomial. We can't distinguish between these two cases, and this
'        algorithm just tries to work assuming that P IS a polynomial.  If not,
'        algorithm will return results, but they won't have any meaning.
'
'      -- ALGLIB --
'         Copyright 30.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbar2cheb(p As barycentricinterpolant, a As Double, b As Double, ByRef t As Double())
		t = New Double(-1) {}
		polint.polynomialbar2cheb(p.innerobj, a, b, t)
		Return
	End Sub

	'************************************************************************
'    Conversion from Chebyshev basis to barycentric representation.
'    This function has O(N^2) complexity.
'
'    INPUT PARAMETERS:
'        T   -   coefficients of Chebyshev representation;
'                P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
'                where Ti - I-th Chebyshev polynomial.
'        N   -   number of coefficients:
'                * if given, only leading N elements of T are used
'                * if not given, automatically determined from size of T
'        A,B -   base interval for Chebyshev polynomials (see above)
'                A<B
'
'    OUTPUT PARAMETERS
'        P   -   polynomial in barycentric form
'
'      -- ALGLIB --
'         Copyright 30.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialcheb2bar(t As Double(), n As Integer, a As Double, b As Double, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialcheb2bar(t, n, a, b, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialcheb2bar(t As Double(), a As Double, b As Double, ByRef p As barycentricinterpolant)
		Dim n As Integer

		p = New barycentricinterpolant()
		n = ap.len(t)
		polint.polynomialcheb2bar(t, n, a, b, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Conversion from barycentric representation to power basis.
'    This function has O(N^2) complexity.
'
'    INPUT PARAMETERS:
'        P   -   polynomial in barycentric form
'        C   -   offset (see below); 0.0 is used as default value.
'        S   -   scale (see below);  1.0 is used as default value. S<>0.
'
'    OUTPUT PARAMETERS
'        A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
'        N   -   number of coefficients (polynomial degree plus 1)
'
'    NOTES:
'    1.  this function accepts offset and scale, which can be  set  to  improve
'        numerical properties of polynomial. For example, if P was obtained  as
'        result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
'        represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
'        is exactly what you need.
'
'        However, if your interpolation model was built on [999,1001], you will
'        see significant growth of numerical errors when using {1, x, x^2, x^3}
'        as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
'        will be better option. Such representation can be  obtained  by  using
'        1000.0 as offset C and 1.0 as scale S.
'
'    2.  power basis is ill-conditioned and tricks described above can't  solve
'        this problem completely. This function  will  return  coefficients  in
'        any  case,  but  for  N>8  they  will  become unreliable. However, N's
'        less than 5 are pretty safe.
'
'    3.  barycentric interpolant passed as P may be either polynomial  obtained
'        from  polynomial  interpolation/ fitting or rational function which is
'        NOT polynomial. We can't distinguish between these two cases, and this
'        algorithm just tries to work assuming that P IS a polynomial.  If not,
'        algorithm will return results, but they won't have any meaning.
'
'      -- ALGLIB --
'         Copyright 30.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbar2pow(p As barycentricinterpolant, c As Double, s As Double, ByRef a As Double())
		a = New Double(-1) {}
		polint.polynomialbar2pow(p.innerobj, c, s, a)
		Return
	End Sub
	Public Shared Sub polynomialbar2pow(p As barycentricinterpolant, ByRef a As Double())
		Dim c As Double
		Dim s As Double

		a = New Double(-1) {}
		c = 0
		s = 1
		polint.polynomialbar2pow(p.innerobj, c, s, a)

		Return
	End Sub

	'************************************************************************
'    Conversion from power basis to barycentric representation.
'    This function has O(N^2) complexity.
'
'    INPUT PARAMETERS:
'        A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
'        N   -   number of coefficients (polynomial degree plus 1)
'                * if given, only leading N elements of A are used
'                * if not given, automatically determined from size of A
'        C   -   offset (see below); 0.0 is used as default value.
'        S   -   scale (see below);  1.0 is used as default value. S<>0.
'
'    OUTPUT PARAMETERS
'        P   -   polynomial in barycentric form
'
'
'    NOTES:
'    1.  this function accepts offset and scale, which can be  set  to  improve
'        numerical properties of polynomial. For example, if you interpolate on
'        [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
'        x^3 and so on. In most cases you it is exactly what you need.
'
'        However, if your interpolation model was built on [999,1001], you will
'        see significant growth of numerical errors when using {1, x, x^2, x^3}
'        as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
'        (x-1000)^3 will be better option (you have to specify 1000.0 as offset
'        C and 1.0 as scale S).
'
'    2.  power basis is ill-conditioned and tricks described above can't  solve
'        this problem completely. This function  will  return barycentric model
'        in any case, but for N>8 accuracy well degrade. However, N's less than
'        5 are pretty safe.
'
'      -- ALGLIB --
'         Copyright 30.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialpow2bar(a As Double(), n As Integer, c As Double, s As Double, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialpow2bar(a, n, c, s, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialpow2bar(a As Double(), ByRef p As barycentricinterpolant)
		Dim n As Integer
		Dim c As Double
		Dim s As Double

		p = New barycentricinterpolant()
		n = ap.len(a)
		c = 0
		s = 1
		polint.polynomialpow2bar(a, n, c, s, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Lagrange intepolant: generation of the model on the general grid.
'    This function has O(N^2) complexity.
'
'    INPUT PARAMETERS:
'        X   -   abscissas, array[0..N-1]
'        Y   -   function values, array[0..N-1]
'        N   -   number of points, N>=1
'
'    OUTPUT PARAMETERS
'        P   -   barycentric model which represents Lagrange interpolant
'                (see ratint unit info and BarycentricCalc() description for
'                more information).
'
'      -- ALGLIB --
'         Copyright 02.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbuild(x As Double(), y As Double(), n As Integer, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialbuild(x, y, n, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialbuild(x As Double(), y As Double(), ByRef p As barycentricinterpolant)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size")
		End If
		p = New barycentricinterpolant()
		n = ap.len(x)
		polint.polynomialbuild(x, y, n, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Lagrange intepolant: generation of the model on equidistant grid.
'    This function has O(N) complexity.
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        Y   -   function values at the nodes, array[0..N-1]
'        N   -   number of points, N>=1
'                for N=1 a constant model is constructed.
'
'    OUTPUT PARAMETERS
'        P   -   barycentric model which represents Lagrange interpolant
'                (see ratint unit info and BarycentricCalc() description for
'                more information).
'
'      -- ALGLIB --
'         Copyright 03.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbuildeqdist(a As Double, b As Double, y As Double(), n As Integer, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialbuildeqdist(a, b, y, n, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialbuildeqdist(a As Double, b As Double, y As Double(), ByRef p As barycentricinterpolant)
		Dim n As Integer

		p = New barycentricinterpolant()
		n = ap.len(y)
		polint.polynomialbuildeqdist(a, b, y, n, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Lagrange intepolant on Chebyshev grid (first kind).
'    This function has O(N) complexity.
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        Y   -   function values at the nodes, array[0..N-1],
'                Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
'        N   -   number of points, N>=1
'                for N=1 a constant model is constructed.
'
'    OUTPUT PARAMETERS
'        P   -   barycentric model which represents Lagrange interpolant
'                (see ratint unit info and BarycentricCalc() description for
'                more information).
'
'      -- ALGLIB --
'         Copyright 03.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbuildcheb1(a As Double, b As Double, y As Double(), n As Integer, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialbuildcheb1(a, b, y, n, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialbuildcheb1(a As Double, b As Double, y As Double(), ByRef p As barycentricinterpolant)
		Dim n As Integer

		p = New barycentricinterpolant()
		n = ap.len(y)
		polint.polynomialbuildcheb1(a, b, y, n, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Lagrange intepolant on Chebyshev grid (second kind).
'    This function has O(N) complexity.
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        Y   -   function values at the nodes, array[0..N-1],
'                Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
'        N   -   number of points, N>=1
'                for N=1 a constant model is constructed.
'
'    OUTPUT PARAMETERS
'        P   -   barycentric model which represents Lagrange interpolant
'                (see ratint unit info and BarycentricCalc() description for
'                more information).
'
'      -- ALGLIB --
'         Copyright 03.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialbuildcheb2(a As Double, b As Double, y As Double(), n As Integer, ByRef p As barycentricinterpolant)
		p = New barycentricinterpolant()
		polint.polynomialbuildcheb2(a, b, y, n, p.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialbuildcheb2(a As Double, b As Double, y As Double(), ByRef p As barycentricinterpolant)
		Dim n As Integer

		p = New barycentricinterpolant()
		n = ap.len(y)
		polint.polynomialbuildcheb2(a, b, y, n, p.innerobj)

		Return
	End Sub

	'************************************************************************
'    Fast equidistant polynomial interpolation function with O(N) complexity
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        F   -   function values, array[0..N-1]
'        N   -   number of points on equidistant grid, N>=1
'                for N=1 a constant model is constructed.
'        T   -   position where P(x) is calculated
'
'    RESULT
'        value of the Lagrange interpolant at T
'
'    IMPORTANT
'        this function provides fast interface which is not overflow-safe
'        nor it is very precise.
'        the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
'        subroutines unless you are pretty sure that your data will not result
'        in overflow.
'
'      -- ALGLIB --
'         Copyright 02.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function polynomialcalceqdist(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double

		Dim result As Double = polint.polynomialcalceqdist(a, b, f, n, t)
		Return result
	End Function
	Public Shared Function polynomialcalceqdist(a As Double, b As Double, f As Double(), t As Double) As Double
		Dim n As Integer


		n = ap.len(f)
		Dim result As Double = polint.polynomialcalceqdist(a, b, f, n, t)

		Return result
	End Function

	'************************************************************************
'    Fast polynomial interpolation function on Chebyshev points (first kind)
'    with O(N) complexity.
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        F   -   function values, array[0..N-1]
'        N   -   number of points on Chebyshev grid (first kind),
'                X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
'                for N=1 a constant model is constructed.
'        T   -   position where P(x) is calculated
'
'    RESULT
'        value of the Lagrange interpolant at T
'
'    IMPORTANT
'        this function provides fast interface which is not overflow-safe
'        nor it is very precise.
'        the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
'        subroutines unless you are pretty sure that your data will not result
'        in overflow.
'
'      -- ALGLIB --
'         Copyright 02.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function polynomialcalccheb1(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double

		Dim result As Double = polint.polynomialcalccheb1(a, b, f, n, t)
		Return result
	End Function
	Public Shared Function polynomialcalccheb1(a As Double, b As Double, f As Double(), t As Double) As Double
		Dim n As Integer


		n = ap.len(f)
		Dim result As Double = polint.polynomialcalccheb1(a, b, f, n, t)

		Return result
	End Function

	'************************************************************************
'    Fast polynomial interpolation function on Chebyshev points (second kind)
'    with O(N) complexity.
'
'    INPUT PARAMETERS:
'        A   -   left boundary of [A,B]
'        B   -   right boundary of [A,B]
'        F   -   function values, array[0..N-1]
'        N   -   number of points on Chebyshev grid (second kind),
'                X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
'                for N=1 a constant model is constructed.
'        T   -   position where P(x) is calculated
'
'    RESULT
'        value of the Lagrange interpolant at T
'
'    IMPORTANT
'        this function provides fast interface which is not overflow-safe
'        nor it is very precise.
'        the best option is to use PolIntBuildCheb2()/BarycentricCalc()
'        subroutines unless you are pretty sure that your data will not result
'        in overflow.
'
'      -- ALGLIB --
'         Copyright 02.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function polynomialcalccheb2(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double

		Dim result As Double = polint.polynomialcalccheb2(a, b, f, n, t)
		Return result
	End Function
	Public Shared Function polynomialcalccheb2(a As Double, b As Double, f As Double(), t As Double) As Double
		Dim n As Integer


		n = ap.len(f)
		Dim result As Double = polint.polynomialcalccheb2(a, b, f, n, t)

		Return result
	End Function

End Class
Public Partial Class alglib


	'************************************************************************
'    1-dimensional spline interpolant
'    ************************************************************************

	Public Class spline1dinterpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New spline1d.spline1dinterpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New spline1dinterpolant(DirectCast(_innerobj.make_copy(), spline1d.spline1dinterpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As spline1d.spline1dinterpolant
		Public ReadOnly Property innerobj() As spline1d.spline1dinterpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As spline1d.spline1dinterpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This subroutine builds linear spline interpolant
'
'    INPUT PARAMETERS:
'        X   -   spline nodes, array[0..N-1]
'        Y   -   function values, array[0..N-1]
'        N   -   points count (optional):
'                * N>=2
'                * if given, only first N points are used to build spline
'                * if not given, automatically detected from X/Y sizes
'                  (len(X) must be equal to len(Y))
'
'    OUTPUT PARAMETERS:
'        C   -   spline interpolant
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'      -- ALGLIB PROJECT --
'         Copyright 24.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildlinear(x As Double(), y As Double(), n As Integer, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildlinear(x, y, n, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildlinear(x As Double(), y As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		spline1d.spline1dbuildlinear(x, y, n, c.innerobj)

		Return
	End Sub

	'************************************************************************
'    This subroutine builds cubic spline interpolant.
'
'    INPUT PARAMETERS:
'        X           -   spline nodes, array[0..N-1].
'        Y           -   function values, array[0..N-1].
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points are used to build spline
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'
'    OUTPUT PARAMETERS:
'        C           -   spline interpolant
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 23.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildcubic(x As Double(), y As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, c.innerobj)

		Return
	End Sub

	'************************************************************************
'    This function solves following problem: given table y[] of function values
'    at nodes x[], it calculates and returns table of function derivatives  d[]
'    (calculated at the same nodes x[]).
'
'    This function yields same result as Spline1DBuildCubic() call followed  by
'    sequence of Spline1DDiff() calls, but it can be several times faster  when
'    called for ordered X[] and X2[].
'
'    INPUT PARAMETERS:
'        X           -   spline nodes
'        Y           -   function values
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points are used
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'
'    OUTPUT PARAMETERS:
'        D           -   derivative values at X[]
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'    Derivative values are correctly reordered on return, so  D[I]  is  always
'    equal to S'(X[I]) independently of points order.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 03.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dgriddiffcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, ByRef d As Double())
		d = New Double(-1) {}
		spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, d)
		Return
	End Sub
	Public Shared Sub spline1dgriddiffcubic(x As Double(), y As Double(), ByRef d As Double())
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size")
		End If
		d = New Double(-1) {}
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, d)

		Return
	End Sub

	'************************************************************************
'    This function solves following problem: given table y[] of function values
'    at  nodes  x[],  it  calculates  and  returns  tables  of first and second
'    function derivatives d1[] and d2[] (calculated at the same nodes x[]).
'
'    This function yields same result as Spline1DBuildCubic() call followed  by
'    sequence of Spline1DDiff() calls, but it can be several times faster  when
'    called for ordered X[] and X2[].
'
'    INPUT PARAMETERS:
'        X           -   spline nodes
'        Y           -   function values
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points are used
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'
'    OUTPUT PARAMETERS:
'        D1          -   S' values at X[]
'        D2          -   S'' values at X[]
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'    Derivative values are correctly reordered on return, so  D[I]  is  always
'    equal to S'(X[I]) independently of points order.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 03.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dgriddiff2cubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, ByRef d1 As Double(), ByRef d2 As Double())
		d1 = New Double(-1) {}
		d2 = New Double(-1) {}
		spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, d1, d2)
		Return
	End Sub
	Public Shared Sub spline1dgriddiff2cubic(x As Double(), y As Double(), ByRef d1 As Double(), ByRef d2 As Double())
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size")
		End If
		d1 = New Double(-1) {}
		d2 = New Double(-1) {}
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, d1, d2)

		Return
	End Sub

	'************************************************************************
'    This function solves following problem: given table y[] of function values
'    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'    function values y2[] (calculated at x2[]).
'
'    This function yields same result as Spline1DBuildCubic() call followed  by
'    sequence of Spline1DDiff() calls, but it can be several times faster  when
'    called for ordered X[] and X2[].
'
'    INPUT PARAMETERS:
'        X           -   old spline nodes
'        Y           -   function values
'        X2           -  new spline nodes
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points from X/Y are used
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'        N2          -   new points count:
'                        * N2>=2
'                        * if given, only first N2 points from X2 are used
'                        * if not given, automatically detected from X2 size
'
'    OUTPUT PARAMETERS:
'        F2          -   function values at X2[]
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller  may pass unsorted array.
'    Function  values  are correctly reordered on  return, so F2[I]  is  always
'    equal to S(X2[I]) independently of points order.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 03.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dconvcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double())
		y2 = New Double(-1) {}
		spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2)
		Return
	End Sub
	Public Shared Sub spline1dconvcubic(x As Double(), y As Double(), x2 As Double(), ByRef y2 As Double())
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		Dim n2 As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size")
		End If
		y2 = New Double(-1) {}
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		n2 = ap.len(x2)
		spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2)

		Return
	End Sub

	'************************************************************************
'    This function solves following problem: given table y[] of function values
'    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'    function values y2[] and derivatives d2[] (calculated at x2[]).
'
'    This function yields same result as Spline1DBuildCubic() call followed  by
'    sequence of Spline1DDiff() calls, but it can be several times faster  when
'    called for ordered X[] and X2[].
'
'    INPUT PARAMETERS:
'        X           -   old spline nodes
'        Y           -   function values
'        X2           -  new spline nodes
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points from X/Y are used
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'        N2          -   new points count:
'                        * N2>=2
'                        * if given, only first N2 points from X2 are used
'                        * if not given, automatically detected from X2 size
'
'    OUTPUT PARAMETERS:
'        F2          -   function values at X2[]
'        D2          -   first derivatives at X2[]
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller  may pass unsorted array.
'    Function  values  are correctly reordered on  return, so F2[I]  is  always
'    equal to S(X2[I]) independently of points order.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 03.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dconvdiffcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double(), ByRef d2 As Double())
		y2 = New Double(-1) {}
		d2 = New Double(-1) {}
		spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2, d2)
		Return
	End Sub
	Public Shared Sub spline1dconvdiffcubic(x As Double(), y As Double(), x2 As Double(), ByRef y2 As Double(), ByRef d2 As Double())
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		Dim n2 As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size")
		End If
		y2 = New Double(-1) {}
		d2 = New Double(-1) {}
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		n2 = ap.len(x2)
		spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2, d2)

		Return
	End Sub

	'************************************************************************
'    This function solves following problem: given table y[] of function values
'    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'    function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
'    (calculated at x2[]).
'
'    This function yields same result as Spline1DBuildCubic() call followed  by
'    sequence of Spline1DDiff() calls, but it can be several times faster  when
'    called for ordered X[] and X2[].
'
'    INPUT PARAMETERS:
'        X           -   old spline nodes
'        Y           -   function values
'        X2           -  new spline nodes
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points from X/Y are used
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundLType  -   boundary condition type for the left boundary
'        BoundL      -   left boundary condition (first or second derivative,
'                        depending on the BoundLType)
'        BoundRType  -   boundary condition type for the right boundary
'        BoundR      -   right boundary condition (first or second derivative,
'                        depending on the BoundRType)
'        N2          -   new points count:
'                        * N2>=2
'                        * if given, only first N2 points from X2 are used
'                        * if not given, automatically detected from X2 size
'
'    OUTPUT PARAMETERS:
'        F2          -   function values at X2[]
'        D2          -   first derivatives at X2[]
'        DD2         -   second derivatives at X2[]
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller  may pass unsorted array.
'    Function  values  are correctly reordered on  return, so F2[I]  is  always
'    equal to S(X2[I]) independently of points order.
'
'    SETTING BOUNDARY VALUES:
'
'    The BoundLType/BoundRType parameters can have the following values:
'        * -1, which corresonds to the periodic (cyclic) boundary conditions.
'              In this case:
'              * both BoundLType and BoundRType must be equal to -1.
'              * BoundL/BoundR are ignored
'              * Y[last] is ignored (it is assumed to be equal to Y[first]).
'        *  0, which  corresponds  to  the  parabolically   terminated  spline
'              (BoundL and/or BoundR are ignored).
'        *  1, which corresponds to the first derivative boundary condition
'        *  2, which corresponds to the second derivative boundary condition
'        *  by default, BoundType=0 is used
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 03.09.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dconvdiff2cubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
		boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double(), ByRef d2 As Double(), ByRef dd2 As Double())
		y2 = New Double(-1) {}
		d2 = New Double(-1) {}
		dd2 = New Double(-1) {}
		spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2, d2, dd2)
		Return
	End Sub
	Public Shared Sub spline1dconvdiff2cubic(x As Double(), y As Double(), x2 As Double(), ByRef y2 As Double(), ByRef d2 As Double(), ByRef dd2 As Double())
		Dim n As Integer
		Dim boundltype As Integer
		Dim boundl As Double
		Dim boundrtype As Integer
		Dim boundr As Double
		Dim n2 As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size")
		End If
		y2 = New Double(-1) {}
		d2 = New Double(-1) {}
		dd2 = New Double(-1) {}
		n = ap.len(x)
		boundltype = 0
		boundl = 0
		boundrtype = 0
		boundr = 0
		n2 = ap.len(x2)
		spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, _
			boundr, x2, n2, y2, d2, dd2)

		Return
	End Sub

	'************************************************************************
'    This subroutine builds Catmull-Rom spline interpolant.
'
'    INPUT PARAMETERS:
'        X           -   spline nodes, array[0..N-1].
'        Y           -   function values, array[0..N-1].
'
'    OPTIONAL PARAMETERS:
'        N           -   points count:
'                        * N>=2
'                        * if given, only first N points are used to build spline
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'        BoundType   -   boundary condition type:
'                        * -1 for periodic boundary condition
'                        *  0 for parabolically terminated spline (default)
'        Tension     -   tension parameter:
'                        * tension=0   corresponds to classic Catmull-Rom spline (default)
'                        * 0<tension<1 corresponds to more general form - cardinal spline
'
'    OUTPUT PARAMETERS:
'        C           -   spline interpolant
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'    However, this subroutine doesn't require you to specify equal  values  for
'    the first and last points - it automatically forces them  to  be  equal by
'    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'    Y[last_point]. However it is recommended to pass consistent values of Y[],
'    i.e. to make Y[first_point]=Y[last_point].
'
'      -- ALGLIB PROJECT --
'         Copyright 23.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildcatmullrom(x As Double(), y As Double(), n As Integer, boundtype As Integer, tension As Double, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildcatmullrom(x As Double(), y As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		Dim boundtype As Integer
		Dim tension As Double
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		boundtype = 0
		tension = 0
		spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj)

		Return
	End Sub

	'************************************************************************
'    This subroutine builds Hermite spline interpolant.
'
'    INPUT PARAMETERS:
'        X           -   spline nodes, array[0..N-1]
'        Y           -   function values, array[0..N-1]
'        D           -   derivatives, array[0..N-1]
'        N           -   points count (optional):
'                        * N>=2
'                        * if given, only first N points are used to build spline
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'
'    OUTPUT PARAMETERS:
'        C           -   spline interpolant.
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'      -- ALGLIB PROJECT --
'         Copyright 23.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildhermite(x As Double(), y As Double(), d As Double(), n As Integer, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildhermite(x As Double(), y As Double(), d As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(d)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj)

		Return
	End Sub

	'************************************************************************
'    This subroutine builds Akima spline interpolant
'
'    INPUT PARAMETERS:
'        X           -   spline nodes, array[0..N-1]
'        Y           -   function values, array[0..N-1]
'        N           -   points count (optional):
'                        * N>=2
'                        * if given, only first N points are used to build spline
'                        * if not given, automatically detected from X/Y sizes
'                          (len(X) must be equal to len(Y))
'
'    OUTPUT PARAMETERS:
'        C           -   spline interpolant
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'      -- ALGLIB PROJECT --
'         Copyright 24.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildakima(x As Double(), y As Double(), n As Integer, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildakima(x, y, n, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildakima(x As Double(), y As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		spline1d.spline1dbuildakima(x, y, n, c.innerobj)

		Return
	End Sub

	'************************************************************************
'    This subroutine calculates the value of the spline at the given point X.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant
'        X   -   point
'
'    Result:
'        S(x)
'
'      -- ALGLIB PROJECT --
'         Copyright 23.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spline1dcalc(c As spline1dinterpolant, x As Double) As Double

		Dim result As Double = spline1d.spline1dcalc(c.innerobj, x)
		Return result
	End Function

	'************************************************************************
'    This subroutine differentiates the spline.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X   -   point
'
'    Result:
'        S   -   S(x)
'        DS  -   S'(x)
'        D2S -   S''(x)
'
'      -- ALGLIB PROJECT --
'         Copyright 24.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1ddiff(c As spline1dinterpolant, x As Double, ByRef s As Double, ByRef ds As Double, ByRef d2s As Double)
		s = 0
		ds = 0
		d2s = 0
		spline1d.spline1ddiff(c.innerobj, x, s, ds, d2s)
		Return
	End Sub

	'************************************************************************
'    This subroutine unpacks the spline into the coefficients table.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X   -   point
'
'    OUTPUT PARAMETERS:
'        Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
'                For I = 0...N-2:
'                    Tbl[I,0] = X[i]
'                    Tbl[I,1] = X[i+1]
'                    Tbl[I,2] = C0
'                    Tbl[I,3] = C1
'                    Tbl[I,4] = C2
'                    Tbl[I,5] = C3
'                On [x[i], x[i+1]] spline is equals to:
'                    S(x) = C0 + C1*t + C2*t^2 + C3*t^3
'                    t = x-x[i]
'
'    NOTE:
'        You  can rebuild spline with  Spline1DBuildHermite()  function,  which
'        accepts as inputs function values and derivatives at nodes, which  are
'        easy to calculate when you have coefficients.
'
'      -- ALGLIB PROJECT --
'         Copyright 29.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dunpack(c As spline1dinterpolant, ByRef n As Integer, ByRef tbl As Double(,))
		n = 0
		tbl = New Double(-1, -1) {}
		spline1d.spline1dunpack(c.innerobj, n, tbl)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the spline argument.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        A, B-   transformation coefficients: x = A*t + B
'    Result:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 30.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dlintransx(c As spline1dinterpolant, a As Double, b As Double)

		spline1d.spline1dlintransx(c.innerobj, a, b)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the spline.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        A, B-   transformation coefficients: S2(x) = A*S(x) + B
'    Result:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 30.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dlintransy(c As spline1dinterpolant, a As Double, b As Double)

		spline1d.spline1dlintransy(c.innerobj, a, b)
		Return
	End Sub

	'************************************************************************
'    This subroutine integrates the spline.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X   -   right bound of the integration interval [a, x],
'                here 'a' denotes min(x[])
'    Result:
'        integral(S(t)dt,a,x)
'
'      -- ALGLIB PROJECT --
'         Copyright 23.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spline1dintegrate(c As spline1dinterpolant, x As Double) As Double

		Dim result As Double = spline1d.spline1dintegrate(c.innerobj, x)
		Return result
	End Function

	'************************************************************************
'    This function builds monotone cubic Hermite interpolant. This interpolant
'    is monotonic in [x(0),x(n-1)] and is constant outside of this interval.
'
'    In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
'    monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
'    monotonically grow at [0..2] and monotonically decrease at [2..4].
'
'    INPUT PARAMETERS:
'        X           -   spline nodes, array[0..N-1]. Subroutine automatically
'                        sorts points, so caller may pass unsorted array.
'        Y           -   function values, array[0..N-1]
'        N           -   the number of points(N>=2).
'
'    OUTPUT PARAMETERS:
'        C           -   spline interpolant.
'
'     -- ALGLIB PROJECT --
'         Copyright 21.06.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dbuildmonotone(x As Double(), y As Double(), n As Integer, ByRef c As spline1dinterpolant)
		c = New spline1dinterpolant()
		spline1d.spline1dbuildmonotone(x, y, n, c.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dbuildmonotone(x As Double(), y As Double(), ByRef c As spline1dinterpolant)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size")
		End If
		c = New spline1dinterpolant()
		n = ap.len(x)
		spline1d.spline1dbuildmonotone(x, y, n, c.innerobj)

		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Polynomial fitting report:
'        TaskRCond       reciprocal of task's condition number
'        RMSError        RMS error
'        AvgError        average error
'        AvgRelError     average relative error (for non-zero Y[I])
'        MaxError        maximum error
'    ************************************************************************

	Public Class polynomialfitreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property taskrcond() As Double
			Get
				Return _innerobj.taskrcond
			End Get
			Set
				_innerobj.taskrcond = value
			End Set
		End Property
		Public Property rmserror() As Double
			Get
				Return _innerobj.rmserror
			End Get
			Set
				_innerobj.rmserror = value
			End Set
		End Property
		Public Property avgerror() As Double
			Get
				Return _innerobj.avgerror
			End Get
			Set
				_innerobj.avgerror = value
			End Set
		End Property
		Public Property avgrelerror() As Double
			Get
				Return _innerobj.avgrelerror
			End Get
			Set
				_innerobj.avgrelerror = value
			End Set
		End Property
		Public Property maxerror() As Double
			Get
				Return _innerobj.maxerror
			End Get
			Set
				_innerobj.maxerror = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New lsfit.polynomialfitreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New polynomialfitreport(DirectCast(_innerobj.make_copy(), lsfit.polynomialfitreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As lsfit.polynomialfitreport
		Public ReadOnly Property innerobj() As lsfit.polynomialfitreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As lsfit.polynomialfitreport)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Barycentric fitting report:
'        RMSError        RMS error
'        AvgError        average error
'        AvgRelError     average relative error (for non-zero Y[I])
'        MaxError        maximum error
'        TaskRCond       reciprocal of task's condition number
'    ************************************************************************

	Public Class barycentricfitreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property taskrcond() As Double
			Get
				Return _innerobj.taskrcond
			End Get
			Set
				_innerobj.taskrcond = value
			End Set
		End Property
		Public Property dbest() As Integer
			Get
				Return _innerobj.dbest
			End Get
			Set
				_innerobj.dbest = value
			End Set
		End Property
		Public Property rmserror() As Double
			Get
				Return _innerobj.rmserror
			End Get
			Set
				_innerobj.rmserror = value
			End Set
		End Property
		Public Property avgerror() As Double
			Get
				Return _innerobj.avgerror
			End Get
			Set
				_innerobj.avgerror = value
			End Set
		End Property
		Public Property avgrelerror() As Double
			Get
				Return _innerobj.avgrelerror
			End Get
			Set
				_innerobj.avgrelerror = value
			End Set
		End Property
		Public Property maxerror() As Double
			Get
				Return _innerobj.maxerror
			End Get
			Set
				_innerobj.maxerror = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New lsfit.barycentricfitreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New barycentricfitreport(DirectCast(_innerobj.make_copy(), lsfit.barycentricfitreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As lsfit.barycentricfitreport
		Public ReadOnly Property innerobj() As lsfit.barycentricfitreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As lsfit.barycentricfitreport)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Spline fitting report:
'        RMSError        RMS error
'        AvgError        average error
'        AvgRelError     average relative error (for non-zero Y[I])
'        MaxError        maximum error
'
'    Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
'    Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
'        TaskRCond       reciprocal of task's condition number
'    ************************************************************************

	Public Class spline1dfitreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property taskrcond() As Double
			Get
				Return _innerobj.taskrcond
			End Get
			Set
				_innerobj.taskrcond = value
			End Set
		End Property
		Public Property rmserror() As Double
			Get
				Return _innerobj.rmserror
			End Get
			Set
				_innerobj.rmserror = value
			End Set
		End Property
		Public Property avgerror() As Double
			Get
				Return _innerobj.avgerror
			End Get
			Set
				_innerobj.avgerror = value
			End Set
		End Property
		Public Property avgrelerror() As Double
			Get
				Return _innerobj.avgrelerror
			End Get
			Set
				_innerobj.avgrelerror = value
			End Set
		End Property
		Public Property maxerror() As Double
			Get
				Return _innerobj.maxerror
			End Get
			Set
				_innerobj.maxerror = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New lsfit.spline1dfitreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New spline1dfitreport(DirectCast(_innerobj.make_copy(), lsfit.spline1dfitreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As lsfit.spline1dfitreport
		Public ReadOnly Property innerobj() As lsfit.spline1dfitreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As lsfit.spline1dfitreport)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Least squares fitting report. This structure contains informational fields
'    which are set by fitting functions provided by this unit.
'
'    Different functions initialize different sets of  fields,  so  you  should
'    read documentation on specific function you used in order  to  know  which
'    fields are initialized.
'
'        TaskRCond       reciprocal of task's condition number
'        IterationsCount number of internal iterations
'
'        VarIdx          if user-supplied gradient contains errors  which  were
'                        detected by nonlinear fitter, this  field  is  set  to
'                        index  of  the  first  component  of gradient which is
'                        suspected to be spoiled by bugs.
'
'        RMSError        RMS error
'        AvgError        average error
'        AvgRelError     average relative error (for non-zero Y[I])
'        MaxError        maximum error
'
'        WRMSError       weighted RMS error
'
'        CovPar          covariance matrix for parameters, filled by some solvers
'        ErrPar          vector of errors in parameters, filled by some solvers
'        ErrCurve        vector of fit errors -  variability  of  the  best-fit
'                        curve, filled by some solvers.
'        Noise           vector of per-point noise estimates, filled by
'                        some solvers.
'        R2              coefficient of determination (non-weighted, non-adjusted),
'                        filled by some solvers.
'    ************************************************************************

	Public Class lsfitreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property taskrcond() As Double
			Get
				Return _innerobj.taskrcond
			End Get
			Set
				_innerobj.taskrcond = value
			End Set
		End Property
		Public Property iterationscount() As Integer
			Get
				Return _innerobj.iterationscount
			End Get
			Set
				_innerobj.iterationscount = value
			End Set
		End Property
		Public Property varidx() As Integer
			Get
				Return _innerobj.varidx
			End Get
			Set
				_innerobj.varidx = value
			End Set
		End Property
		Public Property rmserror() As Double
			Get
				Return _innerobj.rmserror
			End Get
			Set
				_innerobj.rmserror = value
			End Set
		End Property
		Public Property avgerror() As Double
			Get
				Return _innerobj.avgerror
			End Get
			Set
				_innerobj.avgerror = value
			End Set
		End Property
		Public Property avgrelerror() As Double
			Get
				Return _innerobj.avgrelerror
			End Get
			Set
				_innerobj.avgrelerror = value
			End Set
		End Property
		Public Property maxerror() As Double
			Get
				Return _innerobj.maxerror
			End Get
			Set
				_innerobj.maxerror = value
			End Set
		End Property
		Public Property wrmserror() As Double
			Get
				Return _innerobj.wrmserror
			End Get
			Set
				_innerobj.wrmserror = value
			End Set
		End Property
		Public Property covpar() As Double(,)
			Get
				Return _innerobj.covpar
			End Get
			Set
				_innerobj.covpar = value
			End Set
		End Property
		Public Property errpar() As Double()
			Get
				Return _innerobj.errpar
			End Get
			Set
				_innerobj.errpar = value
			End Set
		End Property
		Public Property errcurve() As Double()
			Get
				Return _innerobj.errcurve
			End Get
			Set
				_innerobj.errcurve = value
			End Set
		End Property
		Public Property noise() As Double()
			Get
				Return _innerobj.noise
			End Get
			Set
				_innerobj.noise = value
			End Set
		End Property
		Public Property r2() As Double
			Get
				Return _innerobj.r2
			End Get
			Set
				_innerobj.r2 = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New lsfit.lsfitreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New lsfitreport(DirectCast(_innerobj.make_copy(), lsfit.lsfitreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As lsfit.lsfitreport
		Public ReadOnly Property innerobj() As lsfit.lsfitreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As lsfit.lsfitreport)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Nonlinear fitter.
'
'    You should use ALGLIB functions to work with fitter.
'    Never try to access its fields directly!
'    ************************************************************************

	Public Class lsfitstate
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property needf() As Boolean
			Get
				Return _innerobj.needf
			End Get
			Set
				_innerobj.needf = value
			End Set
		End Property
		Public Property needfg() As Boolean
			Get
				Return _innerobj.needfg
			End Get
			Set
				_innerobj.needfg = value
			End Set
		End Property
		Public Property needfgh() As Boolean
			Get
				Return _innerobj.needfgh
			End Get
			Set
				_innerobj.needfgh = value
			End Set
		End Property
		Public Property xupdated() As Boolean
			Get
				Return _innerobj.xupdated
			End Get
			Set
				_innerobj.xupdated = value
			End Set
		End Property
		Public ReadOnly Property c() As Double()
			Get
				Return _innerobj.c
			End Get
		End Property
		Public Property f() As Double
			Get
				Return _innerobj.f
			End Get
			Set
				_innerobj.f = value
			End Set
		End Property
		Public ReadOnly Property g() As Double()
			Get
				Return _innerobj.g
			End Get
		End Property
		Public ReadOnly Property h() As Double(,)
			Get
				Return _innerobj.h
			End Get
		End Property
		Public ReadOnly Property x() As Double()
			Get
				Return _innerobj.x
			End Get
		End Property

		Public Sub New()
			_innerobj = New lsfit.lsfitstate()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New lsfitstate(DirectCast(_innerobj.make_copy(), lsfit.lsfitstate))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As lsfit.lsfitstate
		Public ReadOnly Property innerobj() As lsfit.lsfitstate
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As lsfit.lsfitstate)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'    Peucker algorithm, which stops after generating specified number of linear
'    sections.
'
'    IMPORTANT:
'    * it does NOT perform least-squares fitting; it  builds  curve,  but  this
'      curve does not minimize some least squares metric.  See  description  of
'      RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
'    * this function does NOT work with parametric curves  (i.e.  curves  which
'      can be represented as {X(t),Y(t)}. It works with curves   which  can  be
'      represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
'      circles  with  this  functions.
'      If  you  want  to  work  with  parametric   curves,   you   should   use
'      ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
'      "Interpolation" package.
'
'    INPUT PARAMETERS:
'        X       -   array of X-coordinates:
'                    * at least N elements
'                    * can be unordered (points are automatically sorted)
'                    * this function may accept non-distinct X (see below for
'                      more information on handling of such inputs)
'        Y       -   array of Y-coordinates:
'                    * at least N elements
'        N       -   number of elements in X/Y
'        M       -   desired number of sections:
'                    * at most M sections are generated by this function
'                    * less than M sections can be generated if we have N<M
'                      (or some X are non-distinct).
'
'    OUTPUT PARAMETERS:
'        X2      -   X-values of corner points for piecewise approximation,
'                    has length NSections+1 or zero (for NSections=0).
'        Y2      -   Y-values of corner points,
'                    has length NSections+1 or zero (for NSections=0).
'        NSections-  number of sections found by algorithm, NSections<=M,
'                    NSections can be zero for degenerate datasets
'                    (N<=1 or all X[] are non-distinct).
'
'    NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
'          curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
'
'      -- ALGLIB --
'         Copyright 02.10.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lstfitpiecewiselinearrdpfixed(x As Double(), y As Double(), n As Integer, m As Integer, ByRef x2 As Double(), ByRef y2 As Double(), _
		ByRef nsections As Integer)
		x2 = New Double(-1) {}
		y2 = New Double(-1) {}
		nsections = 0
		lsfit.lstfitpiecewiselinearrdpfixed(x, y, n, m, x2, y2, _
			nsections)
		Return
	End Sub

	'************************************************************************
'    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'    Peucker algorithm, which stops after achieving desired precision.
'
'    IMPORTANT:
'    * it performs non-least-squares fitting; it builds curve, but  this  curve
'      does not minimize some least squares  metric.  See  description  of  RDP
'      algorithm (say, in Wikipedia) for more details on WHAT is performed.
'    * this function does NOT work with parametric curves  (i.e.  curves  which
'      can be represented as {X(t),Y(t)}. It works with curves   which  can  be
'      represented as Y(X). Thus, it is impossible to model figures like circles
'      with this functions.
'      If  you  want  to  work  with  parametric   curves,   you   should   use
'      ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
'      "Interpolation" package.
'
'    INPUT PARAMETERS:
'        X       -   array of X-coordinates:
'                    * at least N elements
'                    * can be unordered (points are automatically sorted)
'                    * this function may accept non-distinct X (see below for
'                      more information on handling of such inputs)
'        Y       -   array of Y-coordinates:
'                    * at least N elements
'        N       -   number of elements in X/Y
'        Eps     -   positive number, desired precision.
'
'
'    OUTPUT PARAMETERS:
'        X2      -   X-values of corner points for piecewise approximation,
'                    has length NSections+1 or zero (for NSections=0).
'        Y2      -   Y-values of corner points,
'                    has length NSections+1 or zero (for NSections=0).
'        NSections-  number of sections found by algorithm,
'                    NSections can be zero for degenerate datasets
'                    (N<=1 or all X[] are non-distinct).
'
'    NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
'          curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
'
'      -- ALGLIB --
'         Copyright 02.10.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lstfitpiecewiselinearrdp(x As Double(), y As Double(), n As Integer, eps As Double, ByRef x2 As Double(), ByRef y2 As Double(), _
		ByRef nsections As Integer)
		x2 = New Double(-1) {}
		y2 = New Double(-1) {}
		nsections = 0
		lsfit.lstfitpiecewiselinearrdp(x, y, n, eps, x2, y2, _
			nsections)
		Return
	End Sub

	'************************************************************************
'    Fitting by polynomials in barycentric form. This function provides  simple
'    unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
'    you need constrained fitting.
'
'    Task is linear, so linear least squares solver is used. Complexity of this
'    computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'    SEE ALSO:
'        PolynomialFitWC()
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        N   -   number of points, N>0
'                * if given, only leading N elements of X/Y are used
'                * if not given, automatically determined from sizes of X/Y
'        M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearW() subroutine:
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'        P   -   interpolant in barycentric form.
'        Rep -   report, same format as in LSFitLinearW() subroutine.
'                Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    NOTES:
'        you can convert P from barycentric form  to  the  power  or  Chebyshev
'        basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
'        POLINT subpackage.
'
'      -- ALGLIB PROJECT --
'         Copyright 10.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialfit(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, _
		ByRef rep As polynomialfitreport)
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		lsfit.polynomialfit(x, y, n, m, info, p.innerobj, _
			rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_polynomialfit(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, _
		ByRef rep As polynomialfitreport)
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		lsfit._pexec_polynomialfit(x, y, n, m, info, p.innerobj, _
			rep.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialfit(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size")
		End If
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		n = ap.len(x)
		lsfit.polynomialfit(x, y, n, m, info, p.innerobj, _
			rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_polynomialfit(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size")
		End If
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		n = ap.len(x)
		lsfit._pexec_polynomialfit(x, y, n, m, info, p.innerobj, _
			rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted  fitting by polynomials in barycentric form, with constraints  on
'    function values or first derivatives.
'
'    Small regularizing term is used when solving constrained tasks (to improve
'    stability).
'
'    Task is linear, so linear least squares solver is used. Complexity of this
'    computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'    SEE ALSO:
'        PolynomialFit()
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        W   -   weights, array[0..N-1]
'                Each summand in square  sum  of  approximation deviations from
'                given  values  is  multiplied  by  the square of corresponding
'                weight. Fill it by 1's if you don't  want  to  solve  weighted
'                task.
'        N   -   number of points, N>0.
'                * if given, only leading N elements of X/Y/W are used
'                * if not given, automatically determined from sizes of X/Y/W
'        XC  -   points where polynomial values/derivatives are constrained,
'                array[0..K-1].
'        YC  -   values of constraints, array[0..K-1]
'        DC  -   array[0..K-1], types of constraints:
'                * DC[i]=0   means that P(XC[i])=YC[i]
'                * DC[i]=1   means that P'(XC[i])=YC[i]
'                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'        K   -   number of constraints, 0<=K<M.
'                K=0 means no constraints (XC/YC/DC are not used in such cases)
'        M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearW() subroutine:
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'                            -3 means inconsistent constraints
'        P   -   interpolant in barycentric form.
'        Rep -   report, same format as in LSFitLinearW() subroutine.
'                Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    NOTES:
'        you can convert P from barycentric form  to  the  power  or  Chebyshev
'        basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
'        POLINT subpackage.
'
'    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'    Setting constraints can lead  to undesired  results,  like ill-conditioned
'    behavior, or inconsistency being detected. From the other side,  it allows
'    us to improve quality of the fit. Here we summarize  our  experience  with
'    constrained regression splines:
'    * even simple constraints can be inconsistent, see  Wikipedia  article  on
'      this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
'    * the  greater  is  M (given  fixed  constraints),  the  more chances that
'      constraints will be consistent
'    * in the general case, consistency of constraints is NOT GUARANTEED.
'    * in the one special cases, however, we can  guarantee  consistency.  This
'      case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)
'
'    Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'    can't solve your task without them. Anything beyond  special  cases  given
'    above is not guaranteed and may result in inconsistency.
'
'      -- ALGLIB PROJECT --
'         Copyright 10.12.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub polynomialfitwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		lsfit.polynomialfitwc(x, y, w, n, xc, yc, _
			dc, k, m, info, p.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_polynomialfitwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		lsfit._pexec_polynomialfitwc(x, y, w, n, xc, yc, _
			dc, k, m, info, p.innerobj, rep.innerobj)
		Return
	End Sub
	Public Shared Sub polynomialfitwc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
		End If
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit.polynomialfitwc(x, y, w, n, xc, yc, _
			dc, k, m, info, p.innerobj, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_polynomialfitwc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef p As barycentricinterpolant, ByRef rep As polynomialfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
		End If
		info = 0
		p = New barycentricinterpolant()
		rep = New polynomialfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit._pexec_polynomialfitwc(x, y, w, n, xc, yc, _
			dc, k, m, info, p.innerobj, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    This function calculates value of four-parameter logistic (4PL)  model  at
'    specified point X. 4PL model has following form:
'
'        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'    INPUT PARAMETERS:
'        X       -   current point, X>=0:
'                    * zero X is correctly handled even for B<=0
'                    * negative X results in exception.
'        A, B, C, D- parameters of 4PL model:
'                    * A is unconstrained
'                    * B is unconstrained; zero or negative values are handled
'                      correctly.
'                    * C>0, non-positive value results in exception
'                    * D is unconstrained
'
'    RESULT:
'        model value at X
'
'    NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
'          (strictly speaking, 0^0 is undefined).
'
'    NOTE: this function also throws exception  if  all  input  parameters  are
'          correct, but overflow was detected during calculations.
'
'    NOTE: this function performs a lot of checks;  if  you  need  really  high
'          performance, consider evaluating model  yourself,  without  checking
'          for degenerate cases.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.05.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function logisticcalc4(x As Double, a As Double, b As Double, c As Double, d As Double) As Double

		Dim result As Double = lsfit.logisticcalc4(x, a, b, c, d)
		Return result
	End Function

	'************************************************************************
'    This function calculates value of five-parameter logistic (5PL)  model  at
'    specified point X. 5PL model has following form:
'
'        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'    INPUT PARAMETERS:
'        X       -   current point, X>=0:
'                    * zero X is correctly handled even for B<=0
'                    * negative X results in exception.
'        A, B, C, D, G- parameters of 5PL model:
'                    * A is unconstrained
'                    * B is unconstrained; zero or negative values are handled
'                      correctly.
'                    * C>0, non-positive value results in exception
'                    * D is unconstrained
'                    * G>0, non-positive value results in exception
'
'    RESULT:
'        model value at X
'
'    NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
'          zero X (strictly speaking, 0^0 is undefined).
'
'    NOTE: this function also throws exception  if  all  input  parameters  are
'          correct, but overflow was detected during calculations.
'
'    NOTE: this function performs a lot of checks;  if  you  need  really  high
'          performance, consider evaluating model  yourself,  without  checking
'          for degenerate cases.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.05.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function logisticcalc5(x As Double, a As Double, b As Double, c As Double, d As Double, g As Double) As Double

		Dim result As Double = lsfit.logisticcalc5(x, a, b, c, d, g)
		Return result
	End Function

	'************************************************************************
'    This function fits four-parameter logistic (4PL) model  to  data  provided
'    by user. 4PL model has following form:
'
'        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'    Here:
'        * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
'        * B>=0
'        * C>0
'
'    IMPORTANT: output of this function is constrained in  such  way that  B>0.
'               Because 4PL model is symmetric with respect to B, there  is  no
'               need to explore  B<0.  Constraining  B  makes  algorithm easier
'               to stabilize and debug.
'               Users  who  for  some  reason  prefer to work with negative B's
'               should transform output themselves (swap A and D, replace B  by
'               -B).
'
'    4PL fitting is implemented as follows:
'    * we perform small number of restarts from random locations which helps to
'      solve problem of bad local extrema. Locations are only partially  random
'      - we use input data to determine good  initial  guess,  but  we  include
'      controlled amount of randomness.
'    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'      parameters B and C - it allows us to find good  initial  guess  for  the
'      second stage without risk of running into "flat spot".
'    * second  Levenberg-Marquardt  round  is   performed   without   excessive
'      constraints. Results from the previous round are used as initial guess.
'    * after fitting is done, we compare results with best values found so far,
'      rewrite "best solution" if needed, and move to next random location.
'
'    Overall algorithm is very stable and is not prone to  bad  local  extrema.
'    Furthermore, it automatically scales when input data have  very  large  or
'    very small range.
'
'    INPUT PARAMETERS:
'        X       -   array[N], stores X-values.
'                    MUST include only non-negative numbers  (but  may  include
'                    zero values). Can be unsorted.
'        Y       -   array[N], values to fit.
'        N       -   number of points. If N is less than  length  of  X/Y, only
'                    leading N elements are used.
'
'    OUTPUT PARAMETERS:
'        A, B, C, D- parameters of 4PL model
'        Rep     -   fitting report. This structure has many fields,  but  ONLY
'                    ONES LISTED BELOW ARE SET:
'                    * Rep.IterationsCount - number of iterations performed
'                    * Rep.RMSError - root-mean-square error
'                    * Rep.AvgError - average absolute error
'                    * Rep.AvgRelError - average relative error (calculated for
'                      non-zero Y-values)
'                    * Rep.MaxError - maximum absolute error
'                    * Rep.R2 - coefficient of determination,  R-squared.  This
'                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                      of nonlinear  regression  there  are  multiple  ways  to
'                      define R2, each of them giving different results).
'
'    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'          LogisticCalc4() function.
'
'    NOTE: if you need better control over fitting process than provided by this
'          function, you may use LogisticFit45X().
'
'    NOTE: step is automatically scaled according to scale of parameters  being
'          fitted before we compare its length with EpsX. Thus,  this  function
'          can be used to fit data with very small or very large values without
'          changing EpsX.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub logisticfit4(x As Double(), y As Double(), n As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
		ByRef d As Double, ByRef rep As lsfitreport)
		a = 0
		b = 0
		c = 0
		d = 0
		rep = New lsfitreport()
		lsfit.logisticfit4(x, y, n, a, b, c, _
			d, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function fits four-parameter logistic (4PL) model  to  data  provided
'    by user, with optional constraints on parameters A and D.  4PL  model  has
'    following form:
'
'        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'    Here:
'        * A, D - with optional equality constraints
'        * B>=0
'        * C>0
'
'    IMPORTANT: output of this function is constrained in  such  way that  B>0.
'               Because 4PL model is symmetric with respect to B, there  is  no
'               need to explore  B<0.  Constraining  B  makes  algorithm easier
'               to stabilize and debug.
'               Users  who  for  some  reason  prefer to work with negative B's
'               should transform output themselves (swap A and D, replace B  by
'               -B).
'
'    4PL fitting is implemented as follows:
'    * we perform small number of restarts from random locations which helps to
'      solve problem of bad local extrema. Locations are only partially  random
'      - we use input data to determine good  initial  guess,  but  we  include
'      controlled amount of randomness.
'    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'      parameters B and C - it allows us to find good  initial  guess  for  the
'      second stage without risk of running into "flat spot".
'    * second  Levenberg-Marquardt  round  is   performed   without   excessive
'      constraints. Results from the previous round are used as initial guess.
'    * after fitting is done, we compare results with best values found so far,
'      rewrite "best solution" if needed, and move to next random location.
'
'    Overall algorithm is very stable and is not prone to  bad  local  extrema.
'    Furthermore, it automatically scales when input data have  very  large  or
'    very small range.
'
'    INPUT PARAMETERS:
'        X       -   array[N], stores X-values.
'                    MUST include only non-negative numbers  (but  may  include
'                    zero values). Can be unsorted.
'        Y       -   array[N], values to fit.
'        N       -   number of points. If N is less than  length  of  X/Y, only
'                    leading N elements are used.
'        CnstrLeft-  optional equality constraint for model value at the   left
'                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                    not need constraint on the model value at X=0 (in C++  you
'                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                    Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'        CnstrRight- optional equality constraint for model value at X=infinity.
'                    Specify NAN (Not-a-Number) if you do not  need  constraint
'                    on the model value (in C++  you can pass alglib::fp_nan as
'                    parameter, in  C# it will  be Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'
'    OUTPUT PARAMETERS:
'        A, B, C, D- parameters of 4PL model
'        Rep     -   fitting report. This structure has many fields,  but  ONLY
'                    ONES LISTED BELOW ARE SET:
'                    * Rep.IterationsCount - number of iterations performed
'                    * Rep.RMSError - root-mean-square error
'                    * Rep.AvgError - average absolute error
'                    * Rep.AvgRelError - average relative error (calculated for
'                      non-zero Y-values)
'                    * Rep.MaxError - maximum absolute error
'                    * Rep.R2 - coefficient of determination,  R-squared.  This
'                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                      of nonlinear  regression  there  are  multiple  ways  to
'                      define R2, each of them giving different results).
'
'    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'          LogisticCalc4() function.
'
'    NOTE: if you need better control over fitting process than provided by this
'          function, you may use LogisticFit45X().
'
'    NOTE: step is automatically scaled according to scale of parameters  being
'          fitted before we compare its length with EpsX. Thus,  this  function
'          can be used to fit data with very small or very large values without
'          changing EpsX.
'
'    EQUALITY CONSTRAINTS ON PARAMETERS
'
'    4PL/5PL solver supports equality constraints on model values at  the  left
'    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'    completely optional and you can specify both of them, only  one  -  or  no
'    constraints at all.
'
'    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'    fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
'    ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
'    D. That's because 4PL model is normalized in such way that B>=0.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub logisticfit4ec(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, ByRef a As Double, _
		ByRef b As Double, ByRef c As Double, ByRef d As Double, ByRef rep As lsfitreport)
		a = 0
		b = 0
		c = 0
		d = 0
		rep = New lsfitreport()
		lsfit.logisticfit4ec(x, y, n, cnstrleft, cnstrright, a, _
			b, c, d, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function fits five-parameter logistic (5PL) model  to  data  provided
'    by user. 5PL model has following form:
'
'        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'    Here:
'        * A, D - unconstrained
'        * B - unconstrained
'        * C>0
'        * G>0
'
'    IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
'               constrained in  such  way that B is guaranteed to be  positive.
'               Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
'               respect to B, so you can NOT transform model to equivalent one,
'               with B having desired sign (>0 or <0).
'
'    5PL fitting is implemented as follows:
'    * we perform small number of restarts from random locations which helps to
'      solve problem of bad local extrema. Locations are only partially  random
'      - we use input data to determine good  initial  guess,  but  we  include
'      controlled amount of randomness.
'    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'      parameters B and C - it allows us to find good  initial  guess  for  the
'      second stage without risk of running into "flat spot".  Parameter  G  is
'      fixed at G=1.
'    * second  Levenberg-Marquardt  round  is   performed   without   excessive
'      constraints on B and C, but with G still equal to 1.  Results  from  the
'      previous round are used as initial guess.
'    * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
'      different models - one with B>0 and one with B<0.
'    * after fitting is done, we compare results with best values found so far,
'      rewrite "best solution" if needed, and move to next random location.
'
'    Overall algorithm is very stable and is not prone to  bad  local  extrema.
'    Furthermore, it automatically scales when input data have  very  large  or
'    very small range.
'
'    INPUT PARAMETERS:
'        X       -   array[N], stores X-values.
'                    MUST include only non-negative numbers  (but  may  include
'                    zero values). Can be unsorted.
'        Y       -   array[N], values to fit.
'        N       -   number of points. If N is less than  length  of  X/Y, only
'                    leading N elements are used.
'
'    OUTPUT PARAMETERS:
'        A,B,C,D,G-  parameters of 5PL model
'        Rep     -   fitting report. This structure has many fields,  but  ONLY
'                    ONES LISTED BELOW ARE SET:
'                    * Rep.IterationsCount - number of iterations performed
'                    * Rep.RMSError - root-mean-square error
'                    * Rep.AvgError - average absolute error
'                    * Rep.AvgRelError - average relative error (calculated for
'                      non-zero Y-values)
'                    * Rep.MaxError - maximum absolute error
'                    * Rep.R2 - coefficient of determination,  R-squared.  This
'                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                      of nonlinear  regression  there  are  multiple  ways  to
'                      define R2, each of them giving different results).
'
'    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'          LogisticCalc5() function.
'
'    NOTE: if you need better control over fitting process than provided by this
'          function, you may use LogisticFit45X().
'
'    NOTE: step is automatically scaled according to scale of parameters  being
'          fitted before we compare its length with EpsX. Thus,  this  function
'          can be used to fit data with very small or very large values without
'          changing EpsX.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub logisticfit5(x As Double(), y As Double(), n As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
		ByRef d As Double, ByRef g As Double, ByRef rep As lsfitreport)
		a = 0
		b = 0
		c = 0
		d = 0
		g = 0
		rep = New lsfitreport()
		lsfit.logisticfit5(x, y, n, a, b, c, _
			d, g, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function fits five-parameter logistic (5PL) model  to  data  provided
'    by user, subject to optional equality constraints on parameters A  and  D.
'    5PL model has following form:
'
'        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'    Here:
'        * A, D - with optional equality constraints
'        * B - unconstrained
'        * C>0
'        * G>0
'
'    IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
'               constrained in  such  way that B is guaranteed to be  positive.
'               Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
'               respect to B, so you can NOT transform model to equivalent one,
'               with B having desired sign (>0 or <0).
'
'    5PL fitting is implemented as follows:
'    * we perform small number of restarts from random locations which helps to
'      solve problem of bad local extrema. Locations are only partially  random
'      - we use input data to determine good  initial  guess,  but  we  include
'      controlled amount of randomness.
'    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'      parameters B and C - it allows us to find good  initial  guess  for  the
'      second stage without risk of running into "flat spot".  Parameter  G  is
'      fixed at G=1.
'    * second  Levenberg-Marquardt  round  is   performed   without   excessive
'      constraints on B and C, but with G still equal to 1.  Results  from  the
'      previous round are used as initial guess.
'    * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
'      different models - one with B>0 and one with B<0.
'    * after fitting is done, we compare results with best values found so far,
'      rewrite "best solution" if needed, and move to next random location.
'
'    Overall algorithm is very stable and is not prone to  bad  local  extrema.
'    Furthermore, it automatically scales when input data have  very  large  or
'    very small range.
'
'    INPUT PARAMETERS:
'        X       -   array[N], stores X-values.
'                    MUST include only non-negative numbers  (but  may  include
'                    zero values). Can be unsorted.
'        Y       -   array[N], values to fit.
'        N       -   number of points. If N is less than  length  of  X/Y, only
'                    leading N elements are used.
'        CnstrLeft-  optional equality constraint for model value at the   left
'                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                    not need constraint on the model value at X=0 (in C++  you
'                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                    Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'        CnstrRight- optional equality constraint for model value at X=infinity.
'                    Specify NAN (Not-a-Number) if you do not  need  constraint
'                    on the model value (in C++  you can pass alglib::fp_nan as
'                    parameter, in  C# it will  be Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'
'    OUTPUT PARAMETERS:
'        A,B,C,D,G-  parameters of 5PL model
'        Rep     -   fitting report. This structure has many fields,  but  ONLY
'                    ONES LISTED BELOW ARE SET:
'                    * Rep.IterationsCount - number of iterations performed
'                    * Rep.RMSError - root-mean-square error
'                    * Rep.AvgError - average absolute error
'                    * Rep.AvgRelError - average relative error (calculated for
'                      non-zero Y-values)
'                    * Rep.MaxError - maximum absolute error
'                    * Rep.R2 - coefficient of determination,  R-squared.  This
'                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                      of nonlinear  regression  there  are  multiple  ways  to
'                      define R2, each of them giving different results).
'
'    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'          LogisticCalc5() function.
'
'    NOTE: if you need better control over fitting process than provided by this
'          function, you may use LogisticFit45X().
'
'    NOTE: step is automatically scaled according to scale of parameters  being
'          fitted before we compare its length with EpsX. Thus,  this  function
'          can be used to fit data with very small or very large values without
'          changing EpsX.
'
'    EQUALITY CONSTRAINTS ON PARAMETERS
'
'    5PL solver supports equality constraints on model  values  at   the   left
'    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'    completely optional and you can specify both of them, only  one  -  or  no
'    constraints at all.
'
'    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'    fitting), and CnstrRight contains right  one.
'
'    Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
'    of B. Thus, negative B's are possible, and left constraint  may  constrain
'    parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
'    Similarly changes meaning of right constraint.
'
'    You do not have to decide what parameter to  constrain  -  algorithm  will
'    automatically determine correct parameters as fitting progresses. However,
'    question highlighted above is important when you interpret fitting results.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub logisticfit5ec(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, ByRef a As Double, _
		ByRef b As Double, ByRef c As Double, ByRef d As Double, ByRef g As Double, ByRef rep As lsfitreport)
		a = 0
		b = 0
		c = 0
		d = 0
		g = 0
		rep = New lsfitreport()
		lsfit.logisticfit5ec(x, y, n, cnstrleft, cnstrright, a, _
			b, c, d, g, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This is "expert" 4PL/5PL fitting function, which can be used if  you  need
'    better control over fitting process than provided  by  LogisticFit4()  or
'    LogisticFit5().
'
'    This function fits model of the form
'
'        F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)
'
'    or
'
'        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)
'
'    Here:
'        * A, D - unconstrained
'        * B>=0 for 4PL, unconstrained for 5PL
'        * C>0
'        * G>0 (if present)
'
'    INPUT PARAMETERS:
'        X       -   array[N], stores X-values.
'                    MUST include only non-negative numbers  (but  may  include
'                    zero values). Can be unsorted.
'        Y       -   array[N], values to fit.
'        N       -   number of points. If N is less than  length  of  X/Y, only
'                    leading N elements are used.
'        CnstrLeft-  optional equality constraint for model value at the   left
'                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                    not need constraint on the model value at X=0 (in C++  you
'                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                    Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'        CnstrRight- optional equality constraint for model value at X=infinity.
'                    Specify NAN (Not-a-Number) if you do not  need  constraint
'                    on the model value (in C++  you can pass alglib::fp_nan as
'                    parameter, in  C# it will  be Double.NaN).
'                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                    information about constraints.
'        Is4PL   -   whether 4PL or 5PL models are fitted
'        LambdaV -   regularization coefficient, LambdaV>=0.
'                    Set it to zero unless you know what you are doing.
'        EpsX    -   stopping condition (step size), EpsX>=0.
'                    Zero value means that small step is automatically chosen.
'                    See notes below for more information.
'        RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
'                    models are prone to problem of bad local extrema. Utilizing
'                    multiple random restarts allows  us  to  improve algorithm
'                    convergence.
'                    RsCnt>=0.
'                    Zero value means that function automatically choose  small
'                    amount of restarts (recommended).
'
'    OUTPUT PARAMETERS:
'        A, B, C, D- parameters of 4PL model
'        G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
'        Rep     -   fitting report. This structure has many fields,  but  ONLY
'                    ONES LISTED BELOW ARE SET:
'                    * Rep.IterationsCount - number of iterations performed
'                    * Rep.RMSError - root-mean-square error
'                    * Rep.AvgError - average absolute error
'                    * Rep.AvgRelError - average relative error (calculated for
'                      non-zero Y-values)
'                    * Rep.MaxError - maximum absolute error
'                    * Rep.R2 - coefficient of determination,  R-squared.  This
'                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                      of nonlinear  regression  there  are  multiple  ways  to
'                      define R2, each of them giving different results).
'
'    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'          LogisticCalc5() function.
'
'    NOTE: step is automatically scaled according to scale of parameters  being
'          fitted before we compare its length with EpsX. Thus,  this  function
'          can be used to fit data with very small or very large values without
'          changing EpsX.
'
'    EQUALITY CONSTRAINTS ON PARAMETERS
'
'    4PL/5PL solver supports equality constraints on model values at  the  left
'    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'    completely optional and you can specify both of them, only  one  -  or  no
'    constraints at all.
'
'    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'    fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
'    ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
'    D. That's because 4PL model is normalized in such way that B>=0.
'
'    For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
'    symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
'    possible, and left constraint may constrain parameter A (for positive B's)
'    - or parameter D (for negative B's). Similarly changes  meaning  of  right
'    constraint.
'
'    You do not have to decide what parameter to  constrain  -  algorithm  will
'    automatically determine correct parameters as fitting progresses. However,
'    question highlighted above is important when you interpret fitting results.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 14.02.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub logisticfit45x(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, is4pl As Boolean, _
		lambdav As Double, epsx As Double, rscnt As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
		ByRef d As Double, ByRef g As Double, ByRef rep As lsfitreport)
		a = 0
		b = 0
		c = 0
		d = 0
		g = 0
		rep = New lsfitreport()
		lsfit.logisticfit45x(x, y, n, cnstrleft, cnstrright, is4pl, _
			lambdav, epsx, rscnt, a, b, c, _
			d, g, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    Weghted rational least  squares  fitting  using  Floater-Hormann  rational
'    functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
'    individual weights.
'
'    Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
'    functions. Different values of D are tried, optimal D (least WEIGHTED root
'    mean square error) is chosen.  Task  is  linear,  so  linear least squares
'    solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
'    (mostly dominated by the least squares solver).
'
'    SEE ALSO
'    * BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
'      weights and constraints.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        W   -   weights, array[0..N-1]
'                Each summand in square  sum  of  approximation deviations from
'                given  values  is  multiplied  by  the square of corresponding
'                weight. Fill it by 1's if you don't  want  to  solve  weighted
'                task.
'        N   -   number of points, N>0.
'        XC  -   points where function values/derivatives are constrained,
'                array[0..K-1].
'        YC  -   values of constraints, array[0..K-1]
'        DC  -   array[0..K-1], types of constraints:
'                * DC[i]=0   means that S(XC[i])=YC[i]
'                * DC[i]=1   means that S'(XC[i])=YC[i]
'                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'        K   -   number of constraints, 0<=K<M.
'                K=0 means no constraints (XC/YC/DC are not used in such cases)
'        M   -   number of basis functions ( = number_of_nodes), M>=2.
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearWC() subroutine.
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'                            -3 means inconsistent constraints
'                            -1 means another errors in parameters passed
'                               (N<=0, for example)
'        B   -   barycentric interpolant.
'        Rep -   report, same format as in LSFitLinearWC() subroutine.
'                Following fields are set:
'                * DBest         best value of the D parameter
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroutine doesn't calculate task's condition number for K<>0.
'
'    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'    Setting constraints can lead  to undesired  results,  like ill-conditioned
'    behavior, or inconsistency being detected. From the other side,  it allows
'    us to improve quality of the fit. Here we summarize  our  experience  with
'    constrained barycentric interpolants:
'    * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
'      functions aren't as flexible as splines (although they are very smooth).
'    * the more evenly constraints are spread across [min(x),max(x)],  the more
'      chances that they will be consistent
'    * the  greater  is  M (given  fixed  constraints),  the  more chances that
'      constraints will be consistent
'    * in the general case, consistency of constraints IS NOT GUARANTEED.
'    * in the several special cases, however, we CAN guarantee consistency.
'    * one of this cases is constraints on the function  VALUES at the interval
'      boundaries. Note that consustency of the  constraints  on  the  function
'      DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
'      which are more flexible).
'    * another  special  case  is ONE constraint on the function value (OR, but
'      not AND, derivative) anywhere in the interval
'
'    Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'    can't solve your task without them. Anything beyond  special  cases  given
'    above is not guaranteed and may result in inconsistency.
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricfitfloaterhormannwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef b As barycentricinterpolant, ByRef rep As barycentricfitreport)
		info = 0
		b = New barycentricinterpolant()
		rep = New barycentricfitreport()
		lsfit.barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, _
			dc, k, m, info, b.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_barycentricfitfloaterhormannwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef b As barycentricinterpolant, ByRef rep As barycentricfitreport)
		info = 0
		b = New barycentricinterpolant()
		rep = New barycentricfitreport()
		lsfit._pexec_barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, _
			dc, k, m, info, b.innerobj, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    Rational least squares fitting using  Floater-Hormann  rational  functions
'    with optimal D chosen from [0,9].
'
'    Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
'    functions. Different values of D are tried, optimal  D  (least  root  mean
'    square error) is chosen.  Task  is  linear, so linear least squares solver
'    is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
'    dominated by the least squares solver).
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        N   -   number of points, N>0.
'        M   -   number of basis functions ( = number_of_nodes), M>=2.
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearWC() subroutine.
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'                            -3 means inconsistent constraints
'        B   -   barycentric interpolant.
'        Rep -   report, same format as in LSFitLinearWC() subroutine.
'                Following fields are set:
'                * DBest         best value of the D parameter
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub barycentricfitfloaterhormann(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef b As barycentricinterpolant, _
		ByRef rep As barycentricfitreport)
		info = 0
		b = New barycentricinterpolant()
		rep = New barycentricfitreport()
		lsfit.barycentricfitfloaterhormann(x, y, n, m, info, b.innerobj, _
			rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_barycentricfitfloaterhormann(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef b As barycentricinterpolant, _
		ByRef rep As barycentricfitreport)
		info = 0
		b = New barycentricinterpolant()
		rep = New barycentricfitreport()
		lsfit._pexec_barycentricfitfloaterhormann(x, y, n, m, info, b.innerobj, _
			rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    Fitting by penalized cubic spline.
'
'    Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'    basis functions. Basis functions are cubic splines with  natural  boundary
'    conditions. Problem is regularized by  adding non-linearity penalty to the
'    usual least squares penalty function:
'
'        S(x) = arg min { LS + P }, where
'        LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
'        P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
'        rho  - tunable constant given by user
'        C    - automatically determined scale parameter,
'               makes penalty invariant with respect to scaling of X, Y, W.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        N   -   number of points (optional):
'                * N>0
'                * if given, only first N elements of X/Y are processed
'                * if not given, automatically determined from X/Y sizes
'        M   -   number of basis functions ( = number_of_nodes), M>=4.
'        Rho -   regularization  constant  passed   by   user.   It   penalizes
'                nonlinearity in the regression spline. It  is  logarithmically
'                scaled,  i.e.  actual  value  of  regularization  constant  is
'                calculated as 10^Rho. It is automatically scaled so that:
'                * Rho=2.0 corresponds to moderate amount of nonlinearity
'                * generally, it should be somewhere in the [-8.0,+8.0]
'                If you do not want to penalize nonlineary,
'                pass small Rho. Values as low as -15 should work.
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearWC() subroutine.
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD or
'                               Cholesky decomposition; problem may be
'                               too ill-conditioned (very rare)
'        S   -   spline interpolant.
'        Rep -   Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    NOTE 1: additional nodes are added to the spline outside  of  the  fitting
'    interval to force linearity when x<min(x,xc) or x>max(x,xc).  It  is  done
'    for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
'    it is natural to force linearity outside of this interval.
'
'    NOTE 2: function automatically sorts points,  so  caller may pass unsorted
'    array.
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfitpenalized(x As Double(), y As Double(), n As Integer, m As Integer, rho As Double, ByRef info As Integer, _
		ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfitpenalized(x, y, n, m, rho, info, _
			s.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfitpenalized(x As Double(), y As Double(), n As Integer, m As Integer, rho As Double, ByRef info As Integer, _
		ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfitpenalized(x, y, n, m, rho, info, _
			s.innerobj, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfitpenalized(x As Double(), y As Double(), m As Integer, rho As Double, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit.spline1dfitpenalized(x, y, n, m, rho, info, _
			s.innerobj, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfitpenalized(x As Double(), y As Double(), m As Integer, rho As Double, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit._pexec_spline1dfitpenalized(x, y, n, m, rho, info, _
			s.innerobj, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted fitting by penalized cubic spline.
'
'    Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'    basis functions. Basis functions are cubic splines with  natural  boundary
'    conditions. Problem is regularized by  adding non-linearity penalty to the
'    usual least squares penalty function:
'
'        S(x) = arg min { LS + P }, where
'        LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
'        P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
'        rho  - tunable constant given by user
'        C    - automatically determined scale parameter,
'               makes penalty invariant with respect to scaling of X, Y, W.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        W   -   weights, array[0..N-1]
'                Each summand in square  sum  of  approximation deviations from
'                given  values  is  multiplied  by  the square of corresponding
'                weight. Fill it by 1's if you don't  want  to  solve  weighted
'                problem.
'        N   -   number of points (optional):
'                * N>0
'                * if given, only first N elements of X/Y/W are processed
'                * if not given, automatically determined from X/Y/W sizes
'        M   -   number of basis functions ( = number_of_nodes), M>=4.
'        Rho -   regularization  constant  passed   by   user.   It   penalizes
'                nonlinearity in the regression spline. It  is  logarithmically
'                scaled,  i.e.  actual  value  of  regularization  constant  is
'                calculated as 10^Rho. It is automatically scaled so that:
'                * Rho=2.0 corresponds to moderate amount of nonlinearity
'                * generally, it should be somewhere in the [-8.0,+8.0]
'                If you do not want to penalize nonlineary,
'                pass small Rho. Values as low as -15 should work.
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearWC() subroutine.
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD or
'                               Cholesky decomposition; problem may be
'                               too ill-conditioned (very rare)
'        S   -   spline interpolant.
'        Rep -   Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    NOTE 1: additional nodes are added to the spline outside  of  the  fitting
'    interval to force linearity when x<min(x,xc) or x>max(x,xc).  It  is  done
'    for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
'    it is natural to force linearity outside of this interval.
'
'    NOTE 2: function automatically sorts points,  so  caller may pass unsorted
'    array.
'
'      -- ALGLIB PROJECT --
'         Copyright 19.10.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), n As Integer, m As Integer, rho As Double, _
		ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfitpenalizedw(x, y, w, n, m, rho, _
			info, s.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), n As Integer, m As Integer, rho As Double, _
		ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfitpenalizedw(x, y, w, n, m, rho, _
			info, s.innerobj, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), m As Integer, rho As Double, ByRef info As Integer, _
		ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit.spline1dfitpenalizedw(x, y, w, n, m, rho, _
			info, s.innerobj, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), m As Integer, rho As Double, ByRef info As Integer, _
		ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit._pexec_spline1dfitpenalizedw(x, y, w, n, m, rho, _
			info, s.innerobj, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted fitting by cubic  spline,  with constraints on function values or
'    derivatives.
'
'    Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
'    basis functions. Basis functions are cubic splines with continuous  second
'    derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
'    regularizing term is used  when  solving  constrained  tasks  (to  improve
'    stability).
'
'    Task is linear, so linear least squares solver is used. Complexity of this
'    computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'    SEE ALSO
'        Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
'                                    less smooth)
'        Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
'                                    without invididual weights and constraints
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        W   -   weights, array[0..N-1]
'                Each summand in square  sum  of  approximation deviations from
'                given  values  is  multiplied  by  the square of corresponding
'                weight. Fill it by 1's if you don't  want  to  solve  weighted
'                task.
'        N   -   number of points (optional):
'                * N>0
'                * if given, only first N elements of X/Y/W are processed
'                * if not given, automatically determined from X/Y/W sizes
'        XC  -   points where spline values/derivatives are constrained,
'                array[0..K-1].
'        YC  -   values of constraints, array[0..K-1]
'        DC  -   array[0..K-1], types of constraints:
'                * DC[i]=0   means that S(XC[i])=YC[i]
'                * DC[i]=1   means that S'(XC[i])=YC[i]
'                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'        K   -   number of constraints (optional):
'                * 0<=K<M.
'                * K=0 means no constraints (XC/YC/DC are not used)
'                * if given, only first K elements of XC/YC/DC are used
'                * if not given, automatically determined from XC/YC/DC
'        M   -   number of basis functions ( = number_of_nodes+2), M>=4.
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearWC() subroutine.
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'                            -3 means inconsistent constraints
'        S   -   spline interpolant.
'        Rep -   report, same format as in LSFitLinearWC() subroutine.
'                Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'    Setting constraints can lead  to undesired  results,  like ill-conditioned
'    behavior, or inconsistency being detected. From the other side,  it allows
'    us to improve quality of the fit. Here we summarize  our  experience  with
'    constrained regression splines:
'    * excessive constraints can be inconsistent. Splines are  piecewise  cubic
'      functions, and it is easy to create an example, where  large  number  of
'      constraints  concentrated  in  small  area will result in inconsistency.
'      Just because spline is not flexible enough to satisfy all of  them.  And
'      same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'      consistent.
'    * the more evenly constraints are spread across [min(x),max(x)],  the more
'      chances that they will be consistent
'    * the  greater  is  M (given  fixed  constraints),  the  more chances that
'      constraints will be consistent
'    * in the general case, consistency of constraints IS NOT GUARANTEED.
'    * in the several special cases, however, we CAN guarantee consistency.
'    * one of this cases is constraints  on  the  function  values  AND/OR  its
'      derivatives at the interval boundaries.
'    * another  special  case  is ONE constraint on the function value (OR, but
'      not AND, derivative) anywhere in the interval
'
'    Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'    can't solve your task without them. Anything beyond  special  cases  given
'    above is not guaranteed and may result in inconsistency.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfitcubicwc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit._pexec_spline1dfitcubicwc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted  fitting  by Hermite spline,  with constraints on function values
'    or first derivatives.
'
'    Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'    basis functions. Basis functions are Hermite splines.  Small  regularizing
'    term is used when solving constrained tasks (to improve stability).
'
'    Task is linear, so linear least squares solver is used. Complexity of this
'    computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'    SEE ALSO
'        Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
'                                    more smooth)
'        Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
'                                    invididual weights and constraints
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        X   -   points, array[0..N-1].
'        Y   -   function values, array[0..N-1].
'        W   -   weights, array[0..N-1]
'                Each summand in square  sum  of  approximation deviations from
'                given  values  is  multiplied  by  the square of corresponding
'                weight. Fill it by 1's if you don't  want  to  solve  weighted
'                task.
'        N   -   number of points (optional):
'                * N>0
'                * if given, only first N elements of X/Y/W are processed
'                * if not given, automatically determined from X/Y/W sizes
'        XC  -   points where spline values/derivatives are constrained,
'                array[0..K-1].
'        YC  -   values of constraints, array[0..K-1]
'        DC  -   array[0..K-1], types of constraints:
'                * DC[i]=0   means that S(XC[i])=YC[i]
'                * DC[i]=1   means that S'(XC[i])=YC[i]
'                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'        K   -   number of constraints (optional):
'                * 0<=K<M.
'                * K=0 means no constraints (XC/YC/DC are not used)
'                * if given, only first K elements of XC/YC/DC are used
'                * if not given, automatically determined from XC/YC/DC
'        M   -   number of basis functions (= 2 * number of nodes),
'                M>=4,
'                M IS EVEN!
'
'    OUTPUT PARAMETERS:
'        Info-   same format as in LSFitLinearW() subroutine:
'                * Info>0    task is solved
'                * Info<=0   an error occured:
'                            -4 means inconvergence of internal SVD
'                            -3 means inconsistent constraints
'                            -2 means odd M was passed (which is not supported)
'                            -1 means another errors in parameters passed
'                               (N<=0, for example)
'        S   -   spline interpolant.
'        Rep -   report, same format as in LSFitLinearW() subroutine.
'                Following fields are set:
'                * RMSError      rms error on the (X,Y).
'                * AvgError      average error on the (X,Y).
'                * AvgRelError   average relative error on the non-zero Y
'                * MaxError      maximum error
'                                NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    IMPORTANT:
'        this subroitine supports only even M's
'
'
'    ORDER OF POINTS
'
'    Subroutine automatically sorts points, so caller may pass unsorted array.
'
'    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'    Setting constraints can lead  to undesired  results,  like ill-conditioned
'    behavior, or inconsistency being detected. From the other side,  it allows
'    us to improve quality of the fit. Here we summarize  our  experience  with
'    constrained regression splines:
'    * excessive constraints can be inconsistent. Splines are  piecewise  cubic
'      functions, and it is easy to create an example, where  large  number  of
'      constraints  concentrated  in  small  area will result in inconsistency.
'      Just because spline is not flexible enough to satisfy all of  them.  And
'      same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'      consistent.
'    * the more evenly constraints are spread across [min(x),max(x)],  the more
'      chances that they will be consistent
'    * the  greater  is  M (given  fixed  constraints),  the  more chances that
'      constraints will be consistent
'    * in the general case, consistency of constraints is NOT GUARANTEED.
'    * in the several special cases, however, we can guarantee consistency.
'    * one of this cases is  M>=4  and   constraints  on   the  function  value
'      (AND/OR its derivative) at the interval boundaries.
'    * another special case is M>=4  and  ONE  constraint on the function value
'      (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
'
'    Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'    can't solve your task without them. Anything beyond  special  cases  given
'    above is not guaranteed and may result in inconsistency.
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfithermitewc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfithermitewc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
		dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfithermitewc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfithermitewc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfithermitewc(x As Double(), y As Double(), w As Double(), xc As Double(), yc As Double(), dc As Integer(), _
		m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		Dim k As Integer
		If (ap.len(x) <> ap.len(y)) OrElse (ap.len(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
		End If
		If (ap.len(xc) <> ap.len(yc)) OrElse (ap.len(xc) <> ap.len(dc)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		k = ap.len(xc)
		lsfit._pexec_spline1dfithermitewc(x, y, w, n, xc, yc, _
			dc, k, m, info, s.innerobj, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Least squares fitting by cubic spline.
'
'    This subroutine is "lightweight" alternative for more complex and feature-
'    rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
'    about subroutine parameters (we don't duplicate it here because of length)
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfitcubic(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfitcubic(x, y, n, m, info, s.innerobj, _
			rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfitcubic(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfitcubic(x, y, n, m, info, s.innerobj, _
			rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfitcubic(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit.spline1dfitcubic(x, y, n, m, info, s.innerobj, _
			rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfitcubic(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit._pexec_spline1dfitcubic(x, y, n, m, info, s.innerobj, _
			rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Least squares fitting by Hermite spline.
'
'    This subroutine is "lightweight" alternative for more complex and feature-
'    rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
'    more information about subroutine parameters (we don't duplicate  it  here
'    because of length).
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'      -- ALGLIB PROJECT --
'         Copyright 18.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline1dfithermite(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit.spline1dfithermite(x, y, n, m, info, s.innerobj, _
			rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_spline1dfithermite(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, _
		ByRef rep As spline1dfitreport)
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		lsfit._pexec_spline1dfithermite(x, y, n, m, info, s.innerobj, _
			rep.innerobj)
		Return
	End Sub
	Public Shared Sub spline1dfithermite(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit.spline1dfithermite(x, y, n, m, info, s.innerobj, _
			rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_spline1dfithermite(x As Double(), y As Double(), m As Integer, ByRef info As Integer, ByRef s As spline1dinterpolant, ByRef rep As spline1dfitreport)
		Dim n As Integer
		If (ap.len(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size")
		End If
		info = 0
		s = New spline1dinterpolant()
		rep = New spline1dfitreport()
		n = ap.len(x)
		lsfit._pexec_spline1dfithermite(x, y, n, m, info, s.innerobj, _
			rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted linear least squares fitting.
'
'    QR decomposition is used to reduce task to MxM, then triangular solver  or
'    SVD-based solver is used depending on condition number of the  system.  It
'    allows to maximize speed and retain decent accuracy.
'
'    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'               convenient to use PolynomialFit() function. This function gives
'               best  results  on  polynomial  problems  and  solves  numerical
'               stability  issues  which  arise  when   you   fit   high-degree
'               polynomials to your data.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        Y       -   array[0..N-1] Function values in  N  points.
'        W       -   array[0..N-1]  Weights  corresponding to function  values.
'                    Each summand in square  sum  of  approximation  deviations
'                    from  given  values  is  multiplied  by  the   square   of
'                    corresponding weight.
'        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                    FMatrix[I, J] - value of J-th basis function in I-th point.
'        N       -   number of points used. N>=1.
'        M       -   number of basis functions, M>=1.
'
'    OUTPUT PARAMETERS:
'        Info    -   error code:
'                    * -4    internal SVD decomposition subroutine failed (very
'                            rare and for degenerate systems only)
'                    * -1    incorrect N/M were specified
'                    *  1    task is solved
'        C       -   decomposition coefficients, array[0..M-1]
'        Rep     -   fitting report. Following fields are set:
'                    * Rep.TaskRCond     reciprocal of condition number
'                    * R2                non-adjusted coefficient of determination
'                                        (non-weighted)
'                    * RMSError          rms error on the (X,Y).
'                    * AvgError          average error on the (X,Y).
'                    * AvgRelError       average relative error on the non-zero Y
'                    * MaxError          maximum error
'                                        NON-WEIGHTED ERRORS ARE CALCULATED
'
'    ERRORS IN PARAMETERS
'
'    This  solver  also  calculates different kinds of errors in parameters and
'    fills corresponding fields of report:
'    * Rep.CovPar        covariance matrix for parameters, array[K,K].
'    * Rep.ErrPar        errors in parameters, array[K],
'                        errpar = sqrt(diag(CovPar))
'    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                        best-fit curve from "ideal" best-fit curve built  with
'                        infinite number of samples, array[N].
'                        errcurve = sqrt(diag(F*CovPar*F')),
'                        where F is functions matrix.
'    * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'    NOTE:       noise in the data is estimated as follows:
'                * for fitting without user-supplied  weights  all  points  are
'                  assumed to have same level of noise, which is estimated from
'                  the data
'                * for fitting with user-supplied weights we assume that  noise
'                  level in I-th point is inversely proportional to Ith weight.
'                  Coefficient of proportionality is estimated from the data.
'
'    NOTE:       we apply small amount of regularization when we invert squared
'                Jacobian and calculate covariance matrix. It  guarantees  that
'                algorithm won't divide by zero  during  inversion,  but  skews
'                error estimates a bit (fractional error is about 10^-9).
'
'                However, we believe that this difference is insignificant  for
'                all practical purposes except for the situation when you  want
'                to compare ALGLIB results with "reference"  implementation  up
'                to the last significant digit.
'
'    NOTE:       covariance matrix is estimated using  correction  for  degrees
'                of freedom (covariances are divided by N-M instead of dividing
'                by N).
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, _
		ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit.lsfitlinearw(y, w, fmatrix, n, m, info, _
			c, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, _
		ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit._pexec_lsfitlinearw(y, w, fmatrix, n, m, info, _
			c, rep.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		If (ap.len(y) <> ap.len(w)) OrElse (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		lsfit.lsfitlinearw(y, w, fmatrix, n, m, info, _
			c, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		If (ap.len(y) <> ap.len(w)) OrElse (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		lsfit._pexec_lsfitlinearw(y, w, fmatrix, n, m, info, _
			c, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted constained linear least squares fitting.
'
'    This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
'    that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'    task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
'    is called.
'
'    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'               convenient to use PolynomialFit() function. This function gives
'               best  results  on  polynomial  problems  and  solves  numerical
'               stability  issues  which  arise  when   you   fit   high-degree
'               polynomials to your data.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        Y       -   array[0..N-1] Function values in  N  points.
'        W       -   array[0..N-1]  Weights  corresponding to function  values.
'                    Each summand in square  sum  of  approximation  deviations
'                    from  given  values  is  multiplied  by  the   square   of
'                    corresponding weight.
'        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                    FMatrix[I,J] - value of J-th basis function in I-th point.
'        CMatrix -   a table of constaints, array[0..K-1,0..M].
'                    I-th row of CMatrix corresponds to I-th linear constraint:
'                    CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'        N       -   number of points used. N>=1.
'        M       -   number of basis functions, M>=1.
'        K       -   number of constraints, 0 <= K < M
'                    K=0 corresponds to absence of constraints.
'
'    OUTPUT PARAMETERS:
'        Info    -   error code:
'                    * -4    internal SVD decomposition subroutine failed (very
'                            rare and for degenerate systems only)
'                    * -3    either   too   many  constraints  (M   or   more),
'                            degenerate  constraints   (some   constraints  are
'                            repetead twice) or inconsistent  constraints  were
'                            specified.
'                    *  1    task is solved
'        C       -   decomposition coefficients, array[0..M-1]
'        Rep     -   fitting report. Following fields are set:
'                    * R2                non-adjusted coefficient of determination
'                                        (non-weighted)
'                    * RMSError          rms error on the (X,Y).
'                    * AvgError          average error on the (X,Y).
'                    * AvgRelError       average relative error on the non-zero Y
'                    * MaxError          maximum error
'                                        NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    ERRORS IN PARAMETERS
'
'    This  solver  also  calculates different kinds of errors in parameters and
'    fills corresponding fields of report:
'    * Rep.CovPar        covariance matrix for parameters, array[K,K].
'    * Rep.ErrPar        errors in parameters, array[K],
'                        errpar = sqrt(diag(CovPar))
'    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                        best-fit curve from "ideal" best-fit curve built  with
'                        infinite number of samples, array[N].
'                        errcurve = sqrt(diag(F*CovPar*F')),
'                        where F is functions matrix.
'    * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                account boundary/linear constraints! Presence  of  constraints
'                changes distribution of errors, but there is no  easy  way  to
'                account for constraints when you calculate covariance matrix.
'
'    NOTE:       noise in the data is estimated as follows:
'                * for fitting without user-supplied  weights  all  points  are
'                  assumed to have same level of noise, which is estimated from
'                  the data
'                * for fitting with user-supplied weights we assume that  noise
'                  level in I-th point is inversely proportional to Ith weight.
'                  Coefficient of proportionality is estimated from the data.
'
'    NOTE:       we apply small amount of regularization when we invert squared
'                Jacobian and calculate covariance matrix. It  guarantees  that
'                algorithm won't divide by zero  during  inversion,  but  skews
'                error estimates a bit (fractional error is about 10^-9).
'
'                However, we believe that this difference is insignificant  for
'                all practical purposes except for the situation when you  want
'                to compare ALGLIB results with "reference"  implementation  up
'                to the last significant digit.
'
'    NOTE:       covariance matrix is estimated using  correction  for  degrees
'                of freedom (covariances are divided by N-M instead of dividing
'                by N).
'
'      -- ALGLIB --
'         Copyright 07.09.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, _
		k As Integer, ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
			k, info, c, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, _
		k As Integer, ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit._pexec_lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
			k, info, c, rep.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), _
		ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.len(y) <> ap.len(w)) OrElse (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
		End If
		If (ap.cols(fmatrix) <> ap.cols(cmatrix) - 1) Then
			Throw New alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		k = ap.rows(cmatrix)
		lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
			k, info, c, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), _
		ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.len(y) <> ap.len(w)) OrElse (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
		End If
		If (ap.cols(fmatrix) <> ap.cols(cmatrix) - 1) Then
			Throw New alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		k = ap.rows(cmatrix)
		lsfit._pexec_lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
			k, info, c, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Linear least squares fitting.
'
'    QR decomposition is used to reduce task to MxM, then triangular solver  or
'    SVD-based solver is used depending on condition number of the  system.  It
'    allows to maximize speed and retain decent accuracy.
'
'    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'               convenient to use PolynomialFit() function. This function gives
'               best  results  on  polynomial  problems  and  solves  numerical
'               stability  issues  which  arise  when   you   fit   high-degree
'               polynomials to your data.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        Y       -   array[0..N-1] Function values in  N  points.
'        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                    FMatrix[I, J] - value of J-th basis function in I-th point.
'        N       -   number of points used. N>=1.
'        M       -   number of basis functions, M>=1.
'
'    OUTPUT PARAMETERS:
'        Info    -   error code:
'                    * -4    internal SVD decomposition subroutine failed (very
'                            rare and for degenerate systems only)
'                    *  1    task is solved
'        C       -   decomposition coefficients, array[0..M-1]
'        Rep     -   fitting report. Following fields are set:
'                    * Rep.TaskRCond     reciprocal of condition number
'                    * R2                non-adjusted coefficient of determination
'                                        (non-weighted)
'                    * RMSError          rms error on the (X,Y).
'                    * AvgError          average error on the (X,Y).
'                    * AvgRelError       average relative error on the non-zero Y
'                    * MaxError          maximum error
'                                        NON-WEIGHTED ERRORS ARE CALCULATED
'
'    ERRORS IN PARAMETERS
'
'    This  solver  also  calculates different kinds of errors in parameters and
'    fills corresponding fields of report:
'    * Rep.CovPar        covariance matrix for parameters, array[K,K].
'    * Rep.ErrPar        errors in parameters, array[K],
'                        errpar = sqrt(diag(CovPar))
'    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                        best-fit curve from "ideal" best-fit curve built  with
'                        infinite number of samples, array[N].
'                        errcurve = sqrt(diag(F*CovPar*F')),
'                        where F is functions matrix.
'    * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'    NOTE:       noise in the data is estimated as follows:
'                * for fitting without user-supplied  weights  all  points  are
'                  assumed to have same level of noise, which is estimated from
'                  the data
'                * for fitting with user-supplied weights we assume that  noise
'                  level in I-th point is inversely proportional to Ith weight.
'                  Coefficient of proportionality is estimated from the data.
'
'    NOTE:       we apply small amount of regularization when we invert squared
'                Jacobian and calculate covariance matrix. It  guarantees  that
'                algorithm won't divide by zero  during  inversion,  but  skews
'                error estimates a bit (fractional error is about 10^-9).
'
'                However, we believe that this difference is insignificant  for
'                all practical purposes except for the situation when you  want
'                to compare ALGLIB results with "reference"  implementation  up
'                to the last significant digit.
'
'    NOTE:       covariance matrix is estimated using  correction  for  degrees
'                of freedom (covariances are divided by N-M instead of dividing
'                by N).
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitlinear(y As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, ByRef c As Double(), _
		ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit.lsfitlinear(y, fmatrix, n, m, info, c, _
			rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_lsfitlinear(y As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, ByRef c As Double(), _
		ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit._pexec_lsfitlinear(y, fmatrix, n, m, info, c, _
			rep.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitlinear(y As Double(), fmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		If (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		lsfit.lsfitlinear(y, fmatrix, n, m, info, c, _
			rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_lsfitlinear(y As Double(), fmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		If (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		lsfit._pexec_lsfitlinear(y, fmatrix, n, m, info, c, _
			rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Constained linear least squares fitting.
'
'    This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
'    that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'    task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
'    is called.
'
'    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'               convenient to use PolynomialFit() function. This function gives
'               best  results  on  polynomial  problems  and  solves  numerical
'               stability  issues  which  arise  when   you   fit   high-degree
'               polynomials to your data.
'
'    COMMERCIAL EDITION OF ALGLIB:
'
'      ! Commercial version of ALGLIB includes two  important  improvements  of
'      ! this function, which can be used from C++ and C#:
'      ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'      ! * multithreading support
'      !
'      ! Intel MKL gives approximately constant  (with  respect  to  number  of
'      ! worker threads) acceleration factor which depends on CPU  being  used,
'      ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'      ! comparison.
'      !
'      ! Speed-up provided by multithreading greatly depends  on  problem  size
'      ! - only large problems (number of coefficients is more than 500) can be
'      ! efficiently multithreaded.
'      !
'      ! Generally, commercial ALGLIB is several times faster than  open-source
'      ! generic C edition, and many times faster than open-source C# edition.
'      !
'      ! We recommend you to read 'Working with commercial version' section  of
'      ! ALGLIB Reference Manual in order to find out how to  use  performance-
'      ! related features provided by commercial edition of ALGLIB.
'
'    INPUT PARAMETERS:
'        Y       -   array[0..N-1] Function values in  N  points.
'        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                    FMatrix[I,J] - value of J-th basis function in I-th point.
'        CMatrix -   a table of constaints, array[0..K-1,0..M].
'                    I-th row of CMatrix corresponds to I-th linear constraint:
'                    CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'        N       -   number of points used. N>=1.
'        M       -   number of basis functions, M>=1.
'        K       -   number of constraints, 0 <= K < M
'                    K=0 corresponds to absence of constraints.
'
'    OUTPUT PARAMETERS:
'        Info    -   error code:
'                    * -4    internal SVD decomposition subroutine failed (very
'                            rare and for degenerate systems only)
'                    * -3    either   too   many  constraints  (M   or   more),
'                            degenerate  constraints   (some   constraints  are
'                            repetead twice) or inconsistent  constraints  were
'                            specified.
'                    *  1    task is solved
'        C       -   decomposition coefficients, array[0..M-1]
'        Rep     -   fitting report. Following fields are set:
'                    * R2                non-adjusted coefficient of determination
'                                        (non-weighted)
'                    * RMSError          rms error on the (X,Y).
'                    * AvgError          average error on the (X,Y).
'                    * AvgRelError       average relative error on the non-zero Y
'                    * MaxError          maximum error
'                                        NON-WEIGHTED ERRORS ARE CALCULATED
'
'    IMPORTANT:
'        this subroitine doesn't calculate task's condition number for K<>0.
'
'    ERRORS IN PARAMETERS
'
'    This  solver  also  calculates different kinds of errors in parameters and
'    fills corresponding fields of report:
'    * Rep.CovPar        covariance matrix for parameters, array[K,K].
'    * Rep.ErrPar        errors in parameters, array[K],
'                        errpar = sqrt(diag(CovPar))
'    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                        best-fit curve from "ideal" best-fit curve built  with
'                        infinite number of samples, array[N].
'                        errcurve = sqrt(diag(F*CovPar*F')),
'                        where F is functions matrix.
'    * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                account boundary/linear constraints! Presence  of  constraints
'                changes distribution of errors, but there is no  easy  way  to
'                account for constraints when you calculate covariance matrix.
'
'    NOTE:       noise in the data is estimated as follows:
'                * for fitting without user-supplied  weights  all  points  are
'                  assumed to have same level of noise, which is estimated from
'                  the data
'                * for fitting with user-supplied weights we assume that  noise
'                  level in I-th point is inversely proportional to Ith weight.
'                  Coefficient of proportionality is estimated from the data.
'
'    NOTE:       we apply small amount of regularization when we invert squared
'                Jacobian and calculate covariance matrix. It  guarantees  that
'                algorithm won't divide by zero  during  inversion,  but  skews
'                error estimates a bit (fractional error is about 10^-9).
'
'                However, we believe that this difference is insignificant  for
'                all practical purposes except for the situation when you  want
'                to compare ALGLIB results with "reference"  implementation  up
'                to the last significant digit.
'
'    NOTE:       covariance matrix is estimated using  correction  for  degrees
'                of freedom (covariances are divided by N-M instead of dividing
'                by N).
'
'      -- ALGLIB --
'         Copyright 07.09.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, k As Integer, _
		ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, _
			info, c, rep.innerobj)
		Return
	End Sub


	Public Shared Sub smp_lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, k As Integer, _
		ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit._pexec_lsfitlinearc(y, fmatrix, cmatrix, n, m, k, _
			info, c, rep.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
		End If
		If (ap.cols(fmatrix) <> ap.cols(cmatrix) - 1) Then
			Throw New alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		k = ap.rows(cmatrix)
		lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, _
			info, c, rep.innerobj)

		Return
	End Sub


	Public Shared Sub smp_lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.len(y) <> ap.rows(fmatrix)) Then
			Throw New alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
		End If
		If (ap.cols(fmatrix) <> ap.cols(cmatrix) - 1) Then
			Throw New alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
		End If
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		n = ap.len(y)
		m = ap.cols(fmatrix)
		k = ap.rows(cmatrix)
		lsfit._pexec_lsfitlinearc(y, fmatrix, cmatrix, n, m, k, _
			info, c, rep.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted nonlinear least squares fitting using function values only.
'
'    Combination of numerical differentiation and secant updates is used to
'    obtain function Jacobian.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * w is an N-dimensional vector of weight coefficients,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses only f(c,x[i]).
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        W       -   weights, array[0..N-1]
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'        DiffStep-   numerical differentiation step;
'                    should not be very small or large;
'                    large = loss of accuracy
'                    small = growth of round-off errors
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'      -- ALGLIB --
'         Copyright 18.10.2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatewf(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
		k As Integer, diffstep As Double, ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatewf(x, y, w, c, n, m, _
			k, diffstep, state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatewf(x As Double(,), y As Double(), w As Double(), c As Double(), diffstep As Double, ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) OrElse (ap.rows(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatewf(x, y, w, c, n, m, _
			k, diffstep, state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Nonlinear least squares fitting using function values only.
'
'    Combination of numerical differentiation and secant updates is used to
'    obtain function Jacobian.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * w is an N-dimensional vector of weight coefficients,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses only f(c,x[i]).
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'        DiffStep-   numerical differentiation step;
'                    should not be very small or large;
'                    large = loss of accuracy
'                    small = growth of round-off errors
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'      -- ALGLIB --
'         Copyright 18.10.2008 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatef(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
		diffstep As Double, ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatef(x, y, c, n, m, k, _
			diffstep, state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatef(x As Double(,), y As Double(), c As Double(), diffstep As Double, ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatef(x, y, c, n, m, k, _
			diffstep, state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted nonlinear least squares fitting using gradient only.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * w is an N-dimensional vector of weight coefficients,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses only f(c,x[i]) and its gradient.
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        W       -   weights, array[0..N-1]
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'        CheapFG -   boolean flag, which is:
'                    * True  if both function and gradient calculation complexity
'                            are less than O(M^2).  An improved  algorithm  can
'                            be  used  which corresponds  to  FGJ  scheme  from
'                            MINLM unit.
'                    * False otherwise.
'                            Standard Jacibian-bases  Levenberg-Marquardt  algo
'                            will be used (FJ scheme).
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'    See also:
'        LSFitResults
'        LSFitCreateFG (fitting without weights)
'        LSFitCreateWFGH (fitting using Hessian)
'        LSFitCreateFGH (fitting using Hessian, without weights)
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatewfg(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
		k As Integer, cheapfg As Boolean, ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatewfg(x, y, w, c, n, m, _
			k, cheapfg, state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatewfg(x As Double(,), y As Double(), w As Double(), c As Double(), cheapfg As Boolean, ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) OrElse (ap.rows(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatewfg(x, y, w, c, n, m, _
			k, cheapfg, state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Nonlinear least squares fitting using gradient only, without individual
'    weights.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses only f(c,x[i]) and its gradient.
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'        CheapFG -   boolean flag, which is:
'                    * True  if both function and gradient calculation complexity
'                            are less than O(M^2).  An improved  algorithm  can
'                            be  used  which corresponds  to  FGJ  scheme  from
'                            MINLM unit.
'                    * False otherwise.
'                            Standard Jacibian-bases  Levenberg-Marquardt  algo
'                            will be used (FJ scheme).
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatefg(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
		cheapfg As Boolean, ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatefg(x, y, c, n, m, k, _
			cheapfg, state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatefg(x As Double(,), y As Double(), c As Double(), cheapfg As Boolean, ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatefg(x, y, c, n, m, k, _
			cheapfg, state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Weighted nonlinear least squares fitting using gradient/Hessian.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * w is an N-dimensional vector of weight coefficients,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses f(c,x[i]), its gradient and its Hessian.
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        W       -   weights, array[0..N-1]
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatewfgh(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
		k As Integer, ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatewfgh(x, y, w, c, n, m, _
			k, state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatewfgh(x As Double(,), y As Double(), w As Double(), c As Double(), ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) OrElse (ap.rows(x) <> ap.len(w)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatewfgh(x, y, w, c, n, m, _
			k, state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Nonlinear least squares fitting using gradient/Hessian, without individial
'    weights.
'
'    Nonlinear task min(F(c)) is solved, where
'
'        F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
'
'        * N is a number of points,
'        * M is a dimension of a space points belong to,
'        * K is a dimension of a space of parameters being fitted,
'        * x is a set of N points, each of them is an M-dimensional vector,
'        * c is a K-dimensional vector of parameters being fitted
'
'    This subroutine uses f(c,x[i]), its gradient and its Hessian.
'
'    INPUT PARAMETERS:
'        X       -   array[0..N-1,0..M-1], points (one row = one point)
'        Y       -   array[0..N-1], function values.
'        C       -   array[0..K-1], initial approximation to the solution,
'        N       -   number of points, N>1
'        M       -   dimension of space
'        K       -   number of parameters being fitted
'
'    OUTPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitcreatefgh(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
		ByRef state As lsfitstate)
		state = New lsfitstate()
		lsfit.lsfitcreatefgh(x, y, c, n, m, k, _
			state.innerobj)
		Return
	End Sub
	Public Shared Sub lsfitcreatefgh(x As Double(,), y As Double(), c As Double(), ByRef state As lsfitstate)
		Dim n As Integer
		Dim m As Integer
		Dim k As Integer
		If (ap.rows(x) <> ap.len(y)) Then
			Throw New alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size")
		End If
		state = New lsfitstate()
		n = ap.rows(x)
		m = ap.cols(x)
		k = ap.len(c)
		lsfit.lsfitcreatefgh(x, y, c, n, m, k, _
			state.innerobj)

		Return
	End Sub

	'************************************************************************
'    Stopping conditions for nonlinear least squares fitting.
'
'    INPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'        EpsF    -   stopping criterion. Algorithm stops if
'                    |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}
'        EpsX    -   >=0
'                    The subroutine finishes its work if  on  k+1-th  iteration
'                    the condition |v|<=EpsX is fulfilled, where:
'                    * |.| means Euclidian norm
'                    * v - scaled step vector, v[i]=dx[i]/s[i]
'                    * dx - ste pvector, dx=X(k+1)-X(k)
'                    * s - scaling coefficients set by LSFitSetScale()
'        MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                    iterations   is    unlimited.   Only   Levenberg-Marquardt
'                    iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
'                    counted because their cost is very low compared to that of
'                    LM).
'
'    NOTE
'
'    Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
'    stopping criterion selection (according to the scheme used by MINLM unit).
'
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetcond(state As lsfitstate, epsf As Double, epsx As Double, maxits As Integer)

		lsfit.lsfitsetcond(state.innerobj, epsf, epsx, maxits)
		Return
	End Sub

	'************************************************************************
'    This function sets maximum step length
'
'    INPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'        StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                    want to limit step length.
'
'    Use this subroutine when you optimize target function which contains exp()
'    or  other  fast  growing  functions,  and optimization algorithm makes too
'    large  steps  which  leads  to overflow. This function allows us to reject
'    steps  that  are  too  large  (and  therefore  expose  us  to the possible
'    overflow) without actually calculating function value at the x+stp*d.
'
'    NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'    intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'    with limits on step size.
'
'      -- ALGLIB --
'         Copyright 02.04.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetstpmax(state As lsfitstate, stpmax As Double)

		lsfit.lsfitsetstpmax(state.innerobj, stpmax)
		Return
	End Sub

	'************************************************************************
'    This function turns on/off reporting.
'
'    INPUT PARAMETERS:
'        State   -   structure which stores algorithm state
'        NeedXRep-   whether iteration reports are needed or not
'
'    When reports are needed, State.C (current parameters) and State.F (current
'    value of fitting function) are reported.
'
'
'      -- ALGLIB --
'         Copyright 15.08.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetxrep(state As lsfitstate, needxrep As Boolean)

		lsfit.lsfitsetxrep(state.innerobj, needxrep)
		Return
	End Sub

	'************************************************************************
'    This function sets scaling coefficients for underlying optimizer.
'
'    ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
'    size and gradient are scaled before comparison with tolerances).  Scale of
'    the I-th variable is a translation invariant measure of:
'    a) "how large" the variable is
'    b) how large the step should be to make significant changes in the function
'
'    Generally, scale is NOT considered to be a form of preconditioner.  But LM
'    optimizer is unique in that it uses scaling matrix both  in  the  stopping
'    condition tests and as Marquardt damping factor.
'
'    Proper scaling is very important for the algorithm performance. It is less
'    important for the quality of results, but still has some influence (it  is
'    easier  to  converge  when  variables  are  properly  scaled, so premature
'    stopping is possible when very badly scalled variables are  combined  with
'    relaxed stopping conditions).
'
'    INPUT PARAMETERS:
'        State   -   structure stores algorithm state
'        S       -   array[N], non-zero scaling coefficients
'                    S[i] may be negative, sign doesn't matter.
'
'      -- ALGLIB --
'         Copyright 14.01.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetscale(state As lsfitstate, s As Double())

		lsfit.lsfitsetscale(state.innerobj, s)
		Return
	End Sub

	'************************************************************************
'    This function sets boundary constraints for underlying optimizer
'
'    Boundary constraints are inactive by default (after initial creation).
'    They are preserved until explicitly turned off with another SetBC() call.
'
'    INPUT PARAMETERS:
'        State   -   structure stores algorithm state
'        BndL    -   lower bounds, array[K].
'                    If some (all) variables are unbounded, you may specify
'                    very small number or -INF (latter is recommended because
'                    it will allow solver to use better algorithm).
'        BndU    -   upper bounds, array[K].
'                    If some (all) variables are unbounded, you may specify
'                    very large number or +INF (latter is recommended because
'                    it will allow solver to use better algorithm).
'
'    NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
'    variable will be "frozen" at X[i]=BndL[i]=BndU[i].
'
'    NOTE 2: unlike other constrained optimization algorithms, this solver  has
'    following useful properties:
'    * bound constraints are always satisfied exactly
'    * function is evaluated only INSIDE area specified by bound constraints
'
'      -- ALGLIB --
'         Copyright 14.01.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetbc(state As lsfitstate, bndl As Double(), bndu As Double())

		lsfit.lsfitsetbc(state.innerobj, bndl, bndu)
		Return
	End Sub

	'************************************************************************
'    This function provides reverse communication interface
'    Reverse communication interface is not documented or recommended to use.
'    See below for functions which provide better documented API
'    ************************************************************************

	Public Shared Function lsfititeration(state As lsfitstate) As Boolean

		Dim result As Boolean = lsfit.lsfititeration(state.innerobj)
		Return result
	End Function
	'************************************************************************
'    This family of functions is used to launcn iterations of nonlinear fitter
'
'    These functions accept following parameters:
'        func    -   callback which calculates function (or merit function)
'                    value func at given point x
'        grad    -   callback which calculates function (or merit function)
'                    value func and gradient grad at given point x
'        hess    -   callback which calculates function (or merit function)
'                    value func, gradient grad and Hessian hess at given point x
'        rep     -   optional callback which is called after each iteration
'                    can be null
'        obj     -   optional object which is passed to func/grad/hess/jac/rep
'                    can be null
'
'    NOTES:
'
'    1. this algorithm is somewhat unusual because it works with  parameterized
'       function f(C,X), where X is a function argument (we  have  many  points
'       which are characterized by different  argument  values),  and  C  is  a
'       parameter to fit.
'
'       For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
'       x will be argument, and {c0,c1} will be parameters.
'
'       It is important to understand that this algorithm finds minimum in  the
'       space of function PARAMETERS (not arguments), so it  needs  derivatives
'       of f() with respect to C, not X.
'
'       In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
'       instead of {df/dx} = {c0}.
'
'    2. Callback functions accept C as the first parameter, and X as the second
'
'    3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
'       function   and   its   gradient,   but   if   state   was  created with
'       LSFitCreateFGH(), algorithm will need function, gradient and Hessian.
'
'       According  to  the  said  above,  there  ase  several  versions of this
'       function, which accept different sets of callbacks.
'
'       This flexibility opens way to subtle errors - you may create state with
'       LSFitCreateFGH() (optimization using Hessian), but call function  which
'       does not accept Hessian. So when algorithm will request Hessian,  there
'       will be no callback to call. In this case exception will be thrown.
'
'       Be careful to avoid such errors because there is no way to find them at
'       compile time - you can see them at runtime only.
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'
'    ************************************************************************

	Public Shared Sub lsfitfit(state As lsfitstate, func As ndimensional_pfunc, rep As ndimensional_rep, obj As Object)
		If func Is Nothing Then
			Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)")
		End If
		While alglib.lsfititeration(state)
			If state.needf Then
				func(state.c, state.x, state.innerobj.f, obj)
				Continue While
			End If
			If state.innerobj.xupdated Then
                Call rep(state.innerobj.c, state.innerobj.f, obj)
                Continue While
            End If
            Throw New alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
        End While
    End Sub


    Public Shared Sub lsfitfit(state As lsfitstate, func As ndimensional_pfunc, grad As ndimensional_pgrad, rep As ndimensional_rep, obj As Object)
        If func Is Nothing Then
            Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)")
        End If
        If grad Is Nothing Then
            Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)")
        End If
        While alglib.lsfititeration(state)
            If state.needf Then
                func(state.c, state.x, state.innerobj.f, obj)
                Continue While
            End If
            If state.needfg Then
                grad(state.c, state.x, state.innerobj.f, state.innerobj.g, obj)
                Continue While
            End If
            If state.innerobj.xupdated Then
                Call rep(state.innerobj.c, state.innerobj.f, obj)
                Continue While
            End If
            Throw New alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
        End While
    End Sub


    Public Shared Sub lsfitfit(state As lsfitstate, func As ndimensional_pfunc, grad As ndimensional_pgrad, hess As ndimensional_phess, rep As ndimensional_rep, obj As Object)
        If func Is Nothing Then
            Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)")
        End If
        If grad Is Nothing Then
            Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)")
        End If
        If hess Is Nothing Then
            Throw New alglibexception("ALGLIB: error in 'lsfitfit()' (hess is null)")
        End If
        While alglib.lsfititeration(state)
            If state.needf Then
                func(state.c, state.x, state.innerobj.f, obj)
                Continue While
            End If
            If state.needfg Then
                grad(state.c, state.x, state.innerobj.f, state.innerobj.g, obj)
                Continue While
            End If
            If state.needfgh Then
                hess(state.c, state.x, state.innerobj.f, state.innerobj.g, state.innerobj.h, obj)
                Continue While
            End If
            If state.innerobj.xupdated Then
                Call rep(state.innerobj.c, state.innerobj.f, obj)
                Continue While
            End If
            Throw New alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
        End While
    End Sub



	'************************************************************************
'    Nonlinear least squares fitting results.
'
'    Called after return from LSFitFit().
'
'    INPUT PARAMETERS:
'        State   -   algorithm state
'
'    OUTPUT PARAMETERS:
'        Info    -   completion code:
'                        * -7    gradient verification failed.
'                                See LSFitSetGradientCheck() for more information.
'                        *  1    relative function improvement is no more than
'                                EpsF.
'                        *  2    relative step is no more than EpsX.
'                        *  4    gradient norm is no more than EpsG
'                        *  5    MaxIts steps was taken
'                        *  7    stopping conditions are too stringent,
'                                further improvement is impossible
'        C       -   array[0..K-1], solution
'        Rep     -   optimization report. On success following fields are set:
'                    * R2                non-adjusted coefficient of determination
'                                        (non-weighted)
'                    * RMSError          rms error on the (X,Y).
'                    * AvgError          average error on the (X,Y).
'                    * AvgRelError       average relative error on the non-zero Y
'                    * MaxError          maximum error
'                                        NON-WEIGHTED ERRORS ARE CALCULATED
'                    * WRMSError         weighted rms error on the (X,Y).
'
'    ERRORS IN PARAMETERS
'
'    This  solver  also  calculates different kinds of errors in parameters and
'    fills corresponding fields of report:
'    * Rep.CovPar        covariance matrix for parameters, array[K,K].
'    * Rep.ErrPar        errors in parameters, array[K],
'                        errpar = sqrt(diag(CovPar))
'    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                        best-fit curve from "ideal" best-fit curve built  with
'                        infinite number of samples, array[N].
'                        errcurve = sqrt(diag(J*CovPar*J')),
'                        where J is Jacobian matrix.
'    * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                account boundary/linear constraints! Presence  of  constraints
'                changes distribution of errors, but there is no  easy  way  to
'                account for constraints when you calculate covariance matrix.
'
'    NOTE:       noise in the data is estimated as follows:
'                * for fitting without user-supplied  weights  all  points  are
'                  assumed to have same level of noise, which is estimated from
'                  the data
'                * for fitting with user-supplied weights we assume that  noise
'                  level in I-th point is inversely proportional to Ith weight.
'                  Coefficient of proportionality is estimated from the data.
'
'    NOTE:       we apply small amount of regularization when we invert squared
'                Jacobian and calculate covariance matrix. It  guarantees  that
'                algorithm won't divide by zero  during  inversion,  but  skews
'                error estimates a bit (fractional error is about 10^-9).
'
'                However, we believe that this difference is insignificant  for
'                all practical purposes except for the situation when you  want
'                to compare ALGLIB results with "reference"  implementation  up
'                to the last significant digit.
'
'    NOTE:       covariance matrix is estimated using  correction  for  degrees
'                of freedom (covariances are divided by N-M instead of dividing
'                by N).
'
'      -- ALGLIB --
'         Copyright 17.08.2009 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitresults(state As lsfitstate, ByRef info As Integer, ByRef c As Double(), ByRef rep As lsfitreport)
		info = 0
		c = New Double(-1) {}
		rep = New lsfitreport()
		lsfit.lsfitresults(state.innerobj, info, c, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  subroutine  turns  on  verification  of  the  user-supplied analytic
'    gradient:
'    * user calls this subroutine before fitting begins
'    * LSFitFit() is called
'    * prior to actual fitting, for  each  point  in  data  set  X_i  and  each
'      component  of  parameters  being  fited C_j algorithm performs following
'      steps:
'      * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
'        where C_j is j-th parameter and S[j] is a scale of j-th parameter
'      * if needed, steps are bounded with respect to constraints on C[]
'      * F(X_i|C) is evaluated at these trial points
'      * we perform one more evaluation in the middle point of the interval
'      * we  build  cubic  model using function values and derivatives at trial
'        points and we compare its prediction with actual value in  the  middle
'        point
'      * in case difference between prediction and actual value is higher  than
'        some predetermined threshold, algorithm stops with completion code -7;
'        Rep.VarIdx is set to index of the parameter with incorrect derivative.
'    * after verification is over, algorithm proceeds to the actual optimization.
'
'    NOTE 1: verification needs N*K (points count * parameters count)  gradient
'            evaluations. It is very costly and you should use it only for  low
'            dimensional  problems,  when  you  want  to  be  sure  that you've
'            correctly calculated analytic derivatives. You should not  use  it
'            in the production code  (unless  you  want  to  check  derivatives
'            provided by some third party).
'
'    NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
'            (so large that function behaviour is significantly non-cubic) will
'            lead to false alarms. You may use  different  step  for  different
'            parameters by means of setting scale with LSFitSetScale().
'
'    NOTE 3: this function may lead to false positives. In case it reports that
'            I-th  derivative was calculated incorrectly, you may decrease test
'            step  and  try  one  more  time  - maybe your function changes too
'            sharply  and  your  step  is  too  large for such rapidly chanding
'            function.
'
'    NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
'            or LSFitCreateFG() constructors.
'
'    INPUT PARAMETERS:
'        State       -   structure used to store algorithm state
'        TestStep    -   verification step:
'                        * TestStep=0 turns verification off
'                        * TestStep>0 activates verification
'
'      -- ALGLIB --
'         Copyright 15.06.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub lsfitsetgradientcheck(state As lsfitstate, teststep As Double)

		lsfit.lsfitsetgradientcheck(state.innerobj, teststep)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    Parametric spline inteprolant: 2-dimensional curve.
'
'    You should not try to access its members directly - use PSpline2XXXXXXXX()
'    functions instead.
'    ************************************************************************

	Public Class pspline2interpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New parametric.pspline2interpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New pspline2interpolant(DirectCast(_innerobj.make_copy(), parametric.pspline2interpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As parametric.pspline2interpolant
		Public ReadOnly Property innerobj() As parametric.pspline2interpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As parametric.pspline2interpolant)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    Parametric spline inteprolant: 3-dimensional curve.
'
'    You should not try to access its members directly - use PSpline3XXXXXXXX()
'    functions instead.
'    ************************************************************************

	Public Class pspline3interpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New parametric.pspline3interpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New pspline3interpolant(DirectCast(_innerobj.make_copy(), parametric.pspline3interpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As parametric.pspline3interpolant
		Public ReadOnly Property innerobj() As parametric.pspline3interpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As parametric.pspline3interpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This function  builds  non-periodic 2-dimensional parametric spline  which
'    starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
'
'    INPUT PARAMETERS:
'        XY  -   points, array[0..N-1,0..1].
'                XY[I,0:1] corresponds to the Ith point.
'                Order of points is important!
'        N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
'                splines.
'        ST  -   spline type:
'                * 0     Akima spline
'                * 1     parabolically terminated Catmull-Rom spline (Tension=0)
'                * 2     parabolically terminated cubic spline
'        PT  -   parameterization type:
'                * 0     uniform
'                * 1     chord length
'                * 2     centripetal
'
'    OUTPUT PARAMETERS:
'        P   -   parametric spline interpolant
'
'
'    NOTES:
'    * this function  assumes  that  there all consequent points  are distinct.
'      I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
'      However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'      =(x2,y2).
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2build(xy As Double(,), n As Integer, st As Integer, pt As Integer, ByRef p As pspline2interpolant)
		p = New pspline2interpolant()
		parametric.pspline2build(xy, n, st, pt, p.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function  builds  non-periodic 3-dimensional parametric spline  which
'    starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
'
'    Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'    description here.
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3build(xy As Double(,), n As Integer, st As Integer, pt As Integer, ByRef p As pspline3interpolant)
		p = New pspline3interpolant()
		parametric.pspline3build(xy, n, st, pt, p.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  builds  periodic  2-dimensional  parametric  spline  which
'    starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
'    back to (X[0],Y[0]).
'
'    INPUT PARAMETERS:
'        XY  -   points, array[0..N-1,0..1].
'                XY[I,0:1] corresponds to the Ith point.
'                XY[N-1,0:1] must be different from XY[0,0:1].
'                Order of points is important!
'        N   -   points count, N>=3 for other types of splines.
'        ST  -   spline type:
'                * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
'                * 2     cubic spline with cyclic boundary conditions
'        PT  -   parameterization type:
'                * 0     uniform
'                * 1     chord length
'                * 2     centripetal
'
'    OUTPUT PARAMETERS:
'        P   -   parametric spline interpolant
'
'
'    NOTES:
'    * this function  assumes  that there all consequent points  are  distinct.
'      I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
'      However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'      =(x2,y2).
'    * last point of sequence is NOT equal to the first  point.  You  shouldn't
'      make curve "explicitly periodic" by making them equal.
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2buildperiodic(xy As Double(,), n As Integer, st As Integer, pt As Integer, ByRef p As pspline2interpolant)
		p = New pspline2interpolant()
		parametric.pspline2buildperiodic(xy, n, st, pt, p.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  builds  periodic  3-dimensional  parametric  spline  which
'    starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
'    and then back to (X[0],Y[0],Z[0]).
'
'    Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'    description here.
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3buildperiodic(xy As Double(,), n As Integer, st As Integer, pt As Integer, ByRef p As pspline3interpolant)
		p = New pspline3interpolant()
		parametric.pspline3buildperiodic(xy, n, st, pt, p.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function returns vector of parameter values correspoding to points.
'
'    I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
'    have
'        (X[0],Y[0]) = PSpline2Calc(P,U[0]),
'        (X[1],Y[1]) = PSpline2Calc(P,U[1]),
'        (X[2],Y[2]) = PSpline2Calc(P,U[2]),
'        ...
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'
'    OUTPUT PARAMETERS:
'        N   -   array size
'        T   -   array[0..N-1]
'
'
'    NOTES:
'    * for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
'    * for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2parametervalues(p As pspline2interpolant, ByRef n As Integer, ByRef t As Double())
		n = 0
		t = New Double(-1) {}
		parametric.pspline2parametervalues(p.innerobj, n, t)
		Return
	End Sub

	'************************************************************************
'    This function returns vector of parameter values correspoding to points.
'
'    Same as PSpline2ParameterValues(), but for 3D.
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3parametervalues(p As pspline3interpolant, ByRef n As Integer, ByRef t As Double())
		n = 0
		t = New Double(-1) {}
		parametric.pspline3parametervalues(p.innerobj, n, t)
		Return
	End Sub

	'************************************************************************
'    This function  calculates  the value of the parametric spline for a  given
'    value of parameter T
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-position
'        Y   -   Y-position
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2calc(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef y As Double)
		x = 0
		y = 0
		parametric.pspline2calc(p.innerobj, t, x, y)
		Return
	End Sub

	'************************************************************************
'    This function  calculates  the value of the parametric spline for a  given
'    value of parameter T.
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-position
'        Y   -   Y-position
'        Z   -   Z-position
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3calc(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef y As Double, ByRef z As Double)
		x = 0
		y = 0
		z = 0
		parametric.pspline3calc(p.innerobj, t, x, y, z)
		Return
	End Sub

	'************************************************************************
'    This function  calculates  tangent vector for a given value of parameter T
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X    -   X-component of tangent vector (normalized)
'        Y    -   Y-component of tangent vector (normalized)
'
'    NOTE:
'        X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2tangent(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef y As Double)
		x = 0
		y = 0
		parametric.pspline2tangent(p.innerobj, t, x, y)
		Return
	End Sub

	'************************************************************************
'    This function  calculates  tangent vector for a given value of parameter T
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X    -   X-component of tangent vector (normalized)
'        Y    -   Y-component of tangent vector (normalized)
'        Z    -   Z-component of tangent vector (normalized)
'
'    NOTE:
'        X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3tangent(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef y As Double, ByRef z As Double)
		x = 0
		y = 0
		z = 0
		parametric.pspline3tangent(p.innerobj, t, x, y, z)
		Return
	End Sub

	'************************************************************************
'    This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-value
'        DX  -   X-derivative
'        Y   -   Y-value
'        DY  -   Y-derivative
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2diff(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef y As Double, ByRef dy As Double)
		x = 0
		dx = 0
		y = 0
		dy = 0
		parametric.pspline2diff(p.innerobj, t, x, dx, y, dy)
		Return
	End Sub

	'************************************************************************
'    This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-value
'        DX  -   X-derivative
'        Y   -   Y-value
'        DY  -   Y-derivative
'        Z   -   Z-value
'        DZ  -   Z-derivative
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3diff(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef y As Double, ByRef dy As Double, _
		ByRef z As Double, ByRef dz As Double)
		x = 0
		dx = 0
		y = 0
		dy = 0
		z = 0
		dz = 0
		parametric.pspline3diff(p.innerobj, t, x, dx, y, dy, _
			z, dz)
		Return
	End Sub

	'************************************************************************
'    This function calculates first and second derivative with respect to T.
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-value
'        DX  -   derivative
'        D2X -   second derivative
'        Y   -   Y-value
'        DY  -   derivative
'        D2Y -   second derivative
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline2diff2(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef d2x As Double, ByRef y As Double, _
		ByRef dy As Double, ByRef d2y As Double)
		x = 0
		dx = 0
		d2x = 0
		y = 0
		dy = 0
		d2y = 0
		parametric.pspline2diff2(p.innerobj, t, x, dx, d2x, y, _
			dy, d2y)
		Return
	End Sub

	'************************************************************************
'    This function calculates first and second derivative with respect to T.
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        T   -   point:
'                * T in [0,1] corresponds to interval spanned by points
'                * for non-periodic splines T<0 (or T>1) correspond to parts of
'                  the curve before the first (after the last) point
'                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                  by making T=T-floor(T).
'
'    OUTPUT PARAMETERS:
'        X   -   X-value
'        DX  -   derivative
'        D2X -   second derivative
'        Y   -   Y-value
'        DY  -   derivative
'        D2Y -   second derivative
'        Z   -   Z-value
'        DZ  -   derivative
'        D2Z -   second derivative
'
'
'      -- ALGLIB PROJECT --
'         Copyright 28.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub pspline3diff2(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef d2x As Double, ByRef y As Double, _
		ByRef dy As Double, ByRef d2y As Double, ByRef z As Double, ByRef dz As Double, ByRef d2z As Double)
		x = 0
		dx = 0
		d2x = 0
		y = 0
		dy = 0
		d2y = 0
		z = 0
		dz = 0
		d2z = 0
		parametric.pspline3diff2(p.innerobj, t, x, dx, d2x, y, _
			dy, d2y, z, dz, d2z)
		Return
	End Sub

	'************************************************************************
'    This function  calculates  arc length, i.e. length of  curve  between  t=a
'    and t=b.
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        A,B -   parameter values corresponding to arc ends:
'                * B>A will result in positive length returned
'                * B<A will result in negative length returned
'
'    RESULT:
'        length of arc starting at T=A and ending at T=B.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 30.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function pspline2arclength(p As pspline2interpolant, a As Double, b As Double) As Double

		Dim result As Double = parametric.pspline2arclength(p.innerobj, a, b)
		Return result
	End Function

	'************************************************************************
'    This function  calculates  arc length, i.e. length of  curve  between  t=a
'    and t=b.
'
'    INPUT PARAMETERS:
'        P   -   parametric spline interpolant
'        A,B -   parameter values corresponding to arc ends:
'                * B>A will result in positive length returned
'                * B<A will result in negative length returned
'
'    RESULT:
'        length of arc starting at T=A and ending at T=B.
'
'
'      -- ALGLIB PROJECT --
'         Copyright 30.05.2010 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function pspline3arclength(p As pspline3interpolant, a As Double, b As Double) As Double

		Dim result As Double = parametric.pspline3arclength(p.innerobj, a, b)
		Return result
	End Function

	'************************************************************************
'    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'    Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
'    used to fit curves like circles.
'
'    On  input  it  accepts dataset which describes parametric multidimensional
'    curve X(t), with X being vector, and t taking values in [0,N), where N  is
'    a number of points in dataset. As result, it returns reduced  dataset  X2,
'    which can be used to build  parametric  curve  X2(t),  which  approximates
'    X(t) with desired precision (or has specified number of sections).
'
'
'    INPUT PARAMETERS:
'        X       -   array of multidimensional points:
'                    * at least N elements, leading N elements are used if more
'                      than N elements were specified
'                    * order of points is IMPORTANT because  it  is  parametric
'                      fit
'                    * each row of array is one point which has D coordinates
'        N       -   number of elements in X
'        D       -   number of dimensions (elements per row of X)
'        StopM   -   stopping condition - desired number of sections:
'                    * at most M sections are generated by this function
'                    * less than M sections can be generated if we have N<M
'                      (or some X are non-distinct).
'                    * zero StopM means that algorithm does not stop after
'                      achieving some pre-specified section count
'        StopEps -   stopping condition - desired precision:
'                    * algorithm stops after error in each section is at most Eps
'                    * zero Eps means that algorithm does not stop after
'                      achieving some pre-specified precision
'
'    OUTPUT PARAMETERS:
'        X2      -   array of corner points for piecewise approximation,
'                    has length NSections+1 or zero (for NSections=0).
'        Idx2    -   array of indexes (parameter values):
'                    * has length NSections+1 or zero (for NSections=0).
'                    * each element of Idx2 corresponds to same-numbered
'                      element of X2
'                    * each element of Idx2 is index of  corresponding  element
'                      of X2 at original array X, i.e. I-th  row  of  X2  is
'                      Idx2[I]-th row of X.
'                    * elements of Idx2 can be treated as parameter values
'                      which should be used when building new parametric curve
'                    * Idx2[0]=0, Idx2[NSections]=N-1
'        NSections-  number of sections found by algorithm, NSections<=M,
'                    NSections can be zero for degenerate datasets
'                    (N<=1 or all X[] are non-distinct).
'
'    NOTE: algorithm stops after:
'          a) dividing curve into StopM sections
'          b) achieving required precision StopEps
'          c) dividing curve into N-1 sections
'          If both StopM and StopEps are non-zero, algorithm is stopped by  the
'          FIRST criterion which is satisfied. In case both StopM  and  StopEps
'          are zero, algorithm stops because of (c).
'
'      -- ALGLIB --
'         Copyright 02.10.2014 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub parametricrdpfixed(x As Double(,), n As Integer, d As Integer, stopm As Integer, stopeps As Double, ByRef x2 As Double(,), _
		ByRef idx2 As Integer(), ByRef nsections As Integer)
		x2 = New Double(-1, -1) {}
		idx2 = New Integer(-1) {}
		nsections = 0
		parametric.parametricrdpfixed(x, n, d, stopm, stopeps, x2, _
			idx2, nsections)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    RBF model.
'
'    Never try to directly work with fields of this object - always use  ALGLIB
'    functions to use this object.
'    ************************************************************************

	Public Class rbfmodel
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New rbf.rbfmodel()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New rbfmodel(DirectCast(_innerobj.make_copy(), rbf.rbfmodel))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As rbf.rbfmodel
		Public ReadOnly Property innerobj() As rbf.rbfmodel
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As rbf.rbfmodel)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    RBF solution report:
'    * TerminationType   -   termination type, positive values - success,
'                            non-positive - failure.
'    ************************************************************************

	Public Class rbfreport
		Inherits alglibobject
		'
		' Public declarations
		'
		Public Property arows() As Integer
			Get
				Return _innerobj.arows
			End Get
			Set
				_innerobj.arows = value
			End Set
		End Property
		Public Property acols() As Integer
			Get
				Return _innerobj.acols
			End Get
			Set
				_innerobj.acols = value
			End Set
		End Property
		Public Property annz() As Integer
			Get
				Return _innerobj.annz
			End Get
			Set
				_innerobj.annz = value
			End Set
		End Property
		Public Property iterationscount() As Integer
			Get
				Return _innerobj.iterationscount
			End Get
			Set
				_innerobj.iterationscount = value
			End Set
		End Property
		Public Property nmv() As Integer
			Get
				Return _innerobj.nmv
			End Get
			Set
				_innerobj.nmv = value
			End Set
		End Property
		Public Property terminationtype() As Integer
			Get
				Return _innerobj.terminationtype
			End Get
			Set
				_innerobj.terminationtype = value
			End Set
		End Property

		Public Sub New()
			_innerobj = New rbf.rbfreport()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New rbfreport(DirectCast(_innerobj.make_copy(), rbf.rbfreport))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As rbf.rbfreport
		Public ReadOnly Property innerobj() As rbf.rbfreport
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As rbf.rbfreport)
			_innerobj = obj
		End Sub
	End Class


	'************************************************************************
'    This function serializes data structure to string.
'
'    Important properties of s_out:
'    * it contains alphanumeric characters, dots, underscores, minus signs
'    * these symbols are grouped into words, which are separated by spaces
'      and Windows-style (CR+LF) newlines
'    * although  serializer  uses  spaces and CR+LF as separators, you can 
'      replace any separator character by arbitrary combination of spaces,
'      tabs, Windows or Unix newlines. It allows flexible reformatting  of
'      the  string  in  case you want to include it into text or XML file. 
'      But you should not insert separators into the middle of the "words"
'      nor you should change case of letters.
'    * s_out can be freely moved between 32-bit and 64-bit systems, little
'      and big endian machines, and so on. You can serialize structure  on
'      32-bit machine and unserialize it on 64-bit one (or vice versa), or
'      serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
'      serialize  it  in  C# version of ALGLIB and unserialize in C++ one, 
'      and vice versa.
'    ************************************************************************

	Public Shared Sub rbfserialize(obj As rbfmodel, ByRef s_out As String)
		Dim s As New alglib.serializer()
		s.alloc_start()
		rbf.rbfalloc(s, obj.innerobj)
		s.sstart_str()
		rbf.rbfserialize(s, obj.innerobj)
		s.[stop]()
		s_out = s.get_string()
	End Sub


	'************************************************************************
'    This function unserializes data structure from string.
'    ************************************************************************

	Public Shared Sub rbfunserialize(s_in As String, ByRef obj As rbfmodel)
		Dim s As New alglib.serializer()
		obj = New rbfmodel()
		s.ustart_str(s_in)
		rbf.rbfunserialize(s, obj.innerobj)
		s.[stop]()
	End Sub

	'************************************************************************
'    This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
'    function in a NX-dimensional space (NX=2 or NX=3).
'
'    Newly created model is empty. It can be used for interpolation right after
'    creation, but it just returns zeros. You have to add points to the  model,
'    tune interpolation settings, and then  call  model  construction  function
'    RBFBuildModel() which will update model according to your specification.
'
'    USAGE:
'    1. User creates model with RBFCreate()
'    2. User adds dataset with RBFSetPoints() (points do NOT have to  be  on  a
'       regular grid)
'    3. (OPTIONAL) User chooses polynomial term by calling:
'       * RBFLinTerm() to set linear term
'       * RBFConstTerm() to set constant term
'       * RBFZeroTerm() to set zero term
'       By default, linear term is used.
'    4. User chooses specific RBF algorithm to use: either QNN (RBFSetAlgoQNN)
'       or ML (RBFSetAlgoMultiLayer).
'    5. User calls RBFBuildModel() function which rebuilds model  according  to
'       the specification
'    6. User may call RBFCalc() to calculate model value at the specified point,
'       RBFGridCalc() to  calculate   model  values at the points of the regular
'       grid. User may extract model coefficients with RBFUnpack() call.
'
'    INPUT PARAMETERS:
'        NX      -   dimension of the space, NX=2 or NX=3
'        NY      -   function dimension, NY>=1
'
'    OUTPUT PARAMETERS:
'        S       -   RBF model (initially equals to zero)
'
'    NOTE 1: memory requirements. RBF models require amount of memory  which is
'            proportional  to  the  number  of data points. Memory is allocated
'            during model construction, but most of this memory is freed  after
'            model coefficients are calculated.
'
'            Some approximate estimates for N centers with default settings are
'            given below:
'            * about 250*N*(sizeof(double)+2*sizeof(int)) bytes  of  memory  is
'              needed during model construction stage.
'            * about 15*N*sizeof(double) bytes is needed after model is built.
'            For example, for N=100000 we may need 0.6 GB of memory  to  build
'            model, but just about 0.012 GB to store it.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfcreate(nx As Integer, ny As Integer, ByRef s As rbfmodel)
		s = New rbfmodel()
		rbf.rbfcreate(nx, ny, s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function adds dataset.
'
'    This function overrides results of the previous calls, i.e. multiple calls
'    of this function will result in only the last set being added.
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call.
'        XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
'                    in the dataset. First NX elements  are  coordinates,  next
'                    NY elements are function values. Array may  be larger than
'                    specific,  in  this  case  only leading [N,NX+NY] elements
'                    will be used.
'        N       -   number of points in the dataset
'
'    After you've added dataset and (optionally) tuned algorithm  settings  you
'    should call RBFBuildModel() in order to build a model for you.
'
'    NOTE: this   function  has   some   serialization-related  subtleties.  We
'          recommend you to study serialization examples from ALGLIB  Reference
'          Manual if you want to perform serialization of your models.
'
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetpoints(s As rbfmodel, xy As Double(,), n As Integer)

		rbf.rbfsetpoints(s.innerobj, xy, n)
		Return
	End Sub
	Public Shared Sub rbfsetpoints(s As rbfmodel, xy As Double(,))
		Dim n As Integer


		n = ap.rows(xy)
		rbf.rbfsetpoints(s.innerobj, xy, n)

		Return
	End Sub

	'************************************************************************
'    This  function  sets  RBF interpolation algorithm. ALGLIB supports several
'    RBF algorithms with different properties.
'
'    This algorithm is called RBF-QNN and  it  is  good  for  point  sets  with
'    following properties:
'    a) all points are distinct
'    b) all points are well separated.
'    c) points  distribution  is  approximately  uniform.  There is no "contour
'       lines", clusters of points, or other small-scale structures.
'
'    Algorithm description:
'    1) interpolation centers are allocated to data points
'    2) interpolation radii are calculated as distances to the  nearest centers
'       times Q coefficient (where Q is a value from [0.75,1.50]).
'    3) after  performing (2) radii are transformed in order to avoid situation
'       when single outlier has very large radius and  influences  many  points
'       across all dataset. Transformation has following form:
'           new_r[i] = min(r[i],Z*median(r[]))
'       where r[i] is I-th radius, median()  is a median  radius across  entire
'       dataset, Z is user-specified value which controls amount  of  deviation
'       from median radius.
'
'    When (a) is violated,  we  will  be unable to build RBF model. When (b) or
'    (c) are violated, model will be built, but interpolation quality  will  be
'    low. See http://www.alglib.net/interpolation/ for more information on this
'    subject.
'
'    This algorithm is used by default.
'
'    Additional Q parameter controls smoothness properties of the RBF basis:
'    * Q<0.75 will give perfectly conditioned basis,  but  terrible  smoothness
'      properties (RBF interpolant will have sharp peaks around function values)
'    * Q around 1.0 gives good balance between smoothness and condition number
'    * Q>1.5 will lead to badly conditioned systems and slow convergence of the
'      underlying linear solver (although smoothness will be very good)
'    * Q>2.0 will effectively make optimizer useless because it won't  converge
'      within reasonable amount of iterations. It is possible to set such large
'      Q, but it is advised not to do so.
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'        Q       -   Q parameter, Q>0, recommended value - 1.0
'        Z       -   Z parameter, Z>0, recommended value - 5.0
'
'    NOTE: this   function  has   some   serialization-related  subtleties.  We
'          recommend you to study serialization examples from ALGLIB  Reference
'          Manual if you want to perform serialization of your models.
'
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetalgoqnn(s As rbfmodel, q As Double, z As Double)

		rbf.rbfsetalgoqnn(s.innerobj, q, z)
		Return
	End Sub
	Public Shared Sub rbfsetalgoqnn(s As rbfmodel)
		Dim q As Double
		Dim z As Double


		q = 1.0
		z = 5.0
		rbf.rbfsetalgoqnn(s.innerobj, q, z)

		Return
	End Sub

	'************************************************************************
'    This  function  sets  RBF interpolation algorithm. ALGLIB supports several
'    RBF algorithms with different properties.
'
'    This  algorithm is called RBF-ML. It builds  multilayer  RBF  model,  i.e.
'    model with subsequently decreasing  radii,  which  allows  us  to  combine
'    smoothness (due to  large radii of  the first layers) with  exactness (due
'    to small radii of the last layers) and fast convergence.
'
'    Internally RBF-ML uses many different  means  of acceleration, from sparse
'    matrices  to  KD-trees,  which  results in algorithm whose working time is
'    roughly proportional to N*log(N)*Density*RBase^2*NLayers,  where  N  is  a
'    number of points, Density is an average density if points per unit of  the
'    interpolation space, RBase is an initial radius, NLayers is  a  number  of
'    layers.
'
'    RBF-ML is good for following kinds of interpolation problems:
'    1. "exact" problems (perfect fit) with well separated points
'    2. least squares problems with arbitrary distribution of points (algorithm
'       gives  perfect  fit  where it is possible, and resorts to least squares
'       fit in the hard areas).
'    3. noisy problems where  we  want  to  apply  some  controlled  amount  of
'       smoothing.
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'        RBase   -   RBase parameter, RBase>0
'        NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
'                    with - about 5.
'        LambdaV -   regularization value, can be useful when  solving  problem
'                    in the least squares sense.  Optimal  lambda  is  problem-
'                    dependent and require trial and error. In our  experience,
'                    good lambda can be as large as 0.1, and you can use  0.001
'                    as initial guess.
'                    Default  value  - 0.01, which is used when LambdaV is  not
'                    given.  You  can  specify  zero  value,  but  it  is   not
'                    recommended to do so.
'
'    TUNING ALGORITHM
'
'    In order to use this algorithm you have to choose three parameters:
'    * initial radius RBase
'    * number of layers in the model NLayers
'    * regularization coefficient LambdaV
'
'    Initial radius is easy to choose - you can pick any number  several  times
'    larger  than  the  average  distance between points. Algorithm won't break
'    down if you choose radius which is too large (model construction time will
'    increase, but model will be built correctly).
'
'    Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
'    by  the  last  layer)  will  be  smaller than the typical distance between
'    points.  In  case  model  error  is  too large, you can increase number of
'    layers.  Having  more  layers  will make model construction and evaluation
'    proportionally slower, but it will allow you to have model which precisely
'    fits your data. From the other side, if you want to  suppress  noise,  you
'    can DECREASE number of layers to make your model less flexible.
'
'    Regularization coefficient LambdaV controls smoothness of  the  individual
'    models built for each layer. We recommend you to use default value in case
'    you don't want to tune this parameter,  because  having  non-zero  LambdaV
'    accelerates and stabilizes internal iterative algorithm. In case you  want
'    to suppress noise you can use  LambdaV  as  additional  parameter  (larger
'    value = more smoothness) to tune.
'
'    TYPICAL ERRORS
'
'    1. Using  initial  radius  which is too large. Memory requirements  of the
'       RBF-ML are roughly proportional to N*Density*RBase^2 (where Density  is
'       an average density of points per unit of the interpolation  space).  In
'       the extreme case of the very large RBase we will need O(N^2)  units  of
'       memory - and many layers in order to decrease radius to some reasonably
'       small value.
'
'    2. Using too small number of layers - RBF models with large radius are not
'       flexible enough to reproduce small variations in the  target  function.
'       You  need  many  layers  with  different radii, from large to small, in
'       order to have good model.
'
'    3. Using  initial  radius  which  is  too  small.  You will get model with
'       "holes" in the areas which are too far away from interpolation centers.
'       However, algorithm will work correctly (and quickly) in this case.
'
'    4. Using too many layers - you will get too large and too slow model. This
'       model  will  perfectly  reproduce  your function, but maybe you will be
'       able to achieve similar results with less layers (and less memory).
'
'      -- ALGLIB --
'         Copyright 02.03.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetalgomultilayer(s As rbfmodel, rbase As Double, nlayers As Integer, lambdav As Double)

		rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav)
		Return
	End Sub
	Public Shared Sub rbfsetalgomultilayer(s As rbfmodel, rbase As Double, nlayers As Integer)
		Dim lambdav As Double


		lambdav = 0.01
		rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav)

		Return
	End Sub

	'************************************************************************
'    This function sets linear term (model is a sum of radial  basis  functions
'    plus linear polynomial). This function won't have effect until  next  call
'    to RBFBuildModel().
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'
'    NOTE: this   function  has   some   serialization-related  subtleties.  We
'          recommend you to study serialization examples from ALGLIB  Reference
'          Manual if you want to perform serialization of your models.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetlinterm(s As rbfmodel)

		rbf.rbfsetlinterm(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function sets constant term (model is a sum of radial basis functions
'    plus constant).  This  function  won't  have  effect  until  next  call to
'    RBFBuildModel().
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'
'    NOTE: this   function  has   some   serialization-related  subtleties.  We
'          recommend you to study serialization examples from ALGLIB  Reference
'          Manual if you want to perform serialization of your models.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetconstterm(s As rbfmodel)

		rbf.rbfsetconstterm(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This  function  sets  zero  term (model is a sum of radial basis functions
'    without polynomial term). This function won't have effect until next  call
'    to RBFBuildModel().
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'
'    NOTE: this   function  has   some   serialization-related  subtleties.  We
'          recommend you to study serialization examples from ALGLIB  Reference
'          Manual if you want to perform serialization of your models.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfsetzeroterm(s As rbfmodel)

		rbf.rbfsetzeroterm(s.innerobj)
		Return
	End Sub

	'************************************************************************
'    This   function  builds  RBF  model  and  returns  report  (contains  some
'    information which can be used for evaluation of the algorithm properties).
'
'    Call to this function modifies RBF model by calculating its centers/radii/
'    weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel
'    contain zero coefficients, but after call to this function  we  will  have
'    coefficients which were calculated in order to fit our dataset.
'
'    After you called this function you can call RBFCalc(),  RBFGridCalc()  and
'    other model calculation functions.
'
'    INPUT PARAMETERS:
'        S       -   RBF model, initialized by RBFCreate() call
'        Rep     -   report:
'                    * Rep.TerminationType:
'                      * -5 - non-distinct basis function centers were detected,
'                             interpolation aborted
'                      * -4 - nonconvergence of the internal SVD solver
'                      *  1 - successful termination
'                    Fields are used for debugging purposes:
'                    * Rep.IterationsCount - iterations count of the LSQR solver
'                    * Rep.NMV - number of matrix-vector products
'                    * Rep.ARows - rows count for the system matrix
'                    * Rep.ACols - columns count for the system matrix
'                    * Rep.ANNZ - number of significantly non-zero elements
'                      (elements above some algorithm-determined threshold)
'
'    NOTE:  failure  to  build  model will leave current state of the structure
'    unchanged.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfbuildmodel(s As rbfmodel, ByRef rep As rbfreport)
		rep = New rbfreport()
		rbf.rbfbuildmodel(s.innerobj, rep.innerobj)
		Return
	End Sub

	'************************************************************************
'    This function calculates values of the RBF model in the given point.
'
'    This function should be used when we have NY=1 (scalar function) and  NX=2
'    (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
'    you have general situation (NX-dimensional space, NY-dimensional function)
'    you should use general, less efficient implementation RBFCalc().
'
'    If  you  want  to  calculate  function  values  many times, consider using
'    RBFGridCalc2(), which is far more efficient than many subsequent calls  to
'    RBFCalc2().
'
'    This function returns 0.0 when:
'    * model is not initialized
'    * NX<>2
'     *NY<>1
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'        X0      -   first coordinate, finite number
'        X1      -   second coordinate, finite number
'
'    RESULT:
'        value of the model or 0.0 (as defined above)
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function rbfcalc2(s As rbfmodel, x0 As Double, x1 As Double) As Double

		Dim result As Double = rbf.rbfcalc2(s.innerobj, x0, x1)
		Return result
	End Function

	'************************************************************************
'    This function calculates values of the RBF model in the given point.
'
'    This function should be used when we have NY=1 (scalar function) and  NX=3
'    (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
'    you have general situation (NX-dimensional space, NY-dimensional function)
'    you should use general, less efficient implementation RBFCalc().
'
'    This function returns 0.0 when:
'    * model is not initialized
'    * NX<>3
'     *NY<>1
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'        X0      -   first coordinate, finite number
'        X1      -   second coordinate, finite number
'        X2      -   third coordinate, finite number
'
'    RESULT:
'        value of the model or 0.0 (as defined above)
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function rbfcalc3(s As rbfmodel, x0 As Double, x1 As Double, x2 As Double) As Double

		Dim result As Double = rbf.rbfcalc3(s.innerobj, x0, x1, x2)
		Return result
	End Function

	'************************************************************************
'    This function calculates values of the RBF model at the given point.
'
'    This is general function which can be used for arbitrary NX (dimension  of
'    the space of arguments) and NY (dimension of the function itself). However
'    when  you  have  NY=1  you  may  find more convenient to use RBFCalc2() or
'    RBFCalc3().
'
'    This function returns 0.0 when model is not initialized.
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'        X       -   coordinates, array[NX].
'                    X may have more than NX elements, in this case only
'                    leading NX will be used.
'
'    OUTPUT PARAMETERS:
'        Y       -   function value, array[NY]. Y is out-parameter and
'                    reallocated after call to this function. In case you  want
'                    to reuse previously allocated Y, you may use RBFCalcBuf(),
'                    which reallocates Y only when it is too small.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfcalc(s As rbfmodel, x As Double(), ByRef y As Double())
		y = New Double(-1) {}
		rbf.rbfcalc(s.innerobj, x, y)
		Return
	End Sub

	'************************************************************************
'    This function calculates values of the RBF model at the given point.
'
'    Same as RBFCalc(), but does not reallocate Y when in is large enough to
'    store function values.
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'        X       -   coordinates, array[NX].
'                    X may have more than NX elements, in this case only
'                    leading NX will be used.
'        Y       -   possibly preallocated array
'
'    OUTPUT PARAMETERS:
'        Y       -   function value, array[NY]. Y is not reallocated when it
'                    is larger than NY.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfcalcbuf(s As rbfmodel, x As Double(), ByRef y As Double())

		rbf.rbfcalcbuf(s.innerobj, x, y)
		Return
	End Sub

	'************************************************************************
'    This function calculates values of the RBF model at the regular grid.
'
'    Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])
'
'    This function returns 0.0 when:
'    * model is not initialized
'    * NX<>2
'     *NY<>1
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'        X0      -   array of grid nodes, first coordinates, array[N0]
'        N0      -   grid size (number of nodes) in the first dimension
'        X1      -   array of grid nodes, second coordinates, array[N1]
'        N1      -   grid size (number of nodes) in the second dimension
'
'    OUTPUT PARAMETERS:
'        Y       -   function values, array[N0,N1]. Y is out-variable and
'                    is reallocated by this function.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfgridcalc2(s As rbfmodel, x0 As Double(), n0 As Integer, x1 As Double(), n1 As Integer, ByRef y As Double(,))
		y = New Double(-1, -1) {}
		rbf.rbfgridcalc2(s.innerobj, x0, n0, x1, n1, y)
		Return
	End Sub

	'************************************************************************
'    This function "unpacks" RBF model by extracting its coefficients.
'
'    INPUT PARAMETERS:
'        S       -   RBF model
'
'    OUTPUT PARAMETERS:
'        NX      -   dimensionality of argument
'        NY      -   dimensionality of the target function
'        XWR     -   model information, array[NC,NX+NY+1].
'                    One row of the array corresponds to one basis function:
'                    * first NX columns  - coordinates of the center
'                    * next NY columns   - weights, one per dimension of the
'                                          function being modelled
'                    * last column       - radius, same for all dimensions of
'                                          the function being modelled
'        NC      -   number of the centers
'        V       -   polynomial  term , array[NY,NX+1]. One row per one
'                    dimension of the function being modelled. First NX
'                    elements are linear coefficients, V[NX] is equal to the
'                    constant part.
'
'      -- ALGLIB --
'         Copyright 13.12.2011 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub rbfunpack(s As rbfmodel, ByRef nx As Integer, ByRef ny As Integer, ByRef xwr As Double(,), ByRef nc As Integer, ByRef v As Double(,))
		nx = 0
		ny = 0
		xwr = New Double(-1, -1) {}
		nc = 0
		v = New Double(-1, -1) {}
		rbf.rbfunpack(s.innerobj, nx, ny, xwr, nc, v)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    2-dimensional spline inteprolant
'    ************************************************************************

	Public Class spline2dinterpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New spline2d.spline2dinterpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New spline2dinterpolant(DirectCast(_innerobj.make_copy(), spline2d.spline2dinterpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As spline2d.spline2dinterpolant
		Public ReadOnly Property innerobj() As spline2d.spline2dinterpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As spline2d.spline2dinterpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This subroutine calculates the value of the bilinear or bicubic spline  at
'    the given point X.
'
'    Input parameters:
'        C   -   coefficients table.
'                Built by BuildBilinearSpline or BuildBicubicSpline.
'        X, Y-   point
'
'    Result:
'        S(x,y)
'
'      -- ALGLIB PROJECT --
'         Copyright 05.07.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spline2dcalc(c As spline2dinterpolant, x As Double, y As Double) As Double

		Dim result As Double = spline2d.spline2dcalc(c.innerobj, x, y)
		Return result
	End Function

	'************************************************************************
'    This subroutine calculates the value of the bilinear or bicubic spline  at
'    the given point X and its derivatives.
'
'    Input parameters:
'        C   -   spline interpolant.
'        X, Y-   point
'
'    Output parameters:
'        F   -   S(x,y)
'        FX  -   dS(x,y)/dX
'        FY  -   dS(x,y)/dY
'        FXY -   d2S(x,y)/dXdY
'
'      -- ALGLIB PROJECT --
'         Copyright 05.07.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2ddiff(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double, ByRef fx As Double, ByRef fy As Double, _
		ByRef fxy As Double)
		f = 0
		fx = 0
		fy = 0
		fxy = 0
		spline2d.spline2ddiff(c.innerobj, x, y, f, fx, fy, _
			fxy)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the spline argument.
'
'    Input parameters:
'        C       -   spline interpolant
'        AX, BX  -   transformation coefficients: x = A*t + B
'        AY, BY  -   transformation coefficients: y = A*u + B
'    Result:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 30.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dlintransxy(c As spline2dinterpolant, ax As Double, bx As Double, ay As Double, by As Double)

		spline2d.spline2dlintransxy(c.innerobj, ax, bx, ay, by)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the spline.
'
'    Input parameters:
'        C   -   spline interpolant.
'        A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
'
'    Output parameters:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 30.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dlintransf(c As spline2dinterpolant, a As Double, b As Double)

		spline2d.spline2dlintransf(c.innerobj, a, b)
		Return
	End Sub

	'************************************************************************
'    This subroutine makes the copy of the spline model.
'
'    Input parameters:
'        C   -   spline interpolant
'
'    Output parameters:
'        CC  -   spline copy
'
'      -- ALGLIB PROJECT --
'         Copyright 29.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dcopy(c As spline2dinterpolant, ByRef cc As spline2dinterpolant)
		cc = New spline2dinterpolant()
		spline2d.spline2dcopy(c.innerobj, cc.innerobj)
		Return
	End Sub

	'************************************************************************
'    Bicubic spline resampling
'
'    Input parameters:
'        A           -   function values at the old grid,
'                        array[0..OldHeight-1, 0..OldWidth-1]
'        OldHeight   -   old grid height, OldHeight>1
'        OldWidth    -   old grid width, OldWidth>1
'        NewHeight   -   new grid height, NewHeight>1
'        NewWidth    -   new grid width, NewWidth>1
'
'    Output parameters:
'        B           -   function values at the new grid,
'                        array[0..NewHeight-1, 0..NewWidth-1]
'
'      -- ALGLIB routine --
'         15 May, 2007
'         Copyright by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dresamplebicubic(a As Double(,), oldheight As Integer, oldwidth As Integer, ByRef b As Double(,), newheight As Integer, newwidth As Integer)
		b = New Double(-1, -1) {}
		spline2d.spline2dresamplebicubic(a, oldheight, oldwidth, b, newheight, newwidth)
		Return
	End Sub

	'************************************************************************
'    Bilinear spline resampling
'
'    Input parameters:
'        A           -   function values at the old grid,
'                        array[0..OldHeight-1, 0..OldWidth-1]
'        OldHeight   -   old grid height, OldHeight>1
'        OldWidth    -   old grid width, OldWidth>1
'        NewHeight   -   new grid height, NewHeight>1
'        NewWidth    -   new grid width, NewWidth>1
'
'    Output parameters:
'        B           -   function values at the new grid,
'                        array[0..NewHeight-1, 0..NewWidth-1]
'
'      -- ALGLIB routine --
'         09.07.2007
'         Copyright by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dresamplebilinear(a As Double(,), oldheight As Integer, oldwidth As Integer, ByRef b As Double(,), newheight As Integer, newwidth As Integer)
		b = New Double(-1, -1) {}
		spline2d.spline2dresamplebilinear(a, oldheight, oldwidth, b, newheight, newwidth)
		Return
	End Sub

	'************************************************************************
'    This subroutine builds bilinear vector-valued spline.
'
'    Input parameters:
'        X   -   spline abscissas, array[0..N-1]
'        Y   -   spline ordinates, array[0..M-1]
'        F   -   function values, array[0..M*N*D-1]:
'                * first D elements store D values at (X[0],Y[0])
'                * next D elements store D values at (X[1],Y[0])
'                * general form - D function values at (X[i],Y[j]) are stored
'                  at F[D*(J*N+I)...D*(J*N+I)+D-1].
'        M,N -   grid size, M>=2, N>=2
'        D   -   vector dimension, D>=1
'
'    Output parameters:
'        C   -   spline interpolant
'
'      -- ALGLIB PROJECT --
'         Copyright 16.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dbuildbilinearv(x As Double(), n As Integer, y As Double(), m As Integer, f As Double(), d As Integer, _
		ByRef c As spline2dinterpolant)
		c = New spline2dinterpolant()
		spline2d.spline2dbuildbilinearv(x, n, y, m, f, d, _
			c.innerobj)
		Return
	End Sub

	'************************************************************************
'    This subroutine builds bicubic vector-valued spline.
'
'    Input parameters:
'        X   -   spline abscissas, array[0..N-1]
'        Y   -   spline ordinates, array[0..M-1]
'        F   -   function values, array[0..M*N*D-1]:
'                * first D elements store D values at (X[0],Y[0])
'                * next D elements store D values at (X[1],Y[0])
'                * general form - D function values at (X[i],Y[j]) are stored
'                  at F[D*(J*N+I)...D*(J*N+I)+D-1].
'        M,N -   grid size, M>=2, N>=2
'        D   -   vector dimension, D>=1
'
'    Output parameters:
'        C   -   spline interpolant
'
'      -- ALGLIB PROJECT --
'         Copyright 16.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dbuildbicubicv(x As Double(), n As Integer, y As Double(), m As Integer, f As Double(), d As Integer, _
		ByRef c As spline2dinterpolant)
		c = New spline2dinterpolant()
		spline2d.spline2dbuildbicubicv(x, n, y, m, f, d, _
			c.innerobj)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates bilinear or bicubic vector-valued spline at the
'    given point (X,Y).
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X, Y-   point
'        F   -   output buffer, possibly preallocated array. In case array size
'                is large enough to store result, it is not reallocated.  Array
'                which is too short will be reallocated
'
'    OUTPUT PARAMETERS:
'        F   -   array[D] (or larger) which stores function values
'
'      -- ALGLIB PROJECT --
'         Copyright 16.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dcalcvbuf(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double())

		spline2d.spline2dcalcvbuf(c.innerobj, x, y, f)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates bilinear or bicubic vector-valued spline at the
'    given point (X,Y).
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X, Y-   point
'
'    OUTPUT PARAMETERS:
'        F   -   array[D] which stores function values.  F is out-parameter and
'                it  is  reallocated  after  call to this function. In case you
'                want  to    reuse  previously  allocated  F,   you   may   use
'                Spline2DCalcVBuf(),  which  reallocates  F only when it is too
'                small.
'
'      -- ALGLIB PROJECT --
'         Copyright 16.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dcalcv(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double())
		f = New Double(-1) {}
		spline2d.spline2dcalcv(c.innerobj, x, y, f)
		Return
	End Sub

	'************************************************************************
'    This subroutine unpacks two-dimensional spline into the coefficients table
'
'    Input parameters:
'        C   -   spline interpolant.
'
'    Result:
'        M, N-   grid size (x-axis and y-axis)
'        D   -   number of components
'        Tbl -   coefficients table, unpacked format,
'                D - components: [0..(N-1)*(M-1)*D-1, 0..19].
'                For T=0..D-1 (component index), I = 0...N-2 (x index),
'                J=0..M-2 (y index):
'                    K :=  T + I*D + J*D*(N-1)
'
'                    K-th row stores decomposition for T-th component of the
'                    vector-valued function
'
'                    Tbl[K,0] = X[i]
'                    Tbl[K,1] = X[i+1]
'                    Tbl[K,2] = Y[j]
'                    Tbl[K,3] = Y[j+1]
'                    Tbl[K,4] = C00
'                    Tbl[K,5] = C01
'                    Tbl[K,6] = C02
'                    Tbl[K,7] = C03
'                    Tbl[K,8] = C10
'                    Tbl[K,9] = C11
'                    ...
'                    Tbl[K,19] = C33
'                On each grid square spline is equals to:
'                    S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
'                    t = x-x[j]
'                    u = y-y[i]
'
'      -- ALGLIB PROJECT --
'         Copyright 16.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dunpackv(c As spline2dinterpolant, ByRef m As Integer, ByRef n As Integer, ByRef d As Integer, ByRef tbl As Double(,))
		m = 0
		n = 0
		d = 0
		tbl = New Double(-1, -1) {}
		spline2d.spline2dunpackv(c.innerobj, m, n, d, tbl)
		Return
	End Sub

	'************************************************************************
'    This subroutine was deprecated in ALGLIB 3.6.0
'
'    We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
'    flexible and accepts its arguments in more convenient order.
'
'      -- ALGLIB PROJECT --
'         Copyright 05.07.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dbuildbilinear(x As Double(), y As Double(), f As Double(,), m As Integer, n As Integer, ByRef c As spline2dinterpolant)
		c = New spline2dinterpolant()
		spline2d.spline2dbuildbilinear(x, y, f, m, n, c.innerobj)
		Return
	End Sub

	'************************************************************************
'    This subroutine was deprecated in ALGLIB 3.6.0
'
'    We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
'    flexible and accepts its arguments in more convenient order.
'
'      -- ALGLIB PROJECT --
'         Copyright 05.07.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dbuildbicubic(x As Double(), y As Double(), f As Double(,), m As Integer, n As Integer, ByRef c As spline2dinterpolant)
		c = New spline2dinterpolant()
		spline2d.spline2dbuildbicubic(x, y, f, m, n, c.innerobj)
		Return
	End Sub

	'************************************************************************
'    This subroutine was deprecated in ALGLIB 3.6.0
'
'    We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
'    and accepts its arguments in more convenient order.
'
'      -- ALGLIB PROJECT --
'         Copyright 29.06.2007 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline2dunpack(c As spline2dinterpolant, ByRef m As Integer, ByRef n As Integer, ByRef tbl As Double(,))
		m = 0
		n = 0
		tbl = New Double(-1, -1) {}
		spline2d.spline2dunpack(c.innerobj, m, n, tbl)
		Return
	End Sub

End Class
Public Partial Class alglib


	'************************************************************************
'    3-dimensional spline inteprolant
'    ************************************************************************

	Public Class spline3dinterpolant
		Inherits alglibobject
		'
		' Public declarations
		'

		Public Sub New()
			_innerobj = New spline3d.spline3dinterpolant()
		End Sub

		Public Overrides Function make_copy() As alglib.alglibobject
			Return New spline3dinterpolant(DirectCast(_innerobj.make_copy(), spline3d.spline3dinterpolant))
		End Function

		'
		' Although some of declarations below are public, you should not use them
		' They are intended for internal use only
		'
		Private _innerobj As spline3d.spline3dinterpolant
		Public ReadOnly Property innerobj() As spline3d.spline3dinterpolant
			Get
				Return _innerobj
			End Get
		End Property
		Public Sub New(obj As spline3d.spline3dinterpolant)
			_innerobj = obj
		End Sub
	End Class

	'************************************************************************
'    This subroutine calculates the value of the trilinear or tricubic spline at
'    the given point (X,Y,Z).
'
'    INPUT PARAMETERS:
'        C   -   coefficients table.
'                Built by BuildBilinearSpline or BuildBicubicSpline.
'        X, Y,
'        Z   -   point
'
'    Result:
'        S(x,y,z)
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Function spline3dcalc(c As spline3dinterpolant, x As Double, y As Double, z As Double) As Double

		Dim result As Double = spline3d.spline3dcalc(c.innerobj, x, y, z)
		Return result
	End Function

	'************************************************************************
'    This subroutine performs linear transformation of the spline argument.
'
'    INPUT PARAMETERS:
'        C       -   spline interpolant
'        AX, BX  -   transformation coefficients: x = A*u + B
'        AY, BY  -   transformation coefficients: y = A*v + B
'        AZ, BZ  -   transformation coefficients: z = A*w + B
'
'    OUTPUT PARAMETERS:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dlintransxyz(c As spline3dinterpolant, ax As Double, bx As Double, ay As Double, by As Double, az As Double, _
		bz As Double)

		spline3d.spline3dlintransxyz(c.innerobj, ax, bx, ay, by, az, _
			bz)
		Return
	End Sub

	'************************************************************************
'    This subroutine performs linear transformation of the spline.
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B
'
'    OUTPUT PARAMETERS:
'        C   -   transformed spline
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dlintransf(c As spline3dinterpolant, a As Double, b As Double)

		spline3d.spline3dlintransf(c.innerobj, a, b)
		Return
	End Sub

	'************************************************************************
'    Trilinear spline resampling
'
'    INPUT PARAMETERS:
'        A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
'                        values at the old grid, :
'                            A[0]        x=0,y=0,z=0
'                            A[1]        x=1,y=0,z=0
'                            A[..]       ...
'                            A[..]       x=oldxcount-1,y=0,z=0
'                            A[..]       x=0,y=1,z=0
'                            A[..]       ...
'                            ...
'        OldZCount   -   old Z-count, OldZCount>1
'        OldYCount   -   old Y-count, OldYCount>1
'        OldXCount   -   old X-count, OldXCount>1
'        NewZCount   -   new Z-count, NewZCount>1
'        NewYCount   -   new Y-count, NewYCount>1
'        NewXCount   -   new X-count, NewXCount>1
'
'    OUTPUT PARAMETERS:
'        B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
'                        values at the new grid:
'                            B[0]        x=0,y=0,z=0
'                            B[1]        x=1,y=0,z=0
'                            B[..]       ...
'                            B[..]       x=newxcount-1,y=0,z=0
'                            B[..]       x=0,y=1,z=0
'                            B[..]       ...
'                            ...
'
'      -- ALGLIB routine --
'         26.04.2012
'         Copyright by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dresampletrilinear(a As Double(), oldzcount As Integer, oldycount As Integer, oldxcount As Integer, newzcount As Integer, newycount As Integer, _
		newxcount As Integer, ByRef b As Double())
		b = New Double(-1) {}
		spline3d.spline3dresampletrilinear(a, oldzcount, oldycount, oldxcount, newzcount, newycount, _
			newxcount, b)
		Return
	End Sub

	'************************************************************************
'    This subroutine builds trilinear vector-valued spline.
'
'    INPUT PARAMETERS:
'        X   -   spline abscissas,  array[0..N-1]
'        Y   -   spline ordinates,  array[0..M-1]
'        Z   -   spline applicates, array[0..L-1]
'        F   -   function values, array[0..M*N*L*D-1]:
'                * first D elements store D values at (X[0],Y[0],Z[0])
'                * next D elements store D values at (X[1],Y[0],Z[0])
'                * next D elements store D values at (X[2],Y[0],Z[0])
'                * ...
'                * next D elements store D values at (X[0],Y[1],Z[0])
'                * next D elements store D values at (X[1],Y[1],Z[0])
'                * next D elements store D values at (X[2],Y[1],Z[0])
'                * ...
'                * next D elements store D values at (X[0],Y[0],Z[1])
'                * next D elements store D values at (X[1],Y[0],Z[1])
'                * next D elements store D values at (X[2],Y[0],Z[1])
'                * ...
'                * general form - D function values at (X[i],Y[j]) are stored
'                  at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
'        M,N,
'        L   -   grid size, M>=2, N>=2, L>=2
'        D   -   vector dimension, D>=1
'
'    OUTPUT PARAMETERS:
'        C   -   spline interpolant
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dbuildtrilinearv(x As Double(), n As Integer, y As Double(), m As Integer, z As Double(), l As Integer, _
		f As Double(), d As Integer, ByRef c As spline3dinterpolant)
		c = New spline3dinterpolant()
		spline3d.spline3dbuildtrilinearv(x, n, y, m, z, l, _
			f, d, c.innerobj)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates bilinear or bicubic vector-valued spline at the
'    given point (X,Y,Z).
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X, Y,
'        Z   -   point
'        F   -   output buffer, possibly preallocated array. In case array size
'                is large enough to store result, it is not reallocated.  Array
'                which is too short will be reallocated
'
'    OUTPUT PARAMETERS:
'        F   -   array[D] (or larger) which stores function values
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dcalcvbuf(c As spline3dinterpolant, x As Double, y As Double, z As Double, ByRef f As Double())

		spline3d.spline3dcalcvbuf(c.innerobj, x, y, z, f)
		Return
	End Sub

	'************************************************************************
'    This subroutine calculates trilinear or tricubic vector-valued spline at the
'    given point (X,Y,Z).
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'        X, Y,
'        Z   -   point
'
'    OUTPUT PARAMETERS:
'        F   -   array[D] which stores function values.  F is out-parameter and
'                it  is  reallocated  after  call to this function. In case you
'                want  to    reuse  previously  allocated  F,   you   may   use
'                Spline2DCalcVBuf(),  which  reallocates  F only when it is too
'                small.
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dcalcv(c As spline3dinterpolant, x As Double, y As Double, z As Double, ByRef f As Double())
		f = New Double(-1) {}
		spline3d.spline3dcalcv(c.innerobj, x, y, z, f)
		Return
	End Sub

	'************************************************************************
'    This subroutine unpacks tri-dimensional spline into the coefficients table
'
'    INPUT PARAMETERS:
'        C   -   spline interpolant.
'
'    Result:
'        N   -   grid size (X)
'        M   -   grid size (Y)
'        L   -   grid size (Z)
'        D   -   number of components
'        SType-  spline type. Currently, only one spline type is supported:
'                trilinear spline, as indicated by SType=1.
'        Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
'                For T=0..D-1 (component index), I = 0...N-2 (x index),
'                J=0..M-2 (y index), K=0..L-2 (z index):
'                    Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),
'
'                    Q-th row stores decomposition for T-th component of the
'                    vector-valued function
'
'                    Tbl[Q,0] = X[i]
'                    Tbl[Q,1] = X[i+1]
'                    Tbl[Q,2] = Y[j]
'                    Tbl[Q,3] = Y[j+1]
'                    Tbl[Q,4] = Z[k]
'                    Tbl[Q,5] = Z[k+1]
'
'                    Tbl[Q,6] = C000
'                    Tbl[Q,7] = C100
'                    Tbl[Q,8] = C010
'                    Tbl[Q,9] = C110
'                    Tbl[Q,10]= C001
'                    Tbl[Q,11]= C101
'                    Tbl[Q,12]= C011
'                    Tbl[Q,13]= C111
'                On each grid square spline is equals to:
'                    S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
'                    t = x-x[j]
'                    u = y-y[i]
'                    v = z-z[k]
'
'                NOTE: format of Tbl is given for SType=1. Future versions of
'                      ALGLIB can use different formats for different values of
'                      SType.
'
'      -- ALGLIB PROJECT --
'         Copyright 26.04.2012 by Bochkanov Sergey
'    ************************************************************************

	Public Shared Sub spline3dunpackv(c As spline3dinterpolant, ByRef n As Integer, ByRef m As Integer, ByRef l As Integer, ByRef d As Integer, ByRef stype As Integer, _
		ByRef tbl As Double(,))
		n = 0
		m = 0
		l = 0
		d = 0
		stype = 0
		tbl = New Double(-1, -1) {}
		spline3d.spline3dunpackv(c.innerobj, n, m, l, d, stype, _
			tbl)
		Return
	End Sub

End Class
Public Partial Class alglib
	Public Class idwint
		'************************************************************************
'        IDW interpolant.
'        ************************************************************************

		Public Class idwinterpolant
			Inherits apobject
			Public n As Integer
			Public nx As Integer
			Public d As Integer
			Public r As Double
			Public nw As Integer
			Public tree As nearestneighbor.kdtree
			Public modeltype As Integer
			Public q As Double(,)
			Public xbuf As Double()
			Public tbuf As Integer()
			Public rbuf As Double()
			Public xybuf As Double(,)
			Public debugsolverfailures As Integer
			Public debugworstrcond As Double
			Public debugbestrcond As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				tree = New nearestneighbor.kdtree()
				q = New Double(-1, -1) {}
				xbuf = New Double(-1) {}
				tbuf = New Integer(-1) {}
				rbuf = New Double(-1) {}
				xybuf = New Double(-1, -1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New idwinterpolant()
				_result.n = n
				_result.nx = nx
				_result.d = d
				_result.r = r
				_result.nw = nw
				_result.tree = DirectCast(tree.make_copy(), nearestneighbor.kdtree)
				_result.modeltype = modeltype
				_result.q = DirectCast(q.Clone(), Double(,))
				_result.xbuf = DirectCast(xbuf.Clone(), Double())
				_result.tbuf = DirectCast(tbuf.Clone(), Integer())
				_result.rbuf = DirectCast(rbuf.Clone(), Double())
				_result.xybuf = DirectCast(xybuf.Clone(), Double(,))
				_result.debugsolverfailures = debugsolverfailures
				_result.debugworstrcond = debugworstrcond
				_result.debugbestrcond = debugbestrcond
				Return _result
			End Function
		End Class




		Public Const idwqfactor As Double = 1.5
		Public Const idwkmin As Integer = 5


		'************************************************************************
'        IDW interpolation
'
'        INPUT PARAMETERS:
'            Z   -   IDW interpolant built with one of model building
'                    subroutines.
'            X   -   array[0..NX-1], interpolation point
'
'        Result:
'            IDW interpolant Z(X)
'
'          -- ALGLIB --
'             Copyright 02.03.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function idwcalc(z As idwinterpolant, x As Double()) As Double
			Dim result As Double = 0
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim r As Double = 0
			Dim s As Double = 0
			Dim w As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0
			Dim d0 As Double = 0
			Dim di As Double = 0


			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			k = 0

			'
			' Query
			'
			If z.modeltype = 0 Then

				'
				' NQ/NW-based model
				'
				k = nearestneighbor.kdtreequeryknn(z.tree, x, z.nw, True)
				nearestneighbor.kdtreequeryresultsdistances(z.tree, z.rbuf)
				nearestneighbor.kdtreequeryresultstags(z.tree, z.tbuf)
			End If
			If z.modeltype = 1 Then

				'
				' R-based model
				'
				k = nearestneighbor.kdtreequeryrnn(z.tree, x, z.r, True)
				nearestneighbor.kdtreequeryresultsdistances(z.tree, z.rbuf)
				nearestneighbor.kdtreequeryresultstags(z.tree, z.tbuf)
				If k < idwkmin Then

					'
					' we need at least IDWKMin points
					'
					k = nearestneighbor.kdtreequeryknn(z.tree, x, idwkmin, True)
					nearestneighbor.kdtreequeryresultsdistances(z.tree, z.rbuf)
					nearestneighbor.kdtreequeryresultstags(z.tree, z.tbuf)
				End If
			End If

			'
			' initialize weights for linear/quadratic members calculation.
			'
			' NOTE 1: weights are calculated using NORMALIZED modified
			' Shepard's formula. Original formula gives w(i) = sqr((R-di)/(R*di)),
			' where di is i-th distance, R is max(di). Modified formula have
			' following form:
			'     w_mod(i) = 1, if di=d0
			'     w_mod(i) = w(i)/w(0), if di<>d0
			'
			' NOTE 2: self-match is USED for this query
			'
			' NOTE 3: last point almost always gain zero weight, but it MUST
			' be used for fitting because sometimes it will gain NON-ZERO
			' weight - for example, when all distances are equal.
			'
			r = z.rbuf(k - 1)
			d0 = z.rbuf(0)
			result = 0
			s = 0
			For i = 0 To k - 1
				di = z.rbuf(i)
				If CDbl(di) = CDbl(d0) Then

					'
					' distance is equal to shortest, set it 1.0
					' without explicitly calculating (which would give
					' us same result, but 'll expose us to the risk of
					' division by zero).
					'
					w = 1
				Else

					'
					' use normalized formula
					'
					v1 = (r - di) / (r - d0)
					v2 = d0 / di
					w = Math.sqr(v1 * v2)
				End If
				result = result + w * idwcalcq(z, x, z.tbuf(i))
				s = s + w
			Next
			result = result / s
			Return result
		End Function


		'************************************************************************
'        IDW interpolant using modified Shepard method for uniform point
'        distributions.
'
'        INPUT PARAMETERS:
'            XY  -   X and Y values, array[0..N-1,0..NX].
'                    First NX columns contain X-values, last column contain
'                    Y-values.
'            N   -   number of nodes, N>0.
'            NX  -   space dimension, NX>=1.
'            D   -   nodal function type, either:
'                    * 0     constant  model.  Just  for  demonstration only, worst
'                            model ever.
'                    * 1     linear model, least squares fitting. Simpe  model  for
'                            datasets too small for quadratic models
'                    * 2     quadratic  model,  least  squares  fitting. Best model
'                            available (if your dataset is large enough).
'                    * -1    "fast"  linear  model,  use  with  caution!!!   It  is
'                            significantly  faster than linear/quadratic and better
'                            than constant model. But it is less robust (especially
'                            in the presence of noise).
'            NQ  -   number of points used to calculate  nodal  functions  (ignored
'                    for constant models). NQ should be LARGER than:
'                    * max(1.5*(1+NX),2^NX+1) for linear model,
'                    * max(3/4*(NX+2)*(NX+1),2^NX+1) for quadratic model.
'                    Values less than this threshold will be silently increased.
'            NW  -   number of points used to calculate weights and to interpolate.
'                    Required: >=2^NX+1, values less than this  threshold  will  be
'                    silently increased.
'                    Recommended value: about 2*NQ
'
'        OUTPUT PARAMETERS:
'            Z   -   IDW interpolant.
'            
'        NOTES:
'          * best results are obtained with quadratic models, worst - with constant
'            models
'          * when N is large, NQ and NW must be significantly smaller than  N  both
'            to obtain optimal performance and to obtain optimal accuracy. In 2  or
'            3-dimensional tasks NQ=15 and NW=25 are good values to start with.
'          * NQ  and  NW  may  be  greater  than  N.  In  such  cases  they will be
'            automatically decreased.
'          * this subroutine is always succeeds (as long as correct parameters  are
'            passed).
'          * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
'            Robert J. Renka for more information on this algorithm.
'          * this subroutine assumes that point distribution is uniform at the small
'            scales.  If  it  isn't  -  for  example,  points are concentrated along
'            "lines", but "lines" distribution is uniform at the larger scale - then
'            you should use IDWBuildModifiedShepardR()
'
'
'          -- ALGLIB PROJECT --
'             Copyright 02.03.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub idwbuildmodifiedshepard(xy As Double(,), n As Integer, nx As Integer, d As Integer, nq As Integer, nw As Integer, _
			z As idwinterpolant)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim j2 As Integer = 0
			Dim j3 As Integer = 0
			Dim v As Double = 0
			Dim r As Double = 0
			Dim s As Double = 0
			Dim d0 As Double = 0
			Dim di As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0
			Dim nc As Integer = 0
			Dim offs As Integer = 0
			Dim x As Double() = New Double(-1) {}
			Dim qrbuf As Double() = New Double(-1) {}
			Dim qxybuf As Double(,) = New Double(-1, -1) {}
			Dim y As Double() = New Double(-1) {}
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim w As Double() = New Double(-1) {}
			Dim qsol As Double() = New Double(-1) {}
			Dim temp As Double() = New Double(-1) {}
			Dim tags As Integer() = New Integer(-1) {}
			Dim info As Integer = 0
			Dim taskrcond As Double = 0
			Dim i_ As Integer = 0


			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			nc = 0

			'
			' assertions
			'
			alglib.ap.assert(n > 0, "IDWBuildModifiedShepard: N<=0!")
			alglib.ap.assert(nx >= 1, "IDWBuildModifiedShepard: NX<1!")
			alglib.ap.assert(d >= -1 AndAlso d <= 2, "IDWBuildModifiedShepard: D<>-1 and D<>0 and D<>1 and D<>2!")

			'
			' Correct parameters if needed
			'
			If d = 1 Then
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Ceiling(idwqfactor * (1 + nx)))) + 1)
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Round(System.Math.Pow(2, nx)))) + 1)
			End If
			If d = 2 Then
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Ceiling(idwqfactor * (nx + 2) * (nx + 1) / 2))) + 1)
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Round(System.Math.Pow(2, nx)))) + 1)
			End If
			nw = System.Math.Max(nw, CInt(System.Math.Truncate(System.Math.Round(System.Math.Pow(2, nx)))) + 1)
			nq = System.Math.Min(nq, n)
			nw = System.Math.Min(nw, n)

			'
			' primary initialization of Z
			'
			idwinit1(n, nx, d, nq, nw, z)
			z.modeltype = 0

			'
			' Create KD-tree
			'
			tags = New Integer(n - 1) {}
			For i = 0 To n - 1
				tags(i) = i
			Next
			nearestneighbor.kdtreebuildtagged(xy, tags, n, nx, 1, 2, _
				z.tree)

			'
			' build nodal functions
			'
			temp = New Double(nq) {}
			x = New Double(nx - 1) {}
			qrbuf = New Double(nq - 1) {}
			qxybuf = New Double(nq - 1, nx) {}
			If d = -1 Then
				w = New Double(nq - 1) {}
			End If
			If d = 1 Then
				y = New Double(nq - 1) {}
				w = New Double(nq - 1) {}
				qsol = New Double(nx - 1) {}

				'
				' NX for linear members,
				' 1 for temporary storage
				'
				fmatrix = New Double(nq - 1, nx) {}
			End If
			If d = 2 Then
				y = New Double(nq - 1) {}
				w = New Double(nq - 1) {}
				qsol = New Double(nx + (CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5))) - 1)) {}

				'
				' NX for linear members,
				' Round(NX*(NX+1)*0.5) for quadratic model,
				' 1 for temporary storage
				'
				fmatrix = New Double(nq - 1, nx + CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5)))) {}
			End If
			For i = 0 To n - 1

				'
				' Initialize center and function value.
				' If D=0 it is all what we need
				'
				For i_ = 0 To nx
					z.q(i, i_) = xy(i, i_)
				Next
				If d = 0 Then
					Continue For
				End If

				'
				' calculate weights for linear/quadratic members calculation.
				'
				' NOTE 1: weights are calculated using NORMALIZED modified
				' Shepard's formula. Original formula is w(i) = sqr((R-di)/(R*di)),
				' where di is i-th distance, R is max(di). Modified formula have
				' following form:
				'     w_mod(i) = 1, if di=d0
				'     w_mod(i) = w(i)/w(0), if di<>d0
				'
				' NOTE 2: self-match is NOT used for this query
				'
				' NOTE 3: last point almost always gain zero weight, but it MUST
				' be used for fitting because sometimes it will gain NON-ZERO
				' weight - for example, when all distances are equal.
				'
				For i_ = 0 To nx - 1
					x(i_) = xy(i, i_)
				Next
				k = nearestneighbor.kdtreequeryknn(z.tree, x, nq, False)
				nearestneighbor.kdtreequeryresultsxy(z.tree, qxybuf)
				nearestneighbor.kdtreequeryresultsdistances(z.tree, qrbuf)
				r = qrbuf(k - 1)
				d0 = qrbuf(0)
				For j = 0 To k - 1
					di = qrbuf(j)
					If CDbl(di) = CDbl(d0) Then

						'
						' distance is equal to shortest, set it 1.0
						' without explicitly calculating (which would give
						' us same result, but 'll expose us to the risk of
						' division by zero).
						'
						w(j) = 1
					Else

						'
						' use normalized formula
						'
						v1 = (r - di) / (r - d0)
						v2 = d0 / di
						w(j) = Math.sqr(v1 * v2)
					End If
				Next

				'
				' calculate linear/quadratic members
				'
				If d = -1 Then

					'
					' "Fast" linear nodal function calculated using
					' inverse distance weighting
					'
					For j = 0 To nx - 1
						x(j) = 0
					Next
					s = 0
					For j = 0 To k - 1

						'
						' calculate J-th inverse distance weighted gradient:
						'     grad_k = (y_j-y_k)*(x_j-x_k)/sqr(norm(x_j-x_k))
						'     grad   = sum(wk*grad_k)/sum(w_k)
						'
						v = 0
						For j2 = 0 To nx - 1
							v = v + Math.sqr(qxybuf(j, j2) - xy(i, j2))
						Next

						'
						' Although x_j<>x_k, sqr(norm(x_j-x_k)) may be zero due to
						' underflow. If it is, we assume than J-th gradient is zero
						' (i.e. don't add anything)
						'
						If CDbl(v) <> CDbl(0) Then
							For j2 = 0 To nx - 1
								x(j2) = x(j2) + w(j) * (qxybuf(j, nx) - xy(i, nx)) * (qxybuf(j, j2) - xy(i, j2)) / v
							Next
						End If
						s = s + w(j)
					Next
					For j = 0 To nx - 1
						z.q(i, nx + 1 + j) = x(j) / s
					Next
				Else

					'
					' Least squares models: build
					'
					If d = 1 Then

						'
						' Linear nodal function calculated using
						' least squares fitting to its neighbors
						'
						For j = 0 To k - 1
							For j2 = 0 To nx - 1
								fmatrix(j, j2) = qxybuf(j, j2) - xy(i, j2)
							Next
							y(j) = qxybuf(j, nx) - xy(i, nx)
						Next
						nc = nx
					End If
					If d = 2 Then

						'
						' Quadratic nodal function calculated using
						' least squares fitting to its neighbors
						'
						For j = 0 To k - 1
							offs = 0
							For j2 = 0 To nx - 1
								fmatrix(j, offs) = qxybuf(j, j2) - xy(i, j2)
								offs = offs + 1
							Next
							For j2 = 0 To nx - 1
								For j3 = j2 To nx - 1
									fmatrix(j, offs) = (qxybuf(j, j2) - xy(i, j2)) * (qxybuf(j, j3) - xy(i, j3))
									offs = offs + 1
								Next
							Next
							y(j) = qxybuf(j, nx) - xy(i, nx)
						Next
						nc = nx + CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5)))
					End If
					idwinternalsolver(y, w, fmatrix, temp, k, nc, _
						info, qsol, taskrcond)

					'
					' Least squares models: copy results
					'
					If info > 0 Then

						'
						' LLS task is solved, copy results
						'
						z.debugworstrcond = System.Math.Min(z.debugworstrcond, taskrcond)
						z.debugbestrcond = System.Math.Max(z.debugbestrcond, taskrcond)
						For j = 0 To nc - 1
							z.q(i, nx + 1 + j) = qsol(j)
						Next
					Else

						'
						' Solver failure, very strange, but we will use
						' zero values to handle it.
						'
						z.debugsolverfailures = z.debugsolverfailures + 1
						For j = 0 To nc - 1
							z.q(i, nx + 1 + j) = 0
						Next
					End If
				End If
			Next
		End Sub


		'************************************************************************
'        IDW interpolant using modified Shepard method for non-uniform datasets.
'
'        This type of model uses  constant  nodal  functions and interpolates using
'        all nodes which are closer than user-specified radius R. It  may  be  used
'        when points distribution is non-uniform at the small scale, but it  is  at
'        the distances as large as R.
'
'        INPUT PARAMETERS:
'            XY  -   X and Y values, array[0..N-1,0..NX].
'                    First NX columns contain X-values, last column contain
'                    Y-values.
'            N   -   number of nodes, N>0.
'            NX  -   space dimension, NX>=1.
'            R   -   radius, R>0
'
'        OUTPUT PARAMETERS:
'            Z   -   IDW interpolant.
'
'        NOTES:
'        * if there is less than IDWKMin points within  R-ball,  algorithm  selects
'          IDWKMin closest ones, so that continuity properties of  interpolant  are
'          preserved even far from points.
'
'          -- ALGLIB PROJECT --
'             Copyright 11.04.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub idwbuildmodifiedshepardr(xy As Double(,), n As Integer, nx As Integer, r As Double, z As idwinterpolant)
			Dim i As Integer = 0
			Dim tags As Integer() = New Integer(-1) {}
			Dim i_ As Integer = 0


			'
			' assertions
			'
			alglib.ap.assert(n > 0, "IDWBuildModifiedShepardR: N<=0!")
			alglib.ap.assert(nx >= 1, "IDWBuildModifiedShepardR: NX<1!")
			alglib.ap.assert(CDbl(r) > CDbl(0), "IDWBuildModifiedShepardR: R<=0!")

			'
			' primary initialization of Z
			'
			idwinit1(n, nx, 0, 0, n, z)
			z.modeltype = 1
			z.r = r

			'
			' Create KD-tree
			'
			tags = New Integer(n - 1) {}
			For i = 0 To n - 1
				tags(i) = i
			Next
			nearestneighbor.kdtreebuildtagged(xy, tags, n, nx, 1, 2, _
				z.tree)

			'
			' build nodal functions
			'
			For i = 0 To n - 1
				For i_ = 0 To nx
					z.q(i, i_) = xy(i, i_)
				Next
			Next
		End Sub


		'************************************************************************
'        IDW model for noisy data.
'
'        This subroutine may be used to handle noisy data, i.e. data with noise  in
'        OUTPUT values.  It differs from IDWBuildModifiedShepard() in the following
'        aspects:
'        * nodal functions are not constrained to pass through  nodes:  Qi(xi)<>yi,
'          i.e. we have fitting  instead  of  interpolation.
'        * weights which are used during least  squares fitting stage are all equal
'          to 1.0 (independently of distance)
'        * "fast"-linear or constant nodal functions are not supported (either  not
'          robust enough or too rigid)
'
'        This problem require far more complex tuning than interpolation  problems.
'        Below you can find some recommendations regarding this problem:
'        * focus on tuning NQ; it controls noise reduction. As for NW, you can just
'          make it equal to 2*NQ.
'        * you can use cross-validation to determine optimal NQ.
'        * optimal NQ is a result of complex tradeoff  between  noise  level  (more
'          noise = larger NQ required) and underlying  function  complexity  (given
'          fixed N, larger NQ means smoothing of compex features in the data).  For
'          example, NQ=N will reduce noise to the minimum level possible,  but  you
'          will end up with just constant/linear/quadratic (depending on  D)  least
'          squares model for the whole dataset.
'
'        INPUT PARAMETERS:
'            XY  -   X and Y values, array[0..N-1,0..NX].
'                    First NX columns contain X-values, last column contain
'                    Y-values.
'            N   -   number of nodes, N>0.
'            NX  -   space dimension, NX>=1.
'            D   -   nodal function degree, either:
'                    * 1     linear model, least squares fitting. Simpe  model  for
'                            datasets too small for quadratic models (or  for  very
'                            noisy problems).
'                    * 2     quadratic  model,  least  squares  fitting. Best model
'                            available (if your dataset is large enough).
'            NQ  -   number of points used to calculate nodal functions.  NQ should
'                    be  significantly   larger   than  1.5  times  the  number  of
'                    coefficients in a nodal function to overcome effects of noise:
'                    * larger than 1.5*(1+NX) for linear model,
'                    * larger than 3/4*(NX+2)*(NX+1) for quadratic model.
'                    Values less than this threshold will be silently increased.
'            NW  -   number of points used to calculate weights and to interpolate.
'                    Required: >=2^NX+1, values less than this  threshold  will  be
'                    silently increased.
'                    Recommended value: about 2*NQ or larger
'
'        OUTPUT PARAMETERS:
'            Z   -   IDW interpolant.
'
'        NOTES:
'          * best results are obtained with quadratic models, linear models are not
'            recommended to use unless you are pretty sure that it is what you want
'          * this subroutine is always succeeds (as long as correct parameters  are
'            passed).
'          * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
'            Robert J. Renka for more information on this algorithm.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 02.03.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub idwbuildnoisy(xy As Double(,), n As Integer, nx As Integer, d As Integer, nq As Integer, nw As Integer, _
			z As idwinterpolant)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim j2 As Integer = 0
			Dim j3 As Integer = 0
			Dim v As Double = 0
			Dim nc As Integer = 0
			Dim offs As Integer = 0
			Dim taskrcond As Double = 0
			Dim x As Double() = New Double(-1) {}
			Dim qrbuf As Double() = New Double(-1) {}
			Dim qxybuf As Double(,) = New Double(-1, -1) {}
			Dim y As Double() = New Double(-1) {}
			Dim w As Double() = New Double(-1) {}
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim qsol As Double() = New Double(-1) {}
			Dim tags As Integer() = New Integer(-1) {}
			Dim temp As Double() = New Double(-1) {}
			Dim info As Integer = 0
			Dim i_ As Integer = 0


			'
			' these initializers are not really necessary,
			' but without them compiler complains about uninitialized locals
			'
			nc = 0

			'
			' assertions
			'
			alglib.ap.assert(n > 0, "IDWBuildNoisy: N<=0!")
			alglib.ap.assert(nx >= 1, "IDWBuildNoisy: NX<1!")
			alglib.ap.assert(d >= 1 AndAlso d <= 2, "IDWBuildNoisy: D<>1 and D<>2!")

			'
			' Correct parameters if needed
			'
			If d = 1 Then
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Ceiling(idwqfactor * (1 + nx)))) + 1)
			End If
			If d = 2 Then
				nq = System.Math.Max(nq, CInt(System.Math.Truncate(System.Math.Ceiling(idwqfactor * (nx + 2) * (nx + 1) / 2))) + 1)
			End If
			nw = System.Math.Max(nw, CInt(System.Math.Truncate(System.Math.Round(System.Math.Pow(2, nx)))) + 1)
			nq = System.Math.Min(nq, n)
			nw = System.Math.Min(nw, n)

			'
			' primary initialization of Z
			'
			idwinit1(n, nx, d, nq, nw, z)
			z.modeltype = 0

			'
			' Create KD-tree
			'
			tags = New Integer(n - 1) {}
			For i = 0 To n - 1
				tags(i) = i
			Next
			nearestneighbor.kdtreebuildtagged(xy, tags, n, nx, 1, 2, _
				z.tree)

			'
			' build nodal functions
			' (special algorithm for noisy data is used)
			'
			temp = New Double(nq) {}
			x = New Double(nx - 1) {}
			qrbuf = New Double(nq - 1) {}
			qxybuf = New Double(nq - 1, nx) {}
			If d = 1 Then
				y = New Double(nq - 1) {}
				w = New Double(nq - 1) {}
				qsol = New Double(1 + (nx - 1)) {}

				'
				' 1 for constant member,
				' NX for linear members,
				' 1 for temporary storage
				'
				fmatrix = New Double(nq - 1, 1 + nx) {}
			End If
			If d = 2 Then
				y = New Double(nq - 1) {}
				w = New Double(nq - 1) {}
				qsol = New Double(1 + nx + (CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5))) - 1)) {}

				'
				' 1 for constant member,
				' NX for linear members,
				' Round(NX*(NX+1)*0.5) for quadratic model,
				' 1 for temporary storage
				'
				fmatrix = New Double(nq - 1, 1 + nx + CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5)))) {}
			End If
			For i = 0 To n - 1

				'
				' Initialize center.
				'
				For i_ = 0 To nx - 1
					z.q(i, i_) = xy(i, i_)
				Next

				'
				' Calculate linear/quadratic members
				' using least squares fit
				' NOTE 1: all weight are equal to 1.0
				' NOTE 2: self-match is USED for this query
				'
				For i_ = 0 To nx - 1
					x(i_) = xy(i, i_)
				Next
				k = nearestneighbor.kdtreequeryknn(z.tree, x, nq, True)
				nearestneighbor.kdtreequeryresultsxy(z.tree, qxybuf)
				nearestneighbor.kdtreequeryresultsdistances(z.tree, qrbuf)
				If d = 1 Then

					'
					' Linear nodal function calculated using
					' least squares fitting to its neighbors
					'
					For j = 0 To k - 1
						fmatrix(j, 0) = 1.0
						For j2 = 0 To nx - 1
							fmatrix(j, 1 + j2) = qxybuf(j, j2) - xy(i, j2)
						Next
						y(j) = qxybuf(j, nx)
						w(j) = 1
					Next
					nc = 1 + nx
				End If
				If d = 2 Then

					'
					' Quadratic nodal function calculated using
					' least squares fitting to its neighbors
					'
					For j = 0 To k - 1
						fmatrix(j, 0) = 1
						offs = 1
						For j2 = 0 To nx - 1
							fmatrix(j, offs) = qxybuf(j, j2) - xy(i, j2)
							offs = offs + 1
						Next
						For j2 = 0 To nx - 1
							For j3 = j2 To nx - 1
								fmatrix(j, offs) = (qxybuf(j, j2) - xy(i, j2)) * (qxybuf(j, j3) - xy(i, j3))
								offs = offs + 1
							Next
						Next
						y(j) = qxybuf(j, nx)
						w(j) = 1
					Next
					nc = 1 + nx + CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5)))
				End If
				idwinternalsolver(y, w, fmatrix, temp, k, nc, _
					info, qsol, taskrcond)

				'
				' Least squares models: copy results
				'
				If info > 0 Then

					'
					' LLS task is solved, copy results
					'
					z.debugworstrcond = System.Math.Min(z.debugworstrcond, taskrcond)
					z.debugbestrcond = System.Math.Max(z.debugbestrcond, taskrcond)
					For j = 0 To nc - 1
						z.q(i, nx + j) = qsol(j)
					Next
				Else

					'
					' Solver failure, very strange, but we will use
					' zero values to handle it.
					'
					z.debugsolverfailures = z.debugsolverfailures + 1
					v = 0
					For j = 0 To k - 1
						v = v + qxybuf(j, nx)
					Next
					z.q(i, nx) = v / k
					For j = 0 To nc - 2
						z.q(i, nx + 1 + j) = 0
					Next
				End If
			Next
		End Sub


		'************************************************************************
'        Internal subroutine: K-th nodal function calculation
'
'          -- ALGLIB --
'             Copyright 02.03.2010 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Function idwcalcq(z As idwinterpolant, x As Double(), k As Integer) As Double
			Dim result As Double = 0
			Dim nx As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim offs As Integer = 0

			nx = z.nx

			'
			' constant member
			'
			result = z.q(k, nx)

			'
			' linear members
			'
			If z.d >= 1 Then
				For i = 0 To nx - 1
					result = result + z.q(k, nx + 1 + i) * (x(i) - z.q(k, i))
				Next
			End If

			'
			' quadratic members
			'
			If z.d >= 2 Then
				offs = nx + 1 + nx
				For i = 0 To nx - 1
					For j = i To nx - 1
						result = result + z.q(k, offs) * (x(i) - z.q(k, i)) * (x(j) - z.q(k, j))
						offs = offs + 1
					Next
				Next
			End If
			Return result
		End Function


		'************************************************************************
'        Initialization of internal structures.
'
'        It assumes correctness of all parameters.
'
'          -- ALGLIB --
'             Copyright 02.03.2010 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub idwinit1(n As Integer, nx As Integer, d As Integer, nq As Integer, nw As Integer, z As idwinterpolant)
			z.debugsolverfailures = 0
			z.debugworstrcond = 1.0
			z.debugbestrcond = 0
			z.n = n
			z.nx = nx
			z.d = 0
			If d = 1 Then
				z.d = 1
			End If
			If d = 2 Then
				z.d = 2
			End If
			If d = -1 Then
				z.d = 1
			End If
			z.nw = nw
			If d = -1 Then
				z.q = New Double(n - 1, nx + 1 + (nx - 1)) {}
			End If
			If d = 0 Then
				z.q = New Double(n - 1, nx) {}
			End If
			If d = 1 Then
				z.q = New Double(n - 1, nx + 1 + (nx - 1)) {}
			End If
			If d = 2 Then
				z.q = New Double(n - 1, nx + 1 + nx + (CInt(System.Math.Truncate(System.Math.Round(nx * (nx + 1) * 0.5))) - 1)) {}
			End If
			z.tbuf = New Integer(nw - 1) {}
			z.rbuf = New Double(nw - 1) {}
			z.xybuf = New Double(nw - 1, nx) {}
			z.xbuf = New Double(nx - 1) {}
		End Sub


		'************************************************************************
'        Linear least squares solver for small tasks.
'
'        Works faster than standard ALGLIB solver in non-degenerate cases  (due  to
'        absense of internal allocations and optimized row/colums).  In  degenerate
'        cases it calls standard solver, which results in small performance penalty
'        associated with preliminary steps.
'
'        INPUT PARAMETERS:
'            Y           array[0..N-1]
'            W           array[0..N-1]
'            FMatrix     array[0..N-1,0..M], have additional column for temporary
'                        values
'            Temp        array[0..N]
'        ************************************************************************

		Private Shared Sub idwinternalsolver(ByRef y As Double(), ByRef w As Double(), ByRef fmatrix As Double(,), ByRef temp As Double(), n As Integer, m As Integer, _
			ByRef info As Integer, ByRef x As Double(), ByRef taskrcond As Double)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim tau As Double = 0
			Dim b As Double() = New Double(-1) {}
			Dim srep As New densesolver.densesolverlsreport()
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			info = 0


			'
			' set up info
			'
			info = 1

			'
			' prepare matrix
			'
			For i = 0 To n - 1
				fmatrix(i, m) = y(i)
				v = w(i)
				For i_ = 0 To m
					fmatrix(i, i_) = v * fmatrix(i, i_)
				Next
			Next

			'
			' use either fast algorithm or general algorithm
			'
			If m <= n Then

				'
				' QR decomposition
				' We assume that M<=N (we would have called LSFit() otherwise)
				'
				For i = 0 To m - 1
					If i < n - 1 Then
						i1_ = (i) - (1)
						For i_ = 1 To n - i
							temp(i_) = fmatrix(i_ + i1_, i)
						Next
						reflections.generatereflection(temp, n - i, tau)
						fmatrix(i, i) = temp(1)
						temp(1) = 1
						For j = i + 1 To m
							i1_ = (1) - (i)
							v = 0.0
							For i_ = i To n - 1
								v += fmatrix(i_, j) * temp(i_ + i1_)
							Next
							v = tau * v
							i1_ = (1) - (i)
							For i_ = i To n - 1
								fmatrix(i_, j) = fmatrix(i_, j) - v * temp(i_ + i1_)
							Next
						Next
					End If
				Next

				'
				' Check condition number
				'
				taskrcond = rcond.rmatrixtrrcondinf(fmatrix, m, True, False)

				'
				' use either fast algorithm for non-degenerate cases
				' or slow algorithm for degenerate cases
				'
				If CDbl(taskrcond) > CDbl(10000 * n * Math.machineepsilon) Then

					'
					' solve triangular system R*x = FMatrix[0:M-1,M]
					' using fast algorithm, then exit
					'
					x(m - 1) = fmatrix(m - 1, m) / fmatrix(m - 1, m - 1)
					For i = m - 2 To 0 Step -1
						v = 0.0
						For i_ = i + 1 To m - 1
							v += fmatrix(i, i_) * x(i_)
						Next
						x(i) = (fmatrix(i, m) - v) / fmatrix(i, i)
					Next
				Else

					'
					' use more general algorithm
					'
					b = New Double(m - 1) {}
					For i = 0 To m - 1
						For j = 0 To i - 1
							fmatrix(i, j) = 0.0
						Next
						b(i) = fmatrix(i, m)
					Next
					densesolver.rmatrixsolvels(fmatrix, m, m, b, 10000 * Math.machineepsilon, info, _
						srep, x)
				End If
			Else

				'
				' use more general algorithm
				'
				b = New Double(n - 1) {}
				For i = 0 To n - 1
					b(i) = fmatrix(i, m)
				Next
				densesolver.rmatrixsolvels(fmatrix, n, m, b, 10000 * Math.machineepsilon, info, _
					srep, x)
				taskrcond = srep.r2
			End If
		End Sub


	End Class
	Public Class ratint
		'************************************************************************
'        Barycentric interpolant.
'        ************************************************************************

		Public Class barycentricinterpolant
			Inherits apobject
			Public n As Integer
			Public sy As Double
			Public x As Double()
			Public y As Double()
			Public w As Double()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x = New Double(-1) {}
				y = New Double(-1) {}
				w = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New barycentricinterpolant()
				_result.n = n
				_result.sy = sy
				_result.x = DirectCast(x.Clone(), Double())
				_result.y = DirectCast(y.Clone(), Double())
				_result.w = DirectCast(w.Clone(), Double())
				Return _result
			End Function
		End Class




		'************************************************************************
'        Rational interpolation using barycentric formula
'
'        F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'        Input parameters:
'            B   -   barycentric interpolant built with one of model building
'                    subroutines.
'            T   -   interpolation point
'
'        Result:
'            barycentric interpolant F(t)
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function barycentriccalc(b As barycentricinterpolant, t As Double) As Double
			Dim result As Double = 0
			Dim s1 As Double = 0
			Dim s2 As Double = 0
			Dim s As Double = 0
			Dim v As Double = 0
			Dim i As Integer = 0

			alglib.ap.assert(Not [Double].IsInfinity(t), "BarycentricCalc: infinite T!")

			'
			' special case: NaN
			'
			If [Double].IsNaN(t) Then
				result = [Double].NaN
				Return result
			End If

			'
			' special case: N=1
			'
			If b.n = 1 Then
				result = b.sy * b.y(0)
				Return result
			End If

			'
			' Here we assume that task is normalized, i.e.:
			' 1. abs(Y[i])<=1
			' 2. abs(W[i])<=1
			' 3. X[] is ordered
			'
			s = System.Math.Abs(t - b.x(0))
			For i = 0 To b.n - 1
				v = b.x(i)
				If CDbl(v) = CDbl(t) Then
					result = b.sy * b.y(i)
					Return result
				End If
				v = System.Math.Abs(t - v)
				If CDbl(v) < CDbl(s) Then
					s = v
				End If
			Next
			s1 = 0
			s2 = 0
			For i = 0 To b.n - 1
				v = s / (t - b.x(i))
				v = v * b.w(i)
				s1 = s1 + v * b.y(i)
				s2 = s2 + v
			Next
			result = b.sy * s1 / s2
			Return result
		End Function


		'************************************************************************
'        Differentiation of barycentric interpolant: first derivative.
'
'        Algorithm used in this subroutine is very robust and should not fail until
'        provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
'        or greater will overflow).
'
'        INPUT PARAMETERS:
'            B   -   barycentric interpolant built with one of model building
'                    subroutines.
'            T   -   interpolation point
'
'        OUTPUT PARAMETERS:
'            F   -   barycentric interpolant at T
'            DF  -   first derivative
'            
'        NOTE
'
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricdiff1(b As barycentricinterpolant, t As Double, ByRef f As Double, ByRef df As Double)
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim n0 As Double = 0
			Dim n1 As Double = 0
			Dim d0 As Double = 0
			Dim d1 As Double = 0
			Dim s0 As Double = 0
			Dim s1 As Double = 0
			Dim xk As Double = 0
			Dim xi As Double = 0
			Dim xmin As Double = 0
			Dim xmax As Double = 0
			Dim xscale1 As Double = 0
			Dim xoffs1 As Double = 0
			Dim xscale2 As Double = 0
			Dim xoffs2 As Double = 0
			Dim xprev As Double = 0

			f = 0
			df = 0

			alglib.ap.assert(Not [Double].IsInfinity(t), "BarycentricDiff1: infinite T!")

			'
			' special case: NaN
			'
			If [Double].IsNaN(t) Then
				f = [Double].NaN
				df = [Double].NaN
				Return
			End If

			'
			' special case: N=1
			'
			If b.n = 1 Then
				f = b.sy * b.y(0)
				df = 0
				Return
			End If
			If CDbl(b.sy) = CDbl(0) Then
				f = 0
				df = 0
				Return
			End If
			alglib.ap.assert(CDbl(b.sy) > CDbl(0), "BarycentricDiff1: internal error")

			'
			' We assume than N>1 and B.SY>0. Find:
			' 1. pivot point (X[i] closest to T)
			' 2. width of interval containing X[i]
			'
			v = System.Math.Abs(b.x(0) - t)
			k = 0
			xmin = b.x(0)
			xmax = b.x(0)
			For i = 1 To b.n - 1
				vv = b.x(i)
				If CDbl(System.Math.Abs(vv - t)) < CDbl(v) Then
					v = System.Math.Abs(vv - t)
					k = i
				End If
				xmin = System.Math.Min(xmin, vv)
				xmax = System.Math.Max(xmax, vv)
			Next

			'
			' pivot point found, calculate dNumerator and dDenominator
			'
			xscale1 = 1 / (xmax - xmin)
			xoffs1 = -(xmin / (xmax - xmin)) + 1
			xscale2 = 2
			xoffs2 = -3
			t = t * xscale1 + xoffs1
			t = t * xscale2 + xoffs2
			xk = b.x(k)
			xk = xk * xscale1 + xoffs1
			xk = xk * xscale2 + xoffs2
			v = t - xk
			n0 = 0
			n1 = 0
			d0 = 0
			d1 = 0
			xprev = -2
			For i = 0 To b.n - 1
				xi = b.x(i)
				xi = xi * xscale1 + xoffs1
				xi = xi * xscale2 + xoffs2
				alglib.ap.assert(CDbl(xi) > CDbl(xprev), "BarycentricDiff1: points are too close!")
				xprev = xi
				If i <> k Then
					vv = Math.sqr(t - xi)
					s0 = (t - xk) / (t - xi)
					s1 = (xk - xi) / vv
				Else
					s0 = 1
					s1 = 0
				End If
				vv = b.w(i) * b.y(i)
				n0 = n0 + s0 * vv
				n1 = n1 + s1 * vv
				vv = b.w(i)
				d0 = d0 + s0 * vv
				d1 = d1 + s1 * vv
			Next
			f = b.sy * n0 / d0
			df = (n1 * d0 - n0 * d1) / Math.sqr(d0)
			If CDbl(df) <> CDbl(0) Then
				df = System.Math.Sign(df) * System.Math.Exp(System.Math.Log(System.Math.Abs(df)) + System.Math.Log(b.sy) + System.Math.Log(xscale1) + System.Math.Log(xscale2))
			End If
		End Sub


		'************************************************************************
'        Differentiation of barycentric interpolant: first/second derivatives.
'
'        INPUT PARAMETERS:
'            B   -   barycentric interpolant built with one of model building
'                    subroutines.
'            T   -   interpolation point
'
'        OUTPUT PARAMETERS:
'            F   -   barycentric interpolant at T
'            DF  -   first derivative
'            D2F -   second derivative
'
'        NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
'        whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
'        BarycentricDiff1() subroutine in such cases.
'
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricdiff2(b As barycentricinterpolant, t As Double, ByRef f As Double, ByRef df As Double, ByRef d2f As Double)
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim n0 As Double = 0
			Dim n1 As Double = 0
			Dim n2 As Double = 0
			Dim d0 As Double = 0
			Dim d1 As Double = 0
			Dim d2 As Double = 0
			Dim s0 As Double = 0
			Dim s1 As Double = 0
			Dim s2 As Double = 0
			Dim xk As Double = 0
			Dim xi As Double = 0

			f = 0
			df = 0
			d2f = 0

			alglib.ap.assert(Not [Double].IsInfinity(t), "BarycentricDiff1: infinite T!")

			'
			' special case: NaN
			'
			If [Double].IsNaN(t) Then
				f = [Double].NaN
				df = [Double].NaN
				d2f = [Double].NaN
				Return
			End If

			'
			' special case: N=1
			'
			If b.n = 1 Then
				f = b.sy * b.y(0)
				df = 0
				d2f = 0
				Return
			End If
			If CDbl(b.sy) = CDbl(0) Then
				f = 0
				df = 0
				d2f = 0
				Return
			End If

			'
			' We assume than N>1 and B.SY>0. Find:
			' 1. pivot point (X[i] closest to T)
			' 2. width of interval containing X[i]
			'
			alglib.ap.assert(CDbl(b.sy) > CDbl(0), "BarycentricDiff: internal error")
			f = 0
			df = 0
			d2f = 0
			v = System.Math.Abs(b.x(0) - t)
			k = 0
			For i = 1 To b.n - 1
				vv = b.x(i)
				If CDbl(System.Math.Abs(vv - t)) < CDbl(v) Then
					v = System.Math.Abs(vv - t)
					k = i
				End If
			Next

			'
			' pivot point found, calculate dNumerator and dDenominator
			'
			xk = b.x(k)
			v = t - xk
			n0 = 0
			n1 = 0
			n2 = 0
			d0 = 0
			d1 = 0
			d2 = 0
			For i = 0 To b.n - 1
				If i <> k Then
					xi = b.x(i)
					vv = Math.sqr(t - xi)
					s0 = (t - xk) / (t - xi)
					s1 = (xk - xi) / vv
					s2 = -(2 * (xk - xi) / (vv * (t - xi)))
				Else
					s0 = 1
					s1 = 0
					s2 = 0
				End If
				vv = b.w(i) * b.y(i)
				n0 = n0 + s0 * vv
				n1 = n1 + s1 * vv
				n2 = n2 + s2 * vv
				vv = b.w(i)
				d0 = d0 + s0 * vv
				d1 = d1 + s1 * vv
				d2 = d2 + s2 * vv
			Next
			f = b.sy * n0 / d0
			df = b.sy * (n1 * d0 - n0 * d1) / Math.sqr(d0)
			d2f = b.sy * ((n2 * d0 - n0 * d2) * Math.sqr(d0) - (n1 * d0 - n0 * d1) * 2 * d0 * d1) / Math.sqr(Math.sqr(d0))
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the argument.
'
'        INPUT PARAMETERS:
'            B       -   rational interpolant in barycentric form
'            CA, CB  -   transformation coefficients: x = CA*t + CB
'
'        OUTPUT PARAMETERS:
'            B       -   transformed interpolant with X replaced by T
'
'          -- ALGLIB PROJECT --
'             Copyright 19.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentriclintransx(b As barycentricinterpolant, ca As Double, cb As Double)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0


			'
			' special case, replace by constant F(CB)
			'
			If CDbl(ca) = CDbl(0) Then
				b.sy = barycentriccalc(b, cb)
				v = 1
				For i = 0 To b.n - 1
					b.y(i) = 1
					b.w(i) = v
					v = -v
				Next
				Return
			End If

			'
			' general case: CA<>0
			'
			For i = 0 To b.n - 1
				b.x(i) = (b.x(i) - cb) / ca
			Next
			If CDbl(ca) < CDbl(0) Then
				For i = 0 To b.n - 1
					If i < b.n - 1 - i Then
						j = b.n - 1 - i
						v = b.x(i)
						b.x(i) = b.x(j)
						b.x(j) = v
						v = b.y(i)
						b.y(i) = b.y(j)
						b.y(j) = v
						v = b.w(i)
						b.w(i) = b.w(j)
						b.w(j) = v
					Else
						Exit For
					End If
				Next
			End If
		End Sub


		'************************************************************************
'        This  subroutine   performs   linear  transformation  of  the  barycentric
'        interpolant.
'
'        INPUT PARAMETERS:
'            B       -   rational interpolant in barycentric form
'            CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
'
'        OUTPUT PARAMETERS:
'            B       -   transformed interpolant
'
'          -- ALGLIB PROJECT --
'             Copyright 19.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentriclintransy(b As barycentricinterpolant, ca As Double, cb As Double)
			Dim i As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0

			For i = 0 To b.n - 1
				b.y(i) = ca * b.sy * b.y(i) + cb
			Next
			b.sy = 0
			For i = 0 To b.n - 1
				b.sy = System.Math.Max(b.sy, System.Math.Abs(b.y(i)))
			Next
			If CDbl(b.sy) > CDbl(0) Then
				v = 1 / b.sy
				For i_ = 0 To b.n - 1
					b.y(i_) = v * b.y(i_)
				Next
			End If
		End Sub


		'************************************************************************
'        Extracts X/Y/W arrays from rational interpolant
'
'        INPUT PARAMETERS:
'            B   -   barycentric interpolant
'
'        OUTPUT PARAMETERS:
'            N   -   nodes count, N>0
'            X   -   interpolation nodes, array[0..N-1]
'            F   -   function values, array[0..N-1]
'            W   -   barycentric weights, array[0..N-1]
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricunpack(b As barycentricinterpolant, ByRef n As Integer, ByRef x As Double(), ByRef y As Double(), ByRef w As Double())
			Dim v As Double = 0
			Dim i_ As Integer = 0

			n = 0
			x = New Double(-1) {}
			y = New Double(-1) {}
			w = New Double(-1) {}

			n = b.n
			x = New Double(n - 1) {}
			y = New Double(n - 1) {}
			w = New Double(n - 1) {}
			v = b.sy
			For i_ = 0 To n - 1
				x(i_) = b.x(i_)
			Next
			For i_ = 0 To n - 1
				y(i_) = v * b.y(i_)
			Next
			For i_ = 0 To n - 1
				w(i_) = b.w(i_)
			Next
		End Sub


		'************************************************************************
'        Rational interpolant from X/Y/W arrays
'
'        F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'        INPUT PARAMETERS:
'            X   -   interpolation nodes, array[0..N-1]
'            F   -   function values, array[0..N-1]
'            W   -   barycentric weights, array[0..N-1]
'            N   -   nodes count, N>0
'
'        OUTPUT PARAMETERS:
'            B   -   barycentric interpolant built from (X, Y, W)
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricbuildxyw(x As Double(), y As Double(), w As Double(), n As Integer, b As barycentricinterpolant)
			Dim i_ As Integer = 0

			alglib.ap.assert(n > 0, "BarycentricBuildXYW: incorrect N!")

			'
			' fill X/Y/W
			'
			b.x = New Double(n - 1) {}
			b.y = New Double(n - 1) {}
			b.w = New Double(n - 1) {}
			For i_ = 0 To n - 1
				b.x(i_) = x(i_)
			Next
			For i_ = 0 To n - 1
				b.y(i_) = y(i_)
			Next
			For i_ = 0 To n - 1
				b.w(i_) = w(i_)
			Next
			b.n = n

			'
			' Normalize
			'
			barycentricnormalize(b)
		End Sub


		'************************************************************************
'        Rational interpolant without poles
'
'        The subroutine constructs the rational interpolating function without real
'        poles  (see  'Barycentric rational interpolation with no  poles  and  high
'        rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
'        information on this subject).
'
'        Input parameters:
'            X   -   interpolation nodes, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            N   -   number of nodes, N>0.
'            D   -   order of the interpolation scheme, 0 <= D <= N-1.
'                    D<0 will cause an error.
'                    D>=N it will be replaced with D=N-1.
'                    if you don't know what D to choose, use small value about 3-5.
'
'        Output parameters:
'            B   -   barycentric interpolant.
'
'        Note:
'            this algorithm always succeeds and calculates the weights  with  close
'            to machine precision.
'
'          -- ALGLIB PROJECT --
'             Copyright 17.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricbuildfloaterhormann(x As Double(), y As Double(), n As Integer, d As Integer, b As barycentricinterpolant)
			Dim s0 As Double = 0
			Dim s As Double = 0
			Dim v As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim perm As Integer() = New Integer(-1) {}
			Dim wtemp As Double() = New Double(-1) {}
			Dim sortrbuf As Double() = New Double(-1) {}
			Dim sortrbuf2 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			alglib.ap.assert(n > 0, "BarycentricFloaterHormann: N<=0!")
			alglib.ap.assert(d >= 0, "BarycentricFloaterHormann: incorrect D!")

			'
			' Prepare
			'
			If d > n - 1 Then
				d = n - 1
			End If
			b.n = n

			'
			' special case: N=1
			'
			If n = 1 Then
				b.x = New Double(n - 1) {}
				b.y = New Double(n - 1) {}
				b.w = New Double(n - 1) {}
				b.x(0) = x(0)
				b.y(0) = y(0)
				b.w(0) = 1
				barycentricnormalize(b)
				Return
			End If

			'
			' Fill X/Y
			'
			b.x = New Double(n - 1) {}
			b.y = New Double(n - 1) {}
			For i_ = 0 To n - 1
				b.x(i_) = x(i_)
			Next
			For i_ = 0 To n - 1
				b.y(i_) = y(i_)
			Next
			tsort.tagsortfastr(b.x, b.y, sortrbuf, sortrbuf2, n)

			'
			' Calculate Wk
			'
			b.w = New Double(n - 1) {}
			s0 = 1
			For k = 1 To d
				s0 = -s0
			Next
			For k = 0 To n - 1

				'
				' Wk
				'
				s = 0
				For i = System.Math.Max(k - d, 0) To System.Math.Min(k, n - 1 - d)
					v = 1
					For j = i To i + d
						If j <> k Then
							v = v / System.Math.Abs(b.x(k) - b.x(j))
						End If
					Next
					s = s + v
				Next
				b.w(k) = s0 * s

				'
				' Next S0
				'
				s0 = -s0
			Next

			'
			' Normalize
			'
			barycentricnormalize(b)
		End Sub


		'************************************************************************
'        Copying of the barycentric interpolant (for internal use only)
'
'        INPUT PARAMETERS:
'            B   -   barycentric interpolant
'
'        OUTPUT PARAMETERS:
'            B2  -   copy(B1)
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentriccopy(b As barycentricinterpolant, b2 As barycentricinterpolant)
			Dim i_ As Integer = 0

			b2.n = b.n
			b2.sy = b.sy
			b2.x = New Double(b2.n - 1) {}
			b2.y = New Double(b2.n - 1) {}
			b2.w = New Double(b2.n - 1) {}
			For i_ = 0 To b2.n - 1
				b2.x(i_) = b.x(i_)
			Next
			For i_ = 0 To b2.n - 1
				b2.y(i_) = b.y(i_)
			Next
			For i_ = 0 To b2.n - 1
				b2.w(i_) = b.w(i_)
			Next
		End Sub


		'************************************************************************
'        Normalization of barycentric interpolant:
'        * B.N, B.X, B.Y and B.W are initialized
'        * B.SY is NOT initialized
'        * Y[] is normalized, scaling coefficient is stored in B.SY
'        * W[] is normalized, no scaling coefficient is stored
'        * X[] is sorted
'
'        Internal subroutine.
'        ************************************************************************

		Private Shared Sub barycentricnormalize(b As barycentricinterpolant)
			Dim p1 As Integer() = New Integer(-1) {}
			Dim p2 As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim j2 As Integer = 0
			Dim v As Double = 0
			Dim i_ As Integer = 0


			'
			' Normalize task: |Y|<=1, |W|<=1, sort X[]
			'
			b.sy = 0
			For i = 0 To b.n - 1
				b.sy = System.Math.Max(b.sy, System.Math.Abs(b.y(i)))
			Next
			If CDbl(b.sy) > CDbl(0) AndAlso CDbl(System.Math.Abs(b.sy - 1)) > CDbl(10 * Math.machineepsilon) Then
				v = 1 / b.sy
				For i_ = 0 To b.n - 1
					b.y(i_) = v * b.y(i_)
				Next
			End If
			v = 0
			For i = 0 To b.n - 1
				v = System.Math.Max(v, System.Math.Abs(b.w(i)))
			Next
			If CDbl(v) > CDbl(0) AndAlso CDbl(System.Math.Abs(v - 1)) > CDbl(10 * Math.machineepsilon) Then
				v = 1 / v
				For i_ = 0 To b.n - 1
					b.w(i_) = v * b.w(i_)
				Next
			End If
			For i = 0 To b.n - 2
				If CDbl(b.x(i + 1)) < CDbl(b.x(i)) Then
					tsort.tagsort(b.x, b.n, p1, p2)
					For j = 0 To b.n - 1
						j2 = p2(j)
						v = b.y(j)
						b.y(j) = b.y(j2)
						b.y(j2) = v
						v = b.w(j)
						b.w(j) = b.w(j2)
						b.w(j2) = v
					Next
					Exit For
				End If
			Next
		End Sub


	End Class
	Public Class polint
		'************************************************************************
'        Conversion from barycentric representation to Chebyshev basis.
'        This function has O(N^2) complexity.
'
'        INPUT PARAMETERS:
'            P   -   polynomial in barycentric form
'            A,B -   base interval for Chebyshev polynomials (see below)
'                    A<>B
'
'        OUTPUT PARAMETERS
'            T   -   coefficients of Chebyshev representation;
'                    P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
'                    where Ti - I-th Chebyshev polynomial.
'
'        NOTES:
'            barycentric interpolant passed as P may be either polynomial  obtained
'            from  polynomial  interpolation/ fitting or rational function which is
'            NOT polynomial. We can't distinguish between these two cases, and this
'            algorithm just tries to work assuming that P IS a polynomial.  If not,
'            algorithm will return results, but they won't have any meaning.
'
'          -- ALGLIB --
'             Copyright 30.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbar2cheb(p As ratint.barycentricinterpolant, a As Double, b As Double, ByRef t As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim vp As Double() = New Double(-1) {}
			Dim vx As Double() = New Double(-1) {}
			Dim tk As Double() = New Double(-1) {}
			Dim tk1 As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim i_ As Integer = 0

			t = New Double(-1) {}

			alglib.ap.assert(Math.isfinite(a), "PolynomialBar2Cheb: A is not finite!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialBar2Cheb: B is not finite!")
			alglib.ap.assert(CDbl(a) <> CDbl(b), "PolynomialBar2Cheb: A=B!")
			alglib.ap.assert(p.n > 0, "PolynomialBar2Cheb: P is not correctly initialized barycentric interpolant!")

			'
			' Calculate function values on a Chebyshev grid
			'
			vp = New Double(p.n - 1) {}
			vx = New Double(p.n - 1) {}
			For i = 0 To p.n - 1
				vx(i) = System.Math.Cos(System.Math.PI * (i + 0.5) / p.n)
				vp(i) = ratint.barycentriccalc(p, 0.5 * (vx(i) + 1) * (b - a) + a)
			Next

			'
			' T[0]
			'
			t = New Double(p.n - 1) {}
			v = 0
			For i = 0 To p.n - 1
				v = v + vp(i)
			Next
			t(0) = v / p.n

			'
			' other T's.
			'
			' NOTES:
			' 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
			' 2. we can do same calculations with fast DCT, but it
			'    * adds dependencies
			'    * still leaves us with O(N^2) algorithm because
			'      preparation of function values is O(N^2) process
			'
			If p.n > 1 Then
				tk = New Double(p.n - 1) {}
				tk1 = New Double(p.n - 1) {}
				For i = 0 To p.n - 1
					tk(i) = vx(i)
					tk1(i) = 1
				Next
				For k = 1 To p.n - 1

					'
					' calculate discrete product of function vector and TK
					'
					v = 0.0
					For i_ = 0 To p.n - 1
						v += tk(i_) * vp(i_)
					Next
					t(k) = v / (0.5 * p.n)

					'
					' Update TK and TK1
					'
					For i = 0 To p.n - 1
						v = 2 * vx(i) * tk(i) - tk1(i)
						tk1(i) = tk(i)
						tk(i) = v
					Next
				Next
			End If
		End Sub


		'************************************************************************
'        Conversion from Chebyshev basis to barycentric representation.
'        This function has O(N^2) complexity.
'
'        INPUT PARAMETERS:
'            T   -   coefficients of Chebyshev representation;
'                    P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
'                    where Ti - I-th Chebyshev polynomial.
'            N   -   number of coefficients:
'                    * if given, only leading N elements of T are used
'                    * if not given, automatically determined from size of T
'            A,B -   base interval for Chebyshev polynomials (see above)
'                    A<B
'
'        OUTPUT PARAMETERS
'            P   -   polynomial in barycentric form
'
'          -- ALGLIB --
'             Copyright 30.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialcheb2bar(t As Double(), n As Integer, a As Double, b As Double, p As ratint.barycentricinterpolant)
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim y As Double() = New Double(-1) {}
			Dim tk As Double = 0
			Dim tk1 As Double = 0
			Dim vx As Double = 0
			Dim vy As Double = 0
			Dim v As Double = 0

			alglib.ap.assert(Math.isfinite(a), "PolynomialBar2Cheb: A is not finite!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialBar2Cheb: B is not finite!")
			alglib.ap.assert(CDbl(a) <> CDbl(b), "PolynomialBar2Cheb: A=B!")
			alglib.ap.assert(n >= 1, "PolynomialBar2Cheb: N<1")
			alglib.ap.assert(alglib.ap.len(t) >= n, "PolynomialBar2Cheb: Length(T)<N")
			alglib.ap.assert(apserv.isfinitevector(t, n), "PolynomialBar2Cheb: T[] contains INF or NAN")

			'
			' Calculate function values on a Chebyshev grid spanning [-1,+1]
			'
			y = New Double(n - 1) {}
			For i = 0 To n - 1

				'
				' Calculate value on a grid spanning [-1,+1]
				'
				vx = System.Math.Cos(System.Math.PI * (i + 0.5) / n)
				vy = t(0)
				tk1 = 1
				tk = vx
				For k = 1 To n - 1
					vy = vy + t(k) * tk
					v = 2 * vx * tk - tk1
					tk1 = tk
					tk = v
				Next
				y(i) = vy
			Next

			'
			' Build barycentric interpolant, map grid from [-1,+1] to [A,B]
			'
			polynomialbuildcheb1(a, b, y, n, p)
		End Sub


		'************************************************************************
'        Conversion from barycentric representation to power basis.
'        This function has O(N^2) complexity.
'
'        INPUT PARAMETERS:
'            P   -   polynomial in barycentric form
'            C   -   offset (see below); 0.0 is used as default value.
'            S   -   scale (see below);  1.0 is used as default value. S<>0.
'
'        OUTPUT PARAMETERS
'            A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
'            N   -   number of coefficients (polynomial degree plus 1)
'
'        NOTES:
'        1.  this function accepts offset and scale, which can be  set  to  improve
'            numerical properties of polynomial. For example, if P was obtained  as
'            result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
'            represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
'            is exactly what you need.
'
'            However, if your interpolation model was built on [999,1001], you will
'            see significant growth of numerical errors when using {1, x, x^2, x^3}
'            as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
'            will be better option. Such representation can be  obtained  by  using
'            1000.0 as offset C and 1.0 as scale S.
'
'        2.  power basis is ill-conditioned and tricks described above can't  solve
'            this problem completely. This function  will  return  coefficients  in
'            any  case,  but  for  N>8  they  will  become unreliable. However, N's
'            less than 5 are pretty safe.
'            
'        3.  barycentric interpolant passed as P may be either polynomial  obtained
'            from  polynomial  interpolation/ fitting or rational function which is
'            NOT polynomial. We can't distinguish between these two cases, and this
'            algorithm just tries to work assuming that P IS a polynomial.  If not,
'            algorithm will return results, but they won't have any meaning.
'
'          -- ALGLIB --
'             Copyright 30.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbar2pow(p As ratint.barycentricinterpolant, c As Double, s As Double, ByRef a As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim e As Double = 0
			Dim d As Double = 0
			Dim vp As Double() = New Double(-1) {}
			Dim vx As Double() = New Double(-1) {}
			Dim tk As Double() = New Double(-1) {}
			Dim tk1 As Double() = New Double(-1) {}
			Dim t As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim c0 As Double = 0
			Dim s0 As Double = 0
			Dim va As Double = 0
			Dim vb As Double = 0
			Dim vai As Double() = New Double(-1) {}
			Dim vbi As Double() = New Double(-1) {}
			Dim minx As Double = 0
			Dim maxx As Double = 0
			Dim i_ As Integer = 0

			a = New Double(-1) {}


			'
			' We have barycentric model built using set of points X[], and we
			' want to convert it to power basis centered about point  C  with
			' scale S: I-th basis function is ((X-C)/S)^i.
			'
			' We use following three-stage algorithm:
			'
			' 1. we build Chebyshev representation of polynomial using
			'    intermediate center C0 and scale S0, which are derived from X[]:
			'    C0 = 0.5*(min(X)+max(X)), S0 = 0.5*(max(X)-min(X)). Chebyshev
			'    representation is built by sampling points around center C0,
			'    with typical distance between them proportional to S0.
			' 2. then we transform form Chebyshev basis to intermediate power
			'    basis, using same center/scale C0/S0.
			' 3. after that, we apply linear transformation to intermediate
			'    power basis which moves it to final center/scale C/S.
			'
			' The idea of such multi-stage algorithm is that it is much easier to
			' transform barycentric model to Chebyshev basis, and only later to
			' power basis, than transforming it directly to power basis. It is
			' also more numerically stable to sample points using intermediate C0/S0,
			' which are derived from user-supplied model, than using "final" C/S,
			' which may be unsuitable for sampling (say, if S=1, we may have stability
			' problems when working with models built from dataset with non-unit
			' scale of abscissas).
			'
			alglib.ap.assert(Math.isfinite(c), "PolynomialBar2Pow: C is not finite!")
			alglib.ap.assert(Math.isfinite(s), "PolynomialBar2Pow: S is not finite!")
			alglib.ap.assert(CDbl(s) <> CDbl(0), "PolynomialBar2Pow: S=0!")
			alglib.ap.assert(p.n > 0, "PolynomialBar2Pow: P is not correctly initialized barycentric interpolant!")

			'
			' Select intermediate center/scale
			'
			minx = p.x(0)
			maxx = p.x(0)
			For i = 1 To p.n - 1
				minx = System.Math.Min(minx, p.x(i))
				maxx = System.Math.Max(maxx, p.x(i))
			Next
			If CDbl(minx) = CDbl(maxx) Then
				c0 = minx
				s0 = 1.0
			Else
				c0 = 0.5 * (maxx + minx)
				s0 = 0.5 * (maxx - minx)
			End If

			'
			' Calculate function values on a Chebyshev grid using intermediate C0/S0
			'
			vp = New Double(p.n) {}
			vx = New Double(p.n - 1) {}
			For i = 0 To p.n - 1
				vx(i) = System.Math.Cos(System.Math.PI * (i + 0.5) / p.n)
				vp(i) = ratint.barycentriccalc(p, s0 * vx(i) + c0)
			Next

			'
			' T[0]
			'
			t = New Double(p.n - 1) {}
			v = 0
			For i = 0 To p.n - 1
				v = v + vp(i)
			Next
			t(0) = v / p.n

			'
			' other T's.
			'
			' NOTES:
			' 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
			' 2. we can do same calculations with fast DCT, but it
			'    * adds dependencies
			'    * still leaves us with O(N^2) algorithm because
			'      preparation of function values is O(N^2) process
			'
			If p.n > 1 Then
				tk = New Double(p.n - 1) {}
				tk1 = New Double(p.n - 1) {}
				For i = 0 To p.n - 1
					tk(i) = vx(i)
					tk1(i) = 1
				Next
				For k = 1 To p.n - 1

					'
					' calculate discrete product of function vector and TK
					'
					v = 0.0
					For i_ = 0 To p.n - 1
						v += tk(i_) * vp(i_)
					Next
					t(k) = v / (0.5 * p.n)

					'
					' Update TK and TK1
					'
					For i = 0 To p.n - 1
						v = 2 * vx(i) * tk(i) - tk1(i)
						tk1(i) = tk(i)
						tk(i) = v
					Next
				Next
			End If

			'
			' Convert from Chebyshev basis to power basis
			'
			a = New Double(p.n - 1) {}
			For i = 0 To p.n - 1
				a(i) = 0
			Next
			d = 0
			For i = 0 To p.n - 1
				For k = i To p.n - 1
					e = a(k)
					a(k) = 0
					If i <= 1 AndAlso k = i Then
						a(k) = 1
					Else
						If i <> 0 Then
							a(k) = 2 * d
						End If
						If k > i + 1 Then
							a(k) = a(k) - a(k - 2)
						End If
					End If
					d = e
				Next
				d = a(i)
				e = 0
				k = i
				While k <= p.n - 1
					e = e + a(k) * t(k)
					k = k + 2
				End While
				a(i) = e
			Next

			'
			' Apply linear transformation which converts basis from intermediate
			' one Fi=((x-C0)/S0)^i to final one Fi=((x-C)/S)^i.
			'
			' We have y=(x-C0)/S0, z=(x-C)/S, and coefficients A[] for basis Fi(y).
			' Because we have y=A*z+B, for A=s/s0 and B=c/s0-c0/s0, we can perform
			' substitution and get coefficients A_new[] in basis Fi(z).
			'
			alglib.ap.assert(alglib.ap.len(vp) >= p.n + 1, "PolynomialBar2Pow: internal error")
			alglib.ap.assert(alglib.ap.len(t) >= p.n, "PolynomialBar2Pow: internal error")
			For i = 0 To p.n - 1
				t(i) = 0.0
			Next
			va = s / s0
			vb = c / s0 - c0 / s0
			vai = New Double(p.n - 1) {}
			vbi = New Double(p.n - 1) {}
			vai(0) = 1
			vbi(0) = 1
			For k = 1 To p.n - 1
				vai(k) = vai(k - 1) * va
				vbi(k) = vbi(k - 1) * vb
			Next
			For k = 0 To p.n - 1

				'
				' Generate set of binomial coefficients in VP[]
				'
				If k > 0 Then
					vp(k) = 1
					For i = k - 1 To 1 Step -1
						vp(i) = vp(i) + vp(i - 1)
					Next
					vp(0) = 1
				Else
					vp(0) = 1
				End If

				'
				' Update T[] with expansion of K-th basis function
				'
				For i = 0 To k
					t(i) = t(i) + a(k) * vai(i) * vbi(k - i) * vp(i)
				Next
			Next
			For k = 0 To p.n - 1
				a(k) = t(k)
			Next
		End Sub


		'************************************************************************
'        Conversion from power basis to barycentric representation.
'        This function has O(N^2) complexity.
'
'        INPUT PARAMETERS:
'            A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
'            N   -   number of coefficients (polynomial degree plus 1)
'                    * if given, only leading N elements of A are used
'                    * if not given, automatically determined from size of A
'            C   -   offset (see below); 0.0 is used as default value.
'            S   -   scale (see below);  1.0 is used as default value. S<>0.
'
'        OUTPUT PARAMETERS
'            P   -   polynomial in barycentric form
'
'
'        NOTES:
'        1.  this function accepts offset and scale, which can be  set  to  improve
'            numerical properties of polynomial. For example, if you interpolate on
'            [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
'            x^3 and so on. In most cases you it is exactly what you need.
'
'            However, if your interpolation model was built on [999,1001], you will
'            see significant growth of numerical errors when using {1, x, x^2, x^3}
'            as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
'            (x-1000)^3 will be better option (you have to specify 1000.0 as offset
'            C and 1.0 as scale S).
'
'        2.  power basis is ill-conditioned and tricks described above can't  solve
'            this problem completely. This function  will  return barycentric model
'            in any case, but for N>8 accuracy well degrade. However, N's less than
'            5 are pretty safe.
'
'          -- ALGLIB --
'             Copyright 30.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialpow2bar(a As Double(), n As Integer, c As Double, s As Double, p As ratint.barycentricinterpolant)
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim y As Double() = New Double(-1) {}
			Dim vx As Double = 0
			Dim vy As Double = 0
			Dim px As Double = 0

			alglib.ap.assert(Math.isfinite(c), "PolynomialPow2Bar: C is not finite!")
			alglib.ap.assert(Math.isfinite(s), "PolynomialPow2Bar: S is not finite!")
			alglib.ap.assert(CDbl(s) <> CDbl(0), "PolynomialPow2Bar: S is zero!")
			alglib.ap.assert(n >= 1, "PolynomialPow2Bar: N<1")
			alglib.ap.assert(alglib.ap.len(a) >= n, "PolynomialPow2Bar: Length(A)<N")
			alglib.ap.assert(apserv.isfinitevector(a, n), "PolynomialPow2Bar: A[] contains INF or NAN")

			'
			' Calculate function values on a Chebyshev grid spanning [-1,+1]
			'
			y = New Double(n - 1) {}
			For i = 0 To n - 1

				'
				' Calculate value on a grid spanning [-1,+1]
				'
				vx = System.Math.Cos(System.Math.PI * (i + 0.5) / n)
				vy = a(0)
				px = vx
				For k = 1 To n - 1
					vy = vy + px * a(k)
					px = px * vx
				Next
				y(i) = vy
			Next

			'
			' Build barycentric interpolant, map grid from [-1,+1] to [A,B]
			'
			polynomialbuildcheb1(c - s, c + s, y, n, p)
		End Sub


		'************************************************************************
'        Lagrange intepolant: generation of the model on the general grid.
'        This function has O(N^2) complexity.
'
'        INPUT PARAMETERS:
'            X   -   abscissas, array[0..N-1]
'            Y   -   function values, array[0..N-1]
'            N   -   number of points, N>=1
'
'        OUTPUT PARAMETERS
'            P   -   barycentric model which represents Lagrange interpolant
'                    (see ratint unit info and BarycentricCalc() description for
'                    more information).
'
'          -- ALGLIB --
'             Copyright 02.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbuild(x As Double(), y As Double(), n As Integer, p As ratint.barycentricinterpolant)
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim b As Double = 0
			Dim a As Double = 0
			Dim v As Double = 0
			Dim mx As Double = 0
			Dim sortrbuf As Double() = New Double(-1) {}
			Dim sortrbuf2 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())

			alglib.ap.assert(n > 0, "PolynomialBuild: N<=0!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "PolynomialBuild: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialBuild: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "PolynomialBuild: X contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialBuild: Y contains infinite or NaN values!")
			tsort.tagsortfastr(x, y, sortrbuf, sortrbuf2, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "PolynomialBuild: at least two consequent points are too close!")

			'
			' calculate W[j]
			' multi-pass algorithm is used to avoid overflow
			'
			w = New Double(n - 1) {}
			a = x(0)
			b = x(0)
			For j = 0 To n - 1
				w(j) = 1
				a = System.Math.Min(a, x(j))
				b = System.Math.Max(b, x(j))
			Next
			For k = 0 To n - 1

				'
				' W[K] is used instead of 0.0 because
				' cycle on J does not touch K-th element
				' and we MUST get maximum from ALL elements
				'
				mx = System.Math.Abs(w(k))
				For j = 0 To n - 1
					If j <> k Then
						v = (b - a) / (x(j) - x(k))
						w(j) = w(j) * v
						mx = System.Math.Max(mx, System.Math.Abs(w(j)))
					End If
				Next
				If k Mod 5 = 0 Then

					'
					' every 5-th run we renormalize W[]
					'
					v = 1 / mx
					For i_ = 0 To n - 1
						w(i_) = v * w(i_)
					Next
				End If
			Next
			ratint.barycentricbuildxyw(x, y, w, n, p)
		End Sub


		'************************************************************************
'        Lagrange intepolant: generation of the model on equidistant grid.
'        This function has O(N) complexity.
'
'        INPUT PARAMETERS:
'            A   -   left boundary of [A,B]
'            B   -   right boundary of [A,B]
'            Y   -   function values at the nodes, array[0..N-1]
'            N   -   number of points, N>=1
'                    for N=1 a constant model is constructed.
'
'        OUTPUT PARAMETERS
'            P   -   barycentric model which represents Lagrange interpolant
'                    (see ratint unit info and BarycentricCalc() description for
'                    more information).
'
'          -- ALGLIB --
'             Copyright 03.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbuildeqdist(a As Double, b As Double, y As Double(), n As Integer, p As ratint.barycentricinterpolant)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim x As Double() = New Double(-1) {}
			Dim v As Double = 0

			alglib.ap.assert(n > 0, "PolynomialBuildEqDist: N<=0!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialBuildEqDist: Length(Y)<N!")
			alglib.ap.assert(Math.isfinite(a), "PolynomialBuildEqDist: A is infinite or NaN!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialBuildEqDist: B is infinite or NaN!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialBuildEqDist: Y contains infinite or NaN values!")
			alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialBuildEqDist: B=A!")
			alglib.ap.assert(CDbl(a + (b - a) / n) <> CDbl(a), "PolynomialBuildEqDist: B is too close to A!")

			'
			' Special case: N=1
			'
			If n = 1 Then
				x = New Double(0) {}
				w = New Double(0) {}
				x(0) = 0.5 * (b + a)
				w(0) = 1
				ratint.barycentricbuildxyw(x, y, w, 1, p)
				Return
			End If

			'
			' general case
			'
			x = New Double(n - 1) {}
			w = New Double(n - 1) {}
			v = 1
			For i = 0 To n - 1
				w(i) = v
				x(i) = a + (b - a) * i / (n - 1)
				v = -(v * (n - 1 - i))
				v = v / (i + 1)
			Next
			ratint.barycentricbuildxyw(x, y, w, n, p)
		End Sub


		'************************************************************************
'        Lagrange intepolant on Chebyshev grid (first kind).
'        This function has O(N) complexity.
'
'        INPUT PARAMETERS:
'            A   -   left boundary of [A,B]
'            B   -   right boundary of [A,B]
'            Y   -   function values at the nodes, array[0..N-1],
'                    Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
'            N   -   number of points, N>=1
'                    for N=1 a constant model is constructed.
'
'        OUTPUT PARAMETERS
'            P   -   barycentric model which represents Lagrange interpolant
'                    (see ratint unit info and BarycentricCalc() description for
'                    more information).
'
'          -- ALGLIB --
'             Copyright 03.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbuildcheb1(a As Double, b As Double, y As Double(), n As Integer, p As ratint.barycentricinterpolant)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim x As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim t As Double = 0

			alglib.ap.assert(n > 0, "PolynomialBuildCheb1: N<=0!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialBuildCheb1: Length(Y)<N!")
			alglib.ap.assert(Math.isfinite(a), "PolynomialBuildCheb1: A is infinite or NaN!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialBuildCheb1: B is infinite or NaN!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialBuildCheb1: Y contains infinite or NaN values!")
			alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialBuildCheb1: B=A!")

			'
			' Special case: N=1
			'
			If n = 1 Then
				x = New Double(0) {}
				w = New Double(0) {}
				x(0) = 0.5 * (b + a)
				w(0) = 1
				ratint.barycentricbuildxyw(x, y, w, 1, p)
				Return
			End If

			'
			' general case
			'
			x = New Double(n - 1) {}
			w = New Double(n - 1) {}
			v = 1
			For i = 0 To n - 1
				t = System.Math.Tan(0.5 * System.Math.PI * (2 * i + 1) / (2 * n))
				w(i) = 2 * v * t / (1 + Math.sqr(t))
				x(i) = 0.5 * (b + a) + 0.5 * (b - a) * (1 - Math.sqr(t)) / (1 + Math.sqr(t))
				v = -v
			Next
			ratint.barycentricbuildxyw(x, y, w, n, p)
		End Sub


		'************************************************************************
'        Lagrange intepolant on Chebyshev grid (second kind).
'        This function has O(N) complexity.
'
'        INPUT PARAMETERS:
'            A   -   left boundary of [A,B]
'            B   -   right boundary of [A,B]
'            Y   -   function values at the nodes, array[0..N-1],
'                    Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
'            N   -   number of points, N>=1
'                    for N=1 a constant model is constructed.
'
'        OUTPUT PARAMETERS
'            P   -   barycentric model which represents Lagrange interpolant
'                    (see ratint unit info and BarycentricCalc() description for
'                    more information).
'
'          -- ALGLIB --
'             Copyright 03.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialbuildcheb2(a As Double, b As Double, y As Double(), n As Integer, p As ratint.barycentricinterpolant)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim x As Double() = New Double(-1) {}
			Dim v As Double = 0

			alglib.ap.assert(n > 0, "PolynomialBuildCheb2: N<=0!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialBuildCheb2: Length(Y)<N!")
			alglib.ap.assert(Math.isfinite(a), "PolynomialBuildCheb2: A is infinite or NaN!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialBuildCheb2: B is infinite or NaN!")
			alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialBuildCheb2: B=A!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialBuildCheb2: Y contains infinite or NaN values!")

			'
			' Special case: N=1
			'
			If n = 1 Then
				x = New Double(0) {}
				w = New Double(0) {}
				x(0) = 0.5 * (b + a)
				w(0) = 1
				ratint.barycentricbuildxyw(x, y, w, 1, p)
				Return
			End If

			'
			' general case
			'
			x = New Double(n - 1) {}
			w = New Double(n - 1) {}
			v = 1
			For i = 0 To n - 1
				If i = 0 OrElse i = n - 1 Then
					w(i) = v * 0.5
				Else
					w(i) = v
				End If
				x(i) = 0.5 * (b + a) + 0.5 * (b - a) * System.Math.Cos(System.Math.PI * i / (n - 1))
				v = -v
			Next
			ratint.barycentricbuildxyw(x, y, w, n, p)
		End Sub


		'************************************************************************
'        Fast equidistant polynomial interpolation function with O(N) complexity
'
'        INPUT PARAMETERS:
'            A   -   left boundary of [A,B]
'            B   -   right boundary of [A,B]
'            F   -   function values, array[0..N-1]
'            N   -   number of points on equidistant grid, N>=1
'                    for N=1 a constant model is constructed.
'            T   -   position where P(x) is calculated
'
'        RESULT
'            value of the Lagrange interpolant at T
'            
'        IMPORTANT
'            this function provides fast interface which is not overflow-safe
'            nor it is very precise.
'            the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
'            subroutines unless you are pretty sure that your data will not result
'            in overflow.
'
'          -- ALGLIB --
'             Copyright 02.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function polynomialcalceqdist(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double
			Dim result As Double = 0
			Dim s1 As Double = 0
			Dim s2 As Double = 0
			Dim v As Double = 0
			Dim threshold As Double = 0
			Dim s As Double = 0
			Dim h As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim w As Double = 0
			Dim x As Double = 0

			alglib.ap.assert(n > 0, "PolynomialCalcEqDist: N<=0!")
			alglib.ap.assert(alglib.ap.len(f) >= n, "PolynomialCalcEqDist: Length(F)<N!")
			alglib.ap.assert(Math.isfinite(a), "PolynomialCalcEqDist: A is infinite or NaN!")
			alglib.ap.assert(Math.isfinite(b), "PolynomialCalcEqDist: B is infinite or NaN!")
			alglib.ap.assert(apserv.isfinitevector(f, n), "PolynomialCalcEqDist: F contains infinite or NaN values!")
			alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialCalcEqDist: B=A!")
			alglib.ap.assert(Not [Double].IsInfinity(t), "PolynomialCalcEqDist: T is infinite!")

			'
			' Special case: T is NAN
			'
			If [Double].IsNaN(t) Then
				result = [Double].NaN
				Return result
			End If

			'
			' Special case: N=1
			'
			If n = 1 Then
				result = f(0)
				Return result
			End If

			'
			' First, decide: should we use "safe" formula (guarded
			' against overflow) or fast one?
			'
            threshold = System.Math.sqrt(Math.minrealnumber)
            j = 0
            s = t - a
            For i = 1 To n - 1
                x = a + CDbl(i) / CDbl(n - 1) * (b - a)
                If CDbl(System.Math.Abs(t - x)) < CDbl(System.Math.Abs(s)) Then
                    s = t - x
                    j = i
                End If
            Next
            If CDbl(s) = CDbl(0) Then
                result = f(j)
                Return result
            End If
            If CDbl(System.Math.Abs(s)) > CDbl(threshold) Then

                '
                ' use fast formula
                '
                j = -1
                s = 1.0
            End If

            '
            ' Calculate using safe or fast barycentric formula
            '
            s1 = 0
            s2 = 0
            w = 1.0
            h = (b - a) / (n - 1)
            For i = 0 To n - 1
                If i <> j Then
                    v = s * w / (t - (a + i * h))
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                Else
                    v = w
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                End If
                w = -(w * (n - 1 - i))
                w = w / (i + 1)
            Next
            result = s1 / s2
            Return result
        End Function


        '************************************************************************
        '        Fast polynomial interpolation function on Chebyshev points (first kind)
        '        with O(N) complexity.
        '
        '        INPUT PARAMETERS:
        '            A   -   left boundary of [A,B]
        '            B   -   right boundary of [A,B]
        '            F   -   function values, array[0..N-1]
        '            N   -   number of points on Chebyshev grid (first kind),
        '                    X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
        '                    for N=1 a constant model is constructed.
        '            T   -   position where P(x) is calculated
        '
        '        RESULT
        '            value of the Lagrange interpolant at T
        '
        '        IMPORTANT
        '            this function provides fast interface which is not overflow-safe
        '            nor it is very precise.
        '            the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
        '            subroutines unless you are pretty sure that your data will not result
        '            in overflow.
        '
        '          -- ALGLIB --
        '             Copyright 02.12.2009 by Bochkanov Sergey
        '        ************************************************************************

        Public Shared Function polynomialcalccheb1(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double
            Dim result As Double = 0
            Dim s1 As Double = 0
            Dim s2 As Double = 0
            Dim v As Double = 0
            Dim threshold As Double = 0
            Dim s As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim a0 As Double = 0
            Dim delta As Double = 0
            Dim alpha As Double = 0
            Dim beta As Double = 0
            Dim ca As Double = 0
            Dim sa As Double = 0
            Dim tempc As Double = 0
            Dim temps As Double = 0
            Dim x As Double = 0
            Dim w As Double = 0
            Dim p1 As Double = 0

            alglib.ap.assert(n > 0, "PolynomialCalcCheb1: N<=0!")
            alglib.ap.assert(alglib.ap.len(f) >= n, "PolynomialCalcCheb1: Length(F)<N!")
            alglib.ap.assert(Math.isfinite(a), "PolynomialCalcCheb1: A is infinite or NaN!")
            alglib.ap.assert(Math.isfinite(b), "PolynomialCalcCheb1: B is infinite or NaN!")
            alglib.ap.assert(apserv.isfinitevector(f, n), "PolynomialCalcCheb1: F contains infinite or NaN values!")
            alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialCalcCheb1: B=A!")
            alglib.ap.assert(Not [Double].IsInfinity(t), "PolynomialCalcCheb1: T is infinite!")

            '
            ' Special case: T is NAN
            '
            If [Double].IsNaN(t) Then
                result = [Double].NaN
                Return result
            End If

            '
            ' Special case: N=1
            '
            If n = 1 Then
                result = f(0)
                Return result
            End If

            '
            ' Prepare information for the recurrence formula
            ' used to calculate sin(pi*(2j+1)/(2n+2)) and
            ' cos(pi*(2j+1)/(2n+2)):
            '
            ' A0    = pi/(2n+2)
            ' Delta = pi/(n+1)
            ' Alpha = 2 sin^2 (Delta/2)
            ' Beta  = sin(Delta)
            '
            ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
            ' Then we use
            '
            ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
            ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
            '
            ' to repeatedly calculate sin(..) and cos(..).
            '
            threshold = System.Math.sqrt(Math.minrealnumber)
            t = (t - 0.5 * (a + b)) / (0.5 * (b - a))
            a0 = System.Math.PI / (2 * (n - 1) + 2)
            delta = 2 * System.Math.PI / (2 * (n - 1) + 2)
            alpha = 2 * Math.sqr(System.Math.Sin(delta / 2))
            beta = System.Math.Sin(delta)

            '
            ' First, decide: should we use "safe" formula (guarded
            ' against overflow) or fast one?
            '
            ca = System.Math.Cos(a0)
            sa = System.Math.Sin(a0)
            j = 0
            x = ca
            s = t - x
            For i = 1 To n - 1

                '
                ' Next X[i]
                '
                temps = sa - (alpha * sa - beta * ca)
                tempc = ca - (alpha * ca + beta * sa)
                sa = temps
                ca = tempc
                x = ca

                '
                ' Use X[i]
                '
                If CDbl(System.Math.Abs(t - x)) < CDbl(System.Math.Abs(s)) Then
                    s = t - x
                    j = i
                End If
            Next
            If CDbl(s) = CDbl(0) Then
                result = f(j)
                Return result
            End If
            If CDbl(System.Math.Abs(s)) > CDbl(threshold) Then

                '
                ' use fast formula
                '
                j = -1
                s = 1.0
            End If

            '
            ' Calculate using safe or fast barycentric formula
            '
            s1 = 0
            s2 = 0
            ca = System.Math.Cos(a0)
            sa = System.Math.Sin(a0)
            p1 = 1.0
            For i = 0 To n - 1

                '
                ' Calculate X[i], W[i]
                '
                x = ca
                w = p1 * sa

                '
                ' Proceed
                '
                If i <> j Then
                    v = s * w / (t - x)
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                Else
                    v = w
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                End If

                '
                ' Next CA, SA, P1
                '
                temps = sa - (alpha * sa - beta * ca)
                tempc = ca - (alpha * ca + beta * sa)
                sa = temps
                ca = tempc
                p1 = -p1
            Next
            result = s1 / s2
            Return result
        End Function


        '************************************************************************
        '        Fast polynomial interpolation function on Chebyshev points (second kind)
        '        with O(N) complexity.
        '
        '        INPUT PARAMETERS:
        '            A   -   left boundary of [A,B]
        '            B   -   right boundary of [A,B]
        '            F   -   function values, array[0..N-1]
        '            N   -   number of points on Chebyshev grid (second kind),
        '                    X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
        '                    for N=1 a constant model is constructed.
        '            T   -   position where P(x) is calculated
        '
        '        RESULT
        '            value of the Lagrange interpolant at T
        '
        '        IMPORTANT
        '            this function provides fast interface which is not overflow-safe
        '            nor it is very precise.
        '            the best option is to use PolIntBuildCheb2()/BarycentricCalc()
        '            subroutines unless you are pretty sure that your data will not result
        '            in overflow.
        '
        '          -- ALGLIB --
        '             Copyright 02.12.2009 by Bochkanov Sergey
        '        ************************************************************************

        Public Shared Function polynomialcalccheb2(a As Double, b As Double, f As Double(), n As Integer, t As Double) As Double
            Dim result As Double = 0
            Dim s1 As Double = 0
            Dim s2 As Double = 0
            Dim v As Double = 0
            Dim threshold As Double = 0
            Dim s As Double = 0
            Dim i As Integer = 0
            Dim j As Integer = 0
            Dim a0 As Double = 0
            Dim delta As Double = 0
            Dim alpha As Double = 0
            Dim beta As Double = 0
            Dim ca As Double = 0
            Dim sa As Double = 0
            Dim tempc As Double = 0
            Dim temps As Double = 0
            Dim x As Double = 0
            Dim w As Double = 0
            Dim p1 As Double = 0

            alglib.ap.assert(n > 0, "PolynomialCalcCheb2: N<=0!")
            alglib.ap.assert(alglib.ap.len(f) >= n, "PolynomialCalcCheb2: Length(F)<N!")
            alglib.ap.assert(Math.isfinite(a), "PolynomialCalcCheb2: A is infinite or NaN!")
            alglib.ap.assert(Math.isfinite(b), "PolynomialCalcCheb2: B is infinite or NaN!")
            alglib.ap.assert(CDbl(b) <> CDbl(a), "PolynomialCalcCheb2: B=A!")
            alglib.ap.assert(apserv.isfinitevector(f, n), "PolynomialCalcCheb2: F contains infinite or NaN values!")
            alglib.ap.assert(Not [Double].IsInfinity(t), "PolynomialCalcEqDist: T is infinite!")

            '
            ' Special case: T is NAN
            '
            If [Double].IsNaN(t) Then
                result = [Double].NaN
                Return result
            End If

            '
            ' Special case: N=1
            '
            If n = 1 Then
                result = f(0)
                Return result
            End If

            '
            ' Prepare information for the recurrence formula
            ' used to calculate sin(pi*i/n) and
            ' cos(pi*i/n):
            '
            ' A0    = 0
            ' Delta = pi/n
            ' Alpha = 2 sin^2 (Delta/2)
            ' Beta  = sin(Delta)
            '
            ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
            ' Then we use
            '
            ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
            ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
            '
            ' to repeatedly calculate sin(..) and cos(..).
            '
            threshold = System.Math.sqrt(Math.minrealnumber)
            t = (t - 0.5 * (a + b)) / (0.5 * (b - a))
            a0 = 0.0
            delta = System.Math.PI / (n - 1)
            alpha = 2 * Math.sqr(System.Math.Sin(delta / 2))
            beta = System.Math.Sin(delta)

            '
            ' First, decide: should we use "safe" formula (guarded
            ' against overflow) or fast one?
            '
            ca = System.Math.Cos(a0)
            sa = System.Math.Sin(a0)
            j = 0
            x = ca
            s = t - x
            For i = 1 To n - 1

                '
                ' Next X[i]
                '
                temps = sa - (alpha * sa - beta * ca)
                tempc = ca - (alpha * ca + beta * sa)
                sa = temps
                ca = tempc
                x = ca

                '
                ' Use X[i]
                '
                If CDbl(System.Math.Abs(t - x)) < CDbl(System.Math.Abs(s)) Then
                    s = t - x
                    j = i
                End If
            Next
            If CDbl(s) = CDbl(0) Then
                result = f(j)
                Return result
            End If
            If CDbl(System.Math.Abs(s)) > CDbl(threshold) Then

                '
                ' use fast formula
                '
                j = -1
                s = 1.0
            End If

            '
            ' Calculate using safe or fast barycentric formula
            '
            s1 = 0
            s2 = 0
            ca = System.Math.Cos(a0)
            sa = System.Math.Sin(a0)
            p1 = 1.0
            For i = 0 To n - 1

                '
                ' Calculate X[i], W[i]
                '
                x = ca
                If i = 0 OrElse i = n - 1 Then
                    w = 0.5 * p1
                Else
                    w = 1.0 * p1
                End If

                '
                ' Proceed
                '
                If i <> j Then
                    v = s * w / (t - x)
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                Else
                    v = w
                    s1 = s1 + v * f(i)
                    s2 = s2 + v
                End If

                '
                ' Next CA, SA, P1
                '
                temps = sa - (alpha * sa - beta * ca)
                tempc = ca - (alpha * ca + beta * sa)
                sa = temps
                ca = tempc
                p1 = -p1
            Next
            result = s1 / s2
            Return result
        End Function


	End Class
	Public Class spline1d
		'************************************************************************
'        1-dimensional spline interpolant
'        ************************************************************************

		Public Class spline1dinterpolant
			Inherits apobject
			Public periodic As Boolean
			Public n As Integer
			Public k As Integer
			Public continuity As Integer
			Public x As Double()
			Public c As Double()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x = New Double(-1) {}
				c = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New spline1dinterpolant()
				_result.periodic = periodic
				_result.n = n
				_result.k = k
				_result.continuity = continuity
				_result.x = DirectCast(x.Clone(), Double())
				_result.c = DirectCast(c.Clone(), Double())
				Return _result
			End Function
		End Class




		'************************************************************************
'        This subroutine builds linear spline interpolant
'
'        INPUT PARAMETERS:
'            X   -   spline nodes, array[0..N-1]
'            Y   -   function values, array[0..N-1]
'            N   -   points count (optional):
'                    * N>=2
'                    * if given, only first N points are used to build spline
'                    * if not given, automatically detected from X/Y sizes
'                      (len(X) must be equal to len(Y))
'            
'        OUTPUT PARAMETERS:
'            C   -   spline interpolant
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'          -- ALGLIB PROJECT --
'             Copyright 24.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildlinear(x As Double(), y As Double(), n As Integer, c As spline1dinterpolant)
			Dim i As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())

			alglib.ap.assert(n > 1, "Spline1DBuildLinear: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildLinear: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildLinear: Length(Y)<N!")

			'
			' check and sort points
			'
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildLinear: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DBuildLinear: Y contains infinite or NAN values!")
			heapsortpoints(x, y, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildLinear: at least two consequent points are too close!")

			'
			' Build
			'
			c.periodic = False
			c.n = n
			c.k = 3
			c.continuity = 0
			c.x = New Double(n - 1) {}
			c.c = New Double(4 * (n - 1) + 1) {}
			For i = 0 To n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To n - 2
				c.c(4 * i + 0) = y(i)
				c.c(4 * i + 1) = (y(i + 1) - y(i)) / (x(i + 1) - x(i))
				c.c(4 * i + 2) = 0
				c.c(4 * i + 3) = 0
			Next
			c.c(4 * (n - 1) + 0) = y(n - 1)
			c.c(4 * (n - 1) + 1) = c.c(4 * (n - 2) + 1)
		End Sub


		'************************************************************************
'        This subroutine builds cubic spline interpolant.
'
'        INPUT PARAMETERS:
'            X           -   spline nodes, array[0..N-1].
'            Y           -   function values, array[0..N-1].
'            
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points are used to build spline
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'
'        OUTPUT PARAMETERS:
'            C           -   spline interpolant
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 23.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, c As spline1dinterpolant)
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim d As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim ylen As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DBuildCubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DBuildCubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DBuildCubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DBuildCubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DBuildCubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DBuildCubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildCubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildCubic: Length(Y)<N!")

			'
			' check and sort points
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildCubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DBuildCubic: Y contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildCubic: at least two consequent points are too close!")

			'
			' Now we've checked and preordered everything,
			' so we can call internal function to calculate derivatives,
			' and then build Hermite spline using these derivatives
			'
			If boundltype = -1 OrElse boundrtype = -1 Then
				y(n - 1) = y(0)
			End If
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d, a1, a2, a3, b, _
				dt)
			spline1dbuildhermite(x, y, d, n, c)
			c.periodic = boundltype = -1 OrElse boundrtype = -1
			c.continuity = 2
		End Sub


		'************************************************************************
'        This function solves following problem: given table y[] of function values
'        at nodes x[], it calculates and returns table of function derivatives  d[]
'        (calculated at the same nodes x[]).
'
'        This function yields same result as Spline1DBuildCubic() call followed  by
'        sequence of Spline1DDiff() calls, but it can be several times faster  when
'        called for ordered X[] and X2[].
'
'        INPUT PARAMETERS:
'            X           -   spline nodes
'            Y           -   function values
'
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points are used
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'
'        OUTPUT PARAMETERS:
'            D           -   derivative values at X[]
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'        Derivative values are correctly reordered on return, so  D[I]  is  always
'        equal to S'(X[I]) independently of points order.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dgriddiffcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, ByRef d As Double())
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim ylen As Integer = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			d = New Double(-1) {}


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DGridDiffCubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DGridDiffCubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DGridDiffCubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DGridDiffCubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DGridDiffCubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DGridDiffCubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DGridDiffCubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DGridDiffCubic: Length(Y)<N!")

			'
			' check and sort points
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DGridDiffCubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DGridDiffCubic: Y contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DGridDiffCubic: at least two consequent points are too close!")

			'
			' Now we've checked and preordered everything,
			' so we can call internal function.
			'
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d, a1, a2, a3, b, _
				dt)

			'
			' Remember that HeapSortPPoints() call?
			' Now we have to reorder them back.
			'
			If alglib.ap.len(dt) < n Then
				dt = New Double(n - 1) {}
			End If
			For i = 0 To n - 1
				dt(p(i)) = d(i)
			Next
			For i_ = 0 To n - 1
				d(i_) = dt(i_)
			Next
		End Sub


		'************************************************************************
'        This function solves following problem: given table y[] of function values
'        at  nodes  x[],  it  calculates  and  returns  tables  of first and second
'        function derivatives d1[] and d2[] (calculated at the same nodes x[]).
'
'        This function yields same result as Spline1DBuildCubic() call followed  by
'        sequence of Spline1DDiff() calls, but it can be several times faster  when
'        called for ordered X[] and X2[].
'
'        INPUT PARAMETERS:
'            X           -   spline nodes
'            Y           -   function values
'
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points are used
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'
'        OUTPUT PARAMETERS:
'            D1          -   S' values at X[]
'            D2          -   S'' values at X[]
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'        Derivative values are correctly reordered on return, so  D[I]  is  always
'        equal to S'(X[I]) independently of points order.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dgriddiff2cubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, ByRef d1 As Double(), ByRef d2 As Double())
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim ylen As Integer = 0
			Dim delta As Double = 0
			Dim delta2 As Double = 0
			Dim delta3 As Double = 0
			Dim s2 As Double = 0
			Dim s3 As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			d1 = New Double(-1) {}
			d2 = New Double(-1) {}


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DGridDiff2Cubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DGridDiff2Cubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DGridDiff2Cubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DGridDiff2Cubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DGridDiff2Cubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DGridDiff2Cubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DGridDiff2Cubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DGridDiff2Cubic: Length(Y)<N!")

			'
			' check and sort points
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DGridDiff2Cubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DGridDiff2Cubic: Y contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DGridDiff2Cubic: at least two consequent points are too close!")

			'
			' Now we've checked and preordered everything,
			' so we can call internal function.
			'
			' After this call we will calculate second derivatives
			' (manually, by converting to the power basis)
			'
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d1, a1, a2, a3, b, _
				dt)
			d2 = New Double(n - 1) {}
			delta = 0
			s2 = 0
			s3 = 0
			For i = 0 To n - 2

				'
				' We convert from Hermite basis to the power basis.
				' Si is coefficient before x^i.
				'
				' Inside this cycle we need just S2,
				' because we calculate S'' exactly at spline node,
				' (only x^2 matters at x=0), but after iterations
				' will be over, we will need other coefficients
				' to calculate spline value at the last node.
				'
				delta = x(i + 1) - x(i)
				delta2 = Math.sqr(delta)
				delta3 = delta * delta2
				s2 = (3 * (y(i + 1) - y(i)) - 2 * d1(i) * delta - d1(i + 1) * delta) / delta2
				s3 = (2 * (y(i) - y(i + 1)) + d1(i) * delta + d1(i + 1) * delta) / delta3
				d2(i) = 2 * s2
			Next
			d2(n - 1) = 2 * s2 + 6 * s3 * delta

			'
			' Remember that HeapSortPPoints() call?
			' Now we have to reorder them back.
			'
			If alglib.ap.len(dt) < n Then
				dt = New Double(n - 1) {}
			End If
			For i = 0 To n - 1
				dt(p(i)) = d1(i)
			Next
			For i_ = 0 To n - 1
				d1(i_) = dt(i_)
			Next
			For i = 0 To n - 1
				dt(p(i)) = d2(i)
			Next
			For i_ = 0 To n - 1
				d2(i_) = dt(i_)
			Next
		End Sub


		'************************************************************************
'        This function solves following problem: given table y[] of function values
'        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'        function values y2[] (calculated at x2[]).
'
'        This function yields same result as Spline1DBuildCubic() call followed  by
'        sequence of Spline1DDiff() calls, but it can be several times faster  when
'        called for ordered X[] and X2[].
'
'        INPUT PARAMETERS:
'            X           -   old spline nodes
'            Y           -   function values
'            X2           -  new spline nodes
'
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points from X/Y are used
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'            N2          -   new points count:
'                            * N2>=2
'                            * if given, only first N2 points from X2 are used
'                            * if not given, automatically detected from X2 size
'
'        OUTPUT PARAMETERS:
'            F2          -   function values at X2[]
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller  may pass unsorted array.
'        Function  values  are correctly reordered on  return, so F2[I]  is  always
'        equal to S(X2[I]) independently of points order.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dconvcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double())
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim d As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim d1 As Double() = New Double(-1) {}
			Dim d2 As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim p2 As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim ylen As Integer = 0
			Dim t As Double = 0
			Dim t2 As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			x2 = DirectCast(x2.Clone(), Double())
			y2 = New Double(-1) {}


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DConvCubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DConvCubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DConvCubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DConvCubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DConvCubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DConvCubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DConvCubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DConvCubic: Length(Y)<N!")
			alglib.ap.assert(n2 >= 2, "Spline1DConvCubic: N2<2!")
			alglib.ap.assert(alglib.ap.len(x2) >= n2, "Spline1DConvCubic: Length(X2)<N2!")

			'
			' check and sort X/Y
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DConvCubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DConvCubic: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(x2, n2), "Spline1DConvCubic: X2 contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DConvCubic: at least two consequent points are too close!")

			'
			' set up DT (we will need it below)
			'
			dt = New Double(System.Math.Max(n, n2) - 1) {}

			'
			' sort X2:
			' * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
			' * if we have periodic problem, wrap points
			' * sort them, store permutation at P2
			'
			If boundrtype = -1 AndAlso boundltype = -1 Then
				For i = 0 To n2 - 1
					t = x2(i)
					apserv.apperiodicmap(t, x(0), x(n - 1), t2)
					x2(i) = t
				Next
			End If
			heapsortppoints(x2, dt, p2, n2)

			'
			' Now we've checked and preordered everything, so we:
			' * call internal GridDiff() function to get Hermite form of spline
			' * convert using internal Conv() function
			' * convert Y2 back to original order
			'
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d, a1, a2, a3, b, _
				dt)
			spline1dconvdiffinternal(x, y, d, n, x2, n2, _
				y2, True, d1, False, d2, False)
			alglib.ap.assert(alglib.ap.len(dt) >= n2, "Spline1DConvCubic: internal error!")
			For i = 0 To n2 - 1
				dt(p2(i)) = y2(i)
			Next
			For i_ = 0 To n2 - 1
				y2(i_) = dt(i_)
			Next
		End Sub


		'************************************************************************
'        This function solves following problem: given table y[] of function values
'        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'        function values y2[] and derivatives d2[] (calculated at x2[]).
'
'        This function yields same result as Spline1DBuildCubic() call followed  by
'        sequence of Spline1DDiff() calls, but it can be several times faster  when
'        called for ordered X[] and X2[].
'
'        INPUT PARAMETERS:
'            X           -   old spline nodes
'            Y           -   function values
'            X2           -  new spline nodes
'
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points from X/Y are used
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'            N2          -   new points count:
'                            * N2>=2
'                            * if given, only first N2 points from X2 are used
'                            * if not given, automatically detected from X2 size
'
'        OUTPUT PARAMETERS:
'            F2          -   function values at X2[]
'            D2          -   first derivatives at X2[]
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller  may pass unsorted array.
'        Function  values  are correctly reordered on  return, so F2[I]  is  always
'        equal to S(X2[I]) independently of points order.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dconvdiffcubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double(), ByRef d2 As Double())
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim d As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim rt1 As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim p2 As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim ylen As Integer = 0
			Dim t As Double = 0
			Dim t2 As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			x2 = DirectCast(x2.Clone(), Double())
			y2 = New Double(-1) {}
			d2 = New Double(-1) {}


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DConvDiffCubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DConvDiffCubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DConvDiffCubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DConvDiffCubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DConvDiffCubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DConvDiffCubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DConvDiffCubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DConvDiffCubic: Length(Y)<N!")
			alglib.ap.assert(n2 >= 2, "Spline1DConvDiffCubic: N2<2!")
			alglib.ap.assert(alglib.ap.len(x2) >= n2, "Spline1DConvDiffCubic: Length(X2)<N2!")

			'
			' check and sort X/Y
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DConvDiffCubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DConvDiffCubic: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(x2, n2), "Spline1DConvDiffCubic: X2 contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DConvDiffCubic: at least two consequent points are too close!")

			'
			' set up DT (we will need it below)
			'
			dt = New Double(System.Math.Max(n, n2) - 1) {}

			'
			' sort X2:
			' * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
			' * if we have periodic problem, wrap points
			' * sort them, store permutation at P2
			'
			If boundrtype = -1 AndAlso boundltype = -1 Then
				For i = 0 To n2 - 1
					t = x2(i)
					apserv.apperiodicmap(t, x(0), x(n - 1), t2)
					x2(i) = t
				Next
			End If
			heapsortppoints(x2, dt, p2, n2)

			'
			' Now we've checked and preordered everything, so we:
			' * call internal GridDiff() function to get Hermite form of spline
			' * convert using internal Conv() function
			' * convert Y2 back to original order
			'
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d, a1, a2, a3, b, _
				dt)
			spline1dconvdiffinternal(x, y, d, n, x2, n2, _
				y2, True, d2, True, rt1, False)
			alglib.ap.assert(alglib.ap.len(dt) >= n2, "Spline1DConvDiffCubic: internal error!")
			For i = 0 To n2 - 1
				dt(p2(i)) = y2(i)
			Next
			For i_ = 0 To n2 - 1
				y2(i_) = dt(i_)
			Next
			For i = 0 To n2 - 1
				dt(p2(i)) = d2(i)
			Next
			For i_ = 0 To n2 - 1
				d2(i_) = dt(i_)
			Next
		End Sub


		'************************************************************************
'        This function solves following problem: given table y[] of function values
'        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
'        function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
'        (calculated at x2[]).
'
'        This function yields same result as Spline1DBuildCubic() call followed  by
'        sequence of Spline1DDiff() calls, but it can be several times faster  when
'        called for ordered X[] and X2[].
'
'        INPUT PARAMETERS:
'            X           -   old spline nodes
'            Y           -   function values
'            X2           -  new spline nodes
'
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points from X/Y are used
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundLType  -   boundary condition type for the left boundary
'            BoundL      -   left boundary condition (first or second derivative,
'                            depending on the BoundLType)
'            BoundRType  -   boundary condition type for the right boundary
'            BoundR      -   right boundary condition (first or second derivative,
'                            depending on the BoundRType)
'            N2          -   new points count:
'                            * N2>=2
'                            * if given, only first N2 points from X2 are used
'                            * if not given, automatically detected from X2 size
'
'        OUTPUT PARAMETERS:
'            F2          -   function values at X2[]
'            D2          -   first derivatives at X2[]
'            DD2         -   second derivatives at X2[]
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller  may pass unsorted array.
'        Function  values  are correctly reordered on  return, so F2[I]  is  always
'        equal to S(X2[I]) independently of points order.
'
'        SETTING BOUNDARY VALUES:
'
'        The BoundLType/BoundRType parameters can have the following values:
'            * -1, which corresonds to the periodic (cyclic) boundary conditions.
'                  In this case:
'                  * both BoundLType and BoundRType must be equal to -1.
'                  * BoundL/BoundR are ignored
'                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
'            *  0, which  corresponds  to  the  parabolically   terminated  spline
'                  (BoundL and/or BoundR are ignored).
'            *  1, which corresponds to the first derivative boundary condition
'            *  2, which corresponds to the second derivative boundary condition
'            *  by default, BoundType=0 is used
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dconvdiff2cubic(x As Double(), y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, x2 As Double(), n2 As Integer, ByRef y2 As Double(), ByRef d2 As Double(), ByRef dd2 As Double())
			Dim a1 As Double() = New Double(-1) {}
			Dim a2 As Double() = New Double(-1) {}
			Dim a3 As Double() = New Double(-1) {}
			Dim b As Double() = New Double(-1) {}
			Dim d As Double() = New Double(-1) {}
			Dim dt As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim p2 As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim ylen As Integer = 0
			Dim t As Double = 0
			Dim t2 As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			x2 = DirectCast(x2.Clone(), Double())
			y2 = New Double(-1) {}
			d2 = New Double(-1) {}
			dd2 = New Double(-1) {}


			'
			' check correctness of boundary conditions
			'
			alglib.ap.assert(((boundltype = -1 OrElse boundltype = 0) OrElse boundltype = 1) OrElse boundltype = 2, "Spline1DConvDiff2Cubic: incorrect BoundLType!")
			alglib.ap.assert(((boundrtype = -1 OrElse boundrtype = 0) OrElse boundrtype = 1) OrElse boundrtype = 2, "Spline1DConvDiff2Cubic: incorrect BoundRType!")
			alglib.ap.assert((boundrtype = -1 AndAlso boundltype = -1) OrElse (boundrtype <> -1 AndAlso boundltype <> -1), "Spline1DConvDiff2Cubic: incorrect BoundLType/BoundRType!")
			If boundltype = 1 OrElse boundltype = 2 Then
				alglib.ap.assert(Math.isfinite(boundl), "Spline1DConvDiff2Cubic: BoundL is infinite or NAN!")
			End If
			If boundrtype = 1 OrElse boundrtype = 2 Then
				alglib.ap.assert(Math.isfinite(boundr), "Spline1DConvDiff2Cubic: BoundR is infinite or NAN!")
			End If

			'
			' check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DConvDiff2Cubic: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DConvDiff2Cubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DConvDiff2Cubic: Length(Y)<N!")
			alglib.ap.assert(n2 >= 2, "Spline1DConvDiff2Cubic: N2<2!")
			alglib.ap.assert(alglib.ap.len(x2) >= n2, "Spline1DConvDiff2Cubic: Length(X2)<N2!")

			'
			' check and sort X/Y
			'
			ylen = n
			If boundltype = -1 Then
				ylen = n - 1
			End If
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DConvDiff2Cubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, ylen), "Spline1DConvDiff2Cubic: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(x2, n2), "Spline1DConvDiff2Cubic: X2 contains infinite or NAN values!")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DConvDiff2Cubic: at least two consequent points are too close!")

			'
			' set up DT (we will need it below)
			'
			dt = New Double(System.Math.Max(n, n2) - 1) {}

			'
			' sort X2:
			' * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
			' * if we have periodic problem, wrap points
			' * sort them, store permutation at P2
			'
			If boundrtype = -1 AndAlso boundltype = -1 Then
				For i = 0 To n2 - 1
					t = x2(i)
					apserv.apperiodicmap(t, x(0), x(n - 1), t2)
					x2(i) = t
				Next
			End If
			heapsortppoints(x2, dt, p2, n2)

			'
			' Now we've checked and preordered everything, so we:
			' * call internal GridDiff() function to get Hermite form of spline
			' * convert using internal Conv() function
			' * convert Y2 back to original order
			'
			spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, _
				boundr, d, a1, a2, a3, b, _
				dt)
			spline1dconvdiffinternal(x, y, d, n, x2, n2, _
				y2, True, d2, True, dd2, True)
			alglib.ap.assert(alglib.ap.len(dt) >= n2, "Spline1DConvDiff2Cubic: internal error!")
			For i = 0 To n2 - 1
				dt(p2(i)) = y2(i)
			Next
			For i_ = 0 To n2 - 1
				y2(i_) = dt(i_)
			Next
			For i = 0 To n2 - 1
				dt(p2(i)) = d2(i)
			Next
			For i_ = 0 To n2 - 1
				d2(i_) = dt(i_)
			Next
			For i = 0 To n2 - 1
				dt(p2(i)) = dd2(i)
			Next
			For i_ = 0 To n2 - 1
				dd2(i_) = dt(i_)
			Next
		End Sub


		'************************************************************************
'        This subroutine builds Catmull-Rom spline interpolant.
'
'        INPUT PARAMETERS:
'            X           -   spline nodes, array[0..N-1].
'            Y           -   function values, array[0..N-1].
'            
'        OPTIONAL PARAMETERS:
'            N           -   points count:
'                            * N>=2
'                            * if given, only first N points are used to build spline
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'            BoundType   -   boundary condition type:
'                            * -1 for periodic boundary condition
'                            *  0 for parabolically terminated spline (default)
'            Tension     -   tension parameter:
'                            * tension=0   corresponds to classic Catmull-Rom spline (default)
'                            * 0<tension<1 corresponds to more general form - cardinal spline
'
'        OUTPUT PARAMETERS:
'            C           -   spline interpolant
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'        However, this subroutine doesn't require you to specify equal  values  for
'        the first and last points - it automatically forces them  to  be  equal by
'        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
'        Y[last_point]. However it is recommended to pass consistent values of Y[],
'        i.e. to make Y[first_point]=Y[last_point].
'
'          -- ALGLIB PROJECT --
'             Copyright 23.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildcatmullrom(x As Double(), y As Double(), n As Integer, boundtype As Integer, tension As Double, c As spline1dinterpolant)
			Dim d As Double() = New Double(-1) {}
			Dim i As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())

			alglib.ap.assert(n >= 2, "Spline1DBuildCatmullRom: N<2!")
			alglib.ap.assert(boundtype = -1 OrElse boundtype = 0, "Spline1DBuildCatmullRom: incorrect BoundType!")
			alglib.ap.assert(CDbl(tension) >= CDbl(0), "Spline1DBuildCatmullRom: Tension<0!")
			alglib.ap.assert(CDbl(tension) <= CDbl(1), "Spline1DBuildCatmullRom: Tension>1!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildCatmullRom: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildCatmullRom: Length(Y)<N!")

			'
			' check and sort points
			'
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildCatmullRom: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DBuildCatmullRom: Y contains infinite or NAN values!")
			heapsortpoints(x, y, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildCatmullRom: at least two consequent points are too close!")

			'
			' Special cases:
			' * N=2, parabolic terminated boundary condition on both ends
			' * N=2, periodic boundary condition
			'
			If n = 2 AndAlso boundtype = 0 Then

				'
				' Just linear spline
				'
				spline1dbuildlinear(x, y, n, c)
				Return
			End If
			If n = 2 AndAlso boundtype = -1 Then

				'
				' Same as cubic spline with periodic conditions
				'
				spline1dbuildcubic(x, y, n, -1, 0.0, -1, _
					0.0, c)
				Return
			End If

			'
			' Periodic or non-periodic boundary conditions
			'
			If boundtype = -1 Then

				'
				' Periodic boundary conditions
				'
				y(n - 1) = y(0)
				d = New Double(n - 1) {}
				d(0) = (y(1) - y(n - 2)) / (2 * (x(1) - x(0) + x(n - 1) - x(n - 2)))
				For i = 1 To n - 2
					d(i) = (1 - tension) * (y(i + 1) - y(i - 1)) / (x(i + 1) - x(i - 1))
				Next
				d(n - 1) = d(0)

				'
				' Now problem is reduced to the cubic Hermite spline
				'
				spline1dbuildhermite(x, y, d, n, c)
				c.periodic = True
			Else

				'
				' Non-periodic boundary conditions
				'
				d = New Double(n - 1) {}
				For i = 1 To n - 2
					d(i) = (1 - tension) * (y(i + 1) - y(i - 1)) / (x(i + 1) - x(i - 1))
				Next
				d(0) = 2 * (y(1) - y(0)) / (x(1) - x(0)) - d(1)
				d(n - 1) = 2 * (y(n - 1) - y(n - 2)) / (x(n - 1) - x(n - 2)) - d(n - 2)

				'
				' Now problem is reduced to the cubic Hermite spline
				'
				spline1dbuildhermite(x, y, d, n, c)
			End If
		End Sub


		'************************************************************************
'        This subroutine builds Hermite spline interpolant.
'
'        INPUT PARAMETERS:
'            X           -   spline nodes, array[0..N-1]
'            Y           -   function values, array[0..N-1]
'            D           -   derivatives, array[0..N-1]
'            N           -   points count (optional):
'                            * N>=2
'                            * if given, only first N points are used to build spline
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'
'        OUTPUT PARAMETERS:
'            C           -   spline interpolant.
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'          -- ALGLIB PROJECT --
'             Copyright 23.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildhermite(x As Double(), y As Double(), d As Double(), n As Integer, c As spline1dinterpolant)
			Dim i As Integer = 0
			Dim delta As Double = 0
			Dim delta2 As Double = 0
			Dim delta3 As Double = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			d = DirectCast(d.Clone(), Double())

			alglib.ap.assert(n >= 2, "Spline1DBuildHermite: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildHermite: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildHermite: Length(Y)<N!")
			alglib.ap.assert(alglib.ap.len(d) >= n, "Spline1DBuildHermite: Length(D)<N!")

			'
			' check and sort points
			'
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildHermite: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DBuildHermite: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(d, n), "Spline1DBuildHermite: D contains infinite or NAN values!")
			heapsortdpoints(x, y, d, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildHermite: at least two consequent points are too close!")

			'
			' Build
			'
			c.x = New Double(n - 1) {}
			c.c = New Double(4 * (n - 1) + 1) {}
			c.periodic = False
			c.k = 3
			c.n = n
			c.continuity = 1
			For i = 0 To n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To n - 2
				delta = x(i + 1) - x(i)
				delta2 = Math.sqr(delta)
				delta3 = delta * delta2
				c.c(4 * i + 0) = y(i)
				c.c(4 * i + 1) = d(i)
				c.c(4 * i + 2) = (3 * (y(i + 1) - y(i)) - 2 * d(i) * delta - d(i + 1) * delta) / delta2
				c.c(4 * i + 3) = (2 * (y(i) - y(i + 1)) + d(i) * delta + d(i + 1) * delta) / delta3
			Next
			c.c(4 * (n - 1) + 0) = y(n - 1)
			c.c(4 * (n - 1) + 1) = d(n - 1)
		End Sub


		'************************************************************************
'        This subroutine builds Akima spline interpolant
'
'        INPUT PARAMETERS:
'            X           -   spline nodes, array[0..N-1]
'            Y           -   function values, array[0..N-1]
'            N           -   points count (optional):
'                            * N>=2
'                            * if given, only first N points are used to build spline
'                            * if not given, automatically detected from X/Y sizes
'                              (len(X) must be equal to len(Y))
'
'        OUTPUT PARAMETERS:
'            C           -   spline interpolant
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'          -- ALGLIB PROJECT --
'             Copyright 24.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildakima(x As Double(), y As Double(), n As Integer, c As spline1dinterpolant)
			Dim i As Integer = 0
			Dim d As Double() = New Double(-1) {}
			Dim w As Double() = New Double(-1) {}
			Dim diff As Double() = New Double(-1) {}

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())

			alglib.ap.assert(n >= 2, "Spline1DBuildAkima: N<2!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildAkima: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildAkima: Length(Y)<N!")

			'
			' check and sort points
			'
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildAkima: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DBuildAkima: Y contains infinite or NAN values!")
			heapsortpoints(x, y, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildAkima: at least two consequent points are too close!")

			'
			' Handle special cases: N=2, N=3, N=4
			'
			If n <= 4 Then
				spline1dbuildcubic(x, y, n, 0, 0.0, 0, _
					0.0, c)
				Return
			End If

			'
			' Prepare W (weights), Diff (divided differences)
			'
			w = New Double(n - 2) {}
			diff = New Double(n - 2) {}
			For i = 0 To n - 2
				diff(i) = (y(i + 1) - y(i)) / (x(i + 1) - x(i))
			Next
			For i = 1 To n - 2
				w(i) = System.Math.Abs(diff(i) - diff(i - 1))
			Next

			'
			' Prepare Hermite interpolation scheme
			'
			d = New Double(n - 1) {}
			For i = 2 To n - 3
				If CDbl(System.Math.Abs(w(i - 1)) + System.Math.Abs(w(i + 1))) <> CDbl(0) Then
					d(i) = (w(i + 1) * diff(i - 1) + w(i - 1) * diff(i)) / (w(i + 1) + w(i - 1))
				Else
					d(i) = ((x(i + 1) - x(i)) * diff(i - 1) + (x(i) - x(i - 1)) * diff(i)) / (x(i + 1) - x(i - 1))
				End If
			Next
			d(0) = diffthreepoint(x(0), x(0), y(0), x(1), y(1), x(2), _
				y(2))
			d(1) = diffthreepoint(x(1), x(0), y(0), x(1), y(1), x(2), _
				y(2))
			d(n - 2) = diffthreepoint(x(n - 2), x(n - 3), y(n - 3), x(n - 2), y(n - 2), x(n - 1), _
				y(n - 1))
			d(n - 1) = diffthreepoint(x(n - 1), x(n - 3), y(n - 3), x(n - 2), y(n - 2), x(n - 1), _
				y(n - 1))

			'
			' Build Akima spline using Hermite interpolation scheme
			'
			spline1dbuildhermite(x, y, d, n, c)
		End Sub


		'************************************************************************
'        This subroutine calculates the value of the spline at the given point X.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant
'            X   -   point
'
'        Result:
'            S(x)
'
'          -- ALGLIB PROJECT --
'             Copyright 23.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spline1dcalc(c As spline1dinterpolant, x As Double) As Double
			Dim result As Double = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim m As Integer = 0
			Dim t As Double = 0

			alglib.ap.assert(c.k = 3, "Spline1DCalc: internal error")
			alglib.ap.assert(Not [Double].IsInfinity(x), "Spline1DCalc: infinite X!")

			'
			' special case: NaN
			'
			If [Double].IsNaN(x) Then
				result = [Double].NaN
				Return result
			End If

			'
			' correct if periodic
			'
			If c.periodic Then
				apserv.apperiodicmap(x, c.x(0), c.x(c.n - 1), t)
			End If

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = c.n - 2 + 1
			While l <> r - 1
				m = (l + r) \ 2
				If c.x(m) >= x Then
					r = m
				Else
					l = m
				End If
			End While

			'
			' Interpolation
			'
			x = x - c.x(l)
			m = 4 * l
			result = c.c(m) + x * (c.c(m + 1) + x * (c.c(m + 2) + x * c.c(m + 3)))
			Return result
		End Function


		'************************************************************************
'        This subroutine differentiates the spline.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X   -   point
'
'        Result:
'            S   -   S(x)
'            DS  -   S'(x)
'            D2S -   S''(x)
'
'          -- ALGLIB PROJECT --
'             Copyright 24.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1ddiff(c As spline1dinterpolant, x As Double, ByRef s As Double, ByRef ds As Double, ByRef d2s As Double)
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim m As Integer = 0
			Dim t As Double = 0

			s = 0
			ds = 0
			d2s = 0

			alglib.ap.assert(c.k = 3, "Spline1DDiff: internal error")
			alglib.ap.assert(Not [Double].IsInfinity(x), "Spline1DDiff: infinite X!")

			'
			' special case: NaN
			'
			If [Double].IsNaN(x) Then
				s = [Double].NaN
				ds = [Double].NaN
				d2s = [Double].NaN
				Return
			End If

			'
			' correct if periodic
			'
			If c.periodic Then
				apserv.apperiodicmap(x, c.x(0), c.x(c.n - 1), t)
			End If

			'
			' Binary search
			'
			l = 0
			r = c.n - 2 + 1
			While l <> r - 1
				m = (l + r) \ 2
				If c.x(m) >= x Then
					r = m
				Else
					l = m
				End If
			End While

			'
			' Differentiation
			'
			x = x - c.x(l)
			m = 4 * l
			s = c.c(m) + x * (c.c(m + 1) + x * (c.c(m + 2) + x * c.c(m + 3)))
			ds = c.c(m + 1) + 2 * x * c.c(m + 2) + 3 * Math.sqr(x) * c.c(m + 3)
			d2s = 2 * c.c(m + 2) + 6 * x * c.c(m + 3)
		End Sub


		'************************************************************************
'        This subroutine makes the copy of the spline.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'
'        Result:
'            CC  -   spline copy
'
'          -- ALGLIB PROJECT --
'             Copyright 29.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dcopy(c As spline1dinterpolant, cc As spline1dinterpolant)
			Dim s As Integer = 0
			Dim i_ As Integer = 0

			cc.periodic = c.periodic
			cc.n = c.n
			cc.k = c.k
			cc.continuity = c.continuity
			cc.x = New Double(cc.n - 1) {}
			For i_ = 0 To cc.n - 1
				cc.x(i_) = c.x(i_)
			Next
			s = alglib.ap.len(c.c)
			cc.c = New Double(s - 1) {}
			For i_ = 0 To s - 1
				cc.c(i_) = c.c(i_)
			Next
		End Sub


		'************************************************************************
'        This subroutine unpacks the spline into the coefficients table.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X   -   point
'
'        OUTPUT PARAMETERS:
'            Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
'                    For I = 0...N-2:
'                        Tbl[I,0] = X[i]
'                        Tbl[I,1] = X[i+1]
'                        Tbl[I,2] = C0
'                        Tbl[I,3] = C1
'                        Tbl[I,4] = C2
'                        Tbl[I,5] = C3
'                    On [x[i], x[i+1]] spline is equals to:
'                        S(x) = C0 + C1*t + C2*t^2 + C3*t^3
'                        t = x-x[i]
'                        
'        NOTE:
'            You  can rebuild spline with  Spline1DBuildHermite()  function,  which
'            accepts as inputs function values and derivatives at nodes, which  are
'            easy to calculate when you have coefficients.
'
'          -- ALGLIB PROJECT --
'             Copyright 29.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dunpack(c As spline1dinterpolant, ByRef n As Integer, ByRef tbl As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0

			n = 0
			tbl = New Double(-1, -1) {}

			tbl = New Double(c.n - 2, 2 + c.k) {}
			n = c.n

			'
			' Fill
			'
			For i = 0 To n - 2
				tbl(i, 0) = c.x(i)
				tbl(i, 1) = c.x(i + 1)
				For j = 0 To c.k
					tbl(i, 2 + j) = c.c((c.k + 1) * i + j)
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the spline argument.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            A, B-   transformation coefficients: x = A*t + B
'        Result:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 30.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dlintransx(c As spline1dinterpolant, a As Double, b As Double)
			Dim i As Integer = 0
			Dim n As Integer = 0
			Dim v As Double = 0
			Dim dv As Double = 0
			Dim d2v As Double = 0
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim d As Double() = New Double(-1) {}
			Dim isperiodic As New Boolean()
			Dim contval As Integer = 0

			alglib.ap.assert(c.k = 3, "Spline1DLinTransX: internal error")
			n = c.n
			x = New Double(n - 1) {}
			y = New Double(n - 1) {}
			d = New Double(n - 1) {}

			'
			' Unpack, X, Y, dY/dX.
			' Scale and pack with Spline1DBuildHermite again.
			'
			If CDbl(a) = CDbl(0) Then

				'
				' Special case: A=0
				'
				v = spline1dcalc(c, b)
				For i = 0 To n - 1
					x(i) = c.x(i)
					y(i) = v
					d(i) = 0.0
				Next
			Else

				'
				' General case, A<>0
				'
				For i = 0 To n - 1
					x(i) = c.x(i)
					spline1ddiff(c, x(i), v, dv, d2v)
					x(i) = (x(i) - b) / a
					y(i) = v
					d(i) = a * dv
				Next
			End If
			isperiodic = c.periodic
			contval = c.continuity
			If contval > 0 Then
				spline1dbuildhermite(x, y, d, n, c)
			Else
				spline1dbuildlinear(x, y, n, c)
			End If
			c.periodic = isperiodic
			c.continuity = contval
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the spline.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            A, B-   transformation coefficients: S2(x) = A*S(x) + B
'        Result:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 30.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dlintransy(c As spline1dinterpolant, a As Double, b As Double)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim n As Integer = 0

			alglib.ap.assert(c.k = 3, "Spline1DLinTransX: internal error")
			n = c.n
			For i = 0 To n - 2
				c.c(4 * i) = a * c.c(4 * i) + b
				For j = 1 To 3
					c.c(4 * i + j) = a * c.c(4 * i + j)
				Next
			Next
			c.c(4 * (n - 1) + 0) = a * c.c(4 * (n - 1) + 0) + b
			c.c(4 * (n - 1) + 1) = a * c.c(4 * (n - 1) + 1)
		End Sub


		'************************************************************************
'        This subroutine integrates the spline.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X   -   right bound of the integration interval [a, x],
'                    here 'a' denotes min(x[])
'        Result:
'            integral(S(t)dt,a,x)
'
'          -- ALGLIB PROJECT --
'             Copyright 23.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spline1dintegrate(c As spline1dinterpolant, x As Double) As Double
			Dim result As Double = 0
			Dim n As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim m As Integer = 0
			Dim w As Double = 0
			Dim v As Double = 0
			Dim t As Double = 0
			Dim intab As Double = 0
			Dim additionalterm As Double = 0

			n = c.n

			'
			' Periodic splines require special treatment. We make
			' following transformation:
			'
			'     integral(S(t)dt,A,X) = integral(S(t)dt,A,Z)+AdditionalTerm
			'
			' here X may lie outside of [A,B], Z lies strictly in [A,B],
			' AdditionalTerm is equals to integral(S(t)dt,A,B) times some
			' integer number (may be zero).
			'
			If c.periodic AndAlso (CDbl(x) < CDbl(c.x(0)) OrElse CDbl(x) > CDbl(c.x(c.n - 1))) Then

				'
				' compute integral(S(x)dx,A,B)
				'
				intab = 0
				For i = 0 To c.n - 2
					w = c.x(i + 1) - c.x(i)
					m = (c.k + 1) * i
					intab = intab + c.c(m) * w
					v = w
					For j = 1 To c.k
						v = v * w
						intab = intab + c.c(m + j) * v / (j + 1)
					Next
				Next

				'
				' map X into [A,B]
				'
				apserv.apperiodicmap(x, c.x(0), c.x(c.n - 1), t)
				additionalterm = t * intab
			Else
				additionalterm = 0
			End If

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = n - 2 + 1
			While l <> r - 1
				m = (l + r) \ 2
				If CDbl(c.x(m)) >= CDbl(x) Then
					r = m
				Else
					l = m
				End If
			End While

			'
			' Integration
			'
			result = 0
			For i = 0 To l - 1
				w = c.x(i + 1) - c.x(i)
				m = (c.k + 1) * i
				result = result + c.c(m) * w
				v = w
				For j = 1 To c.k
					v = v * w
					result = result + c.c(m + j) * v / (j + 1)
				Next
			Next
			w = x - c.x(l)
			m = (c.k + 1) * l
			v = w
			result = result + c.c(m) * w
			For j = 1 To c.k
				v = v * w
				result = result + c.c(m + j) * v / (j + 1)
			Next
			result = result + additionalterm
			Return result
		End Function


		'************************************************************************
'        Internal version of Spline1DConvDiff
'
'        Converts from Hermite spline given by grid XOld to new grid X2
'
'        INPUT PARAMETERS:
'            XOld    -   old grid
'            YOld    -   values at old grid
'            DOld    -   first derivative at old grid
'            N       -   grid size
'            X2      -   new grid
'            N2      -   new grid size
'            Y       -   possibly preallocated output array
'                        (reallocate if too small)
'            NeedY   -   do we need Y?
'            D1      -   possibly preallocated output array
'                        (reallocate if too small)
'            NeedD1  -   do we need D1?
'            D2      -   possibly preallocated output array
'                        (reallocate if too small)
'            NeedD2  -   do we need D1?
'
'        OUTPUT ARRAYS:
'            Y       -   values, if needed
'            D1      -   first derivative, if needed
'            D2      -   second derivative, if needed
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dconvdiffinternal(xold As Double(), yold As Double(), dold As Double(), n As Integer, x2 As Double(), n2 As Integer, _
			ByRef y As Double(), needy As Boolean, ByRef d1 As Double(), needd1 As Boolean, ByRef d2 As Double(), needd2 As Boolean)
			Dim intervalindex As Integer = 0
			Dim pointindex As Integer = 0
			Dim havetoadvance As New Boolean()
			Dim c0 As Double = 0
			Dim c1 As Double = 0
			Dim c2 As Double = 0
			Dim c3 As Double = 0
			Dim a As Double = 0
			Dim b As Double = 0
			Dim w As Double = 0
			Dim w2 As Double = 0
			Dim w3 As Double = 0
			Dim fa As Double = 0
			Dim fb As Double = 0
			Dim da As Double = 0
			Dim db As Double = 0
			Dim t As Double = 0


			'
			' Prepare space
			'
			If needy AndAlso alglib.ap.len(y) < n2 Then
				y = New Double(n2 - 1) {}
			End If
			If needd1 AndAlso alglib.ap.len(d1) < n2 Then
				d1 = New Double(n2 - 1) {}
			End If
			If needd2 AndAlso alglib.ap.len(d2) < n2 Then
				d2 = New Double(n2 - 1) {}
			End If

			'
			' These assignments aren't actually needed
			' (variables are initialized in the loop below),
			' but without them compiler will complain about uninitialized locals
			'
			c0 = 0
			c1 = 0
			c2 = 0
			c3 = 0
			a = 0
			b = 0

			'
			' Cycle
			'
			intervalindex = -1
			pointindex = 0
			While True

				'
				' are we ready to exit?
				'
				If pointindex >= n2 Then
					Exit While
				End If
				t = x2(pointindex)

				'
				' do we need to advance interval?
				'
				havetoadvance = False
				If intervalindex = -1 Then
					havetoadvance = True
				Else
					If intervalindex < n - 2 Then
						havetoadvance = CDbl(t) >= CDbl(b)
					End If
				End If
				If havetoadvance Then
					intervalindex = intervalindex + 1
					a = xold(intervalindex)
					b = xold(intervalindex + 1)
					w = b - a
					w2 = w * w
					w3 = w * w2
					fa = yold(intervalindex)
					fb = yold(intervalindex + 1)
					da = dold(intervalindex)
					db = dold(intervalindex + 1)
					c0 = fa
					c1 = da
					c2 = (3 * (fb - fa) - 2 * da * w - db * w) / w2
					c3 = (2 * (fa - fb) + da * w + db * w) / w3
					Continue While
				End If

				'
				' Calculate spline and its derivatives using power basis
				'
				t = t - a
				If needy Then
					y(pointindex) = c0 + t * (c1 + t * (c2 + t * c3))
				End If
				If needd1 Then
					d1(pointindex) = c1 + 2 * t * c2 + 3 * t * t * c3
				End If
				If needd2 Then
					d2(pointindex) = 2 * c2 + 6 * t * c3
				End If
				pointindex = pointindex + 1
			End While
		End Sub


		'************************************************************************
'        This function finds all roots and extrema of the spline S(x)  defined  at
'        [A,B] (interval which contains spline nodes).
'
'        It  does not extrapolates function, so roots and extrema located  outside 
'        of [A,B] will not be found. It returns all isolated (including  multiple)
'        roots and extrema.
'
'        INPUT PARAMETERS
'            C           -   spline interpolant
'            
'        OUTPUT PARAMETERS
'            R           -   array[NR], contains roots of the spline. 
'                            In case there is no roots, this array has zero length.
'            NR          -   number of roots, >=0
'            DR          -   is set to True in case there is at least one interval
'                            where spline is just a zero constant. Such degenerate
'                            cases are not reported in the R/NR
'            E           -   array[NE], contains  extrema  (maximums/minimums)  of 
'                            the spline. In case there is no extrema,  this  array 
'                            has zero length.
'            ET          -   array[NE], extrema types:
'                            * ET[i]>0 in case I-th extrema is a minimum
'                            * ET[i]<0 in case I-th extrema is a maximum
'            NE          -   number of extrema, >=0
'            DE          -   is set to True in case there is at least one interval
'                            where spline is a constant. Such degenerate cases are  
'                            not reported in the E/NE.
'                            
'        NOTES:
'
'        1. This function does NOT report following kinds of roots:
'           * intervals where function is constantly zero
'           * roots which are outside of [A,B] (note: it CAN return A or B)
'
'        2. This function does NOT report following kinds of extrema:
'           * intervals where function is a constant
'           * extrema which are outside of (A,B) (note: it WON'T return A or B)
'           
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey   
'        ************************************************************************

		Public Shared Sub spline1drootsandextrema(c As spline1dinterpolant, ByRef r As Double(), ByRef nr As Integer, ByRef dr As Boolean, ByRef e As Double(), ByRef et As Integer(), _
			ByRef ne As Integer, ByRef de As Boolean)
			Dim pl As Double = 0
			Dim ml As Double = 0
			Dim pll As Double = 0
			Dim pr As Double = 0
			Dim mr As Double = 0
			Dim tr As Double() = New Double(-1) {}
			Dim tmpr As Double() = New Double(-1) {}
			Dim tmpe As Double() = New Double(-1) {}
			Dim tmpet As Integer() = New Integer(-1) {}
			Dim tmpc As Double() = New Double(-1) {}
			Dim x0 As Double = 0
			Dim x1 As Double = 0
			Dim x2 As Double = 0
			Dim ex0 As Double = 0
			Dim ex1 As Double = 0
			Dim tne As Integer = 0
			Dim tnr As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim nstep As New Boolean()

			r = New Double(-1) {}
			nr = 0
			dr = New Boolean()
			e = New Double(-1) {}
			et = New Integer(-1) {}
			ne = 0
			de = New Boolean()


			'
			'exception handling
			'
			alglib.ap.assert(c.k = 3, "Spline1DRootsAndExtrema : incorrect parameter C.K!")
			alglib.ap.assert(c.continuity >= 0, "Spline1DRootsAndExtrema : parameter C.Continuity must not be less than 0!")

			'
			'initialization of variable
			'
			nr = 0
			ne = 0
			dr = False
			de = False
			nstep = True

			'
			'consider case, when C.Continuty=0
			'
			If c.continuity = 0 Then

				'
				'allocation for auxiliary arrays 
				''TmpR ' - it stores a time value for roots
				''TmpE ' - it stores a time value for extremums
				''TmpET '- it stores a time value for extremums type
				'
				apserv.rvectorsetlengthatleast(tmpr, 3 * (c.n - 1))
				apserv.rvectorsetlengthatleast(tmpe, 2 * (c.n - 1))
				apserv.ivectorsetlengthatleast(tmpet, 2 * (c.n - 1))

				'
				'start calculating
				'
				For i = 0 To c.n - 2

					'
					'initialization pL, mL, pR, mR
					'
					pl = c.c(4 * i)
					ml = c.c(4 * i + 1)
					pr = c.c(4 * (i + 1))
					mr = c.c(4 * i + 1) + 2 * c.c(4 * i + 2) * (c.x(i + 1) - c.x(i)) + 3 * c.c(4 * i + 3) * (c.x(i + 1) - c.x(i)) * (c.x(i + 1) - c.x(i))

					'
					'pre-searching roots and extremums
					'
					solvecubicpolinom(pl, ml, pr, mr, c.x(i), c.x(i + 1), _
						x0, x1, x2, ex0, ex1, tnr, _
						tne, tr)
					dr = dr OrElse tnr = -1
					de = de OrElse tne = -1

					'
					'searching of roots
					'
					If tnr = 1 AndAlso nstep Then

						'
						'is there roots?
						'
						If nr > 0 Then

							'
							'is a next root equal a previous root?
							'if is't, then write new root
							'
							If CDbl(x0) <> CDbl(tmpr(nr - 1)) Then
								tmpr(nr) = x0
								nr = nr + 1
							End If
						Else

							'
							'write a first root
							'
							tmpr(nr) = x0
							nr = nr + 1
						End If
					Else

						'
						'case when function at a segment identically to zero
						'then we have to clear a root, if the one located on a 
						'constant segment
						'
						If tnr = -1 Then

							'
							'safe state variable as constant
							'
							If nstep Then
								nstep = False
							End If

							'
							'clear the root, if there is
							'
							If nr > 0 Then
								If CDbl(c.x(i)) = CDbl(tmpr(nr - 1)) Then
									nr = nr - 1
								End If
							End If

							'
							'change state for 'DR'
							'
							If Not dr Then
								dr = True
							End If
						Else
							nstep = True
						End If
					End If

					'
					'searching of extremums
					'
					If i > 0 Then
						pll = c.c(4 * (i - 1))

						'
						'if pL=pLL or pL=pR then
						'
						If tne = -1 Then
							If Not de Then
								de = True
							End If
						Else
							If CDbl(pl) > CDbl(pll) AndAlso CDbl(pl) > CDbl(pr) Then

								'
								'maximum
								'
								tmpet(ne) = -1
								tmpe(ne) = c.x(i)
								ne = ne + 1
							Else
								If CDbl(pl) < CDbl(pll) AndAlso CDbl(pl) < CDbl(pr) Then

									'
									'minimum
									'
									tmpet(ne) = 1
									tmpe(ne) = c.x(i)
									ne = ne + 1
								End If
							End If
						End If
					End If
				Next

				'
				'write final result
				'
				apserv.rvectorsetlengthatleast(r, nr)
				apserv.rvectorsetlengthatleast(e, ne)
				apserv.ivectorsetlengthatleast(et, ne)

				'
				'write roots
				'
				For i = 0 To nr - 1
					r(i) = tmpr(i)
				Next

				'
				'write extremums and their types
				'
				For i = 0 To ne - 1
					e(i) = tmpe(i)
					et(i) = tmpet(i)
				Next
			Else

				'
				'case, when C.Continuity>=1 
				''TmpR ' - it stores a time value for roots
				''TmpC' - it stores a time value for extremums and 
				'their function value (TmpC={EX0,F(EX0), EX1,F(EX1), ..., EXn,F(EXn)};)
				''TmpE' - it stores a time value for extremums only
				''TmpET'- it stores a time value for extremums type
				'
				apserv.rvectorsetlengthatleast(tmpr, 2 * c.n - 1)
				apserv.rvectorsetlengthatleast(tmpc, 4 * c.n)
				apserv.rvectorsetlengthatleast(tmpe, 2 * c.n)
				apserv.ivectorsetlengthatleast(tmpet, 2 * c.n)

				'
				'start calculating
				'
				For i = 0 To c.n - 2

					'
					'we calculate pL,mL, pR,mR as Fi+1(F'i+1) at left border
					'
					pl = c.c(4 * i)
					ml = c.c(4 * i + 1)
					pr = c.c(4 * (i + 1))
					mr = c.c(4 * (i + 1) + 1)

					'
					'calculating roots and extremums at [X[i],X[i+1]]
					'
					solvecubicpolinom(pl, ml, pr, mr, c.x(i), c.x(i + 1), _
						x0, x1, x2, ex0, ex1, tnr, _
						tne, tr)

					'
					'searching roots
					'
					If tnr > 0 Then

						'
						're-init tR
						'
						If tnr >= 1 Then
							tr(0) = x0
						End If
						If tnr >= 2 Then
							tr(1) = x1
						End If
						If tnr = 3 Then
							tr(2) = x2
						End If

						'
						'start root selection
						'
						If nr > 0 Then
							If CDbl(tmpr(nr - 1)) <> CDbl(x0) Then

								'
								'previous segment was't constant identical zero
								'
								If nstep Then
									For j = 0 To tnr - 1
										tmpr(nr + j) = tr(j)
									Next
									nr = nr + tnr
								Else

									'
									'previous segment was constant identical zero
									'and we must ignore [NR+j-1] root
									'
									For j = 1 To tnr - 1
										tmpr(nr + j - 1) = tr(j)
									Next
									nr = nr + tnr - 1
									nstep = True
								End If
							Else
								For j = 1 To tnr - 1
									tmpr(nr + j - 1) = tr(j)
								Next
								nr = nr + tnr - 1
							End If
						Else

							'
							'write first root
							'
							For j = 0 To tnr - 1
								tmpr(nr + j) = tr(j)
							Next
							nr = nr + tnr
						End If
					Else
						If tnr = -1 Then

							'
							'decrement 'NR' if at previous step was writen a root
							'(previous segment identical zero)
							'
							If nr > 0 AndAlso nstep Then
								nr = nr - 1
							End If

							'
							'previous segment is't constant
							'
							If nstep Then
								nstep = False
							End If

							'
							'rewrite 'DR'
							'
							If Not dr Then
								dr = True
							End If
						End If
					End If

					'
					'searching extremums
					'write all term like extremums
					'
					If tne = 1 Then
						If ne > 0 Then

							'
							'just ignore identical extremums
							'because he must be one
							'
							If CDbl(tmpc(ne - 2)) <> CDbl(ex0) Then
								tmpc(ne) = ex0
								tmpc(ne + 1) = c.c(4 * i) + c.c(4 * i + 1) * (ex0 - c.x(i)) + c.c(4 * i + 2) * (ex0 - c.x(i)) * (ex0 - c.x(i)) + c.c(4 * i + 3) * (ex0 - c.x(i)) * (ex0 - c.x(i)) * (ex0 - c.x(i))
								ne = ne + 2
							End If
						Else

							'
							'write first extremum and it function value
							'
							tmpc(ne) = ex0
							tmpc(ne + 1) = c.c(4 * i) + c.c(4 * i + 1) * (ex0 - c.x(i)) + c.c(4 * i + 2) * (ex0 - c.x(i)) * (ex0 - c.x(i)) + c.c(4 * i + 3) * (ex0 - c.x(i)) * (ex0 - c.x(i)) * (ex0 - c.x(i))
							ne = ne + 2
						End If
					Else
						If tne = 2 Then
							If ne > 0 Then

								'
								'ignore identical extremum
								'
								If CDbl(tmpc(ne - 2)) <> CDbl(ex0) Then
									tmpc(ne) = ex0
									tmpc(ne + 1) = c.c(4 * i) + c.c(4 * i + 1) * (ex0 - c.x(i)) + c.c(4 * i + 2) * (ex0 - c.x(i)) * (ex0 - c.x(i)) + c.c(4 * i + 3) * (ex0 - c.x(i)) * (ex0 - c.x(i)) * (ex0 - c.x(i))
									ne = ne + 2
								End If
							Else

								'
								'write first extremum
								'
								tmpc(ne) = ex0
								tmpc(ne + 1) = c.c(4 * i) + c.c(4 * i + 1) * (ex0 - c.x(i)) + c.c(4 * i + 2) * (ex0 - c.x(i)) * (ex0 - c.x(i)) + c.c(4 * i + 3) * (ex0 - c.x(i)) * (ex0 - c.x(i)) * (ex0 - c.x(i))
								ne = ne + 2
							End If

							'
							'write second extremum
							'
							tmpc(ne) = ex1
							tmpc(ne + 1) = c.c(4 * i) + c.c(4 * i + 1) * (ex1 - c.x(i)) + c.c(4 * i + 2) * (ex1 - c.x(i)) * (ex1 - c.x(i)) + c.c(4 * i + 3) * (ex1 - c.x(i)) * (ex1 - c.x(i)) * (ex1 - c.x(i))
							ne = ne + 2
						Else
							If tne = -1 Then
								If Not de Then
									de = True
								End If
							End If
						End If
					End If
				Next

				'
				'checking of arrays
				'get number of extremums (tNe=NE/2)
				'initialize pL as value F0(X[0]) and
				'initialize pR as value Fn-1(X[N])
				'
				tne = ne \ 2
				ne = 0
				pl = c.c(0)
				pr = c.c(4 * (c.n - 1))
				For i = 0 To tne - 1
					If i > 0 AndAlso i < tne - 1 Then
						If CDbl(tmpc(2 * i + 1)) > CDbl(tmpc(2 * (i - 1) + 1)) AndAlso CDbl(tmpc(2 * i + 1)) > CDbl(tmpc(2 * (i + 1) + 1)) Then

							'
							'maximum
							'
							tmpe(ne) = tmpc(2 * i)
							tmpet(ne) = -1
							ne = ne + 1
						Else
							If CDbl(tmpc(2 * i + 1)) < CDbl(tmpc(2 * (i - 1) + 1)) AndAlso CDbl(tmpc(2 * i + 1)) < CDbl(tmpc(2 * (i + 1) + 1)) Then

								'
								'minimum
								'
								tmpe(ne) = tmpc(2 * i)
								tmpet(ne) = 1
								ne = ne + 1
							End If
						End If
					Else
						If i = 0 Then
							If CDbl(tmpc(2 * i)) <> CDbl(c.x(0)) Then
								If CDbl(tmpc(2 * i + 1)) > CDbl(pl) AndAlso CDbl(tmpc(2 * i + 1)) > CDbl(tmpc(2 * (i + 1) + 1)) Then

									'
									'maximum
									'
									tmpe(ne) = tmpc(2 * i)
									tmpet(ne) = -1
									ne = ne + 1
								Else
									If CDbl(tmpc(2 * i + 1)) < CDbl(pl) AndAlso CDbl(tmpc(2 * i + 1)) < CDbl(tmpc(2 * (i + 1) + 1)) Then

										'
										'minimum
										'
										tmpe(ne) = tmpc(2 * i)
										tmpet(ne) = 1
										ne = ne + 1
									End If
								End If
							End If
						Else
							If i = tne - 1 Then
								If CDbl(tmpc(2 * i)) <> CDbl(c.x(c.n - 1)) Then
									If CDbl(tmpc(2 * i + 1)) > CDbl(tmpc(2 * (i - 1) + 1)) AndAlso CDbl(tmpc(2 * i + 1)) > CDbl(pr) Then

										'
										'maximum
										'
										tmpe(ne) = tmpc(2 * i)
										tmpet(ne) = -1
										ne = ne + 1
									Else
										If CDbl(tmpc(2 * i + 1)) < CDbl(tmpc(2 * (i - 1) + 1)) AndAlso CDbl(tmpc(2 * i + 1)) < CDbl(pr) Then

											'
											'minimum
											'
											tmpe(ne) = tmpc(2 * i)
											tmpet(ne) = 1
											ne = ne + 1
										End If
									End If
								End If
							End If
						End If
					End If
				Next

				'
				'final results
				'allocate R, E, ET
				'
				apserv.rvectorsetlengthatleast(r, nr)
				apserv.rvectorsetlengthatleast(e, ne)
				apserv.ivectorsetlengthatleast(et, ne)

				'
				'write result for extremus and their types
				'
				For i = 0 To ne - 1
					e(i) = tmpe(i)
					et(i) = tmpet(i)
				Next

				'
				'write result for roots
				'
				For i = 0 To nr - 1
					r(i) = tmpr(i)
				Next
			End If
		End Sub


		'************************************************************************
'        Internal subroutine. Heap sort.
'        ************************************************************************

		Public Shared Sub heapsortdpoints(ByRef x As Double(), ByRef y As Double(), ByRef d As Double(), n As Integer)
			Dim rbuf As Double() = New Double(-1) {}
			Dim ibuf As Integer() = New Integer(-1) {}
			Dim rbuf2 As Double() = New Double(-1) {}
			Dim ibuf2 As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			ibuf = New Integer(n - 1) {}
			rbuf = New Double(n - 1) {}
			For i = 0 To n - 1
				ibuf(i) = i
			Next
			tsort.tagsortfasti(x, ibuf, rbuf2, ibuf2, n)
			For i = 0 To n - 1
				rbuf(i) = y(ibuf(i))
			Next
			For i_ = 0 To n - 1
				y(i_) = rbuf(i_)
			Next
			For i = 0 To n - 1
				rbuf(i) = d(ibuf(i))
			Next
			For i_ = 0 To n - 1
				d(i_) = rbuf(i_)
			Next
		End Sub


		'************************************************************************
'        This procedure search roots of an quadratic equation inside [0;1] and it number of roots.
'
'        INPUT PARAMETERS:
'            P0   -   value of a function at 0
'            M0   -   value of a derivative at 0
'            P1   -   value of a function at 1
'            M1   -   value of a derivative at 1
'
'        OUTPUT PARAMETERS:
'            X0   -  first root of an equation
'            X1   -  second root of an equation
'            NR   -  number of roots
'            
'        RESTRICTIONS OF PARAMETERS:
'
'        Parameters for this procedure has't to be zero simultaneously. Is expected, 
'        that input polinom is't degenerate or constant identicaly ZERO.
'
'
'        REMARK:
'
'        The procedure always fill value for X1 and X2, even if it is't belongs to [0;1].
'        But first true root(even if existing one) is in X1.
'        Number of roots is NR.
'
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub solvepolinom2(p0 As Double, m0 As Double, p1 As Double, m1 As Double, ByRef x0 As Double, ByRef x1 As Double, _
			ByRef nr As Integer)
			Dim a As Double = 0
			Dim b As Double = 0
			Dim c As Double = 0
			Dim dd As Double = 0
			Dim tmp As Double = 0
			Dim exf As Double = 0
			Dim extr As Double = 0

			x0 = 0
			x1 = 0
			nr = 0


			'
			'calculate parameters for equation: A, B  and C
			'
			a = 6 * p0 + 3 * m0 - 6 * p1 + 3 * m1
			b = -(6 * p0) - 4 * m0 + 6 * p1 - 2 * m1
			c = m0

			'
			'check case, when A=0
			'we are considering the linear equation
			'
			If CDbl(a) = CDbl(0) Then

				'
				'B<>0 and root inside [0;1]
				'one root
				'
				If (CDbl(b) <> CDbl(0) AndAlso System.Math.Sign(c) * System.Math.Sign(b) <= 0) AndAlso CDbl(System.Math.Abs(b)) >= CDbl(System.Math.Abs(c)) Then
					x0 = -(c / b)
					nr = 1
					Return
				Else
					nr = 0
					Return
				End If
			End If

			'
			'consider case, when extremumu outside (0;1)
			'exist one root only
			'
			If CDbl(System.Math.Abs(2 * a)) <= CDbl(System.Math.Abs(b)) OrElse System.Math.Sign(b) * System.Math.Sign(a) >= 0 Then
				If System.Math.Sign(m0) * System.Math.Sign(m1) > 0 Then
					nr = 0
					Return
				End If

				'
				'consider case, when the one exist
				'same sign of derivative
				'
				If System.Math.Sign(m0) * System.Math.Sign(m1) < 0 Then
					nr = 1
					extr = -(b / (2 * a))
					dd = b * b - 4 * a * c
					If CDbl(dd) < CDbl(0) Then
						Return
					End If
					x0 = (-b - System.Math.sqrt(dd)) / (2 * a)
					x1 = (-b + System.Math.sqrt(dd)) / (2 * a)
					If (CDbl(extr) >= CDbl(1) AndAlso CDbl(x1) <= CDbl(extr)) OrElse (CDbl(extr) <= CDbl(0) AndAlso CDbl(x1) >= CDbl(extr)) Then
						x0 = x1
					End If
					Return
				End If

				'
				'consider case, when the one is 0
				'
				If CDbl(m0) = CDbl(0) Then
					x0 = 0
					nr = 1
					Return
				End If
				If CDbl(m1) = CDbl(0) Then
					x0 = 1
					nr = 1
					Return
				End If
			Else

				'
				'consider case, when both of derivatives is 0
				'
				If CDbl(m0) = CDbl(0) AndAlso CDbl(m1) = CDbl(0) Then
					x0 = 0
					x1 = 1
					nr = 2
					Return
				End If

				'
				'consider case, when derivative at 0 is 0, and derivative at 1 is't 0
				'
				If CDbl(m0) = CDbl(0) AndAlso CDbl(m1) <> CDbl(0) Then
					dd = b * b - 4 * a * c
					If CDbl(dd) < CDbl(0) Then
						x0 = 0
						nr = 1
						Return
					End If
					x0 = (-b - System.Math.sqrt(dd)) / (2 * a)
					x1 = (-b + System.Math.sqrt(dd)) / (2 * a)
					extr = -(b / (2 * a))
					exf = a * extr * extr + b * extr + c
					If System.Math.Sign(exf) * System.Math.Sign(m1) > 0 Then
						x0 = 0
						nr = 1
						Return
					Else
						If CDbl(extr) > CDbl(x0) Then
							x0 = 0
						Else
							x1 = 0
						End If
						nr = 2

						'
						'roots must placed ascending
						'
						If CDbl(x0) > CDbl(x1) Then
							tmp = x0
							x0 = x1
							x1 = tmp
						End If
						Return
					End If
				End If
				If CDbl(m1) = CDbl(0) AndAlso CDbl(m0) <> CDbl(0) Then
					dd = b * b - 4 * a * c
					If CDbl(dd) < CDbl(0) Then
						x0 = 1
						nr = 1
						Return
					End If
					x0 = (-b - System.Math.sqrt(dd)) / (2 * a)
					x1 = (-b + System.Math.sqrt(dd)) / (2 * a)
					extr = -(b / (2 * a))
					exf = a * extr * extr + b * extr + c
					If System.Math.Sign(exf) * System.Math.Sign(m0) > 0 Then
						x0 = 1
						nr = 1
						Return
					Else
						If CDbl(extr) < CDbl(x0) Then
							x0 = 1
						Else
							x1 = 1
						End If
						nr = 2

						'
						'roots must placed ascending
						'
						If CDbl(x0) > CDbl(x1) Then
							tmp = x0
							x0 = x1
							x1 = tmp
						End If
						Return
					End If
				Else
					extr = -(b / (2 * a))
					exf = a * extr * extr + b * extr + c
					If System.Math.Sign(exf) * System.Math.Sign(m0) > 0 AndAlso System.Math.Sign(exf) * System.Math.Sign(m1) > 0 Then
						nr = 0
						Return
					End If
					dd = b * b - 4 * a * c
					If CDbl(dd) < CDbl(0) Then
						nr = 0
						Return
					End If
					x0 = (-b - System.Math.sqrt(dd)) / (2 * a)
					x1 = (-b + System.Math.sqrt(dd)) / (2 * a)

					'
					'if EXF and m0, EXF and m1 has different signs, then equation has two roots              
					'
					If System.Math.Sign(exf) * System.Math.Sign(m0) < 0 AndAlso System.Math.Sign(exf) * System.Math.Sign(m1) < 0 Then
						nr = 2

						'
						'roots must placed ascending
						'
						If CDbl(x0) > CDbl(x1) Then
							tmp = x0
							x0 = x1
							x1 = tmp
						End If
						Return
					Else
						nr = 1
						If System.Math.Sign(exf) * System.Math.Sign(m0) < 0 Then
							If CDbl(x1) < CDbl(extr) Then
								x0 = x1
							End If
							Return
						End If
						If System.Math.Sign(exf) * System.Math.Sign(m1) < 0 Then
							If CDbl(x1) > CDbl(extr) Then
								x0 = x1
							End If
							Return
						End If
					End If
				End If
			End If
		End Sub


		'************************************************************************
'        This procedure search roots of an cubic equation inside [A;B], it number of roots 
'        and number of extremums.
'
'        INPUT PARAMETERS:
'            pA   -   value of a function at A
'            mA   -   value of a derivative at A
'            pB   -   value of a function at B
'            mB   -   value of a derivative at B
'            A0   -   left border [A0;B0]
'            B0   -   right border [A0;B0]
'
'        OUTPUT PARAMETERS:
'            X0   -  first root of an equation
'            X1   -  second root of an equation
'            X2   -  third root of an equation
'            EX0  -  first extremum of a function
'            EX0  -  second extremum of a function
'            NR   -  number of roots
'            NR   -  number of extrmums
'            
'        RESTRICTIONS OF PARAMETERS:
'
'        Length of [A;B] must be positive and is't zero, i.e. A<>B and A<B.
'
'
'        REMARK:
'
'        If 'NR' is -1 it's mean, than polinom has infiniti roots.
'        If 'NE' is -1 it's mean, than polinom has infiniti extremums.
'
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub solvecubicpolinom(pa As Double, ma As Double, pb As Double, mb As Double, a As Double, b As Double, _
			ByRef x0 As Double, ByRef x1 As Double, ByRef x2 As Double, ByRef ex0 As Double, ByRef ex1 As Double, ByRef nr As Integer, _
			ByRef ne As Integer, ByRef tempdata As Double())
			Dim i As Integer = 0
			Dim tmpma As Double = 0
			Dim tmpmb As Double = 0
			Dim tex0 As Double = 0
			Dim tex1 As Double = 0

			x0 = 0
			x1 = 0
			x2 = 0
			ex0 = 0
			ex1 = 0
			nr = 0
			ne = 0

			apserv.rvectorsetlengthatleast(tempdata, 3)

			'
			'case, when A>B
			'
			alglib.ap.assert(CDbl(a) < CDbl(b), vbLf & "SolveCubicPolinom: incorrect borders for [A;B]!" & vbLf)

			'
			'case 1    
			'function can be identicaly to ZERO
			'
			If ((CDbl(ma) = CDbl(0) AndAlso CDbl(mb) = CDbl(0)) AndAlso CDbl(pa) = CDbl(pb)) AndAlso CDbl(pa) = CDbl(0) Then
				nr = -1
				ne = -1
				Return
			End If
			If (CDbl(ma) = CDbl(0) AndAlso CDbl(mb) = CDbl(0)) AndAlso CDbl(pa) = CDbl(pb) Then
				nr = 0
				ne = -1
				Return
			End If
			tmpma = ma * (b - a)
			tmpmb = mb * (b - a)
			solvepolinom2(pa, tmpma, pb, tmpmb, ex0, ex1, _
				ne)
			ex0 = rescaleval(0, 1, a, b, ex0)
			ex1 = rescaleval(0, 1, a, b, ex1)

			'
			'case 3.1
			'no extremums at [A;B]
			'
			If ne = 0 Then
				nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, _
					x0)
				If nr = 1 Then
					x0 = rescaleval(0, 1, a, b, x0)
				End If
				Return
			End If

			'
			'case 3.2
			'one extremum
			'
			If ne = 1 Then
				If CDbl(ex0) = CDbl(a) OrElse CDbl(ex0) = CDbl(b) Then
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, _
						x0)
					If nr = 1 Then
						x0 = rescaleval(0, 1, a, b, x0)
					End If
					Return
				Else
					nr = 0
					i = 0
					tex0 = rescaleval(a, b, 0, 1, ex0)
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, _
						x0) + nr
					If nr > i Then
						tempdata(i) = rescaleval(0, tex0, a, ex0, x0)
						i = i + 1
					End If
					nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1, _
						x0) + nr
					If nr > i Then
						x0 = rescaleval(tex0, 1, ex0, b, x0)
						If i > 0 Then
							If CDbl(x0) <> CDbl(tempdata(i - 1)) Then
								tempdata(i) = x0
								i = i + 1
							Else
								nr = nr - 1
							End If
						Else
							tempdata(i) = x0
							i = i + 1
						End If
					End If
					If nr > 0 Then
						x0 = tempdata(0)
						If nr > 1 Then
							x1 = tempdata(1)
						End If
						Return
					End If
				End If
				Return
			Else

				'
				'case 3.3
				'two extremums(or more, but it's impossible)
				'
				'
				'case 3.3.0
				'both extremums at the border
				'
				If CDbl(ex0) = CDbl(a) AndAlso CDbl(ex1) = CDbl(b) Then
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, _
						x0)
					If nr = 1 Then
						x0 = rescaleval(0, 1, a, b, x0)
					End If
					Return
				End If
				If CDbl(ex0) = CDbl(a) AndAlso CDbl(ex1) <> CDbl(b) Then
					nr = 0
					i = 0
					tex1 = rescaleval(a, b, 0, 1, ex1)
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex1, _
						x0) + nr
					If nr > i Then
						tempdata(i) = rescaleval(0, tex1, a, ex1, x0)
						i = i + 1
					End If
					nr = bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1, _
						x0) + nr
					If nr > i Then
						x0 = rescaleval(tex1, 1, ex1, b, x0)
						If CDbl(x0) <> CDbl(tempdata(i - 1)) Then
							tempdata(i) = x0
							i = i + 1
						Else
							nr = nr - 1
						End If
					End If
					If nr > 0 Then
						x0 = tempdata(0)
						If nr > 1 Then
							x1 = tempdata(1)
						End If
						Return
					End If
				End If
				If CDbl(ex1) = CDbl(b) AndAlso CDbl(ex0) <> CDbl(a) Then
					nr = 0
					i = 0
					tex0 = rescaleval(a, b, 0, 1, ex0)
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, _
						x0) + nr
					If nr > i Then
						tempdata(i) = rescaleval(0, tex0, a, ex0, x0)
						i = i + 1
					End If
					nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1, _
						x0) + nr
					If nr > i Then
						x0 = rescaleval(tex0, 1, ex0, b, x0)
						If i > 0 Then
							If CDbl(x0) <> CDbl(tempdata(i - 1)) Then
								tempdata(i) = x0
								i = i + 1
							Else
								nr = nr - 1
							End If
						Else
							tempdata(i) = x0
							i = i + 1
						End If
					End If
					If nr > 0 Then
						x0 = tempdata(0)
						If nr > 1 Then
							x1 = tempdata(1)
						End If
						Return
					End If
				Else

					'
					'case 3.3.2
					'both extremums inside (0;1)
					'
					nr = 0
					i = 0
					tex0 = rescaleval(a, b, 0, 1, ex0)
					tex1 = rescaleval(a, b, 0, 1, ex1)
					nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, _
						x0) + nr
					If nr > i Then
						tempdata(i) = rescaleval(0, tex0, a, ex0, x0)
						i = i + 1
					End If
					nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, tex1, _
						x0) + nr
					If nr > i Then
						x0 = rescaleval(tex0, tex1, ex0, ex1, x0)
						If i > 0 Then
							If CDbl(x0) <> CDbl(tempdata(i - 1)) Then
								tempdata(i) = x0
								i = i + 1
							Else
								nr = nr - 1
							End If
						Else
							tempdata(i) = x0
							i = i + 1
						End If
					End If
					nr = bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1, _
						x0) + nr
					If nr > i Then
						x0 = rescaleval(tex1, 1, ex1, b, x0)
						If i > 0 Then
							If CDbl(x0) <> CDbl(tempdata(i - 1)) Then
								tempdata(i) = x0
								i = i + 1
							Else
								nr = nr - 1
							End If
						Else
							tempdata(i) = x0
							i = i + 1
						End If
					End If

					'
					'write are found roots
					'
					If nr > 0 Then
						x0 = tempdata(0)
						If nr > 1 Then
							x1 = tempdata(1)
						End If
						If nr > 2 Then
							x2 = tempdata(2)
						End If
						Return
					End If
				End If
			End If
		End Sub


		'************************************************************************
'        Function for searching a root at [A;B] by bisection method and return number of roots
'        (0 or 1)
'
'        INPUT PARAMETERS:
'            pA   -   value of a function at A
'            mA   -   value of a derivative at A
'            pB   -   value of a function at B
'            mB   -   value of a derivative at B
'            A0   -   left border [A0;B0] 
'            B0   -   right border [A0;B0]
'            
'        RESTRICTIONS OF PARAMETERS:
'
'        We assume, that B0>A0.
'
'
'        REMARK:
'
'        Assume, that exist one root only at [A;B], else 
'        function may be work incorrectly.
'        The function dont check value A0,B0!
'
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function bisectmethod(pa As Double, ma As Double, pb As Double, mb As Double, a As Double, b As Double, _
			ByRef x As Double) As Integer
			Dim result As Integer = 0
			Dim vacuum As Double = 0
			Dim eps As Double = 0
			Dim a0 As Double = 0
			Dim b0 As Double = 0
			Dim m As Double = 0
			Dim lf As Double = 0
			Dim rf As Double = 0
			Dim mf As Double = 0

			x = 0


			'
			'accuracy
			'
			eps = 1000 * (b - a) * Math.machineepsilon

			'
			'initialization left and right borders
			'
			a0 = a
			b0 = b

			'
			'initialize function value at 'A' and 'B'
			'
			hermitecalc(pa, ma, pb, mb, a, lf, _
				vacuum)
			hermitecalc(pa, ma, pb, mb, b, rf, _
				vacuum)

			'
			'check, that 'A' and 'B' are't roots,
			'and that root exist
			'
			If System.Math.Sign(lf) * System.Math.Sign(rf) > 0 Then
				result = 0
				Return result
			Else
				If CDbl(lf) = CDbl(0) Then
					x = a
					result = 1
					Return result
				Else
					If CDbl(rf) = CDbl(0) Then
						x = b
						result = 1
						Return result
					End If
				End If
			End If

			'
			'searching a root
			'
			Do
				m = (b0 + a0) / 2
				hermitecalc(pa, ma, pb, mb, a0, lf, _
					vacuum)
				hermitecalc(pa, ma, pb, mb, b0, rf, _
					vacuum)
				hermitecalc(pa, ma, pb, mb, m, mf, _
					vacuum)
				If System.Math.Sign(mf) * System.Math.Sign(lf) < 0 Then
					b0 = m
				Else
					If System.Math.Sign(mf) * System.Math.Sign(rf) < 0 Then
						a0 = m
					Else
						If CDbl(lf) = CDbl(0) Then
							x = a0
							result = 1
							Return result
						End If
						If CDbl(rf) = CDbl(0) Then
							x = b0
							result = 1
							Return result
						End If
						If CDbl(mf) = CDbl(0) Then
							x = m
							result = 1
							Return result
						End If
					End If
				End If
			Loop While CDbl(System.Math.Abs(b0 - a0)) >= CDbl(eps)
			x = m
			result = 1
			Return result
		End Function


		'************************************************************************
'        This function builds monotone cubic Hermite interpolant. This interpolant
'        is monotonic in [x(0),x(n-1)] and is constant outside of this interval.
'
'        In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
'        monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
'        monotonically grow at [0..2] and monotonically decrease at [2..4].
'
'        INPUT PARAMETERS:
'            X           -   spline nodes, array[0..N-1]. Subroutine automatically
'                            sorts points, so caller may pass unsorted array.
'            Y           -   function values, array[0..N-1]
'            N           -   the number of points(N>=2).
'
'        OUTPUT PARAMETERS:
'            C           -   spline interpolant.
'
'         -- ALGLIB PROJECT --
'             Copyright 21.06.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dbuildmonotone(x As Double(), y As Double(), n As Integer, c As spline1dinterpolant)
			Dim d As Double() = New Double(-1) {}
			Dim ex As Double() = New Double(-1) {}
			Dim ey As Double() = New Double(-1) {}
			Dim p As Integer() = New Integer(-1) {}
			Dim delta As Double = 0
			Dim alpha As Double = 0
			Dim beta As Double = 0
			Dim tmpn As Integer = 0
			Dim sn As Integer = 0
			Dim ca As Double = 0
			Dim cb As Double = 0
			Dim epsilon As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())


			'
			' Check lengths of arguments
			'
			alglib.ap.assert(n >= 2, "Spline1DBuildMonotone: N<2")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DBuildMonotone: Length(X)<N")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DBuildMonotone: Length(Y)<N")

			'
			' Check and sort points
			'
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DBuildMonotone: X contains infinite or NAN values")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DBuildMonotone: Y contains infinite or NAN values")
			heapsortppoints(x, y, p, n)
			alglib.ap.assert(apserv.aredistinct(x, n), "Spline1DBuildMonotone: at least two consequent points are too close")
			epsilon = Math.machineepsilon
			n = n + 2
			d = New Double(n - 1) {}
			ex = New Double(n - 1) {}
			ey = New Double(n - 1) {}
			ex(0) = x(0) - System.Math.Abs(x(1) - x(0))
			ex(n - 1) = x(n - 3) + System.Math.Abs(x(n - 3) - x(n - 4))
			ey(0) = y(0)
			ey(n - 1) = y(n - 3)
			For i = 1 To n - 2
				ex(i) = x(i - 1)
				ey(i) = y(i - 1)
			Next

			'
			' Init sign of the function for first segment
			'
			i = 0
			ca = 0
			Do
				ca = ey(i + 1) - ey(i)
				i = i + 1
			Loop While Not (CDbl(ca) <> CDbl(0) OrElse i > n - 2)
			If CDbl(ca) <> CDbl(0) Then
				ca = ca / System.Math.Abs(ca)
			End If
			i = 0
			While i < n - 1

				'
				' Partition of the segment [X0;Xn]
				'
				tmpn = 1
				For j = i To n - 2
					cb = ey(j + 1) - ey(j)
					If CDbl(ca * cb) >= CDbl(0) Then
						tmpn = tmpn + 1
					Else
						ca = cb / System.Math.Abs(cb)
						Exit For
					End If
				Next
				sn = i + tmpn
				alglib.ap.assert(tmpn >= 2, "Spline1DBuildMonotone: internal error")

				'
				' Calculate derivatives for current segment
				'
				d(i) = 0
				d(sn - 1) = 0
				For j = i + 1 To sn - 2
					d(j) = ((ey(j) - ey(j - 1)) / (ex(j) - ex(j - 1)) + (ey(j + 1) - ey(j)) / (ex(j + 1) - ex(j))) / 2
				Next
				For j = i To sn - 2
					delta = (ey(j + 1) - ey(j)) / (ex(j + 1) - ex(j))
					If CDbl(System.Math.Abs(delta)) <= CDbl(epsilon) Then
						d(j) = 0
						d(j + 1) = 0
					Else
						alpha = d(j) / delta
						beta = d(j + 1) / delta
						If CDbl(alpha) <> CDbl(0) Then
							cb = alpha * System.Math.sqrt(1 + Math.sqr(beta / alpha))
						Else
							If CDbl(beta) <> CDbl(0) Then
								cb = beta
							Else
								Continue For
							End If
						End If
						If CDbl(cb) > CDbl(3) Then
							d(j) = 3 * alpha * delta / cb
							d(j + 1) = 3 * beta * delta / cb
						End If
					End If
				Next

				'
				' Transition to next segment
				'
				i = sn - 1
			End While
			spline1dbuildhermite(ex, ey, d, n, c)
			c.continuity = 2
		End Sub


		'************************************************************************
'        Internal version of Spline1DGridDiffCubic.
'
'        Accepts pre-ordered X/Y, temporary arrays (which may be  preallocated,  if
'        you want to save time, or not) and output array (which may be preallocated
'        too).
'
'        Y is passed as var-parameter because we may need to force last element  to
'        be equal to the first one (if periodic boundary conditions are specified).
'
'          -- ALGLIB PROJECT --
'             Copyright 03.09.2010 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub spline1dgriddiffcubicinternal(x As Double(), ByRef y As Double(), n As Integer, boundltype As Integer, boundl As Double, boundrtype As Integer, _
			boundr As Double, ByRef d As Double(), ByRef a1 As Double(), ByRef a2 As Double(), ByRef a3 As Double(), ByRef b As Double(), _
			ByRef dt As Double())
			Dim i As Integer = 0
			Dim i_ As Integer = 0


			'
			' allocate arrays
			'
			If alglib.ap.len(d) < n Then
				d = New Double(n - 1) {}
			End If
			If alglib.ap.len(a1) < n Then
				a1 = New Double(n - 1) {}
			End If
			If alglib.ap.len(a2) < n Then
				a2 = New Double(n - 1) {}
			End If
			If alglib.ap.len(a3) < n Then
				a3 = New Double(n - 1) {}
			End If
			If alglib.ap.len(b) < n Then
				b = New Double(n - 1) {}
			End If
			If alglib.ap.len(dt) < n Then
				dt = New Double(n - 1) {}
			End If

			'
			' Special cases:
			' * N=2, parabolic terminated boundary condition on both ends
			' * N=2, periodic boundary condition
			'
			If (n = 2 AndAlso boundltype = 0) AndAlso boundrtype = 0 Then
				d(0) = (y(1) - y(0)) / (x(1) - x(0))
				d(1) = d(0)
				Return
			End If
			If (n = 2 AndAlso boundltype = -1) AndAlso boundrtype = -1 Then
				d(0) = 0
				d(1) = 0
				Return
			End If

			'
			' Periodic and non-periodic boundary conditions are
			' two separate classes
			'
			If boundrtype = -1 AndAlso boundltype = -1 Then

				'
				' Periodic boundary conditions
				'
				y(n - 1) = y(0)

				'
				' Boundary conditions at N-1 points
				' (one point less because last point is the same as first point).
				'
				a1(0) = x(1) - x(0)
				a2(0) = 2 * (x(1) - x(0) + x(n - 1) - x(n - 2))
				a3(0) = x(n - 1) - x(n - 2)
				b(0) = 3 * (y(n - 1) - y(n - 2)) / (x(n - 1) - x(n - 2)) * (x(1) - x(0)) + 3 * (y(1) - y(0)) / (x(1) - x(0)) * (x(n - 1) - x(n - 2))
				For i = 1 To n - 2

					'
					' Altough last point is [N-2], we use X[N-1] and Y[N-1]
					' (because of periodicity)
					'
					a1(i) = x(i + 1) - x(i)
					a2(i) = 2 * (x(i + 1) - x(i - 1))
					a3(i) = x(i) - x(i - 1)
					b(i) = 3 * (y(i) - y(i - 1)) / (x(i) - x(i - 1)) * (x(i + 1) - x(i)) + 3 * (y(i + 1) - y(i)) / (x(i + 1) - x(i)) * (x(i) - x(i - 1))
				Next

				'
				' Solve, add last point (with index N-1)
				'
				solvecyclictridiagonal(a1, a2, a3, b, n - 1, dt)
				For i_ = 0 To n - 2
					d(i_) = dt(i_)
				Next
				d(n - 1) = d(0)
			Else

				'
				' Non-periodic boundary condition.
				' Left boundary conditions.
				'
				If boundltype = 0 Then
					a1(0) = 0
					a2(0) = 1
					a3(0) = 1
					b(0) = 2 * (y(1) - y(0)) / (x(1) - x(0))
				End If
				If boundltype = 1 Then
					a1(0) = 0
					a2(0) = 1
					a3(0) = 0
					b(0) = boundl
				End If
				If boundltype = 2 Then
					a1(0) = 0
					a2(0) = 2
					a3(0) = 1
					b(0) = 3 * (y(1) - y(0)) / (x(1) - x(0)) - 0.5 * boundl * (x(1) - x(0))
				End If

				'
				' Central conditions
				'
				For i = 1 To n - 2
					a1(i) = x(i + 1) - x(i)
					a2(i) = 2 * (x(i + 1) - x(i - 1))
					a3(i) = x(i) - x(i - 1)
					b(i) = 3 * (y(i) - y(i - 1)) / (x(i) - x(i - 1)) * (x(i + 1) - x(i)) + 3 * (y(i + 1) - y(i)) / (x(i + 1) - x(i)) * (x(i) - x(i - 1))
				Next

				'
				' Right boundary conditions
				'
				If boundrtype = 0 Then
					a1(n - 1) = 1
					a2(n - 1) = 1
					a3(n - 1) = 0
					b(n - 1) = 2 * (y(n - 1) - y(n - 2)) / (x(n - 1) - x(n - 2))
				End If
				If boundrtype = 1 Then
					a1(n - 1) = 0
					a2(n - 1) = 1
					a3(n - 1) = 0
					b(n - 1) = boundr
				End If
				If boundrtype = 2 Then
					a1(n - 1) = 1
					a2(n - 1) = 2
					a3(n - 1) = 0
					b(n - 1) = 3 * (y(n - 1) - y(n - 2)) / (x(n - 1) - x(n - 2)) + 0.5 * boundr * (x(n - 1) - x(n - 2))
				End If

				'
				' Solve
				'
				solvetridiagonal(a1, a2, a3, b, n, d)
			End If
		End Sub


		'************************************************************************
'        Internal subroutine. Heap sort.
'        ************************************************************************

		Private Shared Sub heapsortpoints(ByRef x As Double(), ByRef y As Double(), n As Integer)
			Dim bufx As Double() = New Double(-1) {}
			Dim bufy As Double() = New Double(-1) {}

			tsort.tagsortfastr(x, y, bufx, bufy, n)
		End Sub


		'************************************************************************
'        Internal subroutine. Heap sort.
'
'        Accepts:
'            X, Y    -   points
'            P       -   empty or preallocated array
'            
'        Returns:
'            X, Y    -   sorted by X
'            P       -   array of permutations; I-th position of output
'                        arrays X/Y contains (X[P[I]],Y[P[I]])
'        ************************************************************************

		Private Shared Sub heapsortppoints(ByRef x As Double(), ByRef y As Double(), ByRef p As Integer(), n As Integer)
			Dim rbuf As Double() = New Double(-1) {}
			Dim ibuf As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			If alglib.ap.len(p) < n Then
				p = New Integer(n - 1) {}
			End If
			rbuf = New Double(n - 1) {}
			For i = 0 To n - 1
				p(i) = i
			Next
			tsort.tagsortfasti(x, p, rbuf, ibuf, n)
			For i = 0 To n - 1
				rbuf(i) = y(p(i))
			Next
			For i_ = 0 To n - 1
				y(i_) = rbuf(i_)
			Next
		End Sub


		'************************************************************************
'        Internal subroutine. Tridiagonal solver. Solves
'
'        ( B[0] C[0]                      
'        ( A[1] B[1] C[1]                 )
'        (      A[2] B[2] C[2]            )
'        (            ..........          ) * X = D
'        (            ..........          )
'        (           A[N-2] B[N-2] C[N-2] )
'        (                  A[N-1] B[N-1] )
'
'        ************************************************************************

		Private Shared Sub solvetridiagonal(a As Double(), b As Double(), c As Double(), d As Double(), n As Integer, ByRef x As Double())
			Dim k As Integer = 0
			Dim t As Double = 0

			b = DirectCast(b.Clone(), Double())
			d = DirectCast(d.Clone(), Double())

			If alglib.ap.len(x) < n Then
				x = New Double(n - 1) {}
			End If
			For k = 1 To n - 1
				t = a(k) / b(k - 1)
				b(k) = b(k) - t * c(k - 1)
				d(k) = d(k) - t * d(k - 1)
			Next
			x(n - 1) = d(n - 1) / b(n - 1)
			For k = n - 2 To 0 Step -1
				x(k) = (d(k) - c(k) * x(k + 1)) / b(k)
			Next
		End Sub


		'************************************************************************
'        Internal subroutine. Cyclic tridiagonal solver. Solves
'
'        ( B[0] C[0]                 A[0] )
'        ( A[1] B[1] C[1]                 )
'        (      A[2] B[2] C[2]            )
'        (            ..........          ) * X = D
'        (            ..........          )
'        (           A[N-2] B[N-2] C[N-2] )
'        ( C[N-1]           A[N-1] B[N-1] )
'        ************************************************************************

		Private Shared Sub solvecyclictridiagonal(a As Double(), b As Double(), c As Double(), d As Double(), n As Integer, ByRef x As Double())
			Dim k As Integer = 0
			Dim alpha As Double = 0
			Dim beta As Double = 0
			Dim gamma As Double = 0
			Dim y As Double() = New Double(-1) {}
			Dim z As Double() = New Double(-1) {}
			Dim u As Double() = New Double(-1) {}

			b = DirectCast(b.Clone(), Double())

			If alglib.ap.len(x) < n Then
				x = New Double(n - 1) {}
			End If
			beta = a(0)
			alpha = c(n - 1)
			gamma = -b(0)
			b(0) = 2 * b(0)
			b(n - 1) = b(n - 1) - alpha * beta / gamma
			u = New Double(n - 1) {}
			For k = 0 To n - 1
				u(k) = 0
			Next
			u(0) = gamma
			u(n - 1) = alpha
			solvetridiagonal(a, b, c, d, n, y)
			solvetridiagonal(a, b, c, u, n, z)
			For k = 0 To n - 1
				x(k) = y(k) - (y(0) + beta / gamma * y(n - 1)) / (1 + z(0) + beta / gamma * z(n - 1)) * z(k)
			Next
		End Sub


		'************************************************************************
'        Internal subroutine. Three-point differentiation
'        ************************************************************************

		Private Shared Function diffthreepoint(t As Double, x0 As Double, f0 As Double, x1 As Double, f1 As Double, x2 As Double, _
			f2 As Double) As Double
			Dim result As Double = 0
			Dim a As Double = 0
			Dim b As Double = 0

			t = t - x0
			x1 = x1 - x0
			x2 = x2 - x0
			a = (f2 - f0 - x2 / x1 * (f1 - f0)) / (Math.sqr(x2) - x1 * x2)
			b = (f1 - f0 - a * Math.sqr(x1)) / x1
			result = 2 * a * t + b
			Return result
		End Function


		'************************************************************************
'        Procedure for calculating value of a function is providet in the form of
'        Hermite polinom  
'
'        INPUT PARAMETERS:
'            P0   -   value of a function at 0
'            M0   -   value of a derivative at 0
'            P1   -   value of a function at 1
'            M1   -   value of a derivative at 1
'            T    -   point inside [0;1]
'            
'        OUTPUT PARAMETERS:
'            S    -   value of a function at T
'            B0   -   value of a derivative function at T
'            
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub hermitecalc(p0 As Double, m0 As Double, p1 As Double, m1 As Double, t As Double, ByRef s As Double, _
			ByRef ds As Double)
			s = 0
			ds = 0

			s = p0 * (1 + 2 * t) * (1 - t) * (1 - t) + m0 * t * (1 - t) * (1 - t) + p1 * (3 - 2 * t) * t * t + m1 * t * t * (t - 1)
			ds = -(p0 * 6 * t * (1 - t)) + m0 * (1 - t) * (1 - 3 * t) + p1 * 6 * t * (1 - t) + m1 * t * (3 * t - 2)
		End Sub


		'************************************************************************
'        Function for mapping from [A0;B0] to [A1;B1]
'
'        INPUT PARAMETERS:
'            A0   -   left border [A0;B0]
'            B0   -   right border [A0;B0]
'            A1   -   left border [A1;B1]
'            B1   -   right border [A1;B1]
'            T    -   value inside [A0;B0]  
'            
'        RESTRICTIONS OF PARAMETERS:
'
'        We assume, that B0>A0 and B1>A1. But we chech, that T is inside [A0;B0], 
'        and if T<A0 then T become A1, if T>B0 then T - B1. 
'
'        INPUT PARAMETERS:
'                A0   -   left border for segment [A0;B0] from 'T' is converted to [A1;B1] 
'                B0   -   right border for segment [A0;B0] from 'T' is converted to [A1;B1] 
'                A1   -   left border for segment [A1;B1] to 'T' is converted from [A0;B0] 
'                B1   -   right border for segment [A1;B1] to 'T' is converted from [A0;B0] 
'                T    -   the parameter is mapped from [A0;B0] to [A1;B1] 
'
'        Result:
'            is converted value for 'T' from [A0;B0] to [A1;B1]
'                 
'        REMARK:
'
'        The function dont check value A0,B0 and A1,B1!
'
'         -- ALGLIB PROJECT --
'             Copyright 26.09.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Function rescaleval(a0 As Double, b0 As Double, a1 As Double, b1 As Double, t As Double) As Double
			Dim result As Double = 0


			'
			'return left border
			'
			If CDbl(t) <= CDbl(a0) Then
				result = a1
				Return result
			End If

			'
			'return right border
			'
			If CDbl(t) >= CDbl(b0) Then
				result = b1
				Return result
			End If

			'
			'return value between left and right borders
			'
			result = (b1 - a1) * (t - a0) / (b0 - a0) + a1
			Return result
		End Function


	End Class
	Public Class lsfit
		'************************************************************************
'        Polynomial fitting report:
'            TaskRCond       reciprocal of task's condition number
'            RMSError        RMS error
'            AvgError        average error
'            AvgRelError     average relative error (for non-zero Y[I])
'            MaxError        maximum error
'        ************************************************************************

		Public Class polynomialfitreport
			Inherits apobject
			Public taskrcond As Double
			Public rmserror As Double
			Public avgerror As Double
			Public avgrelerror As Double
			Public maxerror As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New polynomialfitreport()
				_result.taskrcond = taskrcond
				_result.rmserror = rmserror
				_result.avgerror = avgerror
				_result.avgrelerror = avgrelerror
				_result.maxerror = maxerror
				Return _result
			End Function
		End Class


		'************************************************************************
'        Barycentric fitting report:
'            RMSError        RMS error
'            AvgError        average error
'            AvgRelError     average relative error (for non-zero Y[I])
'            MaxError        maximum error
'            TaskRCond       reciprocal of task's condition number
'        ************************************************************************

		Public Class barycentricfitreport
			Inherits apobject
			Public taskrcond As Double
			Public dbest As Integer
			Public rmserror As Double
			Public avgerror As Double
			Public avgrelerror As Double
			Public maxerror As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New barycentricfitreport()
				_result.taskrcond = taskrcond
				_result.dbest = dbest
				_result.rmserror = rmserror
				_result.avgerror = avgerror
				_result.avgrelerror = avgrelerror
				_result.maxerror = maxerror
				Return _result
			End Function
		End Class


		'************************************************************************
'        Spline fitting report:
'            RMSError        RMS error
'            AvgError        average error
'            AvgRelError     average relative error (for non-zero Y[I])
'            MaxError        maximum error
'            
'        Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
'        Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
'            TaskRCond       reciprocal of task's condition number
'        ************************************************************************

		Public Class spline1dfitreport
			Inherits apobject
			Public taskrcond As Double
			Public rmserror As Double
			Public avgerror As Double
			Public avgrelerror As Double
			Public maxerror As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New spline1dfitreport()
				_result.taskrcond = taskrcond
				_result.rmserror = rmserror
				_result.avgerror = avgerror
				_result.avgrelerror = avgrelerror
				_result.maxerror = maxerror
				Return _result
			End Function
		End Class


		'************************************************************************
'        Least squares fitting report. This structure contains informational fields
'        which are set by fitting functions provided by this unit.
'
'        Different functions initialize different sets of  fields,  so  you  should
'        read documentation on specific function you used in order  to  know  which
'        fields are initialized.
'
'            TaskRCond       reciprocal of task's condition number
'            IterationsCount number of internal iterations
'            
'            VarIdx          if user-supplied gradient contains errors  which  were
'                            detected by nonlinear fitter, this  field  is  set  to
'                            index  of  the  first  component  of gradient which is
'                            suspected to be spoiled by bugs.
'
'            RMSError        RMS error
'            AvgError        average error
'            AvgRelError     average relative error (for non-zero Y[I])
'            MaxError        maximum error
'
'            WRMSError       weighted RMS error
'
'            CovPar          covariance matrix for parameters, filled by some solvers
'            ErrPar          vector of errors in parameters, filled by some solvers
'            ErrCurve        vector of fit errors -  variability  of  the  best-fit
'                            curve, filled by some solvers.
'            Noise           vector of per-point noise estimates, filled by
'                            some solvers.
'            R2              coefficient of determination (non-weighted, non-adjusted),
'                            filled by some solvers.
'        ************************************************************************

		Public Class lsfitreport
			Inherits apobject
			Public taskrcond As Double
			Public iterationscount As Integer
			Public varidx As Integer
			Public rmserror As Double
			Public avgerror As Double
			Public avgrelerror As Double
			Public maxerror As Double
			Public wrmserror As Double
			Public covpar As Double(,)
			Public errpar As Double()
			Public errcurve As Double()
			Public noise As Double()
			Public r2 As Double
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				covpar = New Double(-1, -1) {}
				errpar = New Double(-1) {}
				errcurve = New Double(-1) {}
				noise = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New lsfitreport()
				_result.taskrcond = taskrcond
				_result.iterationscount = iterationscount
				_result.varidx = varidx
				_result.rmserror = rmserror
				_result.avgerror = avgerror
				_result.avgrelerror = avgrelerror
				_result.maxerror = maxerror
				_result.wrmserror = wrmserror
				_result.covpar = DirectCast(covpar.Clone(), Double(,))
				_result.errpar = DirectCast(errpar.Clone(), Double())
				_result.errcurve = DirectCast(errcurve.Clone(), Double())
				_result.noise = DirectCast(noise.Clone(), Double())
				_result.r2 = r2
				Return _result
			End Function
		End Class


		'************************************************************************
'        Nonlinear fitter.
'
'        You should use ALGLIB functions to work with fitter.
'        Never try to access its fields directly!
'        ************************************************************************

		Public Class lsfitstate
			Inherits apobject
			Public optalgo As Integer
			Public m As Integer
			Public k As Integer
			Public epsf As Double
			Public epsx As Double
			Public maxits As Integer
			Public stpmax As Double
			Public xrep As Boolean
			Public s As Double()
			Public bndl As Double()
			Public bndu As Double()
			Public taskx As Double(,)
			Public tasky As Double()
			Public npoints As Integer
			Public taskw As Double()
			Public nweights As Integer
			Public wkind As Integer
			Public wits As Integer
			Public diffstep As Double
			Public teststep As Double
			Public xupdated As Boolean
			Public needf As Boolean
			Public needfg As Boolean
			Public needfgh As Boolean
			Public pointindex As Integer
			Public x As Double()
			Public c As Double()
			Public f As Double
			Public g As Double()
			Public h As Double(,)
			Public wcur As Double()
			Public tmp As Double()
			Public tmpf As Double()
			Public tmpjac As Double(,)
			Public tmpjacw As Double(,)
			Public tmpnoise As Double
			Public invrep As matinv.matinvreport
			Public repiterationscount As Integer
			Public repterminationtype As Integer
			Public repvaridx As Integer
			Public reprmserror As Double
			Public repavgerror As Double
			Public repavgrelerror As Double
			Public repmaxerror As Double
			Public repwrmserror As Double
			Public rep As lsfitreport
			Public optstate As minlm.minlmstate
			Public optrep As minlm.minlmreport
			Public prevnpt As Integer
			Public prevalgo As Integer
			Public rstate As rcommstate
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				s = New Double(-1) {}
				bndl = New Double(-1) {}
				bndu = New Double(-1) {}
				taskx = New Double(-1, -1) {}
				tasky = New Double(-1) {}
				taskw = New Double(-1) {}
				x = New Double(-1) {}
				c = New Double(-1) {}
				g = New Double(-1) {}
				h = New Double(-1, -1) {}
				wcur = New Double(-1) {}
				tmp = New Double(-1) {}
				tmpf = New Double(-1) {}
				tmpjac = New Double(-1, -1) {}
				tmpjacw = New Double(-1, -1) {}
				invrep = New matinv.matinvreport()
				rep = New lsfitreport()
				optstate = New minlm.minlmstate()
				optrep = New minlm.minlmreport()
				rstate = New rcommstate()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New lsfitstate()
				_result.optalgo = optalgo
				_result.m = m
				_result.k = k
				_result.epsf = epsf
				_result.epsx = epsx
				_result.maxits = maxits
				_result.stpmax = stpmax
				_result.xrep = xrep
				_result.s = DirectCast(s.Clone(), Double())
				_result.bndl = DirectCast(bndl.Clone(), Double())
				_result.bndu = DirectCast(bndu.Clone(), Double())
				_result.taskx = DirectCast(taskx.Clone(), Double(,))
				_result.tasky = DirectCast(tasky.Clone(), Double())
				_result.npoints = npoints
				_result.taskw = DirectCast(taskw.Clone(), Double())
				_result.nweights = nweights
				_result.wkind = wkind
				_result.wits = wits
				_result.diffstep = diffstep
				_result.teststep = teststep
				_result.xupdated = xupdated
				_result.needf = needf
				_result.needfg = needfg
				_result.needfgh = needfgh
				_result.pointindex = pointindex
				_result.x = DirectCast(x.Clone(), Double())
				_result.c = DirectCast(c.Clone(), Double())
				_result.f = f
				_result.g = DirectCast(g.Clone(), Double())
				_result.h = DirectCast(h.Clone(), Double(,))
				_result.wcur = DirectCast(wcur.Clone(), Double())
				_result.tmp = DirectCast(tmp.Clone(), Double())
				_result.tmpf = DirectCast(tmpf.Clone(), Double())
				_result.tmpjac = DirectCast(tmpjac.Clone(), Double(,))
				_result.tmpjacw = DirectCast(tmpjacw.Clone(), Double(,))
				_result.tmpnoise = tmpnoise
				_result.invrep = DirectCast(invrep.make_copy(), matinv.matinvreport)
				_result.repiterationscount = repiterationscount
				_result.repterminationtype = repterminationtype
				_result.repvaridx = repvaridx
				_result.reprmserror = reprmserror
				_result.repavgerror = repavgerror
				_result.repavgrelerror = repavgrelerror
				_result.repmaxerror = repmaxerror
				_result.repwrmserror = repwrmserror
				_result.rep = DirectCast(rep.make_copy(), lsfitreport)
				_result.optstate = DirectCast(optstate.make_copy(), minlm.minlmstate)
				_result.optrep = DirectCast(optrep.make_copy(), minlm.minlmreport)
				_result.prevnpt = prevnpt
				_result.prevalgo = prevalgo
				_result.rstate = DirectCast(rstate.make_copy(), rcommstate)
				Return _result
			End Function
		End Class




		'************************************************************************
'        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'        Peucker algorithm, which stops after generating specified number of linear
'        sections.
'
'        IMPORTANT:
'        * it does NOT perform least-squares fitting; it  builds  curve,  but  this
'          curve does not minimize some least squares metric.  See  description  of
'          RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
'        * this function does NOT work with parametric curves  (i.e.  curves  which
'          can be represented as {X(t),Y(t)}. It works with curves   which  can  be
'          represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
'          circles  with  this  functions.
'          If  you  want  to  work  with  parametric   curves,   you   should   use
'          ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
'          "Interpolation" package.
'
'        INPUT PARAMETERS:
'            X       -   array of X-coordinates:
'                        * at least N elements
'                        * can be unordered (points are automatically sorted)
'                        * this function may accept non-distinct X (see below for
'                          more information on handling of such inputs)
'            Y       -   array of Y-coordinates:
'                        * at least N elements
'            N       -   number of elements in X/Y
'            M       -   desired number of sections:
'                        * at most M sections are generated by this function
'                        * less than M sections can be generated if we have N<M
'                          (or some X are non-distinct).
'
'        OUTPUT PARAMETERS:
'            X2      -   X-values of corner points for piecewise approximation,
'                        has length NSections+1 or zero (for NSections=0).
'            Y2      -   Y-values of corner points,
'                        has length NSections+1 or zero (for NSections=0).
'            NSections-  number of sections found by algorithm, NSections<=M,
'                        NSections can be zero for degenerate datasets
'                        (N<=1 or all X[] are non-distinct).
'
'        NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
'              curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
'
'          -- ALGLIB --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lstfitpiecewiselinearrdpfixed(x As Double(), y As Double(), n As Integer, m As Integer, ByRef x2 As Double(), ByRef y2 As Double(), _
			ByRef nsections As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0
			Dim k2 As Integer = 0
			Dim buf0 As Double() = New Double(-1) {}
			Dim buf1 As Double() = New Double(-1) {}
			Dim sections As Double(,) = New Double(-1, -1) {}
			Dim points As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim worstidx As Integer = 0
			Dim worsterror As Double = 0
			Dim idx0 As Integer = 0
			Dim idx1 As Integer = 0
			Dim e0 As Double = 0
			Dim e1 As Double = 0
			Dim heaperrors As Double() = New Double(-1) {}
			Dim heaptags As Integer() = New Integer(-1) {}

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			x2 = New Double(-1) {}
			y2 = New Double(-1) {}
			nsections = 0

			alglib.ap.assert(n >= 0, "LSTFitPiecewiseLinearRDPFixed: N<0")
			alglib.ap.assert(m >= 1, "LSTFitPiecewiseLinearRDPFixed: M<1")
			alglib.ap.assert(alglib.ap.len(x) >= n, "LSTFitPiecewiseLinearRDPFixed: Length(X)<N")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSTFitPiecewiseLinearRDPFixed: Length(Y)<N")
			If n <= 1 Then
				nsections = 0
				Return
			End If

			'
			' Sort points.
			' Handle possible ties (tied values are replaced by their mean)
			'
			tsort.tagsortfastr(x, y, buf0, buf1, n)
			i = 0
			While i <= n - 1
				j = i + 1
				v = y(i)
				While j <= n - 1 AndAlso CDbl(x(j)) = CDbl(x(i))
					v = v + y(j)
					j = j + 1
				End While
				v = v / (j - i)
				For k = i To j - 1
					y(k) = v
				Next
				i = j
			End While

			'
			' Handle degenerate case x[0]=x[N-1]
			'
			If CDbl(x(n - 1)) = CDbl(x(0)) Then
				nsections = 0
				Return
			End If

			'
			' Prepare first section
			'
			rdpanalyzesection(x, y, 0, n - 1, worstidx, worsterror)
			sections = New Double(m - 1, 3) {}
			heaperrors = New Double(m - 1) {}
			heaptags = New Integer(m - 1) {}
			nsections = 1
			sections(0, 0) = 0
			sections(0, 1) = n - 1
			sections(0, 2) = worstidx
			sections(0, 3) = worsterror
			heaperrors(0) = worsterror
			heaptags(0) = 0
			alglib.ap.assert(CDbl(sections(0, 1)) = CDbl(n - 1), "RDP algorithm: integrity check failed")

			'
			' Main loop.
			' Repeatedly find section with worst error and divide it.
			' Terminate after M-th section, or because of other reasons (see loop internals).
			'
			While nsections < m

				'
				' Break if worst section has zero error.
				' Store index of worst section to K.
				'
				If CDbl(heaperrors(0)) = CDbl(0) Then
					Exit While
				End If
				k = heaptags(0)

				'
				' K-th section is divided in two:
				' * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
				' * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
				'
				' First section is stored at K-th position, second one is appended to the table.
				' Then we update heap which stores pairs of (error,section_index)
				'
				k0 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 0))))
				k1 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 1))))
				k2 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 2))))
				rdpanalyzesection(x, y, k0, k2, idx0, e0)
				rdpanalyzesection(x, y, k2, k1, idx1, e1)
				sections(k, 0) = k0
				sections(k, 1) = k2
				sections(k, 2) = idx0
				sections(k, 3) = e0
				tsort.tagheapreplacetopi(heaperrors, heaptags, nsections, e0, k)
				sections(nsections, 0) = k2
				sections(nsections, 1) = k1
				sections(nsections, 2) = idx1
				sections(nsections, 3) = e1
				tsort.tagheappushi(heaperrors, heaptags, nsections, e1, nsections)
			End While

			'
			' Convert from sections to points
			'
			points = New Double(nsections) {}
			k = CInt(System.Math.Truncate(System.Math.Round(sections(0, 1))))
			For i = 0 To nsections - 1
				points(i) = CInt(System.Math.Truncate(System.Math.Round(sections(i, 0))))
				If CDbl(x(CInt(System.Math.Truncate(System.Math.Round(sections(i, 1)))))) > CDbl(x(k)) Then
					k = CInt(System.Math.Truncate(System.Math.Round(sections(i, 1))))
				End If
			Next
			points(nsections) = k
			tsort.tagsortfast(points, buf0, nsections + 1)

			'
			' Output sections:
			' * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
			' * last element of X2/Y2 is filled by right boundary of rightmost section
			' * X2/Y2 is sorted by ascending of X2
			'
			x2 = New Double(nsections) {}
			y2 = New Double(nsections) {}
			For i = 0 To nsections
				x2(i) = x(CInt(System.Math.Truncate(System.Math.Round(points(i)))))
				y2(i) = y(CInt(System.Math.Truncate(System.Math.Round(points(i)))))
			Next
		End Sub


		'************************************************************************
'        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'        Peucker algorithm, which stops after achieving desired precision.
'
'        IMPORTANT:
'        * it performs non-least-squares fitting; it builds curve, but  this  curve
'          does not minimize some least squares  metric.  See  description  of  RDP
'          algorithm (say, in Wikipedia) for more details on WHAT is performed.
'        * this function does NOT work with parametric curves  (i.e.  curves  which
'          can be represented as {X(t),Y(t)}. It works with curves   which  can  be
'          represented as Y(X). Thus, it is impossible to model figures like circles
'          with this functions.
'          If  you  want  to  work  with  parametric   curves,   you   should   use
'          ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
'          "Interpolation" package.
'
'        INPUT PARAMETERS:
'            X       -   array of X-coordinates:
'                        * at least N elements
'                        * can be unordered (points are automatically sorted)
'                        * this function may accept non-distinct X (see below for
'                          more information on handling of such inputs)
'            Y       -   array of Y-coordinates:
'                        * at least N elements
'            N       -   number of elements in X/Y
'            Eps     -   positive number, desired precision.
'            
'
'        OUTPUT PARAMETERS:
'            X2      -   X-values of corner points for piecewise approximation,
'                        has length NSections+1 or zero (for NSections=0).
'            Y2      -   Y-values of corner points,
'                        has length NSections+1 or zero (for NSections=0).
'            NSections-  number of sections found by algorithm,
'                        NSections can be zero for degenerate datasets
'                        (N<=1 or all X[] are non-distinct).
'
'        NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
'              curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
'
'          -- ALGLIB --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lstfitpiecewiselinearrdp(x As Double(), y As Double(), n As Integer, eps As Double, ByRef x2 As Double(), ByRef y2 As Double(), _
			ByRef nsections As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim buf0 As Double() = New Double(-1) {}
			Dim buf1 As Double() = New Double(-1) {}
			Dim xtmp As Double() = New Double(-1) {}
			Dim ytmp As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim npts As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			x2 = New Double(-1) {}
			y2 = New Double(-1) {}
			nsections = 0

			alglib.ap.assert(n >= 0, "LSTFitPiecewiseLinearRDP: N<0")
			alglib.ap.assert(CDbl(eps) > CDbl(0), "LSTFitPiecewiseLinearRDP: Eps<=0")
			alglib.ap.assert(alglib.ap.len(x) >= n, "LSTFitPiecewiseLinearRDP: Length(X)<N")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSTFitPiecewiseLinearRDP: Length(Y)<N")
			If n <= 1 Then
				nsections = 0
				Return
			End If

			'
			' Sort points.
			' Handle possible ties (tied values are replaced by their mean)
			'
			tsort.tagsortfastr(x, y, buf0, buf1, n)
			i = 0
			While i <= n - 1
				j = i + 1
				v = y(i)
				While j <= n - 1 AndAlso CDbl(x(j)) = CDbl(x(i))
					v = v + y(j)
					j = j + 1
				End While
				v = v / (j - i)
				For k = i To j - 1
					y(k) = v
				Next
				i = j
			End While

			'
			' Handle degenerate case x[0]=x[N-1]
			'
			If CDbl(x(n - 1)) = CDbl(x(0)) Then
				nsections = 0
				Return
			End If

			'
			' Prepare data for recursive algorithm
			'
			xtmp = New Double(n - 1) {}
			ytmp = New Double(n - 1) {}
			npts = 2
			xtmp(0) = x(0)
			ytmp(0) = y(0)
			xtmp(1) = x(n - 1)
			ytmp(1) = y(n - 1)
			rdprecursive(x, y, 0, n - 1, eps, xtmp, _
				ytmp, npts)

			'
			' Output sections:
			' * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
			' * last element of X2/Y2 is filled by right boundary of rightmost section
			' * X2/Y2 is sorted by ascending of X2
			'
			nsections = npts - 1
			x2 = New Double(npts - 1) {}
			y2 = New Double(npts - 1) {}
			For i = 0 To nsections
				x2(i) = xtmp(i)
				y2(i) = ytmp(i)
			Next
			tsort.tagsortfastr(x2, y2, buf0, buf1, npts)
		End Sub


		'************************************************************************
'        Fitting by polynomials in barycentric form. This function provides  simple
'        unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
'        you need constrained fitting.
'
'        Task is linear, so linear least squares solver is used. Complexity of this
'        computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'        SEE ALSO:
'            PolynomialFitWC()
'            
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            N   -   number of points, N>0
'                    * if given, only leading N elements of X/Y are used
'                    * if not given, automatically determined from sizes of X/Y
'            M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearW() subroutine:
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'            P   -   interpolant in barycentric form.
'            Rep -   report, same format as in LSFitLinearW() subroutine.
'                    Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        NOTES:
'            you can convert P from barycentric form  to  the  power  or  Chebyshev
'            basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
'            POLINT subpackage.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialfit(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, p As ratint.barycentricinterpolant, _
			rep As polynomialfitreport)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim xc As Double() = New Double(-1) {}
			Dim yc As Double() = New Double(-1) {}
			Dim dc As Integer() = New Integer(-1) {}

			info = 0

			alglib.ap.assert(n > 0, "PolynomialFit: N<=0!")
			alglib.ap.assert(m > 0, "PolynomialFit: M<=0!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "PolynomialFit: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialFit: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "PolynomialFit: X contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialFit: Y contains infinite or NaN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			polynomialfitwc(x, y, w, n, xc, yc, _
				dc, 0, m, info, p, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_polynomialfit(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, p As ratint.barycentricinterpolant, _
			rep As polynomialfitreport)
			polynomialfit(x, y, n, m, info, p, _
				rep)
		End Sub


		'************************************************************************
'        Weighted  fitting by polynomials in barycentric form, with constraints  on
'        function values or first derivatives.
'
'        Small regularizing term is used when solving constrained tasks (to improve
'        stability).
'
'        Task is linear, so linear least squares solver is used. Complexity of this
'        computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'        SEE ALSO:
'            PolynomialFit()
'            
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            W   -   weights, array[0..N-1]
'                    Each summand in square  sum  of  approximation deviations from
'                    given  values  is  multiplied  by  the square of corresponding
'                    weight. Fill it by 1's if you don't  want  to  solve  weighted
'                    task.
'            N   -   number of points, N>0.
'                    * if given, only leading N elements of X/Y/W are used
'                    * if not given, automatically determined from sizes of X/Y/W
'            XC  -   points where polynomial values/derivatives are constrained,
'                    array[0..K-1].
'            YC  -   values of constraints, array[0..K-1]
'            DC  -   array[0..K-1], types of constraints:
'                    * DC[i]=0   means that P(XC[i])=YC[i]
'                    * DC[i]=1   means that P'(XC[i])=YC[i]
'                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'            K   -   number of constraints, 0<=K<M.
'                    K=0 means no constraints (XC/YC/DC are not used in such cases)
'            M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearW() subroutine:
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'                                -3 means inconsistent constraints
'            P   -   interpolant in barycentric form.
'            Rep -   report, same format as in LSFitLinearW() subroutine.
'                    Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'        NOTES:
'            you can convert P from barycentric form  to  the  power  or  Chebyshev
'            basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
'            POLINT subpackage.
'
'        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'        Setting constraints can lead  to undesired  results,  like ill-conditioned
'        behavior, or inconsistency being detected. From the other side,  it allows
'        us to improve quality of the fit. Here we summarize  our  experience  with
'        constrained regression splines:
'        * even simple constraints can be inconsistent, see  Wikipedia  article  on
'          this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
'        * the  greater  is  M (given  fixed  constraints),  the  more chances that
'          constraints will be consistent
'        * in the general case, consistency of constraints is NOT GUARANTEED.
'        * in the one special cases, however, we can  guarantee  consistency.  This
'          case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)
'
'        Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'        can't solve your task without them. Anything beyond  special  cases  given
'        above is not guaranteed and may result in inconsistency.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub polynomialfitwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, p As ratint.barycentricinterpolant, rep As polynomialfitreport)
			Dim xa As Double = 0
			Dim xb As Double = 0
			Dim sa As Double = 0
			Dim sb As Double = 0
			Dim xoriginal As Double() = New Double(-1) {}
			Dim yoriginal As Double() = New Double(-1) {}
			Dim y2 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim tmp2 As Double() = New Double(-1) {}
			Dim bx As Double() = New Double(-1) {}
			Dim by As Double() = New Double(-1) {}
			Dim bw As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim u As Double = 0
			Dim v As Double = 0
			Dim s As Double = 0
			Dim relcnt As Integer = 0
			Dim lrep As New lsfitreport()

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			w = DirectCast(w.Clone(), Double())
			xc = DirectCast(xc.Clone(), Double())
			yc = DirectCast(yc.Clone(), Double())
			info = 0

			alglib.ap.assert(n > 0, "PolynomialFitWC: N<=0!")
			alglib.ap.assert(m > 0, "PolynomialFitWC: M<=0!")
			alglib.ap.assert(k >= 0, "PolynomialFitWC: K<0!")
			alglib.ap.assert(k < m, "PolynomialFitWC: K>=M!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "PolynomialFitWC: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "PolynomialFitWC: Length(Y)<N!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "PolynomialFitWC: Length(W)<N!")
			alglib.ap.assert(alglib.ap.len(xc) >= k, "PolynomialFitWC: Length(XC)<K!")
			alglib.ap.assert(alglib.ap.len(yc) >= k, "PolynomialFitWC: Length(YC)<K!")
			alglib.ap.assert(alglib.ap.len(dc) >= k, "PolynomialFitWC: Length(DC)<K!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "PolynomialFitWC: X contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "PolynomialFitWC: Y contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "PolynomialFitWC: X contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(xc, k), "PolynomialFitWC: XC contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(yc, k), "PolynomialFitWC: YC contains infinite or NaN values!")
			For i = 0 To k - 1
				alglib.ap.assert(dc(i) = 0 OrElse dc(i) = 1, "PolynomialFitWC: one of DC[] is not 0 or 1!")
			Next

			'
			' Scale X, Y, XC, YC.
			' Solve scaled problem using internal Chebyshev fitting function.
			'
			lsfitscalexy(x, y, w, n, xc, yc, _
				dc, k, xa, xb, sa, sb, _
				xoriginal, yoriginal)
			internalchebyshevfit(x, y, w, n, xc, yc, _
				dc, k, m, info, tmp, lrep)
			If info < 0 Then
				Return
			End If

			'
			' Generate barycentric model and scale it
			' * BX, BY store barycentric model nodes
			' * FMatrix is reused (remember - it is at least MxM, what we need)
			'
			' Model intialization is done in O(M^2). In principle, it can be
			' done in O(M*log(M)), but before it we solved task with O(N*M^2)
			' complexity, so it is only a small amount of total time spent.
			'
			bx = New Double(m - 1) {}
			by = New Double(m - 1) {}
			bw = New Double(m - 1) {}
			tmp2 = New Double(m - 1) {}
			s = 1
			For i = 0 To m - 1
				If m <> 1 Then
					u = System.Math.Cos(System.Math.PI * i / (m - 1))
				Else
					u = 0
				End If
				v = 0
				For j = 0 To m - 1
					If j = 0 Then
						tmp2(j) = 1
					Else
						If j = 1 Then
							tmp2(j) = u
						Else
							tmp2(j) = 2 * u * tmp2(j - 1) - tmp2(j - 2)
						End If
					End If
					v = v + tmp(j) * tmp2(j)
				Next
				bx(i) = u
				by(i) = v
				bw(i) = s
				If i = 0 OrElse i = m - 1 Then
					bw(i) = 0.5 * bw(i)
				End If
				s = -s
			Next
			ratint.barycentricbuildxyw(bx, by, bw, m, p)
			ratint.barycentriclintransx(p, 2 / (xb - xa), -((xa + xb) / (xb - xa)))
			ratint.barycentriclintransy(p, sb - sa, sa)

			'
			' Scale absolute errors obtained from LSFitLinearW.
			' Relative error should be calculated separately
			' (because of shifting/scaling of the task)
			'
			rep.taskrcond = lrep.taskrcond
			rep.rmserror = lrep.rmserror * (sb - sa)
			rep.avgerror = lrep.avgerror * (sb - sa)
			rep.maxerror = lrep.maxerror * (sb - sa)
			rep.avgrelerror = 0
			relcnt = 0
			For i = 0 To n - 1
				If CDbl(yoriginal(i)) <> CDbl(0) Then
					rep.avgrelerror = rep.avgrelerror + System.Math.Abs(ratint.barycentriccalc(p, xoriginal(i)) - yoriginal(i)) / System.Math.Abs(yoriginal(i))
					relcnt = relcnt + 1
				End If
			Next
			If relcnt <> 0 Then
				rep.avgrelerror = rep.avgrelerror / relcnt
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_polynomialfitwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, p As ratint.barycentricinterpolant, rep As polynomialfitreport)
			polynomialfitwc(x, y, w, n, xc, yc, _
				dc, k, m, info, p, rep)
		End Sub


		'************************************************************************
'        This function calculates value of four-parameter logistic (4PL)  model  at
'        specified point X. 4PL model has following form:
'
'            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'        INPUT PARAMETERS:
'            X       -   current point, X>=0:
'                        * zero X is correctly handled even for B<=0
'                        * negative X results in exception.
'            A, B, C, D- parameters of 4PL model:
'                        * A is unconstrained
'                        * B is unconstrained; zero or negative values are handled
'                          correctly.
'                        * C>0, non-positive value results in exception
'                        * D is unconstrained
'                        
'        RESULT:
'            model value at X
'
'        NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
'              (strictly speaking, 0^0 is undefined).
'
'        NOTE: this function also throws exception  if  all  input  parameters  are
'              correct, but overflow was detected during calculations.
'              
'        NOTE: this function performs a lot of checks;  if  you  need  really  high
'              performance, consider evaluating model  yourself,  without  checking
'              for degenerate cases.
'              
'            
'          -- ALGLIB PROJECT --
'             Copyright 14.05.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function logisticcalc4(x As Double, a As Double, b As Double, c As Double, d As Double) As Double
			Dim result As Double = 0

			alglib.ap.assert(Math.isfinite(x), "LogisticCalc4: X is not finite")
			alglib.ap.assert(Math.isfinite(a), "LogisticCalc4: A is not finite")
			alglib.ap.assert(Math.isfinite(b), "LogisticCalc4: B is not finite")
			alglib.ap.assert(Math.isfinite(c), "LogisticCalc4: C is not finite")
			alglib.ap.assert(Math.isfinite(d), "LogisticCalc4: D is not finite")
			alglib.ap.assert(CDbl(x) >= CDbl(0), "LogisticCalc4: X is negative")
			alglib.ap.assert(CDbl(c) > CDbl(0), "LogisticCalc4: C is non-positive")

			'
			' Check for degenerate cases
			'
			If CDbl(b) = CDbl(0) Then
				result = 0.5 * (a + d)
				Return result
			End If
			If CDbl(x) = CDbl(0) Then
				If CDbl(b) > CDbl(0) Then
					result = a
				Else
					result = d
				End If
				Return result
			End If

			'
			' General case
			'
			result = d + (a - d) / (1.0 + System.Math.Pow(x / c, b))
			alglib.ap.assert(Math.isfinite(result), "LogisticCalc4: overflow during calculations")
			Return result
		End Function


		'************************************************************************
'        This function calculates value of five-parameter logistic (5PL)  model  at
'        specified point X. 5PL model has following form:
'
'            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'        INPUT PARAMETERS:
'            X       -   current point, X>=0:
'                        * zero X is correctly handled even for B<=0
'                        * negative X results in exception.
'            A, B, C, D, G- parameters of 5PL model:
'                        * A is unconstrained
'                        * B is unconstrained; zero or negative values are handled
'                          correctly.
'                        * C>0, non-positive value results in exception
'                        * D is unconstrained
'                        * G>0, non-positive value results in exception
'                        
'        RESULT:
'            model value at X
'
'        NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
'              zero X (strictly speaking, 0^0 is undefined).
'
'        NOTE: this function also throws exception  if  all  input  parameters  are
'              correct, but overflow was detected during calculations.
'              
'        NOTE: this function performs a lot of checks;  if  you  need  really  high
'              performance, consider evaluating model  yourself,  without  checking
'              for degenerate cases.
'              
'            
'          -- ALGLIB PROJECT --
'             Copyright 14.05.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function logisticcalc5(x As Double, a As Double, b As Double, c As Double, d As Double, g As Double) As Double
			Dim result As Double = 0

			alglib.ap.assert(Math.isfinite(x), "LogisticCalc5: X is not finite")
			alglib.ap.assert(Math.isfinite(a), "LogisticCalc5: A is not finite")
			alglib.ap.assert(Math.isfinite(b), "LogisticCalc5: B is not finite")
			alglib.ap.assert(Math.isfinite(c), "LogisticCalc5: C is not finite")
			alglib.ap.assert(Math.isfinite(d), "LogisticCalc5: D is not finite")
			alglib.ap.assert(Math.isfinite(g), "LogisticCalc5: G is not finite")
			alglib.ap.assert(CDbl(x) >= CDbl(0), "LogisticCalc5: X is negative")
			alglib.ap.assert(CDbl(c) > CDbl(0), "LogisticCalc5: C is non-positive")
			alglib.ap.assert(CDbl(g) > CDbl(0), "LogisticCalc5: G is non-positive")

			'
			' Check for degenerate cases
			'
			If CDbl(b) = CDbl(0) Then
				result = d + (a - d) / System.Math.Pow(2.0, g)
				Return result
			End If
			If CDbl(x) = CDbl(0) Then
				If CDbl(b) > CDbl(0) Then
					result = a
				Else
					result = d
				End If
				Return result
			End If

			'
			' General case
			'
			result = d + (a - d) / System.Math.Pow(1.0 + System.Math.Pow(x / c, b), g)
			alglib.ap.assert(Math.isfinite(result), "LogisticCalc5: overflow during calculations")
			Return result
		End Function


		'************************************************************************
'        This function fits four-parameter logistic (4PL) model  to  data  provided
'        by user. 4PL model has following form:
'
'            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'        Here:
'            * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
'            * B>=0
'            * C>0
'            
'        IMPORTANT: output of this function is constrained in  such  way that  B>0.
'                   Because 4PL model is symmetric with respect to B, there  is  no
'                   need to explore  B<0.  Constraining  B  makes  algorithm easier
'                   to stabilize and debug.
'                   Users  who  for  some  reason  prefer to work with negative B's
'                   should transform output themselves (swap A and D, replace B  by
'                   -B).
'                   
'        4PL fitting is implemented as follows:
'        * we perform small number of restarts from random locations which helps to
'          solve problem of bad local extrema. Locations are only partially  random
'          - we use input data to determine good  initial  guess,  but  we  include
'          controlled amount of randomness.
'        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'          parameters B and C - it allows us to find good  initial  guess  for  the
'          second stage without risk of running into "flat spot".
'        * second  Levenberg-Marquardt  round  is   performed   without   excessive
'          constraints. Results from the previous round are used as initial guess.
'        * after fitting is done, we compare results with best values found so far,
'          rewrite "best solution" if needed, and move to next random location.
'          
'        Overall algorithm is very stable and is not prone to  bad  local  extrema.
'        Furthermore, it automatically scales when input data have  very  large  or
'        very small range.
'
'        INPUT PARAMETERS:
'            X       -   array[N], stores X-values.
'                        MUST include only non-negative numbers  (but  may  include
'                        zero values). Can be unsorted.
'            Y       -   array[N], values to fit.
'            N       -   number of points. If N is less than  length  of  X/Y, only
'                        leading N elements are used.
'                        
'        OUTPUT PARAMETERS:
'            A, B, C, D- parameters of 4PL model
'            Rep     -   fitting report. This structure has many fields,  but  ONLY
'                        ONES LISTED BELOW ARE SET:
'                        * Rep.IterationsCount - number of iterations performed
'                        * Rep.RMSError - root-mean-square error
'                        * Rep.AvgError - average absolute error
'                        * Rep.AvgRelError - average relative error (calculated for
'                          non-zero Y-values)
'                        * Rep.MaxError - maximum absolute error
'                        * Rep.R2 - coefficient of determination,  R-squared.  This
'                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                          of nonlinear  regression  there  are  multiple  ways  to
'                          define R2, each of them giving different results).
'                          
'        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'              LogisticCalc4() function.
'
'        NOTE: if you need better control over fitting process than provided by this
'              function, you may use LogisticFit45X().
'                        
'        NOTE: step is automatically scaled according to scale of parameters  being
'              fitted before we compare its length with EpsX. Thus,  this  function
'              can be used to fit data with very small or very large values without
'              changing EpsX.
'            
'
'          -- ALGLIB PROJECT --
'             Copyright 14.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub logisticfit4(x As Double(), y As Double(), n As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
			ByRef d As Double, rep As lsfitreport)
			Dim g As Double = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			a = 0
			b = 0
			c = 0
			d = 0

			logisticfit45x(x, y, n, [Double].NaN, [Double].NaN, True, _
				0.0, 0.0, 0, a, b, c, _
				d, g, rep)
		End Sub


		'************************************************************************
'        This function fits four-parameter logistic (4PL) model  to  data  provided
'        by user, with optional constraints on parameters A and D.  4PL  model  has
'        following form:
'
'            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
'
'        Here:
'            * A, D - with optional equality constraints
'            * B>=0
'            * C>0
'            
'        IMPORTANT: output of this function is constrained in  such  way that  B>0.
'                   Because 4PL model is symmetric with respect to B, there  is  no
'                   need to explore  B<0.  Constraining  B  makes  algorithm easier
'                   to stabilize and debug.
'                   Users  who  for  some  reason  prefer to work with negative B's
'                   should transform output themselves (swap A and D, replace B  by
'                   -B).
'                   
'        4PL fitting is implemented as follows:
'        * we perform small number of restarts from random locations which helps to
'          solve problem of bad local extrema. Locations are only partially  random
'          - we use input data to determine good  initial  guess,  but  we  include
'          controlled amount of randomness.
'        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'          parameters B and C - it allows us to find good  initial  guess  for  the
'          second stage without risk of running into "flat spot".
'        * second  Levenberg-Marquardt  round  is   performed   without   excessive
'          constraints. Results from the previous round are used as initial guess.
'        * after fitting is done, we compare results with best values found so far,
'          rewrite "best solution" if needed, and move to next random location.
'          
'        Overall algorithm is very stable and is not prone to  bad  local  extrema.
'        Furthermore, it automatically scales when input data have  very  large  or
'        very small range.
'
'        INPUT PARAMETERS:
'            X       -   array[N], stores X-values.
'                        MUST include only non-negative numbers  (but  may  include
'                        zero values). Can be unsorted.
'            Y       -   array[N], values to fit.
'            N       -   number of points. If N is less than  length  of  X/Y, only
'                        leading N elements are used.
'            CnstrLeft-  optional equality constraint for model value at the   left
'                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                        not need constraint on the model value at X=0 (in C++  you
'                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                        Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'            CnstrRight- optional equality constraint for model value at X=infinity.
'                        Specify NAN (Not-a-Number) if you do not  need  constraint
'                        on the model value (in C++  you can pass alglib::fp_nan as
'                        parameter, in  C# it will  be Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'                        
'        OUTPUT PARAMETERS:
'            A, B, C, D- parameters of 4PL model
'            Rep     -   fitting report. This structure has many fields,  but  ONLY
'                        ONES LISTED BELOW ARE SET:
'                        * Rep.IterationsCount - number of iterations performed
'                        * Rep.RMSError - root-mean-square error
'                        * Rep.AvgError - average absolute error
'                        * Rep.AvgRelError - average relative error (calculated for
'                          non-zero Y-values)
'                        * Rep.MaxError - maximum absolute error
'                        * Rep.R2 - coefficient of determination,  R-squared.  This
'                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                          of nonlinear  regression  there  are  multiple  ways  to
'                          define R2, each of them giving different results).
'
'        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'              LogisticCalc4() function.
'
'        NOTE: if you need better control over fitting process than provided by this
'              function, you may use LogisticFit45X().
'                        
'        NOTE: step is automatically scaled according to scale of parameters  being
'              fitted before we compare its length with EpsX. Thus,  this  function
'              can be used to fit data with very small or very large values without
'              changing EpsX.
'
'        EQUALITY CONSTRAINTS ON PARAMETERS
'
'        4PL/5PL solver supports equality constraints on model values at  the  left
'        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'        completely optional and you can specify both of them, only  one  -  or  no
'        constraints at all.
'
'        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'        fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
'        ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
'        D. That's because 4PL model is normalized in such way that B>=0.
'            
'
'          -- ALGLIB PROJECT --
'             Copyright 14.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub logisticfit4ec(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, ByRef a As Double, _
			ByRef b As Double, ByRef c As Double, ByRef d As Double, rep As lsfitreport)
			Dim g As Double = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			a = 0
			b = 0
			c = 0
			d = 0

			logisticfit45x(x, y, n, cnstrleft, cnstrright, True, _
				0.0, 0.0, 0, a, b, c, _
				d, g, rep)
		End Sub


		'************************************************************************
'        This function fits five-parameter logistic (5PL) model  to  data  provided
'        by user. 5PL model has following form:
'
'            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'        Here:
'            * A, D - unconstrained
'            * B - unconstrained
'            * C>0
'            * G>0
'            
'        IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
'                   constrained in  such  way that B is guaranteed to be  positive.
'                   Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
'                   respect to B, so you can NOT transform model to equivalent one,
'                   with B having desired sign (>0 or <0).
'            
'        5PL fitting is implemented as follows:
'        * we perform small number of restarts from random locations which helps to
'          solve problem of bad local extrema. Locations are only partially  random
'          - we use input data to determine good  initial  guess,  but  we  include
'          controlled amount of randomness.
'        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'          parameters B and C - it allows us to find good  initial  guess  for  the
'          second stage without risk of running into "flat spot".  Parameter  G  is
'          fixed at G=1.
'        * second  Levenberg-Marquardt  round  is   performed   without   excessive
'          constraints on B and C, but with G still equal to 1.  Results  from  the
'          previous round are used as initial guess.
'        * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
'          different models - one with B>0 and one with B<0.
'        * after fitting is done, we compare results with best values found so far,
'          rewrite "best solution" if needed, and move to next random location.
'          
'        Overall algorithm is very stable and is not prone to  bad  local  extrema.
'        Furthermore, it automatically scales when input data have  very  large  or
'        very small range.
'
'        INPUT PARAMETERS:
'            X       -   array[N], stores X-values.
'                        MUST include only non-negative numbers  (but  may  include
'                        zero values). Can be unsorted.
'            Y       -   array[N], values to fit.
'            N       -   number of points. If N is less than  length  of  X/Y, only
'                        leading N elements are used.
'                        
'        OUTPUT PARAMETERS:
'            A,B,C,D,G-  parameters of 5PL model
'            Rep     -   fitting report. This structure has many fields,  but  ONLY
'                        ONES LISTED BELOW ARE SET:
'                        * Rep.IterationsCount - number of iterations performed
'                        * Rep.RMSError - root-mean-square error
'                        * Rep.AvgError - average absolute error
'                        * Rep.AvgRelError - average relative error (calculated for
'                          non-zero Y-values)
'                        * Rep.MaxError - maximum absolute error
'                        * Rep.R2 - coefficient of determination,  R-squared.  This
'                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                          of nonlinear  regression  there  are  multiple  ways  to
'                          define R2, each of them giving different results).
'
'        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'              LogisticCalc5() function.
'
'        NOTE: if you need better control over fitting process than provided by this
'              function, you may use LogisticFit45X().
'                        
'        NOTE: step is automatically scaled according to scale of parameters  being
'              fitted before we compare its length with EpsX. Thus,  this  function
'              can be used to fit data with very small or very large values without
'              changing EpsX.
'            
'
'          -- ALGLIB PROJECT --
'             Copyright 14.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub logisticfit5(x As Double(), y As Double(), n As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
			ByRef d As Double, ByRef g As Double, rep As lsfitreport)
			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			a = 0
			b = 0
			c = 0
			d = 0
			g = 0

			logisticfit45x(x, y, n, [Double].NaN, [Double].NaN, False, _
				0.0, 0.0, 0, a, b, c, _
				d, g, rep)
		End Sub


		'************************************************************************
'        This function fits five-parameter logistic (5PL) model  to  data  provided
'        by user, subject to optional equality constraints on parameters A  and  D.
'        5PL model has following form:
'
'            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
'
'        Here:
'            * A, D - with optional equality constraints
'            * B - unconstrained
'            * C>0
'            * G>0
'            
'        IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
'                   constrained in  such  way that B is guaranteed to be  positive.
'                   Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
'                   respect to B, so you can NOT transform model to equivalent one,
'                   with B having desired sign (>0 or <0).
'            
'        5PL fitting is implemented as follows:
'        * we perform small number of restarts from random locations which helps to
'          solve problem of bad local extrema. Locations are only partially  random
'          - we use input data to determine good  initial  guess,  but  we  include
'          controlled amount of randomness.
'        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
'          parameters B and C - it allows us to find good  initial  guess  for  the
'          second stage without risk of running into "flat spot".  Parameter  G  is
'          fixed at G=1.
'        * second  Levenberg-Marquardt  round  is   performed   without   excessive
'          constraints on B and C, but with G still equal to 1.  Results  from  the
'          previous round are used as initial guess.
'        * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
'          different models - one with B>0 and one with B<0.
'        * after fitting is done, we compare results with best values found so far,
'          rewrite "best solution" if needed, and move to next random location.
'          
'        Overall algorithm is very stable and is not prone to  bad  local  extrema.
'        Furthermore, it automatically scales when input data have  very  large  or
'        very small range.
'
'        INPUT PARAMETERS:
'            X       -   array[N], stores X-values.
'                        MUST include only non-negative numbers  (but  may  include
'                        zero values). Can be unsorted.
'            Y       -   array[N], values to fit.
'            N       -   number of points. If N is less than  length  of  X/Y, only
'                        leading N elements are used.
'            CnstrLeft-  optional equality constraint for model value at the   left
'                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                        not need constraint on the model value at X=0 (in C++  you
'                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                        Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'            CnstrRight- optional equality constraint for model value at X=infinity.
'                        Specify NAN (Not-a-Number) if you do not  need  constraint
'                        on the model value (in C++  you can pass alglib::fp_nan as
'                        parameter, in  C# it will  be Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'                        
'        OUTPUT PARAMETERS:
'            A,B,C,D,G-  parameters of 5PL model
'            Rep     -   fitting report. This structure has many fields,  but  ONLY
'                        ONES LISTED BELOW ARE SET:
'                        * Rep.IterationsCount - number of iterations performed
'                        * Rep.RMSError - root-mean-square error
'                        * Rep.AvgError - average absolute error
'                        * Rep.AvgRelError - average relative error (calculated for
'                          non-zero Y-values)
'                        * Rep.MaxError - maximum absolute error
'                        * Rep.R2 - coefficient of determination,  R-squared.  This
'                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                          of nonlinear  regression  there  are  multiple  ways  to
'                          define R2, each of them giving different results).
'
'        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'              LogisticCalc5() function.
'
'        NOTE: if you need better control over fitting process than provided by this
'              function, you may use LogisticFit45X().
'                        
'        NOTE: step is automatically scaled according to scale of parameters  being
'              fitted before we compare its length with EpsX. Thus,  this  function
'              can be used to fit data with very small or very large values without
'              changing EpsX.
'
'        EQUALITY CONSTRAINTS ON PARAMETERS
'
'        5PL solver supports equality constraints on model  values  at   the   left
'        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'        completely optional and you can specify both of them, only  one  -  or  no
'        constraints at all.
'
'        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'        fitting), and CnstrRight contains right  one.
'
'        Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
'        of B. Thus, negative B's are possible, and left constraint  may  constrain
'        parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
'        Similarly changes meaning of right constraint.
'
'        You do not have to decide what parameter to  constrain  -  algorithm  will
'        automatically determine correct parameters as fitting progresses. However,
'        question highlighted above is important when you interpret fitting results.
'            
'
'          -- ALGLIB PROJECT --
'             Copyright 14.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub logisticfit5ec(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, ByRef a As Double, _
			ByRef b As Double, ByRef c As Double, ByRef d As Double, ByRef g As Double, rep As lsfitreport)
			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			a = 0
			b = 0
			c = 0
			d = 0
			g = 0

			logisticfit45x(x, y, n, cnstrleft, cnstrright, False, _
				0.0, 0.0, 0, a, b, c, _
				d, g, rep)
		End Sub


		'************************************************************************
'        This is "expert" 4PL/5PL fitting function, which can be used if  you  need
'        better control over fitting process than provided  by  LogisticFit4()  or
'        LogisticFit5().
'
'        This function fits model of the form
'
'            F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)
'
'        or
'
'            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)
'            
'        Here:
'            * A, D - unconstrained
'            * B>=0 for 4PL, unconstrained for 5PL
'            * C>0
'            * G>0 (if present)
'
'        INPUT PARAMETERS:
'            X       -   array[N], stores X-values.
'                        MUST include only non-negative numbers  (but  may  include
'                        zero values). Can be unsorted.
'            Y       -   array[N], values to fit.
'            N       -   number of points. If N is less than  length  of  X/Y, only
'                        leading N elements are used.
'            CnstrLeft-  optional equality constraint for model value at the   left
'                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
'                        not need constraint on the model value at X=0 (in C++  you
'                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
'                        Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'            CnstrRight- optional equality constraint for model value at X=infinity.
'                        Specify NAN (Not-a-Number) if you do not  need  constraint
'                        on the model value (in C++  you can pass alglib::fp_nan as
'                        parameter, in  C# it will  be Double.NaN).
'                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
'                        information about constraints.
'            Is4PL   -   whether 4PL or 5PL models are fitted
'            LambdaV -   regularization coefficient, LambdaV>=0.
'                        Set it to zero unless you know what you are doing.
'            EpsX    -   stopping condition (step size), EpsX>=0.
'                        Zero value means that small step is automatically chosen.
'                        See notes below for more information.
'            RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
'                        models are prone to problem of bad local extrema. Utilizing
'                        multiple random restarts allows  us  to  improve algorithm
'                        convergence.
'                        RsCnt>=0.
'                        Zero value means that function automatically choose  small
'                        amount of restarts (recommended).
'                        
'        OUTPUT PARAMETERS:
'            A, B, C, D- parameters of 4PL model
'            G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
'            Rep     -   fitting report. This structure has many fields,  but  ONLY
'                        ONES LISTED BELOW ARE SET:
'                        * Rep.IterationsCount - number of iterations performed
'                        * Rep.RMSError - root-mean-square error
'                        * Rep.AvgError - average absolute error
'                        * Rep.AvgRelError - average relative error (calculated for
'                          non-zero Y-values)
'                        * Rep.MaxError - maximum absolute error
'                        * Rep.R2 - coefficient of determination,  R-squared.  This
'                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
'                          of nonlinear  regression  there  are  multiple  ways  to
'                          define R2, each of them giving different results).
'                        
'        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
'              LogisticCalc5() function.
'
'        NOTE: step is automatically scaled according to scale of parameters  being
'              fitted before we compare its length with EpsX. Thus,  this  function
'              can be used to fit data with very small or very large values without
'              changing EpsX.
'
'        EQUALITY CONSTRAINTS ON PARAMETERS
'
'        4PL/5PL solver supports equality constraints on model values at  the  left
'        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
'        completely optional and you can specify both of them, only  one  -  or  no
'        constraints at all.
'
'        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
'        fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
'        ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
'        D. That's because 4PL model is normalized in such way that B>=0.
'
'        For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
'        symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
'        possible, and left constraint may constrain parameter A (for positive B's)
'        - or parameter D (for negative B's). Similarly changes  meaning  of  right
'        constraint.
'
'        You do not have to decide what parameter to  constrain  -  algorithm  will
'        automatically determine correct parameters as fitting progresses. However,
'        question highlighted above is important when you interpret fitting results.
'            
'
'          -- ALGLIB PROJECT --
'             Copyright 14.02.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub logisticfit45x(x As Double(), y As Double(), n As Integer, cnstrleft As Double, cnstrright As Double, is4pl As Boolean, _
			lambdav As Double, epsx As Double, rscnt As Integer, ByRef a As Double, ByRef b As Double, ByRef c As Double, _
			ByRef d As Double, ByRef g As Double, rep As lsfitreport)
			Dim i As Integer = 0
			Dim k As Integer = 0
			Dim innerit As Integer = 0
			Dim outerit As Integer = 0
			Dim nz As Integer = 0
			Dim v As Double = 0
			Dim b00 As Double = 0
			Dim b01 As Double = 0
			Dim b10 As Double = 0
			Dim b11 As Double = 0
			Dim b30 As Double = 0
			Dim b31 As Double = 0
			Dim p0 As Double() = New Double(-1) {}
			Dim p1 As Double() = New Double(-1) {}
			Dim p2 As Double() = New Double(-1) {}
			Dim bndl As Double() = New Double(-1) {}
			Dim bndu As Double() = New Double(-1) {}
			Dim s As Double() = New Double(-1) {}
			Dim z As Double(,) = New Double(-1, -1) {}
			Dim rs As New hqrnd.hqrndstate()
			Dim state As New minlm.minlmstate()
			Dim replm As New minlm.minlmreport()
			Dim maxits As Integer = 0
			Dim fbest As Double = 0
			Dim flast As Double = 0
			Dim flast2 As Double = 0
			Dim scalex As Double = 0
			Dim scaley As Double = 0
			Dim bufx As Double() = New Double(-1) {}
			Dim bufy As Double() = New Double(-1) {}
			Dim rss As Double = 0
			Dim tss As Double = 0
			Dim meany As Double = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			a = 0
			b = 0
			c = 0
			d = 0
			g = 0

			alglib.ap.assert(Math.isfinite(epsx), "LogisticFitX: EpsX is infinite/NAN")
			alglib.ap.assert(Math.isfinite(lambdav), "LogisticFitX: LambdaV is infinite/NAN")
			alglib.ap.assert(Math.isfinite(cnstrleft) OrElse [Double].IsNaN(cnstrleft), "LogisticFitX: CnstrLeft is NOT finite or NAN")
			alglib.ap.assert(Math.isfinite(cnstrright) OrElse [Double].IsNaN(cnstrright), "LogisticFitX: CnstrRight is NOT finite or NAN")
			alglib.ap.assert(CDbl(lambdav) >= CDbl(0), "LogisticFitX: negative LambdaV")
			alglib.ap.assert(n > 0, "LogisticFitX: N<=0")
			alglib.ap.assert(rscnt >= 0, "LogisticFitX: RsCnt<0")
			alglib.ap.assert(CDbl(epsx) >= CDbl(0), "LogisticFitX: EpsX<0")
			alglib.ap.assert(alglib.ap.len(x) >= n, "LogisticFitX: Length(X)<N")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LogisticFitX: Length(Y)<N")
			alglib.ap.assert(apserv.isfinitevector(x, n), "LogisticFitX: X contains infinite/NAN values")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LogisticFitX: X contains infinite/NAN values")
			hqrnd.hqrndseed(2211, 1033044, rs)
			clearreport(rep)
			If CDbl(epsx) = CDbl(0) Then
				epsx = 1E-10
			End If
			If rscnt = 0 Then
				rscnt = 4
			End If
			maxits = 1000

			'
			' Sort points by X.
			' Determine number of zero and non-zero values.
			'
			tsort.tagsortfastr(x, y, bufx, bufy, n)
			alglib.ap.assert(CDbl(x(0)) >= CDbl(0), "LogisticFitX: some X[] are negative")
			nz = n
			For i = 0 To n - 1
				If CDbl(x(i)) > CDbl(0) Then
					nz = i
					Exit For
				End If
			Next

			'
			' For NZ=N (all X[] are zero) special code is used.
			' For NZ<N we use general-purpose code.
			'
			rep.iterationscount = 0
			If nz = n Then

				'
				' NZ=N, degenerate problem.
				' No need to run optimizer.
				'
				v = 0.0
				For i = 0 To n - 1
					v = v + y(i)
				Next
				v = v / n
				If Math.isfinite(cnstrleft) Then
					a = cnstrleft
				Else
					a = v
				End If
				b = 1
				c = 1
				If Math.isfinite(cnstrright) Then
					d = cnstrright
				Else
					d = a
				End If
				g = 1
			Else

				'
				' Non-degenerate problem.
				' Determine scale of data.
				'
				scalex = x(nz + (n - nz) \ 2)
				alglib.ap.assert(CDbl(scalex) > CDbl(0), "LogisticFitX: internal error")
				v = 0.0
				For i = 0 To n - 1
					v = v + y(i)
				Next
				v = v / n
				scaley = 0.0
				For i = 0 To n - 1
					scaley = scaley + Math.sqr(y(i) - v)
				Next
				scaley = System.Math.sqrt(scaley / n)
				If CDbl(scaley) = CDbl(0) Then
					scaley = 1.0
				End If
				s = New Double(4) {}
				s(0) = scaley
				s(1) = 0.1
				s(2) = scalex
				s(3) = scaley
				s(4) = 0.1
				p0 = New Double(4) {}
				p0(0) = 0
				p0(1) = 0
				p0(2) = 0
				p0(3) = 0
				p0(4) = 0
				bndl = New Double(4) {}
				bndu = New Double(4) {}
				minlm.minlmcreatevj(5, n + 5, p0, state)
				minlm.minlmsetscale(state, s)
				minlm.minlmsetcond(state, 0.0, 0.0, epsx, maxits)
				minlm.minlmsetxrep(state, True)

				'
				' Main loop - includes THREE (!) nested iterations:
				'
				' 1. Inner iteration is minimization of target function from
				'    the current initial point P1 subject to boundary constraints
				'    given by arrays BndL and BndU.
				'
				' 2. Middle iteration changes boundary constraints from tight to
				'    relaxed ones:
				'    * at the first middle iteration we optimize with "tight"
				'      constraints on parameters B and C (P[1] and P[2]). It
				'      allows us to find good initial point for the next middle
				'      iteration without risk of running into "hard" points (B=0, C=0).
				'      Initial point is initialized by outer iteration.
				'      Solution is placed to P1.
				'    * at the second middle iteration we relax boundary constraints
				'      on B and C. Solution P1 from the first middle iteration is
				'      used as initial point for the second one.
				'    * both first and second iterations are 4PL models, even when
				'      we fit 5PL.
				'    * additionally, for 5PL models, we use results from the second
				'      middle iteration is initial guess for 5PL fit.
				'    * after middle iteration is over we compare quality of the
				'      solution stored in P1 and offload it to A/B/C/D/G, if it
				'      is better.
				'
				' 3. Outer iteration (starts below) changes following parameters:
				'    * initial point
				'    * "tight" constraints BndL/BndU
				'    * "relaxed" constraints BndL/BndU
				'
				' Below we prepare combined matrix Z of optimization settings for
				' outer/middle iterations:
				'
				'     [ P00 BndL00 BndU00 BndL01 BndU01 ]
				'     [                                 ]
				'     [ P10 BndL10 BndU10 BndL11 BndU11 ]
				'
				' Here:
				' * Pi0 is initial point for I-th outer iteration
				' * BndLij is lower boundary for I-th outer iteration, J-th inner iteration
				' * BndUij - same as BndLij
				'
				z = New Double(rscnt - 1, 5 + (4 * 5 - 1)) {}
				For i = 0 To rscnt - 1
					If Math.isfinite(cnstrleft) Then
						z(i, 0) = cnstrleft
					Else
						z(i, 0) = y(0) + 0.25 * scaley * (hqrnd.hqrnduniformr(rs) - 0.5)
					End If
					z(i, 1) = 0.5 + hqrnd.hqrnduniformr(rs)
					z(i, 2) = x(nz + hqrnd.hqrnduniformi(rs, n - nz))
					If Math.isfinite(cnstrright) Then
						z(i, 3) = cnstrright
					Else
						z(i, 3) = y(n - 1) + 0.25 * scaley * (hqrnd.hqrnduniformr(rs) - 0.5)
					End If
					z(i, 4) = 1.0
					If Math.isfinite(cnstrleft) Then
						z(i, 5 + 0) = cnstrleft
						z(i, 10 + 0) = cnstrleft
					Else
						z(i, 5 + 0) = [Double].NegativeInfinity
						z(i, 10 + 0) = [Double].PositiveInfinity
					End If
					z(i, 5 + 1) = 0.5
					z(i, 10 + 1) = 2.0
					z(i, 5 + 2) = 0.5 * scalex
					z(i, 10 + 2) = 2.0 * scalex
					If Math.isfinite(cnstrright) Then
						z(i, 5 + 3) = cnstrright
						z(i, 10 + 3) = cnstrright
					Else
						z(i, 5 + 3) = [Double].NegativeInfinity
						z(i, 10 + 3) = [Double].PositiveInfinity
					End If
					z(i, 5 + 4) = 1.0
					z(i, 10 + 4) = 1.0
					If Math.isfinite(cnstrleft) Then
						z(i, 15 + 0) = cnstrleft
						z(i, 20 + 0) = cnstrleft
					Else
						z(i, 15 + 0) = [Double].NegativeInfinity
						z(i, 20 + 0) = [Double].PositiveInfinity
					End If
					z(i, 15 + 1) = 0.01
					z(i, 20 + 1) = [Double].PositiveInfinity
					z(i, 15 + 2) = Math.machineepsilon * scalex
					z(i, 20 + 2) = [Double].PositiveInfinity
					If Math.isfinite(cnstrright) Then
						z(i, 15 + 3) = cnstrright
						z(i, 20 + 3) = cnstrright
					Else
						z(i, 15 + 3) = [Double].NegativeInfinity
						z(i, 20 + 3) = [Double].PositiveInfinity
					End If
					z(i, 15 + 4) = 1.0
					z(i, 20 + 4) = 1.0
				Next

				'
				' Run outer iterations
				'
				a = 0
				b = 1
				c = 1
				d = 1
				g = 1
                fbest = Math.maxrealnumber
                p1 = New Double(4) {}
                p2 = New Double(4) {}
                For outerit = 0 To alglib.ap.rows(z) - 1

                    '
                    ' Beginning of the middle iterations.
                    ' Prepare initial point P1.
                    '
                    For i = 0 To 4
                        p1(i) = z(outerit, i)
                    Next
                    flast = Math.maxrealnumber
                    For innerit = 0 To 1

                        '
                        ' Set current boundary constraints.
                        ' Run inner iteration.
                        '
                        For i = 0 To 4
                            bndl(i) = z(outerit, 5 + innerit * 10 + 0 + i)
                            bndu(i) = z(outerit, 5 + innerit * 10 + 5 + i)
                        Next
                        minlm.minlmsetbc(state, bndl, bndu)
                        logisticfitinternal(x, y, n, True, lambdav, state, _
                            replm, p1, flast)
                        rep.iterationscount = rep.iterationscount + replm.iterationscount
                    Next

                    '
                    ' Middle iteration: try to fit with 5-parameter logistic model (if needed).
                    '
                    ' We perform two attempts to fit: one with B>0, another one with B<0.
                    ' For PL4, these are equivalent up to transposition of A/D, but for 5PL
                    ' sign of B is very important.
                    '
                    ' NOTE: results of 4PL fit are used as initial point for 5PL.
                    '
                    If Not is4pl Then

                        '
                        ' Loosen constraints on G,
                        ' save constraints on A/B/D to B0/B1
                        '
                        bndl(4) = 0.1
                        bndu(4) = 10.0
                        b00 = bndl(0)
                        b01 = bndu(0)
                        b10 = bndl(1)
                        b11 = bndu(1)
                        b30 = bndl(3)
                        b31 = bndu(3)

                        '
                        ' First attempt: fitting with positive B
                        '
                        p2(0) = p1(0)
                        p2(1) = p1(1)
                        p2(2) = p1(2)
                        p2(3) = p1(3)
                        p2(4) = p1(4)
                        bndl(0) = b00
                        bndu(0) = b01
                        bndl(1) = b10
                        bndu(1) = b11
                        bndl(3) = b30
                        bndu(3) = b31
                        minlm.minlmsetbc(state, bndl, bndu)
                        logisticfitinternal(x, y, n, False, lambdav, state, _
                            replm, p2, flast2)
                        rep.iterationscount = rep.iterationscount + replm.iterationscount
                        If CDbl(flast2) < CDbl(flast) Then
                            For i = 0 To 4
                                p1(i) = p2(i)
                            Next
                            flast = flast2
                        End If

                        '
                        ' First attempt: fitting with negative B
                        '
                        p2(0) = p1(3)
                        p2(1) = -p1(1)
                        p2(2) = p1(2)
                        p2(3) = p1(0)
                        p2(4) = p1(4)
                        bndl(0) = b30
                        bndu(0) = b31
                        bndl(1) = -b11
                        bndu(1) = -b10
                        bndl(3) = b00
                        bndu(3) = b01
                        minlm.minlmsetbc(state, bndl, bndu)
                        logisticfitinternal(x, y, n, False, lambdav, state, _
                            replm, p2, flast2)
                        rep.iterationscount = rep.iterationscount + replm.iterationscount
                        If CDbl(flast2) < CDbl(flast) Then
                            For i = 0 To 4
                                p1(i) = p2(i)
                            Next
                            flast = flast2
                        End If
                    End If

                    '
                    ' Middle iteration is done, compare its results with best value
                    ' found so far.
                    '
                    If CDbl(flast) < CDbl(fbest) Then
                        a = p1(0)
                        b = p1(1)
                        c = p1(2)
                        d = p1(3)
                        g = p1(4)
                        fbest = flast
                    End If
                Next
            End If

            '
            ' Calculate errors
            '
            rep.rmserror = 0
            rep.avgerror = 0
            rep.avgrelerror = 0
            rep.maxerror = 0
            k = 0
            rss = 0.0
            tss = 0.0
            meany = 0.0
            For i = 0 To n - 1
                meany = meany + y(i)
            Next
            meany = meany / n
            For i = 0 To n - 1

                '
                ' Calculate residual from regression
                '
                If CDbl(x(i)) > CDbl(0) Then
                    v = d + (a - d) / System.Math.Pow(1.0 + System.Math.Pow(x(i) / c, b), g) - y(i)
                Else
                    If CDbl(b) >= CDbl(0) Then
                        v = a - y(i)
                    Else
                        v = d - y(i)
                    End If
                End If

                '
                ' Update RSS (residual sum of squares) and TSS (total sum of squares)
                ' which are used to calculate coefficient of determination.
                '
                ' NOTE: we use formula R2 = 1-RSS/TSS because it has nice property of
                '       being equal to 0.0 if and only if model perfectly fits data.
                '
                '       When we fit nonlinear models, there are exist multiple ways of
                '       determining R2, each of them giving different results. Formula
                '       above is the most intuitive one.
                '
                rss = rss + v * v
                tss = tss + Math.sqr(y(i) - meany)

                '
                ' Update errors
                '
                rep.rmserror = rep.rmserror + Math.sqr(v)
                rep.avgerror = rep.avgerror + System.Math.Abs(v)
                If CDbl(y(i)) <> CDbl(0) Then
                    rep.avgrelerror = rep.avgrelerror + System.Math.Abs(v / y(i))
                    k = k + 1
                End If
                rep.maxerror = System.Math.Max(rep.maxerror, System.Math.Abs(v))
            Next
            rep.rmserror = System.Math.sqrt(rep.rmserror / n)
            rep.avgerror = rep.avgerror / n
            If k > 0 Then
                rep.avgrelerror = rep.avgrelerror / k
            End If
            rep.r2 = 1.0 - rss / tss
        End Sub


        '************************************************************************
        '        Weghted rational least  squares  fitting  using  Floater-Hormann  rational
        '        functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
        '        individual weights.
        '
        '        Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
        '        functions. Different values of D are tried, optimal D (least WEIGHTED root
        '        mean square error) is chosen.  Task  is  linear,  so  linear least squares
        '        solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
        '        (mostly dominated by the least squares solver).
        '
        '        SEE ALSO
        '        * BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
        '          weights and constraints.
        '          
        '        COMMERCIAL EDITION OF ALGLIB:
        '
        '          ! Commercial version of ALGLIB includes two  important  improvements  of
        '          ! this function, which can be used from C++ and C#:
        '          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
        '          ! * multithreading support
        '          !
        '          ! Intel MKL gives approximately constant  (with  respect  to  number  of
        '          ! worker threads) acceleration factor which depends on CPU  being  used,
        '          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
        '          ! comparison.
        '          !
        '          ! Speed-up provided by multithreading greatly depends  on  problem  size
        '          ! - only large problems (number of coefficients is more than 500) can be
        '          ! efficiently multithreaded.
        '          !
        '          ! Generally, commercial ALGLIB is several times faster than  open-source
        '          ! generic C edition, and many times faster than open-source C# edition.
        '          !
        '          ! We recommend you to read 'Working with commercial version' section  of
        '          ! ALGLIB Reference Manual in order to find out how to  use  performance-
        '          ! related features provided by commercial edition of ALGLIB.
        '
        '        INPUT PARAMETERS:
        '            X   -   points, array[0..N-1].
        '            Y   -   function values, array[0..N-1].
        '            W   -   weights, array[0..N-1]
        '                    Each summand in square  sum  of  approximation deviations from
        '                    given  values  is  multiplied  by  the square of corresponding
        '                    weight. Fill it by 1's if you don't  want  to  solve  weighted
        '                    task.
        '            N   -   number of points, N>0.
        '            XC  -   points where function values/derivatives are constrained,
        '                    array[0..K-1].
        '            YC  -   values of constraints, array[0..K-1]
        '            DC  -   array[0..K-1], types of constraints:
        '                    * DC[i]=0   means that S(XC[i])=YC[i]
        '                    * DC[i]=1   means that S'(XC[i])=YC[i]
        '                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
        '            K   -   number of constraints, 0<=K<M.
        '                    K=0 means no constraints (XC/YC/DC are not used in such cases)
        '            M   -   number of basis functions ( = number_of_nodes), M>=2.
        '
        '        OUTPUT PARAMETERS:
        '            Info-   same format as in LSFitLinearWC() subroutine.
        '                    * Info>0    task is solved
        '                    * Info<=0   an error occured:
        '                                -4 means inconvergence of internal SVD
        '                                -3 means inconsistent constraints
        '                                -1 means another errors in parameters passed
        '                                   (N<=0, for example)
        '            B   -   barycentric interpolant.
        '            Rep -   report, same format as in LSFitLinearWC() subroutine.
        '                    Following fields are set:
        '                    * DBest         best value of the D parameter
        '                    * RMSError      rms error on the (X,Y).
        '                    * AvgError      average error on the (X,Y).
        '                    * AvgRelError   average relative error on the non-zero Y
        '                    * MaxError      maximum error
        '                                    NON-WEIGHTED ERRORS ARE CALCULATED
        '
        '        IMPORTANT:
        '            this subroutine doesn't calculate task's condition number for K<>0.
        '
        '        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
        '
        '        Setting constraints can lead  to undesired  results,  like ill-conditioned
        '        behavior, or inconsistency being detected. From the other side,  it allows
        '        us to improve quality of the fit. Here we summarize  our  experience  with
        '        constrained barycentric interpolants:
        '        * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
        '          functions aren't as flexible as splines (although they are very smooth).
        '        * the more evenly constraints are spread across [min(x),max(x)],  the more
        '          chances that they will be consistent
        '        * the  greater  is  M (given  fixed  constraints),  the  more chances that
        '          constraints will be consistent
        '        * in the general case, consistency of constraints IS NOT GUARANTEED.
        '        * in the several special cases, however, we CAN guarantee consistency.
        '        * one of this cases is constraints on the function  VALUES at the interval
        '          boundaries. Note that consustency of the  constraints  on  the  function
        '          DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
        '          which are more flexible).
        '        * another  special  case  is ONE constraint on the function value (OR, but
        '          not AND, derivative) anywhere in the interval
        '
        '        Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
        '        can't solve your task without them. Anything beyond  special  cases  given
        '        above is not guaranteed and may result in inconsistency.
        '
        '          -- ALGLIB PROJECT --
        '             Copyright 18.08.2009 by Bochkanov Sergey
        '        ************************************************************************

        Public Shared Sub barycentricfitfloaterhormannwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
            dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, b As ratint.barycentricinterpolant, rep As barycentricfitreport)
            Dim d As Integer = 0
            Dim i As Integer = 0
            Dim wrmscur As Double = 0
            Dim wrmsbest As Double = 0
            Dim locb As New ratint.barycentricinterpolant()
            Dim locrep As New barycentricfitreport()
            Dim locinfo As Integer = 0

            info = 0

            alglib.ap.assert(n > 0, "BarycentricFitFloaterHormannWC: N<=0!")
            alglib.ap.assert(m > 0, "BarycentricFitFloaterHormannWC: M<=0!")
            alglib.ap.assert(k >= 0, "BarycentricFitFloaterHormannWC: K<0!")
            alglib.ap.assert(k < m, "BarycentricFitFloaterHormannWC: K>=M!")
            alglib.ap.assert(alglib.ap.len(x) >= n, "BarycentricFitFloaterHormannWC: Length(X)<N!")
            alglib.ap.assert(alglib.ap.len(y) >= n, "BarycentricFitFloaterHormannWC: Length(Y)<N!")
            alglib.ap.assert(alglib.ap.len(w) >= n, "BarycentricFitFloaterHormannWC: Length(W)<N!")
            alglib.ap.assert(alglib.ap.len(xc) >= k, "BarycentricFitFloaterHormannWC: Length(XC)<K!")
            alglib.ap.assert(alglib.ap.len(yc) >= k, "BarycentricFitFloaterHormannWC: Length(YC)<K!")
            alglib.ap.assert(alglib.ap.len(dc) >= k, "BarycentricFitFloaterHormannWC: Length(DC)<K!")
            alglib.ap.assert(apserv.isfinitevector(x, n), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!")
            alglib.ap.assert(apserv.isfinitevector(y, n), "BarycentricFitFloaterHormannWC: Y contains infinite or NaN values!")
            alglib.ap.assert(apserv.isfinitevector(w, n), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!")
            alglib.ap.assert(apserv.isfinitevector(xc, k), "BarycentricFitFloaterHormannWC: XC contains infinite or NaN values!")
            alglib.ap.assert(apserv.isfinitevector(yc, k), "BarycentricFitFloaterHormannWC: YC contains infinite or NaN values!")
            For i = 0 To k - 1
                alglib.ap.assert(dc(i) = 0 OrElse dc(i) = 1, "BarycentricFitFloaterHormannWC: one of DC[] is not 0 or 1!")
            Next

            '
            ' Find optimal D
            '
            ' Info is -3 by default (degenerate constraints).
            ' If LocInfo will always be equal to -3, Info will remain equal to -3.
            ' If at least once LocInfo will be -4, Info will be -4.
            '
            wrmsbest = Math.maxrealnumber
            rep.dbest = -1
            info = -3
            For d = 0 To System.Math.Min(9, n - 1)
                barycentricfitwcfixedd(x, y, w, n, xc, yc, _
                    dc, k, m, d, locinfo, locb, _
                    locrep)
                alglib.ap.assert((locinfo = -4 OrElse locinfo = -3) OrElse locinfo > 0, "BarycentricFitFloaterHormannWC: unexpected result from BarycentricFitWCFixedD!")
                If locinfo > 0 Then

                    '
                    ' Calculate weghted RMS
                    '
                    wrmscur = 0
                    For i = 0 To n - 1
                        wrmscur = wrmscur + Math.sqr(w(i) * (y(i) - ratint.barycentriccalc(locb, x(i))))
                    Next
                    wrmscur = System.Math.sqrt(wrmscur / n)
                    If CDbl(wrmscur) < CDbl(wrmsbest) OrElse rep.dbest < 0 Then
                        ratint.barycentriccopy(locb, b)
                        rep.dbest = d
                        info = 1
                        rep.rmserror = locrep.rmserror
                        rep.avgerror = locrep.avgerror
                        rep.avgrelerror = locrep.avgrelerror
                        rep.maxerror = locrep.maxerror
                        rep.taskrcond = locrep.taskrcond
                        wrmsbest = wrmscur
                    End If
                Else
                    If locinfo <> -3 AndAlso info < 0 Then
                        info = locinfo
                    End If
                End If
            Next
        End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_barycentricfitfloaterhormannwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, b As ratint.barycentricinterpolant, rep As barycentricfitreport)
			barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, _
				dc, k, m, info, b, rep)
		End Sub


		'************************************************************************
'        Rational least squares fitting using  Floater-Hormann  rational  functions
'        with optimal D chosen from [0,9].
'
'        Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
'        functions. Different values of D are tried, optimal  D  (least  root  mean
'        square error) is chosen.  Task  is  linear, so linear least squares solver
'        is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
'        dominated by the least squares solver).
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            N   -   number of points, N>0.
'            M   -   number of basis functions ( = number_of_nodes), M>=2.
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearWC() subroutine.
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'                                -3 means inconsistent constraints
'            B   -   barycentric interpolant.
'            Rep -   report, same format as in LSFitLinearWC() subroutine.
'                    Following fields are set:
'                    * DBest         best value of the D parameter
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub barycentricfitfloaterhormann(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, b As ratint.barycentricinterpolant, _
			rep As barycentricfitreport)
			Dim w As Double() = New Double(-1) {}
			Dim xc As Double() = New Double(-1) {}
			Dim yc As Double() = New Double(-1) {}
			Dim dc As Integer() = New Integer(-1) {}
			Dim i As Integer = 0

			info = 0

			alglib.ap.assert(n > 0, "BarycentricFitFloaterHormann: N<=0!")
			alglib.ap.assert(m > 0, "BarycentricFitFloaterHormann: M<=0!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "BarycentricFitFloaterHormann: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "BarycentricFitFloaterHormann: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "BarycentricFitFloaterHormann: X contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "BarycentricFitFloaterHormann: Y contains infinite or NaN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, _
				dc, 0, m, info, b, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_barycentricfitfloaterhormann(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, b As ratint.barycentricinterpolant, _
			rep As barycentricfitreport)
			barycentricfitfloaterhormann(x, y, n, m, info, b, _
				rep)
		End Sub


		'************************************************************************
'        Fitting by penalized cubic spline.
'
'        Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'        basis functions. Basis functions are cubic splines with  natural  boundary
'        conditions. Problem is regularized by  adding non-linearity penalty to the
'        usual least squares penalty function:
'
'            S(x) = arg min { LS + P }, where
'            LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
'            P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
'            rho  - tunable constant given by user
'            C    - automatically determined scale parameter,
'                   makes penalty invariant with respect to scaling of X, Y, W.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'                   
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            N   -   number of points (optional):
'                    * N>0
'                    * if given, only first N elements of X/Y are processed
'                    * if not given, automatically determined from X/Y sizes
'            M   -   number of basis functions ( = number_of_nodes), M>=4.
'            Rho -   regularization  constant  passed   by   user.   It   penalizes
'                    nonlinearity in the regression spline. It  is  logarithmically
'                    scaled,  i.e.  actual  value  of  regularization  constant  is
'                    calculated as 10^Rho. It is automatically scaled so that:
'                    * Rho=2.0 corresponds to moderate amount of nonlinearity
'                    * generally, it should be somewhere in the [-8.0,+8.0]
'                    If you do not want to penalize nonlineary,
'                    pass small Rho. Values as low as -15 should work.
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearWC() subroutine.
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD or
'                                   Cholesky decomposition; problem may be
'                                   too ill-conditioned (very rare)
'            S   -   spline interpolant.
'            Rep -   Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'        NOTE 1: additional nodes are added to the spline outside  of  the  fitting
'        interval to force linearity when x<min(x,xc) or x>max(x,xc).  It  is  done
'        for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
'        it is natural to force linearity outside of this interval.
'
'        NOTE 2: function automatically sorts points,  so  caller may pass unsorted
'        array.
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfitpenalized(x As Double(), y As Double(), n As Integer, m As Integer, rho As Double, ByRef info As Integer, _
			s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			Dim w As Double() = New Double(-1) {}
			Dim i As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitPenalized: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitPenalized: M<4!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitPenalized: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitPenalized: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitPenalized: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitPenalized: Y contains infinite or NAN values!")
			alglib.ap.assert(Math.isfinite(rho), "Spline1DFitPenalized: Rho is infinite!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			spline1dfitpenalizedw(x, y, w, n, m, rho, _
				info, s, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfitpenalized(x As Double(), y As Double(), n As Integer, m As Integer, rho As Double, ByRef info As Integer, _
			s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			spline1dfitpenalized(x, y, n, m, rho, info, _
				s, rep)
		End Sub


		'************************************************************************
'        Weighted fitting by penalized cubic spline.
'
'        Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'        basis functions. Basis functions are cubic splines with  natural  boundary
'        conditions. Problem is regularized by  adding non-linearity penalty to the
'        usual least squares penalty function:
'
'            S(x) = arg min { LS + P }, where
'            LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
'            P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
'            rho  - tunable constant given by user
'            C    - automatically determined scale parameter,
'                   makes penalty invariant with respect to scaling of X, Y, W.
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'                   
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            W   -   weights, array[0..N-1]
'                    Each summand in square  sum  of  approximation deviations from
'                    given  values  is  multiplied  by  the square of corresponding
'                    weight. Fill it by 1's if you don't  want  to  solve  weighted
'                    problem.
'            N   -   number of points (optional):
'                    * N>0
'                    * if given, only first N elements of X/Y/W are processed
'                    * if not given, automatically determined from X/Y/W sizes
'            M   -   number of basis functions ( = number_of_nodes), M>=4.
'            Rho -   regularization  constant  passed   by   user.   It   penalizes
'                    nonlinearity in the regression spline. It  is  logarithmically
'                    scaled,  i.e.  actual  value  of  regularization  constant  is
'                    calculated as 10^Rho. It is automatically scaled so that:
'                    * Rho=2.0 corresponds to moderate amount of nonlinearity
'                    * generally, it should be somewhere in the [-8.0,+8.0]
'                    If you do not want to penalize nonlineary,
'                    pass small Rho. Values as low as -15 should work.
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearWC() subroutine.
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD or
'                                   Cholesky decomposition; problem may be
'                                   too ill-conditioned (very rare)
'            S   -   spline interpolant.
'            Rep -   Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'        NOTE 1: additional nodes are added to the spline outside  of  the  fitting
'        interval to force linearity when x<min(x,xc) or x>max(x,xc).  It  is  done
'        for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
'        it is natural to force linearity outside of this interval.
'
'        NOTE 2: function automatically sorts points,  so  caller may pass unsorted
'        array.
'
'          -- ALGLIB PROJECT --
'             Copyright 19.10.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), n As Integer, m As Integer, rho As Double, _
			ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim b As Integer = 0
			Dim v As Double = 0
			Dim relcnt As Double = 0
			Dim xa As Double = 0
			Dim xb As Double = 0
			Dim sa As Double = 0
			Dim sb As Double = 0
			Dim xoriginal As Double() = New Double(-1) {}
			Dim yoriginal As Double() = New Double(-1) {}
			Dim pdecay As Double = 0
			Dim tdecay As Double = 0
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim fcolumn As Double() = New Double(-1) {}
			Dim y2 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim xc As Double() = New Double(-1) {}
			Dim yc As Double() = New Double(-1) {}
			Dim dc As Integer() = New Integer(-1) {}
			Dim fdmax As Double = 0
			Dim admax As Double = 0
			Dim amatrix As Double(,) = New Double(-1, -1) {}
			Dim d2matrix As Double(,) = New Double(-1, -1) {}
			Dim fa As Double = 0
			Dim ga As Double = 0
			Dim fb As Double = 0
			Dim gb As Double = 0
			Dim lambdav As Double = 0
			Dim bx As Double() = New Double(-1) {}
			Dim by As Double() = New Double(-1) {}
			Dim bd1 As Double() = New Double(-1) {}
			Dim bd2 As Double() = New Double(-1) {}
			Dim tx As Double() = New Double(-1) {}
			Dim ty As Double() = New Double(-1) {}
			Dim td As Double() = New Double(-1) {}
			Dim bs As New spline1d.spline1dinterpolant()
			Dim nmatrix As Double(,) = New Double(-1, -1) {}
			Dim rightpart As Double() = New Double(-1) {}
			Dim cgstate As New fbls.fblslincgstate()
			Dim c As Double() = New Double(-1) {}
			Dim tmp0 As Double() = New Double(-1) {}
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			w = DirectCast(w.Clone(), Double())
			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitPenalizedW: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitPenalizedW: M<4!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitPenalizedW: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitPenalizedW: Length(Y)<N!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "Spline1DFitPenalizedW: Length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitPenalizedW: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitPenalizedW: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "Spline1DFitPenalizedW: Y contains infinite or NAN values!")
			alglib.ap.assert(Math.isfinite(rho), "Spline1DFitPenalizedW: Rho is infinite!")

			'
			' Prepare LambdaV
			'
			v = -(System.Math.Log(Math.machineepsilon) / System.Math.Log(10))
			If CDbl(rho) < CDbl(-v) Then
				rho = -v
			End If
			If CDbl(rho) > CDbl(v) Then
				rho = v
			End If
			lambdav = System.Math.Pow(10, rho)

			'
			' Sort X, Y, W
			'
			spline1d.heapsortdpoints(x, y, w, n)

			'
			' Scale X, Y, XC, YC
			'
			lsfitscalexy(x, y, w, n, xc, yc, _
				dc, 0, xa, xb, sa, sb, _
				xoriginal, yoriginal)

			'
			' Allocate space
			'
			fmatrix = New Double(n - 1, m - 1) {}
			amatrix = New Double(m - 1, m - 1) {}
			d2matrix = New Double(m - 1, m - 1) {}
			bx = New Double(m - 1) {}
			by = New Double(m - 1) {}
			fcolumn = New Double(n - 1) {}
			nmatrix = New Double(m - 1, m - 1) {}
			rightpart = New Double(m - 1) {}
			tmp0 = New Double(System.Math.Max(m, n) - 1) {}
			c = New Double(m - 1) {}

			'
			' Fill:
			' * FMatrix by values of basis functions
			' * TmpAMatrix by second derivatives of I-th function at J-th point
			' * CMatrix by constraints
			'
			fdmax = 0
			For b = 0 To m - 1

				'
				' Prepare I-th basis function
				'
				For j = 0 To m - 1
					bx(j) = CDbl(2 * j) / CDbl(m - 1) - 1
					by(j) = 0
				Next
				by(b) = 1
				spline1d.spline1dgriddiff2cubic(bx, by, m, 2, 0.0, 2, _
					0.0, bd1, bd2)
				spline1d.spline1dbuildcubic(bx, by, m, 2, 0.0, 2, _
					0.0, bs)

				'
				' Calculate B-th column of FMatrix
				' Update FDMax (maximum column norm)
				'
				spline1d.spline1dconvcubic(bx, by, m, 2, 0.0, 2, _
					0.0, x, n, fcolumn)
				For i_ = 0 To n - 1
					fmatrix(i_, b) = fcolumn(i_)
				Next
				v = 0
				For i = 0 To n - 1
					v = v + Math.sqr(w(i) * fcolumn(i))
				Next
				fdmax = System.Math.Max(fdmax, v)

				'
				' Fill temporary with second derivatives of basis function
				'
				For i_ = 0 To m - 1
					d2matrix(b, i_) = bd2(i_)
				Next
			Next

			'
			' * calculate penalty matrix A
			' * calculate max of diagonal elements of A
			' * calculate PDecay - coefficient before penalty matrix
			'
			For i = 0 To m - 1
				For j = i To m - 1

					'
					' calculate integral(B_i''*B_j'') where B_i and B_j are
					' i-th and j-th basis splines.
					' B_i and B_j are piecewise linear functions.
					'
					v = 0
					For b = 0 To m - 2
						fa = d2matrix(i, b)
						fb = d2matrix(i, b + 1)
						ga = d2matrix(j, b)
						gb = d2matrix(j, b + 1)
						v = v + (bx(b + 1) - bx(b)) * (fa * ga + (fa * (gb - ga) + ga * (fb - fa)) / 2 + (fb - fa) * (gb - ga) / 3)
					Next
					amatrix(i, j) = v
					amatrix(j, i) = v
				Next
			Next
			admax = 0
			For i = 0 To m - 1
				admax = System.Math.Max(admax, System.Math.Abs(amatrix(i, i)))
			Next
			pdecay = lambdav * fdmax / admax

			'
			' Calculate TDecay for Tikhonov regularization
			'
			tdecay = fdmax * (1 + pdecay) * 10 * Math.machineepsilon

			'
			' Prepare system
			'
			' NOTE: FMatrix is spoiled during this process
			'
			For i = 0 To n - 1
				v = w(i)
				For i_ = 0 To m - 1
					fmatrix(i, i_) = v * fmatrix(i, i_)
				Next
			Next
			ablas.rmatrixgemm(m, m, n, 1.0, fmatrix, 0, _
				0, 1, fmatrix, 0, 0, 0, _
				0.0, nmatrix, 0, 0)
			For i = 0 To m - 1
				For j = 0 To m - 1
					nmatrix(i, j) = nmatrix(i, j) + pdecay * amatrix(i, j)
				Next
			Next
			For i = 0 To m - 1
				nmatrix(i, i) = nmatrix(i, i) + tdecay
			Next
			For i = 0 To m - 1
				rightpart(i) = 0
			Next
			For i = 0 To n - 1
				v = y(i) * w(i)
				For i_ = 0 To m - 1
					rightpart(i_) = rightpart(i_) + v * fmatrix(i, i_)
				Next
			Next

			'
			' Solve system
			'
			If Not trfac.spdmatrixcholesky(nmatrix, m, True) Then
				info = -4
				Return
			End If
			fbls.fblscholeskysolve(nmatrix, 1.0, m, True, rightpart, tmp0)
			For i_ = 0 To m - 1
				c(i_) = rightpart(i_)
			Next

			'
			' add nodes to force linearity outside of the fitting interval
			'
			spline1d.spline1dgriddiffcubic(bx, c, m, 2, 0.0, 2, _
				0.0, bd1)
			tx = New Double(m + 1) {}
			ty = New Double(m + 1) {}
			td = New Double(m + 1) {}
			i1_ = (0) - (1)
			For i_ = 1 To m
				tx(i_) = bx(i_ + i1_)
			Next
			i1_ = (0) - (1)
			For i_ = 1 To m
				ty(i_) = rightpart(i_ + i1_)
			Next
			i1_ = (0) - (1)
			For i_ = 1 To m
				td(i_) = bd1(i_ + i1_)
			Next
			tx(0) = tx(1) - (tx(2) - tx(1))
			ty(0) = ty(1) - td(1) * (tx(2) - tx(1))
			td(0) = td(1)
			tx(m + 1) = tx(m) + (tx(m) - tx(m - 1))
			ty(m + 1) = ty(m) + td(m) * (tx(m) - tx(m - 1))
			td(m + 1) = td(m)
			spline1d.spline1dbuildhermite(tx, ty, td, m + 2, s)
			spline1d.spline1dlintransx(s, 2 / (xb - xa), -((xa + xb) / (xb - xa)))
			spline1d.spline1dlintransy(s, sb - sa, sa)
			info = 1

			'
			' Fill report
			'
			rep.rmserror = 0
			rep.avgerror = 0
			rep.avgrelerror = 0
			rep.maxerror = 0
			relcnt = 0
			spline1d.spline1dconvcubic(bx, rightpart, m, 2, 0.0, 2, _
				0.0, x, n, fcolumn)
			For i = 0 To n - 1
				v = (sb - sa) * fcolumn(i) + sa
				rep.rmserror = rep.rmserror + Math.sqr(v - yoriginal(i))
				rep.avgerror = rep.avgerror + System.Math.Abs(v - yoriginal(i))
				If CDbl(yoriginal(i)) <> CDbl(0) Then
					rep.avgrelerror = rep.avgrelerror + System.Math.Abs(v - yoriginal(i)) / System.Math.Abs(yoriginal(i))
					relcnt = relcnt + 1
				End If
				rep.maxerror = System.Math.Max(rep.maxerror, System.Math.Abs(v - yoriginal(i)))
			Next
			rep.rmserror = System.Math.sqrt(rep.rmserror / n)
			rep.avgerror = rep.avgerror / n
			If CDbl(relcnt) <> CDbl(0) Then
				rep.avgrelerror = rep.avgrelerror / relcnt
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfitpenalizedw(x As Double(), y As Double(), w As Double(), n As Integer, m As Integer, rho As Double, _
			ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			spline1dfitpenalizedw(x, y, w, n, m, rho, _
				info, s, rep)
		End Sub


		'************************************************************************
'        Weighted fitting by cubic  spline,  with constraints on function values or
'        derivatives.
'
'        Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
'        basis functions. Basis functions are cubic splines with continuous  second
'        derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
'        regularizing term is used  when  solving  constrained  tasks  (to  improve
'        stability).
'
'        Task is linear, so linear least squares solver is used. Complexity of this
'        computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'        SEE ALSO
'            Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
'                                        less smooth)
'            Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
'                                        without invididual weights and constraints
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'                                        
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            W   -   weights, array[0..N-1]
'                    Each summand in square  sum  of  approximation deviations from
'                    given  values  is  multiplied  by  the square of corresponding
'                    weight. Fill it by 1's if you don't  want  to  solve  weighted
'                    task.
'            N   -   number of points (optional):
'                    * N>0
'                    * if given, only first N elements of X/Y/W are processed
'                    * if not given, automatically determined from X/Y/W sizes
'            XC  -   points where spline values/derivatives are constrained,
'                    array[0..K-1].
'            YC  -   values of constraints, array[0..K-1]
'            DC  -   array[0..K-1], types of constraints:
'                    * DC[i]=0   means that S(XC[i])=YC[i]
'                    * DC[i]=1   means that S'(XC[i])=YC[i]
'                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'            K   -   number of constraints (optional):
'                    * 0<=K<M.
'                    * K=0 means no constraints (XC/YC/DC are not used)
'                    * if given, only first K elements of XC/YC/DC are used
'                    * if not given, automatically determined from XC/YC/DC
'            M   -   number of basis functions ( = number_of_nodes+2), M>=4.
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearWC() subroutine.
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'                                -3 means inconsistent constraints
'            S   -   spline interpolant.
'            Rep -   report, same format as in LSFitLinearWC() subroutine.
'                    Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'        Setting constraints can lead  to undesired  results,  like ill-conditioned
'        behavior, or inconsistency being detected. From the other side,  it allows
'        us to improve quality of the fit. Here we summarize  our  experience  with
'        constrained regression splines:
'        * excessive constraints can be inconsistent. Splines are  piecewise  cubic
'          functions, and it is easy to create an example, where  large  number  of
'          constraints  concentrated  in  small  area will result in inconsistency.
'          Just because spline is not flexible enough to satisfy all of  them.  And
'          same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'          consistent.
'        * the more evenly constraints are spread across [min(x),max(x)],  the more
'          chances that they will be consistent
'        * the  greater  is  M (given  fixed  constraints),  the  more chances that
'          constraints will be consistent
'        * in the general case, consistency of constraints IS NOT GUARANTEED.
'        * in the several special cases, however, we CAN guarantee consistency.
'        * one of this cases is constraints  on  the  function  values  AND/OR  its
'          derivatives at the interval boundaries.
'        * another  special  case  is ONE constraint on the function value (OR, but
'          not AND, derivative) anywhere in the interval
'
'        Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'        can't solve your task without them. Anything beyond  special  cases  given
'        above is not guaranteed and may result in inconsistency.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			Dim i As Integer = 0

			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitCubicWC: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitCubicWC: M<4!")
			alglib.ap.assert(k >= 0, "Spline1DFitCubicWC: K<0!")
			alglib.ap.assert(k < m, "Spline1DFitCubicWC: K>=M!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitCubicWC: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitCubicWC: Length(Y)<N!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "Spline1DFitCubicWC: Length(W)<N!")
			alglib.ap.assert(alglib.ap.len(xc) >= k, "Spline1DFitCubicWC: Length(XC)<K!")
			alglib.ap.assert(alglib.ap.len(yc) >= k, "Spline1DFitCubicWC: Length(YC)<K!")
			alglib.ap.assert(alglib.ap.len(dc) >= k, "Spline1DFitCubicWC: Length(DC)<K!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitCubicWC: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitCubicWC: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "Spline1DFitCubicWC: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(xc, k), "Spline1DFitCubicWC: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(yc, k), "Spline1DFitCubicWC: Y contains infinite or NAN values!")
			For i = 0 To k - 1
				alglib.ap.assert(dc(i) = 0 OrElse dc(i) = 1, "Spline1DFitCubicWC: DC[i] is neither 0 or 1!")
			Next
			spline1dfitinternal(0, x, y, w, n, xc, _
				yc, dc, k, m, info, s, _
				rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfitcubicwc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			spline1dfitcubicwc(x, y, w, n, xc, yc, _
				dc, k, m, info, s, rep)
		End Sub


		'************************************************************************
'        Weighted  fitting  by Hermite spline,  with constraints on function values
'        or first derivatives.
'
'        Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'        basis functions. Basis functions are Hermite splines.  Small  regularizing
'        term is used when solving constrained tasks (to improve stability).
'
'        Task is linear, so linear least squares solver is used. Complexity of this
'        computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'        SEE ALSO
'            Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
'                                        more smooth)
'            Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
'                                        invididual weights and constraints
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'                                        
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            W   -   weights, array[0..N-1]
'                    Each summand in square  sum  of  approximation deviations from
'                    given  values  is  multiplied  by  the square of corresponding
'                    weight. Fill it by 1's if you don't  want  to  solve  weighted
'                    task.
'            N   -   number of points (optional):
'                    * N>0
'                    * if given, only first N elements of X/Y/W are processed
'                    * if not given, automatically determined from X/Y/W sizes
'            XC  -   points where spline values/derivatives are constrained,
'                    array[0..K-1].
'            YC  -   values of constraints, array[0..K-1]
'            DC  -   array[0..K-1], types of constraints:
'                    * DC[i]=0   means that S(XC[i])=YC[i]
'                    * DC[i]=1   means that S'(XC[i])=YC[i]
'                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'            K   -   number of constraints (optional):
'                    * 0<=K<M.
'                    * K=0 means no constraints (XC/YC/DC are not used)
'                    * if given, only first K elements of XC/YC/DC are used
'                    * if not given, automatically determined from XC/YC/DC
'            M   -   number of basis functions (= 2 * number of nodes),
'                    M>=4,
'                    M IS EVEN!
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearW() subroutine:
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'                                -3 means inconsistent constraints
'                                -2 means odd M was passed (which is not supported)
'                                -1 means another errors in parameters passed
'                                   (N<=0, for example)
'            S   -   spline interpolant.
'            Rep -   report, same format as in LSFitLinearW() subroutine.
'                    Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'        IMPORTANT:
'            this subroitine supports only even M's
'
'
'        ORDER OF POINTS
'
'        Subroutine automatically sorts points, so caller may pass unsorted array.
'
'        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'        Setting constraints can lead  to undesired  results,  like ill-conditioned
'        behavior, or inconsistency being detected. From the other side,  it allows
'        us to improve quality of the fit. Here we summarize  our  experience  with
'        constrained regression splines:
'        * excessive constraints can be inconsistent. Splines are  piecewise  cubic
'          functions, and it is easy to create an example, where  large  number  of
'          constraints  concentrated  in  small  area will result in inconsistency.
'          Just because spline is not flexible enough to satisfy all of  them.  And
'          same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'          consistent.
'        * the more evenly constraints are spread across [min(x),max(x)],  the more
'          chances that they will be consistent
'        * the  greater  is  M (given  fixed  constraints),  the  more chances that
'          constraints will be consistent
'        * in the general case, consistency of constraints is NOT GUARANTEED.
'        * in the several special cases, however, we can guarantee consistency.
'        * one of this cases is  M>=4  and   constraints  on   the  function  value
'          (AND/OR its derivative) at the interval boundaries.
'        * another special case is M>=4  and  ONE  constraint on the function value
'          (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
'
'        Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'        can't solve your task without them. Anything beyond  special  cases  given
'        above is not guaranteed and may result in inconsistency.
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfithermitewc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			Dim i As Integer = 0

			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitHermiteWC: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitHermiteWC: M<4!")
			alglib.ap.assert(m Mod 2 = 0, "Spline1DFitHermiteWC: M is odd!")
			alglib.ap.assert(k >= 0, "Spline1DFitHermiteWC: K<0!")
			alglib.ap.assert(k < m, "Spline1DFitHermiteWC: K>=M!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitHermiteWC: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitHermiteWC: Length(Y)<N!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "Spline1DFitHermiteWC: Length(W)<N!")
			alglib.ap.assert(alglib.ap.len(xc) >= k, "Spline1DFitHermiteWC: Length(XC)<K!")
			alglib.ap.assert(alglib.ap.len(yc) >= k, "Spline1DFitHermiteWC: Length(YC)<K!")
			alglib.ap.assert(alglib.ap.len(dc) >= k, "Spline1DFitHermiteWC: Length(DC)<K!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitHermiteWC: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitHermiteWC: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "Spline1DFitHermiteWC: Y contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(xc, k), "Spline1DFitHermiteWC: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(yc, k), "Spline1DFitHermiteWC: Y contains infinite or NAN values!")
			For i = 0 To k - 1
				alglib.ap.assert(dc(i) = 0 OrElse dc(i) = 1, "Spline1DFitHermiteWC: DC[i] is neither 0 or 1!")
			Next
			spline1dfitinternal(1, x, y, w, n, xc, _
				yc, dc, k, m, info, s, _
				rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfithermitewc(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, rep As spline1dfitreport)
			spline1dfithermitewc(x, y, w, n, xc, yc, _
				dc, k, m, info, s, rep)
		End Sub


		'************************************************************************
'        Least squares fitting by cubic spline.
'
'        This subroutine is "lightweight" alternative for more complex and feature-
'        rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
'        about subroutine parameters (we don't duplicate it here because of length)
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfitcubic(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, _
			rep As spline1dfitreport)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim xc As Double() = New Double(-1) {}
			Dim yc As Double() = New Double(-1) {}
			Dim dc As Integer() = New Integer(-1) {}

			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitCubic: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitCubic: M<4!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitCubic: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitCubic: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitCubic: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitCubic: Y contains infinite or NAN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			spline1dfitcubicwc(x, y, w, n, xc, yc, _
				dc, 0, m, info, s, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfitcubic(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, _
			rep As spline1dfitreport)
			spline1dfitcubic(x, y, n, m, info, s, _
				rep)
		End Sub


		'************************************************************************
'        Least squares fitting by Hermite spline.
'
'        This subroutine is "lightweight" alternative for more complex and feature-
'        rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
'        more information about subroutine parameters (we don't duplicate  it  here
'        because of length).
'
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'          -- ALGLIB PROJECT --
'             Copyright 18.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline1dfithermite(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, _
			rep As spline1dfitreport)
			Dim i As Integer = 0
			Dim w As Double() = New Double(-1) {}
			Dim xc As Double() = New Double(-1) {}
			Dim yc As Double() = New Double(-1) {}
			Dim dc As Integer() = New Integer(-1) {}

			info = 0

			alglib.ap.assert(n >= 1, "Spline1DFitHermite: N<1!")
			alglib.ap.assert(m >= 4, "Spline1DFitHermite: M<4!")
			alglib.ap.assert(m Mod 2 = 0, "Spline1DFitHermite: M is odd!")
			alglib.ap.assert(alglib.ap.len(x) >= n, "Spline1DFitHermite: Length(X)<N!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "Spline1DFitHermite: Length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(x, n), "Spline1DFitHermite: X contains infinite or NAN values!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "Spline1DFitHermite: Y contains infinite or NAN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			spline1dfithermitewc(x, y, w, n, xc, yc, _
				dc, 0, m, info, s, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_spline1dfithermite(x As Double(), y As Double(), n As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, _
			rep As spline1dfitreport)
			spline1dfithermite(x, y, n, m, info, s, _
				rep)
		End Sub


		'************************************************************************
'        Weighted linear least squares fitting.
'
'        QR decomposition is used to reduce task to MxM, then triangular solver  or
'        SVD-based solver is used depending on condition number of the  system.  It
'        allows to maximize speed and retain decent accuracy.
'
'        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'                   convenient to use PolynomialFit() function. This function gives
'                   best  results  on  polynomial  problems  and  solves  numerical
'                   stability  issues  which  arise  when   you   fit   high-degree
'                   polynomials to your data.
'                   
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            Y       -   array[0..N-1] Function values in  N  points.
'            W       -   array[0..N-1]  Weights  corresponding to function  values.
'                        Each summand in square  sum  of  approximation  deviations
'                        from  given  values  is  multiplied  by  the   square   of
'                        corresponding weight.
'            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                        FMatrix[I, J] - value of J-th basis function in I-th point.
'            N       -   number of points used. N>=1.
'            M       -   number of basis functions, M>=1.
'
'        OUTPUT PARAMETERS:
'            Info    -   error code:
'                        * -4    internal SVD decomposition subroutine failed (very
'                                rare and for degenerate systems only)
'                        * -1    incorrect N/M were specified
'                        *  1    task is solved
'            C       -   decomposition coefficients, array[0..M-1]
'            Rep     -   fitting report. Following fields are set:
'                        * Rep.TaskRCond     reciprocal of condition number
'                        * R2                non-adjusted coefficient of determination
'                                            (non-weighted)
'                        * RMSError          rms error on the (X,Y).
'                        * AvgError          average error on the (X,Y).
'                        * AvgRelError       average relative error on the non-zero Y
'                        * MaxError          maximum error
'                                            NON-WEIGHTED ERRORS ARE CALCULATED
'                        
'        ERRORS IN PARAMETERS                
'                        
'        This  solver  also  calculates different kinds of errors in parameters and
'        fills corresponding fields of report:
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(F*CovPar*F')),
'                            where F is functions matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'                    
'        NOTE:       covariance matrix is estimated using  correction  for  degrees
'                    of freedom (covariances are divided by N-M instead of dividing
'                    by N).
'                                            
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, _
			ByRef c As Double(), rep As lsfitreport)
			info = 0
			c = New Double(-1) {}

			alglib.ap.assert(n >= 1, "LSFitLinearW: N<1!")
			alglib.ap.assert(m >= 1, "LSFitLinearW: M<1!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitLinearW: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitLinearW: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "LSFitLinearW: length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "LSFitLinearW: W contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(fmatrix) >= n, "LSFitLinearW: rows(FMatrix)<N!")
			alglib.ap.assert(alglib.ap.cols(fmatrix) >= m, "LSFitLinearW: cols(FMatrix)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m), "LSFitLinearW: FMatrix contains infinite or NaN values!")
			lsfitlinearinternal(y, w, fmatrix, n, m, info, _
				c, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_lsfitlinearw(y As Double(), w As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, _
			ByRef c As Double(), rep As lsfitreport)
			lsfitlinearw(y, w, fmatrix, n, m, info, _
				c, rep)
		End Sub


		'************************************************************************
'        Weighted constained linear least squares fitting.
'
'        This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
'        that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'        task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
'        is called.
'
'        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'                   convenient to use PolynomialFit() function. This function gives
'                   best  results  on  polynomial  problems  and  solves  numerical
'                   stability  issues  which  arise  when   you   fit   high-degree
'                   polynomials to your data.
'                   
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            Y       -   array[0..N-1] Function values in  N  points.
'            W       -   array[0..N-1]  Weights  corresponding to function  values.
'                        Each summand in square  sum  of  approximation  deviations
'                        from  given  values  is  multiplied  by  the   square   of
'                        corresponding weight.
'            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                        FMatrix[I,J] - value of J-th basis function in I-th point.
'            CMatrix -   a table of constaints, array[0..K-1,0..M].
'                        I-th row of CMatrix corresponds to I-th linear constraint:
'                        CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'            N       -   number of points used. N>=1.
'            M       -   number of basis functions, M>=1.
'            K       -   number of constraints, 0 <= K < M
'                        K=0 corresponds to absence of constraints.
'
'        OUTPUT PARAMETERS:
'            Info    -   error code:
'                        * -4    internal SVD decomposition subroutine failed (very
'                                rare and for degenerate systems only)
'                        * -3    either   too   many  constraints  (M   or   more),
'                                degenerate  constraints   (some   constraints  are
'                                repetead twice) or inconsistent  constraints  were
'                                specified.
'                        *  1    task is solved
'            C       -   decomposition coefficients, array[0..M-1]
'            Rep     -   fitting report. Following fields are set:
'                        * R2                non-adjusted coefficient of determination
'                                            (non-weighted)
'                        * RMSError          rms error on the (X,Y).
'                        * AvgError          average error on the (X,Y).
'                        * AvgRelError       average relative error on the non-zero Y
'                        * MaxError          maximum error
'                                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'                        
'        ERRORS IN PARAMETERS                
'                        
'        This  solver  also  calculates different kinds of errors in parameters and
'        fills corresponding fields of report:
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(F*CovPar*F')),
'                            where F is functions matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                    account boundary/linear constraints! Presence  of  constraints
'                    changes distribution of errors, but there is no  easy  way  to
'                    account for constraints when you calculate covariance matrix.
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'                    
'        NOTE:       covariance matrix is estimated using  correction  for  degrees
'                    of freedom (covariances are divided by N-M instead of dividing
'                    by N).
'
'          -- ALGLIB --
'             Copyright 07.09.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, _
			k As Integer, ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim tau As Double() = New Double(-1) {}
			Dim q As Double(,) = New Double(-1, -1) {}
			Dim f2 As Double(,) = New Double(-1, -1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim c0 As Double() = New Double(-1) {}
			Dim v As Double = 0
			Dim i_ As Integer = 0

			y = DirectCast(y.Clone(), Double())
			cmatrix = DirectCast(cmatrix.Clone(), Double(,))
			info = 0
			c = New Double(-1) {}

			alglib.ap.assert(n >= 1, "LSFitLinearWC: N<1!")
			alglib.ap.assert(m >= 1, "LSFitLinearWC: M<1!")
			alglib.ap.assert(k >= 0, "LSFitLinearWC: K<0!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitLinearWC: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitLinearWC: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "LSFitLinearWC: length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "LSFitLinearWC: W contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(fmatrix) >= n, "LSFitLinearWC: rows(FMatrix)<N!")
			alglib.ap.assert(alglib.ap.cols(fmatrix) >= m, "LSFitLinearWC: cols(FMatrix)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m), "LSFitLinearWC: FMatrix contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(cmatrix) >= k, "LSFitLinearWC: rows(CMatrix)<K!")
			alglib.ap.assert(alglib.ap.cols(cmatrix) >= m + 1 OrElse k = 0, "LSFitLinearWC: cols(CMatrix)<M+1!")
			alglib.ap.assert(apserv.apservisfinitematrix(cmatrix, k, m + 1), "LSFitLinearWC: CMatrix contains infinite or NaN values!")
			If k >= m Then
				info = -3
				Return
			End If

			'
			' Solve
			'
			If k = 0 Then

				'
				' no constraints
				'
				lsfitlinearinternal(y, w, fmatrix, n, m, info, _
					c, rep)
			Else

				'
				' First, find general form solution of constraints system:
				' * factorize C = L*Q
				' * unpack Q
				' * fill upper part of C with zeros (for RCond)
				'
				' We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
				'
				ortfac.rmatrixlq(cmatrix, k, m, tau)
				ortfac.rmatrixlqunpackq(cmatrix, k, m, tau, m, q)
				For i = 0 To k - 1
					For j = i + 1 To m - 1
						cmatrix(i, j) = 0.0
					Next
				Next
				If CDbl(rcond.rmatrixlurcondinf(cmatrix, k)) < CDbl(1000 * Math.machineepsilon) Then
					info = -3
					Return
				End If
				tmp = New Double(k - 1) {}
				For i = 0 To k - 1
					If i > 0 Then
						v = 0.0
						For i_ = 0 To i - 1
							v += cmatrix(i, i_) * tmp(i_)
						Next
					Else
						v = 0
					End If
					tmp(i) = (cmatrix(i, m) - v) / cmatrix(i, i)
				Next
				c0 = New Double(m - 1) {}
				For i = 0 To m - 1
					c0(i) = 0
				Next
				For i = 0 To k - 1
					v = tmp(i)
					For i_ = 0 To m - 1
						c0(i_) = c0(i_) + v * q(i, i_)
					Next
				Next

				'
				' Second, prepare modified matrix F2 = F*Q2' and solve modified task
				'
				tmp = New Double(System.Math.Max(n, m)) {}
				f2 = New Double(n - 1, m - k - 1) {}
				blas.matrixvectormultiply(fmatrix, 0, n - 1, 0, m - 1, False, _
					c0, 0, m - 1, -1.0, y, 0, _
					n - 1, 1.0)
				ablas.rmatrixgemm(n, m - k, m, 1.0, fmatrix, 0, _
					0, 0, q, k, 0, 1, _
					0.0, f2, 0, 0)
				lsfitlinearinternal(y, w, f2, n, m - k, info, _
					tmp, rep)
				rep.taskrcond = -1
				If info <= 0 Then
					Return
				End If

				'
				' then, convert back to original answer: C = C0 + Q2'*Y0
				'
				c = New Double(m - 1) {}
				For i_ = 0 To m - 1
					c(i_) = c0(i_)
				Next
				blas.matrixvectormultiply(q, k, m - 1, 0, m - 1, True, _
					tmp, 0, m - k - 1, 1.0, c, 0, _
					m - 1, 1.0)
			End If
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_lsfitlinearwc(y As Double(), w As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, _
			k As Integer, ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
				k, info, c, rep)
		End Sub


		'************************************************************************
'        Linear least squares fitting.
'
'        QR decomposition is used to reduce task to MxM, then triangular solver  or
'        SVD-based solver is used depending on condition number of the  system.  It
'        allows to maximize speed and retain decent accuracy.
'
'        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'                   convenient to use PolynomialFit() function. This function gives
'                   best  results  on  polynomial  problems  and  solves  numerical
'                   stability  issues  which  arise  when   you   fit   high-degree
'                   polynomials to your data.
'                   
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            Y       -   array[0..N-1] Function values in  N  points.
'            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                        FMatrix[I, J] - value of J-th basis function in I-th point.
'            N       -   number of points used. N>=1.
'            M       -   number of basis functions, M>=1.
'
'        OUTPUT PARAMETERS:
'            Info    -   error code:
'                        * -4    internal SVD decomposition subroutine failed (very
'                                rare and for degenerate systems only)
'                        *  1    task is solved
'            C       -   decomposition coefficients, array[0..M-1]
'            Rep     -   fitting report. Following fields are set:
'                        * Rep.TaskRCond     reciprocal of condition number
'                        * R2                non-adjusted coefficient of determination
'                                            (non-weighted)
'                        * RMSError          rms error on the (X,Y).
'                        * AvgError          average error on the (X,Y).
'                        * AvgRelError       average relative error on the non-zero Y
'                        * MaxError          maximum error
'                                            NON-WEIGHTED ERRORS ARE CALCULATED
'                        
'        ERRORS IN PARAMETERS                
'                        
'        This  solver  also  calculates different kinds of errors in parameters and
'        fills corresponding fields of report:
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(F*CovPar*F')),
'                            where F is functions matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'                    
'        NOTE:       covariance matrix is estimated using  correction  for  degrees
'                    of freedom (covariances are divided by N-M instead of dividing
'                    by N).
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitlinear(y As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, ByRef c As Double(), _
			rep As lsfitreport)
			Dim w As Double() = New Double(-1) {}
			Dim i As Integer = 0

			info = 0
			c = New Double(-1) {}

			alglib.ap.assert(n >= 1, "LSFitLinear: N<1!")
			alglib.ap.assert(m >= 1, "LSFitLinear: M<1!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitLinear: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitLinear: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(fmatrix) >= n, "LSFitLinear: rows(FMatrix)<N!")
			alglib.ap.assert(alglib.ap.cols(fmatrix) >= m, "LSFitLinear: cols(FMatrix)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m), "LSFitLinear: FMatrix contains infinite or NaN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			lsfitlinearinternal(y, w, fmatrix, n, m, info, _
				c, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_lsfitlinear(y As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, ByRef c As Double(), _
			rep As lsfitreport)
			lsfitlinear(y, fmatrix, n, m, info, c, _
				rep)
		End Sub


		'************************************************************************
'        Constained linear least squares fitting.
'
'        This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
'        that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'        task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
'        is called.
'
'        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
'                   convenient to use PolynomialFit() function. This function gives
'                   best  results  on  polynomial  problems  and  solves  numerical
'                   stability  issues  which  arise  when   you   fit   high-degree
'                   polynomials to your data.
'                   
'        COMMERCIAL EDITION OF ALGLIB:
'
'          ! Commercial version of ALGLIB includes two  important  improvements  of
'          ! this function, which can be used from C++ and C#:
'          ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
'          ! * multithreading support
'          !
'          ! Intel MKL gives approximately constant  (with  respect  to  number  of
'          ! worker threads) acceleration factor which depends on CPU  being  used,
'          ! problem  size  and  "baseline"  ALGLIB  edition  which  is  used   for
'          ! comparison.
'          !
'          ! Speed-up provided by multithreading greatly depends  on  problem  size
'          ! - only large problems (number of coefficients is more than 500) can be
'          ! efficiently multithreaded.
'          !
'          ! Generally, commercial ALGLIB is several times faster than  open-source
'          ! generic C edition, and many times faster than open-source C# edition.
'          !
'          ! We recommend you to read 'Working with commercial version' section  of
'          ! ALGLIB Reference Manual in order to find out how to  use  performance-
'          ! related features provided by commercial edition of ALGLIB.
'
'        INPUT PARAMETERS:
'            Y       -   array[0..N-1] Function values in  N  points.
'            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                        FMatrix[I,J] - value of J-th basis function in I-th point.
'            CMatrix -   a table of constaints, array[0..K-1,0..M].
'                        I-th row of CMatrix corresponds to I-th linear constraint:
'                        CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'            N       -   number of points used. N>=1.
'            M       -   number of basis functions, M>=1.
'            K       -   number of constraints, 0 <= K < M
'                        K=0 corresponds to absence of constraints.
'
'        OUTPUT PARAMETERS:
'            Info    -   error code:
'                        * -4    internal SVD decomposition subroutine failed (very
'                                rare and for degenerate systems only)
'                        * -3    either   too   many  constraints  (M   or   more),
'                                degenerate  constraints   (some   constraints  are
'                                repetead twice) or inconsistent  constraints  were
'                                specified.
'                        *  1    task is solved
'            C       -   decomposition coefficients, array[0..M-1]
'            Rep     -   fitting report. Following fields are set:
'                        * R2                non-adjusted coefficient of determination
'                                            (non-weighted)
'                        * RMSError          rms error on the (X,Y).
'                        * AvgError          average error on the (X,Y).
'                        * AvgRelError       average relative error on the non-zero Y
'                        * MaxError          maximum error
'                                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'                        
'        ERRORS IN PARAMETERS                
'                        
'        This  solver  also  calculates different kinds of errors in parameters and
'        fills corresponding fields of report:
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(F*CovPar*F')),
'                            where F is functions matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                    account boundary/linear constraints! Presence  of  constraints
'                    changes distribution of errors, but there is no  easy  way  to
'                    account for constraints when you calculate covariance matrix.
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'                    
'        NOTE:       covariance matrix is estimated using  correction  for  degrees
'                    of freedom (covariances are divided by N-M instead of dividing
'                    by N).
'
'          -- ALGLIB --
'             Copyright 07.09.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, k As Integer, _
			ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			Dim w As Double() = New Double(-1) {}
			Dim i As Integer = 0

			y = DirectCast(y.Clone(), Double())
			info = 0
			c = New Double(-1) {}

			alglib.ap.assert(n >= 1, "LSFitLinearC: N<1!")
			alglib.ap.assert(m >= 1, "LSFitLinearC: M<1!")
			alglib.ap.assert(k >= 0, "LSFitLinearC: K<0!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitLinearC: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitLinearC: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(fmatrix) >= n, "LSFitLinearC: rows(FMatrix)<N!")
			alglib.ap.assert(alglib.ap.cols(fmatrix) >= m, "LSFitLinearC: cols(FMatrix)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m), "LSFitLinearC: FMatrix contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(cmatrix) >= k, "LSFitLinearC: rows(CMatrix)<K!")
			alglib.ap.assert(alglib.ap.cols(cmatrix) >= m + 1 OrElse k = 0, "LSFitLinearC: cols(CMatrix)<M+1!")
			alglib.ap.assert(apserv.apservisfinitematrix(cmatrix, k, m + 1), "LSFitLinearC: CMatrix contains infinite or NaN values!")
			w = New Double(n - 1) {}
			For i = 0 To n - 1
				w(i) = 1
			Next
			lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
				k, info, c, rep)
		End Sub


		'************************************************************************
'        Single-threaded stub. HPC ALGLIB replaces it by multithreaded code.
'        ************************************************************************

		Public Shared Sub _pexec_lsfitlinearc(y As Double(), fmatrix As Double(,), cmatrix As Double(,), n As Integer, m As Integer, k As Integer, _
			ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			lsfitlinearc(y, fmatrix, cmatrix, n, m, k, _
				info, c, rep)
		End Sub


		'************************************************************************
'        Weighted nonlinear least squares fitting using function values only.
'
'        Combination of numerical differentiation and secant updates is used to
'        obtain function Jacobian.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * w is an N-dimensional vector of weight coefficients,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'
'        This subroutine uses only f(c,x[i]).
'
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            W       -   weights, array[0..N-1]
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'            DiffStep-   numerical differentiation step;
'                        should not be very small or large;
'                        large = loss of accuracy
'                        small = growth of round-off errors
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'          -- ALGLIB --
'             Copyright 18.10.2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatewf(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
			k As Integer, diffstep As Double, state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateWF: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateWF: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateWF: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateWF: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateWF: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateWF: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateWF: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "LSFitCreateWF: length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "LSFitCreateWF: W contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateWF: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateWF: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateWF: X contains infinite or NaN values!")
			alglib.ap.assert(Math.isfinite(diffstep), "LSFitCreateWF: DiffStep is not finite!")
			alglib.ap.assert(CDbl(diffstep) > CDbl(0), "LSFitCreateWF: DiffStep<=0!")
			state.teststep = 0
			state.diffstep = diffstep
			state.npoints = n
			state.nweights = n
			state.wkind = 1
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.taskw = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.x = New Double(m - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i_ = 0 To n - 1
				state.taskw(i_) = w(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 0
			state.prevnpt = -1
			state.prevalgo = -1
			minlm.minlmcreatev(k, n, state.c, diffstep, state.optstate)
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Nonlinear least squares fitting using function values only.
'
'        Combination of numerical differentiation and secant updates is used to
'        obtain function Jacobian.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,
'
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * w is an N-dimensional vector of weight coefficients,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'
'        This subroutine uses only f(c,x[i]).
'
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'            DiffStep-   numerical differentiation step;
'                        should not be very small or large;
'                        large = loss of accuracy
'                        small = growth of round-off errors
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'          -- ALGLIB --
'             Copyright 18.10.2008 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatef(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
			diffstep As Double, state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateF: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateF: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateF: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateF: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateF: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateF: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateF: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateF: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateF: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateF: X contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateF: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateF: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateF: X contains infinite or NaN values!")
			alglib.ap.assert(Math.isfinite(diffstep), "LSFitCreateF: DiffStep is not finite!")
			alglib.ap.assert(CDbl(diffstep) > CDbl(0), "LSFitCreateF: DiffStep<=0!")
			state.teststep = 0
			state.diffstep = diffstep
			state.npoints = n
			state.wkind = 0
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.x = New Double(m - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 0
			state.prevnpt = -1
			state.prevalgo = -1
			minlm.minlmcreatev(k, n, state.c, diffstep, state.optstate)
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Weighted nonlinear least squares fitting using gradient only.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'            
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * w is an N-dimensional vector of weight coefficients,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'            
'        This subroutine uses only f(c,x[i]) and its gradient.
'            
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            W       -   weights, array[0..N-1]
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'            CheapFG -   boolean flag, which is:
'                        * True  if both function and gradient calculation complexity
'                                are less than O(M^2).  An improved  algorithm  can
'                                be  used  which corresponds  to  FGJ  scheme  from
'                                MINLM unit.
'                        * False otherwise.
'                                Standard Jacibian-bases  Levenberg-Marquardt  algo
'                                will be used (FJ scheme).
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'        See also:
'            LSFitResults
'            LSFitCreateFG (fitting without weights)
'            LSFitCreateWFGH (fitting using Hessian)
'            LSFitCreateFGH (fitting using Hessian, without weights)
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatewfg(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
			k As Integer, cheapfg As Boolean, state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateWFG: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateWFG: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateWFG: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateWFG: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateWFG: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateWFG: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateWFG: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "LSFitCreateWFG: length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "LSFitCreateWFG: W contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateWFG: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateWFG: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateWFG: X contains infinite or NaN values!")
			state.teststep = 0
			state.diffstep = 0
			state.npoints = n
			state.nweights = n
			state.wkind = 1
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.taskw = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.x = New Double(m - 1) {}
			state.g = New Double(k - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i_ = 0 To n - 1
				state.taskw(i_) = w(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 1
			state.prevnpt = -1
			state.prevalgo = -1
			If cheapfg Then
				minlm.minlmcreatevgj(k, n, state.c, state.optstate)
			Else
				minlm.minlmcreatevj(k, n, state.c, state.optstate)
			End If
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Nonlinear least squares fitting using gradient only, without individual
'        weights.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
'
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'
'        This subroutine uses only f(c,x[i]) and its gradient.
'
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'            CheapFG -   boolean flag, which is:
'                        * True  if both function and gradient calculation complexity
'                                are less than O(M^2).  An improved  algorithm  can
'                                be  used  which corresponds  to  FGJ  scheme  from
'                                MINLM unit.
'                        * False otherwise.
'                                Standard Jacibian-bases  Levenberg-Marquardt  algo
'                                will be used (FJ scheme).
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatefg(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
			cheapfg As Boolean, state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateFG: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateFG: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateFG: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateFG: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateFG: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateFG: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateFG: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateFG: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateFG: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateFG: X contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateFG: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateFG: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateFG: X contains infinite or NaN values!")
			state.teststep = 0
			state.diffstep = 0
			state.npoints = n
			state.wkind = 0
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.x = New Double(m - 1) {}
			state.g = New Double(k - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 1
			state.prevnpt = -1
			state.prevalgo = -1
			If cheapfg Then
				minlm.minlmcreatevgj(k, n, state.c, state.optstate)
			Else
				minlm.minlmcreatevj(k, n, state.c, state.optstate)
			End If
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Weighted nonlinear least squares fitting using gradient/Hessian.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
'
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * w is an N-dimensional vector of weight coefficients,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'
'        This subroutine uses f(c,x[i]), its gradient and its Hessian.
'
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            W       -   weights, array[0..N-1]
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatewfgh(x As Double(,), y As Double(), w As Double(), c As Double(), n As Integer, m As Integer, _
			k As Integer, state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateWFGH: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateWFGH: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateWFGH: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateWFGH: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateWFGH: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateWFGH: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateWFGH: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(w) >= n, "LSFitCreateWFGH: length(W)<N!")
			alglib.ap.assert(apserv.isfinitevector(w, n), "LSFitCreateWFGH: W contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateWFGH: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateWFGH: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateWFGH: X contains infinite or NaN values!")
			state.teststep = 0
			state.diffstep = 0
			state.npoints = n
			state.nweights = n
			state.wkind = 1
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.taskw = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.h = New Double(k - 1, k - 1) {}
			state.x = New Double(m - 1) {}
			state.g = New Double(k - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i_ = 0 To n - 1
				state.taskw(i_) = w(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 2
			state.prevnpt = -1
			state.prevalgo = -1
			minlm.minlmcreatefgh(k, state.c, state.optstate)
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Nonlinear least squares fitting using gradient/Hessian, without individial
'        weights.
'
'        Nonlinear task min(F(c)) is solved, where
'
'            F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
'
'            * N is a number of points,
'            * M is a dimension of a space points belong to,
'            * K is a dimension of a space of parameters being fitted,
'            * x is a set of N points, each of them is an M-dimensional vector,
'            * c is a K-dimensional vector of parameters being fitted
'
'        This subroutine uses f(c,x[i]), its gradient and its Hessian.
'
'        INPUT PARAMETERS:
'            X       -   array[0..N-1,0..M-1], points (one row = one point)
'            Y       -   array[0..N-1], function values.
'            C       -   array[0..K-1], initial approximation to the solution,
'            N       -   number of points, N>1
'            M       -   dimension of space
'            K       -   number of parameters being fitted
'
'        OUTPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitcreatefgh(x As Double(,), y As Double(), c As Double(), n As Integer, m As Integer, k As Integer, _
			state As lsfitstate)
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(n >= 1, "LSFitCreateFGH: N<1!")
			alglib.ap.assert(m >= 1, "LSFitCreateFGH: M<1!")
			alglib.ap.assert(k >= 1, "LSFitCreateFGH: K<1!")
			alglib.ap.assert(alglib.ap.len(c) >= k, "LSFitCreateFGH: length(C)<K!")
			alglib.ap.assert(apserv.isfinitevector(c, k), "LSFitCreateFGH: C contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.len(y) >= n, "LSFitCreateFGH: length(Y)<N!")
			alglib.ap.assert(apserv.isfinitevector(y, n), "LSFitCreateFGH: Y contains infinite or NaN values!")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSFitCreateFGH: rows(X)<N!")
			alglib.ap.assert(alglib.ap.cols(x) >= m, "LSFitCreateFGH: cols(X)<M!")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, m), "LSFitCreateFGH: X contains infinite or NaN values!")
			state.teststep = 0
			state.diffstep = 0
			state.npoints = n
			state.wkind = 0
			state.m = m
			state.k = k
			lsfitsetcond(state, 0.0, 0.0, 0)
			lsfitsetstpmax(state, 0.0)
			lsfitsetxrep(state, False)
			state.taskx = New Double(n - 1, m - 1) {}
			state.tasky = New Double(n - 1) {}
			state.c = New Double(k - 1) {}
			state.h = New Double(k - 1, k - 1) {}
			state.x = New Double(m - 1) {}
			state.g = New Double(k - 1) {}
			For i_ = 0 To k - 1
				state.c(i_) = c(i_)
			Next
			For i = 0 To n - 1
				For i_ = 0 To m - 1
					state.taskx(i, i_) = x(i, i_)
				Next
				state.tasky(i) = y(i)
			Next
			state.s = New Double(k - 1) {}
			state.bndl = New Double(k - 1) {}
			state.bndu = New Double(k - 1) {}
			For i = 0 To k - 1
				state.s(i) = 1.0
				state.bndl(i) = [Double].NegativeInfinity
				state.bndu(i) = [Double].PositiveInfinity
			Next
			state.optalgo = 2
			state.prevnpt = -1
			state.prevalgo = -1
			minlm.minlmcreatefgh(k, state.c, state.optstate)
			lsfitclearrequestfields(state)
			state.rstate.ia = New Integer(6) {}
			state.rstate.ra = New Double(8) {}
			state.rstate.stage = -1
		End Sub


		'************************************************************************
'        Stopping conditions for nonlinear least squares fitting.
'
'        INPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'            EpsF    -   stopping criterion. Algorithm stops if
'                        |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}
'            EpsX    -   >=0
'                        The subroutine finishes its work if  on  k+1-th  iteration
'                        the condition |v|<=EpsX is fulfilled, where:
'                        * |.| means Euclidian norm
'                        * v - scaled step vector, v[i]=dx[i]/s[i]
'                        * dx - ste pvector, dx=X(k+1)-X(k)
'                        * s - scaling coefficients set by LSFitSetScale()
'            MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
'                        iterations   is    unlimited.   Only   Levenberg-Marquardt
'                        iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
'                        counted because their cost is very low compared to that of
'                        LM).
'
'        NOTE
'
'        Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
'        stopping criterion selection (according to the scheme used by MINLM unit).
'
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetcond(state As lsfitstate, epsf As Double, epsx As Double, maxits As Integer)
			alglib.ap.assert(Math.isfinite(epsf), "LSFitSetCond: EpsF is not finite!")
			alglib.ap.assert(CDbl(epsf) >= CDbl(0), "LSFitSetCond: negative EpsF!")
			alglib.ap.assert(Math.isfinite(epsx), "LSFitSetCond: EpsX is not finite!")
			alglib.ap.assert(CDbl(epsx) >= CDbl(0), "LSFitSetCond: negative EpsX!")
			alglib.ap.assert(maxits >= 0, "LSFitSetCond: negative MaxIts!")
			state.epsf = epsf
			state.epsx = epsx
			state.maxits = maxits
		End Sub


		'************************************************************************
'        This function sets maximum step length
'
'        INPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'            StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                        want to limit step length.
'
'        Use this subroutine when you optimize target function which contains exp()
'        or  other  fast  growing  functions,  and optimization algorithm makes too
'        large  steps  which  leads  to overflow. This function allows us to reject
'        steps  that  are  too  large  (and  therefore  expose  us  to the possible
'        overflow) without actually calculating function value at the x+stp*d.
'
'        NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'        intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'        with limits on step size.
'
'          -- ALGLIB --
'             Copyright 02.04.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetstpmax(state As lsfitstate, stpmax As Double)
			alglib.ap.assert(CDbl(stpmax) >= CDbl(0), "LSFitSetStpMax: StpMax<0!")
			state.stpmax = stpmax
		End Sub


		'************************************************************************
'        This function turns on/off reporting.
'
'        INPUT PARAMETERS:
'            State   -   structure which stores algorithm state
'            NeedXRep-   whether iteration reports are needed or not
'            
'        When reports are needed, State.C (current parameters) and State.F (current
'        value of fitting function) are reported.
'
'
'          -- ALGLIB --
'             Copyright 15.08.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetxrep(state As lsfitstate, needxrep As Boolean)
			state.xrep = needxrep
		End Sub


		'************************************************************************
'        This function sets scaling coefficients for underlying optimizer.
'
'        ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
'        size and gradient are scaled before comparison with tolerances).  Scale of
'        the I-th variable is a translation invariant measure of:
'        a) "how large" the variable is
'        b) how large the step should be to make significant changes in the function
'
'        Generally, scale is NOT considered to be a form of preconditioner.  But LM
'        optimizer is unique in that it uses scaling matrix both  in  the  stopping
'        condition tests and as Marquardt damping factor.
'
'        Proper scaling is very important for the algorithm performance. It is less
'        important for the quality of results, but still has some influence (it  is
'        easier  to  converge  when  variables  are  properly  scaled, so premature
'        stopping is possible when very badly scalled variables are  combined  with
'        relaxed stopping conditions).
'
'        INPUT PARAMETERS:
'            State   -   structure stores algorithm state
'            S       -   array[N], non-zero scaling coefficients
'                        S[i] may be negative, sign doesn't matter.
'
'          -- ALGLIB --
'             Copyright 14.01.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetscale(state As lsfitstate, s As Double())
			Dim i As Integer = 0

			alglib.ap.assert(alglib.ap.len(s) >= state.k, "LSFitSetScale: Length(S)<K")
			For i = 0 To state.k - 1
				alglib.ap.assert(Math.isfinite(s(i)), "LSFitSetScale: S contains infinite or NAN elements")
				alglib.ap.assert(CDbl(s(i)) <> CDbl(0), "LSFitSetScale: S contains infinite or NAN elements")
				state.s(i) = System.Math.Abs(s(i))
			Next
		End Sub


		'************************************************************************
'        This function sets boundary constraints for underlying optimizer
'
'        Boundary constraints are inactive by default (after initial creation).
'        They are preserved until explicitly turned off with another SetBC() call.
'
'        INPUT PARAMETERS:
'            State   -   structure stores algorithm state
'            BndL    -   lower bounds, array[K].
'                        If some (all) variables are unbounded, you may specify
'                        very small number or -INF (latter is recommended because
'                        it will allow solver to use better algorithm).
'            BndU    -   upper bounds, array[K].
'                        If some (all) variables are unbounded, you may specify
'                        very large number or +INF (latter is recommended because
'                        it will allow solver to use better algorithm).
'
'        NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
'        variable will be "frozen" at X[i]=BndL[i]=BndU[i].
'
'        NOTE 2: unlike other constrained optimization algorithms, this solver  has
'        following useful properties:
'        * bound constraints are always satisfied exactly
'        * function is evaluated only INSIDE area specified by bound constraints
'
'          -- ALGLIB --
'             Copyright 14.01.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetbc(state As lsfitstate, bndl As Double(), bndu As Double())
			Dim i As Integer = 0
			Dim k As Integer = 0

			k = state.k
			alglib.ap.assert(alglib.ap.len(bndl) >= k, "LSFitSetBC: Length(BndL)<K")
			alglib.ap.assert(alglib.ap.len(bndu) >= k, "LSFitSetBC: Length(BndU)<K")
			For i = 0 To k - 1
				alglib.ap.assert(Math.isfinite(bndl(i)) OrElse [Double].IsNegativeInfinity(bndl(i)), "LSFitSetBC: BndL contains NAN or +INF")
				alglib.ap.assert(Math.isfinite(bndu(i)) OrElse [Double].IsPositiveInfinity(bndu(i)), "LSFitSetBC: BndU contains NAN or -INF")
				If Math.isfinite(bndl(i)) AndAlso Math.isfinite(bndu(i)) Then
					alglib.ap.assert(CDbl(bndl(i)) <= CDbl(bndu(i)), "LSFitSetBC: BndL[i]>BndU[i]")
				End If
				state.bndl(i) = bndl(i)
				state.bndu(i) = bndu(i)
			Next
		End Sub


		'************************************************************************
'        NOTES:
'
'        1. this algorithm is somewhat unusual because it works with  parameterized
'           function f(C,X), where X is a function argument (we  have  many  points
'           which are characterized by different  argument  values),  and  C  is  a
'           parameter to fit.
'
'           For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
'           x will be argument, and {c0,c1} will be parameters.
'           
'           It is important to understand that this algorithm finds minimum in  the
'           space of function PARAMETERS (not arguments), so it  needs  derivatives
'           of f() with respect to C, not X.
'           
'           In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
'           instead of {df/dx} = {c0}.
'
'        2. Callback functions accept C as the first parameter, and X as the second
'
'        3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
'           function   and   its   gradient,   but   if   state   was  created with
'           LSFitCreateFGH(), algorithm will need function, gradient and Hessian.
'           
'           According  to  the  said  above,  there  ase  several  versions of this
'           function, which accept different sets of callbacks.
'           
'           This flexibility opens way to subtle errors - you may create state with
'           LSFitCreateFGH() (optimization using Hessian), but call function  which
'           does not accept Hessian. So when algorithm will request Hessian,  there
'           will be no callback to call. In this case exception will be thrown.
'           
'           Be careful to avoid such errors because there is no way to find them at
'           compile time - you can see them at runtime only.
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function lsfititeration(state As lsfitstate) As Boolean
			Dim result As New Boolean()
			Dim lx As Double = 0
			Dim lf As Double = 0
			Dim ld As Double = 0
			Dim rx As Double = 0
			Dim rf As Double = 0
			Dim rd As Double = 0
			Dim n As Integer = 0
			Dim m As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim vv As Double = 0
			Dim relcnt As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim info As Integer = 0
			Dim i_ As Integer = 0


			'
			' Reverse communication preparations
			' I know it looks ugly, but it works the same way
			' anywhere from C++ to Python.
			'
			' This code initializes locals by:
			' * random values determined during code
			'   generation - on first subroutine call
			' * values from previous call - on subsequent calls
			'
			If state.rstate.stage >= 0 Then
				n = state.rstate.ia(0)
				m = state.rstate.ia(1)
				k = state.rstate.ia(2)
				i = state.rstate.ia(3)
				j = state.rstate.ia(4)
				j1 = state.rstate.ia(5)
				info = state.rstate.ia(6)
				lx = state.rstate.ra(0)
				lf = state.rstate.ra(1)
				ld = state.rstate.ra(2)
				rx = state.rstate.ra(3)
				rf = state.rstate.ra(4)
				rd = state.rstate.ra(5)
				v = state.rstate.ra(6)
				vv = state.rstate.ra(7)
				relcnt = state.rstate.ra(8)
			Else
				n = -983
				m = -989
				k = -834
				i = 900
				j = -287
				j1 = 364
				info = 214
				lx = -338
				lf = -686
				ld = 912
				rx = 585
				rf = 497
				rd = -271
				v = -581
				vv = 745
				relcnt = -533
			End If
			If state.rstate.stage = 0 Then
				GoTo lbl_0
			End If
			If state.rstate.stage = 1 Then
				GoTo lbl_1
			End If
			If state.rstate.stage = 2 Then
				GoTo lbl_2
			End If
			If state.rstate.stage = 3 Then
				GoTo lbl_3
			End If
			If state.rstate.stage = 4 Then
				GoTo lbl_4
			End If
			If state.rstate.stage = 5 Then
				GoTo lbl_5
			End If
			If state.rstate.stage = 6 Then
				GoTo lbl_6
			End If
			If state.rstate.stage = 7 Then
				GoTo lbl_7
			End If
			If state.rstate.stage = 8 Then
				GoTo lbl_8
			End If
			If state.rstate.stage = 9 Then
				GoTo lbl_9
			End If
			If state.rstate.stage = 10 Then
				GoTo lbl_10
			End If
			If state.rstate.stage = 11 Then
				GoTo lbl_11
			End If
			If state.rstate.stage = 12 Then
				GoTo lbl_12
			End If
			If state.rstate.stage = 13 Then
				GoTo lbl_13
			End If

			'
			' Routine body
			'

			'
			' Init
			'
			If state.wkind = 1 Then
				alglib.ap.assert(state.npoints = state.nweights, "LSFitFit: number of points is not equal to the number of weights")
			End If
			state.repvaridx = -1
			n = state.npoints
			m = state.m
			k = state.k
			minlm.minlmsetcond(state.optstate, 0.0, state.epsf, state.epsx, state.maxits)
			minlm.minlmsetstpmax(state.optstate, state.stpmax)
			minlm.minlmsetxrep(state.optstate, state.xrep)
			minlm.minlmsetscale(state.optstate, state.s)
			minlm.minlmsetbc(state.optstate, state.bndl, state.bndu)

			'
			'  Check that user-supplied gradient is correct
			'
			lsfitclearrequestfields(state)
			If Not (CDbl(state.teststep) > CDbl(0) AndAlso state.optalgo = 1) Then
				GoTo lbl_14
			End If
			For i = 0 To k - 1
				If Math.isfinite(state.bndl(i)) Then
					state.c(i) = System.Math.Max(state.c(i), state.bndl(i))
				End If
				If Math.isfinite(state.bndu(i)) Then
					state.c(i) = System.Math.Min(state.c(i), state.bndu(i))
				End If
			Next
			state.needfg = True
			i = 0
			lbl_16:
			If i > k - 1 Then
				GoTo lbl_18
			End If
			alglib.ap.assert(CDbl(state.bndl(i)) <= CDbl(state.c(i)) AndAlso CDbl(state.c(i)) <= CDbl(state.bndu(i)), "LSFitIteration: internal error(State.C is out of bounds)")
			v = state.c(i)
			j = 0
			lbl_19:
			If j > n - 1 Then
				GoTo lbl_21
			End If
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(j, i_)
			Next
			state.c(i) = v - state.teststep * state.s(i)
			If Math.isfinite(state.bndl(i)) Then
				state.c(i) = System.Math.Max(state.c(i), state.bndl(i))
			End If
			lx = state.c(i)
			state.rstate.stage = 0
			GoTo lbl_rcomm
			lbl_0:
			lf = state.f
			ld = state.g(i)
			state.c(i) = v + state.teststep * state.s(i)
			If Math.isfinite(state.bndu(i)) Then
				state.c(i) = System.Math.Min(state.c(i), state.bndu(i))
			End If
			rx = state.c(i)
			state.rstate.stage = 1
			GoTo lbl_rcomm
			lbl_1:
			rf = state.f
			rd = state.g(i)
			state.c(i) = (lx + rx) / 2
			If Math.isfinite(state.bndl(i)) Then
				state.c(i) = System.Math.Max(state.c(i), state.bndl(i))
			End If
			If Math.isfinite(state.bndu(i)) Then
				state.c(i) = System.Math.Min(state.c(i), state.bndu(i))
			End If
			state.rstate.stage = 2
			GoTo lbl_rcomm
			lbl_2:
			state.c(i) = v
			If Not optserv.derivativecheck(lf, ld, rf, rd, state.f, state.g(i), _
				rx - lx) Then
				state.repvaridx = i
				state.repterminationtype = -7
				result = False
				Return result
			End If
			j = j + 1
			GoTo lbl_19
			lbl_21:
			i = i + 1
			GoTo lbl_16
			lbl_18:
			state.needfg = False
			lbl_14:

			'
			' Fill WCur by weights:
			' * for WKind=0 unit weights are chosen
			' * for WKind=1 we use user-supplied weights stored in State.TaskW
			'
			apserv.rvectorsetlengthatleast(state.wcur, n)
			For i = 0 To n - 1
				state.wcur(i) = 1.0
				If state.wkind = 1 Then
					state.wcur(i) = state.taskw(i)
				End If
			Next
			lbl_22:

			'
			' Optimize
			'
			If Not minlm.minlmiteration(state.optstate) Then
				GoTo lbl_23
			End If
			If Not state.optstate.needfi Then
				GoTo lbl_24
			End If

			'
			' calculate f[] = wi*(f(xi,c)-yi)
			'
			i = 0
			lbl_26:
			If i > n - 1 Then
				GoTo lbl_28
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needf = True
			state.rstate.stage = 3
			GoTo lbl_rcomm
			lbl_3:
			state.needf = False
			vv = state.wcur(i)
			state.optstate.fi(i) = vv * (state.f - state.tasky(i))
			i = i + 1
			GoTo lbl_26
			lbl_28:
			GoTo lbl_22
			lbl_24:
			If Not state.optstate.needf Then
				GoTo lbl_29
			End If

			'
			' calculate F = sum (wi*(f(xi,c)-yi))^2
			'
			state.optstate.f = 0
			i = 0
			lbl_31:
			If i > n - 1 Then
				GoTo lbl_33
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needf = True
			state.rstate.stage = 4
			GoTo lbl_rcomm
			lbl_4:
			state.needf = False
			vv = state.wcur(i)
			state.optstate.f = state.optstate.f + Math.sqr(vv * (state.f - state.tasky(i)))
			i = i + 1
			GoTo lbl_31
			lbl_33:
			GoTo lbl_22
			lbl_29:
			If Not state.optstate.needfg Then
				GoTo lbl_34
			End If

			'
			' calculate F/gradF
			'
			state.optstate.f = 0
			For i = 0 To k - 1
				state.optstate.g(i) = 0
			Next
			i = 0
			lbl_36:
			If i > n - 1 Then
				GoTo lbl_38
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needfg = True
			state.rstate.stage = 5
			GoTo lbl_rcomm
			lbl_5:
			state.needfg = False
			vv = state.wcur(i)
			state.optstate.f = state.optstate.f + Math.sqr(vv * (state.f - state.tasky(i)))
			v = Math.sqr(vv) * 2 * (state.f - state.tasky(i))
			For i_ = 0 To k - 1
				state.optstate.g(i_) = state.optstate.g(i_) + v * state.g(i_)
			Next
			i = i + 1
			GoTo lbl_36
			lbl_38:
			GoTo lbl_22
			lbl_34:
			If Not state.optstate.needfij Then
				GoTo lbl_39
			End If

			'
			' calculate Fi/jac(Fi)
			'
			i = 0
			lbl_41:
			If i > n - 1 Then
				GoTo lbl_43
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needfg = True
			state.rstate.stage = 6
			GoTo lbl_rcomm
			lbl_6:
			state.needfg = False
			vv = state.wcur(i)
			state.optstate.fi(i) = vv * (state.f - state.tasky(i))
			For i_ = 0 To k - 1
				state.optstate.j(i, i_) = vv * state.g(i_)
			Next
			i = i + 1
			GoTo lbl_41
			lbl_43:
			GoTo lbl_22
			lbl_39:
			If Not state.optstate.needfgh Then
				GoTo lbl_44
			End If

			'
			' calculate F/grad(F)/hess(F)
			'
			state.optstate.f = 0
			For i = 0 To k - 1
				state.optstate.g(i) = 0
			Next
			For i = 0 To k - 1
				For j = 0 To k - 1
					state.optstate.h(i, j) = 0
				Next
			Next
			i = 0
			lbl_46:
			If i > n - 1 Then
				GoTo lbl_48
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needfgh = True
			state.rstate.stage = 7
			GoTo lbl_rcomm
			lbl_7:
			state.needfgh = False
			vv = state.wcur(i)
			state.optstate.f = state.optstate.f + Math.sqr(vv * (state.f - state.tasky(i)))
			v = Math.sqr(vv) * 2 * (state.f - state.tasky(i))
			For i_ = 0 To k - 1
				state.optstate.g(i_) = state.optstate.g(i_) + v * state.g(i_)
			Next
			For j = 0 To k - 1
				v = 2 * Math.sqr(vv) * state.g(j)
				For i_ = 0 To k - 1
					state.optstate.h(j, i_) = state.optstate.h(j, i_) + v * state.g(i_)
				Next
				v = 2 * Math.sqr(vv) * (state.f - state.tasky(i))
				For i_ = 0 To k - 1
					state.optstate.h(j, i_) = state.optstate.h(j, i_) + v * state.h(j, i_)
				Next
			Next
			i = i + 1
			GoTo lbl_46
			lbl_48:
			GoTo lbl_22
			lbl_44:
			If Not state.optstate.xupdated Then
				GoTo lbl_49
			End If

			'
			' Report new iteration
			'
			For i_ = 0 To k - 1
				state.c(i_) = state.optstate.x(i_)
			Next
			state.f = state.optstate.f
			lsfitclearrequestfields(state)
			state.xupdated = True
			state.rstate.stage = 8
			GoTo lbl_rcomm
			lbl_8:
			state.xupdated = False
			GoTo lbl_22
			lbl_49:
			GoTo lbl_22
			lbl_23:
			minlm.minlmresults(state.optstate, state.c, state.optrep)
			state.repterminationtype = state.optrep.terminationtype
			state.repiterationscount = state.optrep.iterationscount

			'
			' calculate errors
			'
			If state.repterminationtype <= 0 Then
				GoTo lbl_51
			End If

			'
			' Calculate RMS/Avg/Max/... errors
			'
			state.reprmserror = 0
			state.repwrmserror = 0
			state.repavgerror = 0
			state.repavgrelerror = 0
			state.repmaxerror = 0
			relcnt = 0
			i = 0
			lbl_53:
			If i > n - 1 Then
				GoTo lbl_55
			End If
			For i_ = 0 To k - 1
				state.c(i_) = state.c(i_)
			Next
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			lsfitclearrequestfields(state)
			state.needf = True
			state.rstate.stage = 9
			GoTo lbl_rcomm
			lbl_9:
			state.needf = False
			v = state.f
			vv = state.wcur(i)
			state.reprmserror = state.reprmserror + Math.sqr(v - state.tasky(i))
			state.repwrmserror = state.repwrmserror + Math.sqr(vv * (v - state.tasky(i)))
			state.repavgerror = state.repavgerror + System.Math.Abs(v - state.tasky(i))
			If CDbl(state.tasky(i)) <> CDbl(0) Then
				state.repavgrelerror = state.repavgrelerror + System.Math.Abs(v - state.tasky(i)) / System.Math.Abs(state.tasky(i))
				relcnt = relcnt + 1
			End If
			state.repmaxerror = System.Math.Max(state.repmaxerror, System.Math.Abs(v - state.tasky(i)))
			i = i + 1
			GoTo lbl_53
			lbl_55:
			state.reprmserror = System.Math.sqrt(state.reprmserror / n)
			state.repwrmserror = System.Math.sqrt(state.repwrmserror / n)
			state.repavgerror = state.repavgerror / n
			If CDbl(relcnt) <> CDbl(0) Then
				state.repavgrelerror = state.repavgrelerror / relcnt
			End If

			'
			' Calculate covariance matrix
			'
			apserv.rmatrixsetlengthatleast(state.tmpjac, n, k)
			apserv.rvectorsetlengthatleast(state.tmpf, n)
			apserv.rvectorsetlengthatleast(state.tmp, k)
			If CDbl(state.diffstep) <= CDbl(0) Then
				GoTo lbl_56
			End If

			'
			' Compute Jacobian by means of numerical differentiation
			'
			lsfitclearrequestfields(state)
			state.needf = True
			i = 0
			lbl_58:
			If i > n - 1 Then
				GoTo lbl_60
			End If
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			state.rstate.stage = 10
			GoTo lbl_rcomm
			lbl_10:
			state.tmpf(i) = state.f
			j = 0
			lbl_61:
			If j > k - 1 Then
				GoTo lbl_63
			End If
			v = state.c(j)
			lx = v - state.diffstep * state.s(j)
			state.c(j) = lx
			If Math.isfinite(state.bndl(j)) Then
				state.c(j) = System.Math.Max(state.c(j), state.bndl(j))
			End If
			state.rstate.stage = 11
			GoTo lbl_rcomm
			lbl_11:
			lf = state.f
			rx = v + state.diffstep * state.s(j)
			state.c(j) = rx
			If Math.isfinite(state.bndu(j)) Then
				state.c(j) = System.Math.Min(state.c(j), state.bndu(j))
			End If
			state.rstate.stage = 12
			GoTo lbl_rcomm
			lbl_12:
			rf = state.f
			state.c(j) = v
			If CDbl(rx) <> CDbl(lx) Then
				state.tmpjac(i, j) = (rf - lf) / (rx - lx)
			Else
				state.tmpjac(i, j) = 0
			End If
			j = j + 1
			GoTo lbl_61
			lbl_63:
			i = i + 1
			GoTo lbl_58
			lbl_60:
			state.needf = False
			GoTo lbl_57
			lbl_56:

			'
			' Jacobian is calculated with user-provided analytic gradient
			'
			lsfitclearrequestfields(state)
			state.needfg = True
			i = 0
			lbl_64:
			If i > n - 1 Then
				GoTo lbl_66
			End If
			For i_ = 0 To m - 1
				state.x(i_) = state.taskx(i, i_)
			Next
			state.pointindex = i
			state.rstate.stage = 13
			GoTo lbl_rcomm
			lbl_13:
			state.tmpf(i) = state.f
			For j = 0 To k - 1
				state.tmpjac(i, j) = state.g(j)
			Next
			i = i + 1
			GoTo lbl_64
			lbl_66:
			state.needfg = False
			lbl_57:
			For i = 0 To k - 1
				state.tmp(i) = 0.0
			Next
			estimateerrors(state.tmpjac, state.tmpf, state.tasky, state.wcur, state.tmp, state.s, _
				n, k, state.rep, state.tmpjacw, 0)
			lbl_51:
			result = False
			Return result
			lbl_rcomm:

			'
			' Saving state
			'
			result = True
			state.rstate.ia(0) = n
			state.rstate.ia(1) = m
			state.rstate.ia(2) = k
			state.rstate.ia(3) = i
			state.rstate.ia(4) = j
			state.rstate.ia(5) = j1
			state.rstate.ia(6) = info
			state.rstate.ra(0) = lx
			state.rstate.ra(1) = lf
			state.rstate.ra(2) = ld
			state.rstate.ra(3) = rx
			state.rstate.ra(4) = rf
			state.rstate.ra(5) = rd
			state.rstate.ra(6) = v
			state.rstate.ra(7) = vv
			state.rstate.ra(8) = relcnt
			Return result
		End Function


		'************************************************************************
'        Nonlinear least squares fitting results.
'
'        Called after return from LSFitFit().
'
'        INPUT PARAMETERS:
'            State   -   algorithm state
'
'        OUTPUT PARAMETERS:
'            Info    -   completion code:
'                            * -7    gradient verification failed.
'                                    See LSFitSetGradientCheck() for more information.
'                            *  1    relative function improvement is no more than
'                                    EpsF.
'                            *  2    relative step is no more than EpsX.
'                            *  4    gradient norm is no more than EpsG
'                            *  5    MaxIts steps was taken
'                            *  7    stopping conditions are too stringent,
'                                    further improvement is impossible
'            C       -   array[0..K-1], solution
'            Rep     -   optimization report. On success following fields are set:
'                        * R2                non-adjusted coefficient of determination
'                                            (non-weighted)
'                        * RMSError          rms error on the (X,Y).
'                        * AvgError          average error on the (X,Y).
'                        * AvgRelError       average relative error on the non-zero Y
'                        * MaxError          maximum error
'                                            NON-WEIGHTED ERRORS ARE CALCULATED
'                        * WRMSError         weighted rms error on the (X,Y).
'                        
'        ERRORS IN PARAMETERS                
'                        
'        This  solver  also  calculates different kinds of errors in parameters and
'        fills corresponding fields of report:
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(J*CovPar*J')),
'                            where J is Jacobian matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'
'        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                    account boundary/linear constraints! Presence  of  constraints
'                    changes distribution of errors, but there is no  easy  way  to
'                    account for constraints when you calculate covariance matrix.
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'                    
'        NOTE:       covariance matrix is estimated using  correction  for  degrees
'                    of freedom (covariances are divided by N-M instead of dividing
'                    by N).
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitresults(state As lsfitstate, ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0

			info = 0
			c = New Double(-1) {}

			clearreport(rep)
			info = state.repterminationtype
			rep.varidx = state.repvaridx
			If info > 0 Then
				c = New Double(state.k - 1) {}
				For i_ = 0 To state.k - 1
					c(i_) = state.c(i_)
				Next
				rep.rmserror = state.reprmserror
				rep.wrmserror = state.repwrmserror
				rep.avgerror = state.repavgerror
				rep.avgrelerror = state.repavgrelerror
				rep.maxerror = state.repmaxerror
				rep.iterationscount = state.repiterationscount
				rep.covpar = New Double(state.k - 1, state.k - 1) {}
				rep.errpar = New Double(state.k - 1) {}
				rep.errcurve = New Double(state.npoints - 1) {}
				rep.noise = New Double(state.npoints - 1) {}
				rep.r2 = state.rep.r2
				For i = 0 To state.k - 1
					For j = 0 To state.k - 1
						rep.covpar(i, j) = state.rep.covpar(i, j)
					Next
					rep.errpar(i) = state.rep.errpar(i)
				Next
				For i = 0 To state.npoints - 1
					rep.errcurve(i) = state.rep.errcurve(i)
					rep.noise(i) = state.rep.noise(i)
				Next
			End If
		End Sub


		'************************************************************************
'        This  subroutine  turns  on  verification  of  the  user-supplied analytic
'        gradient:
'        * user calls this subroutine before fitting begins
'        * LSFitFit() is called
'        * prior to actual fitting, for  each  point  in  data  set  X_i  and  each
'          component  of  parameters  being  fited C_j algorithm performs following
'          steps:
'          * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
'            where C_j is j-th parameter and S[j] is a scale of j-th parameter
'          * if needed, steps are bounded with respect to constraints on C[]
'          * F(X_i|C) is evaluated at these trial points
'          * we perform one more evaluation in the middle point of the interval
'          * we  build  cubic  model using function values and derivatives at trial
'            points and we compare its prediction with actual value in  the  middle
'            point
'          * in case difference between prediction and actual value is higher  than
'            some predetermined threshold, algorithm stops with completion code -7;
'            Rep.VarIdx is set to index of the parameter with incorrect derivative.
'        * after verification is over, algorithm proceeds to the actual optimization.
'
'        NOTE 1: verification needs N*K (points count * parameters count)  gradient
'                evaluations. It is very costly and you should use it only for  low
'                dimensional  problems,  when  you  want  to  be  sure  that you've
'                correctly calculated analytic derivatives. You should not  use  it
'                in the production code  (unless  you  want  to  check  derivatives
'                provided by some third party).
'
'        NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
'                (so large that function behaviour is significantly non-cubic) will
'                lead to false alarms. You may use  different  step  for  different
'                parameters by means of setting scale with LSFitSetScale().
'
'        NOTE 3: this function may lead to false positives. In case it reports that
'                I-th  derivative was calculated incorrectly, you may decrease test
'                step  and  try  one  more  time  - maybe your function changes too
'                sharply  and  your  step  is  too  large for such rapidly chanding
'                function.
'
'        NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
'                or LSFitCreateFG() constructors.
'                
'        INPUT PARAMETERS:
'            State       -   structure used to store algorithm state
'            TestStep    -   verification step:
'                            * TestStep=0 turns verification off
'                            * TestStep>0 activates verification
'
'          -- ALGLIB --
'             Copyright 15.06.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitsetgradientcheck(state As lsfitstate, teststep As Double)
			alglib.ap.assert(Math.isfinite(teststep), "LSFitSetGradientCheck: TestStep contains NaN or Infinite")
			alglib.ap.assert(CDbl(teststep) >= CDbl(0), "LSFitSetGradientCheck: invalid argument TestStep(TestStep<0)")
			state.teststep = teststep
		End Sub


		'************************************************************************
'        Internal subroutine: automatic scaling for LLS tasks.
'        NEVER CALL IT DIRECTLY!
'
'        Maps abscissas to [-1,1], standartizes ordinates and correspondingly scales
'        constraints. It also scales weights so that max(W[i])=1
'
'        Transformations performed:
'        * X, XC         [XA,XB] => [-1,+1]
'                        transformation makes min(X)=-1, max(X)=+1
'
'        * Y             [SA,SB] => [0,1]
'                        transformation makes mean(Y)=0, stddev(Y)=1
'                        
'        * YC            transformed accordingly to SA, SB, DC[I]
'
'          -- ALGLIB PROJECT --
'             Copyright 08.09.2009 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub lsfitscalexy(ByRef x As Double(), ByRef y As Double(), ByRef w As Double(), n As Integer, ByRef xc As Double(), ByRef yc As Double(), _
			dc As Integer(), k As Integer, ByRef xa As Double, ByRef xb As Double, ByRef sa As Double, ByRef sb As Double, _
			ByRef xoriginal As Double(), ByRef yoriginal As Double())
			Dim xmin As Double = 0
			Dim xmax As Double = 0
			Dim i As Integer = 0
			Dim mx As Double = 0
			Dim i_ As Integer = 0

			xa = 0
			xb = 0
			sa = 0
			sb = 0
			xoriginal = New Double(-1) {}
			yoriginal = New Double(-1) {}

			alglib.ap.assert(n >= 1, "LSFitScaleXY: incorrect N")
			alglib.ap.assert(k >= 0, "LSFitScaleXY: incorrect K")

			'
			' Calculate xmin/xmax.
			' Force xmin<>xmax.
			'
			xmin = x(0)
			xmax = x(0)
			For i = 1 To n - 1
				xmin = System.Math.Min(xmin, x(i))
				xmax = System.Math.Max(xmax, x(i))
			Next
			For i = 0 To k - 1
				xmin = System.Math.Min(xmin, xc(i))
				xmax = System.Math.Max(xmax, xc(i))
			Next
			If CDbl(xmin) = CDbl(xmax) Then
				If CDbl(xmin) = CDbl(0) Then
					xmin = -1
					xmax = 1
				Else
					If CDbl(xmin) > CDbl(0) Then
						xmin = 0.5 * xmin
					Else
						xmax = 0.5 * xmax
					End If
				End If
			End If

			'
			' Transform abscissas: map [XA,XB] to [0,1]
			'
			' Store old X[] in XOriginal[] (it will be used
			' to calculate relative error).
			'
			xoriginal = New Double(n - 1) {}
			For i_ = 0 To n - 1
				xoriginal(i_) = x(i_)
			Next
			xa = xmin
			xb = xmax
			For i = 0 To n - 1
				x(i) = 2 * (x(i) - 0.5 * (xa + xb)) / (xb - xa)
			Next
			For i = 0 To k - 1
				alglib.ap.assert(dc(i) >= 0, "LSFitScaleXY: internal error!")
				xc(i) = 2 * (xc(i) - 0.5 * (xa + xb)) / (xb - xa)
				yc(i) = yc(i) * System.Math.Pow(0.5 * (xb - xa), dc(i))
			Next

			'
			' Transform function values: map [SA,SB] to [0,1]
			' SA = mean(Y),
			' SB = SA+stddev(Y).
			'
			' Store old Y[] in YOriginal[] (it will be used
			' to calculate relative error).
			'
			yoriginal = New Double(n - 1) {}
			For i_ = 0 To n - 1
				yoriginal(i_) = y(i_)
			Next
			sa = 0
			For i = 0 To n - 1
				sa = sa + y(i)
			Next
			sa = sa / n
			sb = 0
			For i = 0 To n - 1
				sb = sb + Math.sqr(y(i) - sa)
			Next
			sb = System.Math.sqrt(sb / n) + sa
			If CDbl(sb) = CDbl(sa) Then
				sb = 2 * sa
			End If
			If CDbl(sb) = CDbl(sa) Then
				sb = sa + 1
			End If
			For i = 0 To n - 1
				y(i) = (y(i) - sa) / (sb - sa)
			Next
			For i = 0 To k - 1
				If dc(i) = 0 Then
					yc(i) = (yc(i) - sa) / (sb - sa)
				Else
					yc(i) = yc(i) / (sb - sa)
				End If
			Next

			'
			' Scale weights
			'
			mx = 0
			For i = 0 To n - 1
				mx = System.Math.Max(mx, System.Math.Abs(w(i)))
			Next
			If CDbl(mx) <> CDbl(0) Then
				For i = 0 To n - 1
					w(i) = w(i) / mx
				Next
			End If
		End Sub


		'************************************************************************
'        This function analyzes section of curve for processing by RDP algorithm:
'        given set of points X,Y with indexes [I0,I1] it returns point with
'        worst deviation from linear model (non-parametric version which sees curve
'        as Y(x)).
'
'        Input parameters:
'            X, Y        -   SORTED arrays.
'            I0,I1       -   interval (boundaries included) to process
'            Eps         -   desired precision
'            
'        OUTPUT PARAMETERS:
'            WorstIdx    -   index of worst point
'            WorstError  -   error at worst point
'            
'        NOTE: this function guarantees that it returns exactly zero for a section
'              with less than 3 points.
'
'          -- ALGLIB PROJECT --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rdpanalyzesection(x As Double(), y As Double(), i0 As Integer, i1 As Integer, ByRef worstidx As Integer, ByRef worsterror As Double)
			Dim i As Integer = 0
			Dim xleft As Double = 0
			Dim xright As Double = 0
			Dim vx As Double = 0
			Dim ve As Double = 0
			Dim a As Double = 0
			Dim b As Double = 0

			worstidx = 0
			worsterror = 0

			xleft = x(i0)
			xright = x(i1)
			If i1 - i0 + 1 < 3 OrElse CDbl(xright) = CDbl(xleft) Then
				worstidx = i0
				worsterror = 0.0
				Return
			End If
			a = (y(i1) - y(i0)) / (xright - xleft)
			b = (y(i0) * xright - y(i1) * xleft) / (xright - xleft)
			worstidx = -1
			worsterror = 0
			For i = i0 + 1 To i1 - 1
				vx = x(i)
				ve = System.Math.Abs(a * vx + b - y(i))
				If (CDbl(vx) > CDbl(xleft) AndAlso CDbl(vx) < CDbl(xright)) AndAlso CDbl(ve) > CDbl(worsterror) Then
					worsterror = ve
					worstidx = i
				End If
			Next
		End Sub


		'************************************************************************
'        Recursive splitting of interval [I0,I1] (right boundary included) with RDP
'        algorithm (non-parametric version which sees curve as Y(x)).
'
'        Input parameters:
'            X, Y        -   SORTED arrays.
'            I0,I1       -   interval (boundaries included) to process
'            Eps         -   desired precision
'            XOut,YOut   -   preallocated output arrays large enough to store result;
'                            XOut[0..1], YOut[0..1] contain first and last points of
'                            curve
'            NOut        -   must contain 2 on input
'            
'        OUTPUT PARAMETERS:
'            XOut, YOut  -   curve generated by RDP algorithm, UNSORTED
'            NOut        -   number of points in curve
'
'          -- ALGLIB PROJECT --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rdprecursive(x As Double(), y As Double(), i0 As Integer, i1 As Integer, eps As Double, xout As Double(), _
			yout As Double(), ByRef nout As Integer)
			Dim worstidx As Integer = 0
			Dim worsterror As Double = 0

			alglib.ap.assert(CDbl(eps) > CDbl(0), "RDPRecursive: internal error, Eps<0")
			rdpanalyzesection(x, y, i0, i1, worstidx, worsterror)
			If CDbl(worsterror) <= CDbl(eps) Then
				Return
			End If
			xout(nout) = x(worstidx)
			yout(nout) = y(worstidx)
			nout = nout + 1
			If worstidx - i0 < i1 - worstidx Then
				rdprecursive(x, y, i0, worstidx, eps, xout, _
					yout, nout)
				rdprecursive(x, y, worstidx, i1, eps, xout, _
					yout, nout)
			Else
				rdprecursive(x, y, worstidx, i1, eps, xout, _
					yout, nout)
				rdprecursive(x, y, i0, worstidx, eps, xout, _
					yout, nout)
			End If
		End Sub


		'************************************************************************
'        Internal 4PL/5PL fitting function.
'
'        Accepts X, Y and already initialized and prepared MinLMState structure.
'        On input P1 contains initial guess, on output it contains solution.  FLast
'        stores function value at P1.
'        ************************************************************************

		Private Shared Sub logisticfitinternal(x As Double(), y As Double(), n As Integer, is4pl As Boolean, lambdav As Double, state As minlm.minlmstate, _
			replm As minlm.minlmreport, ByRef p1 As Double(), ByRef flast As Double)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim ta As Double = 0
			Dim tb As Double = 0
			Dim tc As Double = 0
			Dim td As Double = 0
			Dim tg As Double = 0
			Dim vp As Double = 0
			Dim vp0 As Double = 0
			Dim vp1 As Double = 0

			flast = 0

			minlm.minlmrestartfrom(state, p1)
			While minlm.minlmiteration(state)
				ta = state.x(0)
				tb = state.x(1)
				tc = state.x(2)
				td = state.x(3)
				tg = state.x(4)
				If state.xupdated Then

					'
					' Save best function value obtained so far.
					'
					flast = state.f
					Continue While
				End If
				If state.needfi Then

					'
					' Function vector
					'
					For i = 0 To n - 1
						If CDbl(x(i)) > CDbl(0) Then
							state.fi(i) = td + (ta - td) / System.Math.Pow(1.0 + System.Math.Pow(x(i) / tc, tb), tg) - y(i)
						Else
							If CDbl(tb) >= CDbl(0) Then
								state.fi(i) = ta - y(i)
							Else
								state.fi(i) = td - y(i)
							End If
						End If
					Next
					For i = 0 To 4
						state.fi(n + i) = lambdav * state.x(i)
					Next
					Continue While
				End If
				If state.needfij Then

					'
					' Function vector and Jacobian
					'
					For i = 0 To n - 1
						If CDbl(x(i)) > CDbl(0) Then
							If is4pl Then
								vp = System.Math.Pow(x(i) / tc, tb)
								state.fi(i) = td + (ta - td) / (1 + vp) - y(i)
								state.j(i, 0) = 1 / (1 + vp)
								state.j(i, 1) = -((ta - td) * vp * System.Math.Log(x(i) / tc) / Math.sqr(1 + vp))
								state.j(i, 2) = (ta - td) * (tb / tc) * vp / Math.sqr(1 + vp)
								state.j(i, 3) = 1 - 1 / (1 + vp)
								state.j(i, 4) = 0
							Else
								vp0 = System.Math.Pow(x(i) / tc, tb)
								vp1 = System.Math.Pow(1 + vp0, tg)
								state.fi(i) = td + (ta - td) / vp1 - y(i)
								state.j(i, 0) = 1 / vp1
								state.j(i, 1) = (ta - td) * -tg * System.Math.Pow(1 + vp0, -tg - 1) * vp0 * System.Math.Log(x(i) / tc)
								state.j(i, 2) = (ta - td) * -tg * System.Math.Pow(1 + vp0, -tg - 1) * vp0 * -(tb / tc)
								state.j(i, 3) = 1 - 1 / vp1
								state.j(i, 4) = -((ta - td) / vp1 * System.Math.Log(1 + vp0))
							End If
						Else
							If CDbl(tb) >= CDbl(0) Then
								state.fi(i) = ta - y(i)
								state.j(i, 0) = 1
								state.j(i, 1) = 0
								state.j(i, 2) = 0
								state.j(i, 3) = 0
								state.j(i, 4) = 0
							Else
								state.fi(i) = td - y(i)
								state.j(i, 0) = 0
								state.j(i, 1) = 0
								state.j(i, 2) = 0
								state.j(i, 3) = 1
								state.j(i, 4) = 0
							End If
						End If
					Next
					For i = 0 To 4
						For j = 0 To 4
							state.j(n + i, j) = 0.0
						Next
					Next
					For i = 0 To 4
						state.fi(n + i) = lambdav * state.x(i)
						state.j(n + i, i) = lambdav
					Next
					Continue While
				End If
				alglib.ap.assert(False, "LogisticFitX: internal error")
			End While
			minlm.minlmresultsbuf(state, p1, replm)
			alglib.ap.assert(replm.terminationtype > 0, "LogisticFitX: internal error")
		End Sub


		'************************************************************************
'        Internal spline fitting subroutine
'
'          -- ALGLIB PROJECT --
'             Copyright 08.09.2009 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub spline1dfitinternal(st As Integer, x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), _
			yc As Double(), dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, s As spline1d.spline1dinterpolant, _
			rep As spline1dfitreport)
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim cmatrix As Double(,) = New Double(-1, -1) {}
			Dim y2 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim sx As Double() = New Double(-1) {}
			Dim sy As Double() = New Double(-1) {}
			Dim sd As Double() = New Double(-1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim xoriginal As Double() = New Double(-1) {}
			Dim yoriginal As Double() = New Double(-1) {}
			Dim lrep As New lsfitreport()
			Dim v0 As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0
			Dim mx As Double = 0
			Dim s2 As New spline1d.spline1dinterpolant()
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim relcnt As Integer = 0
			Dim xa As Double = 0
			Dim xb As Double = 0
			Dim sa As Double = 0
			Dim sb As Double = 0
			Dim bl As Double = 0
			Dim br As Double = 0
			Dim decay As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			w = DirectCast(w.Clone(), Double())
			xc = DirectCast(xc.Clone(), Double())
			yc = DirectCast(yc.Clone(), Double())
			info = 0

			alglib.ap.assert(st = 0 OrElse st = 1, "Spline1DFit: internal error!")
			If st = 0 AndAlso m < 4 Then
				info = -1
				Return
			End If
			If st = 1 AndAlso m < 4 Then
				info = -1
				Return
			End If
			If (n < 1 OrElse k < 0) OrElse k >= m Then
				info = -1
				Return
			End If
			For i = 0 To k - 1
				info = 0
				If dc(i) < 0 Then
					info = -1
				End If
				If dc(i) > 1 Then
					info = -1
				End If
				If info < 0 Then
					Return
				End If
			Next
			If st = 1 AndAlso m Mod 2 <> 0 Then

				'
				' Hermite fitter must have even number of basis functions
				'
				info = -2
				Return
			End If

			'
			' weight decay for correct handling of task which becomes
			' degenerate after constraints are applied
			'
			decay = 10000 * Math.machineepsilon

			'
			' Scale X, Y, XC, YC
			'
			lsfitscalexy(x, y, w, n, xc, yc, _
				dc, k, xa, xb, sa, sb, _
				xoriginal, yoriginal)

			'
			' allocate space, initialize:
			' * SX     -   grid for basis functions
			' * SY     -   values of basis functions at grid points
			' * FMatrix-   values of basis functions at X[]
			' * CMatrix-   values (derivatives) of basis functions at XC[]
			'
			y2 = New Double(n + (m - 1)) {}
			w2 = New Double(n + (m - 1)) {}
			fmatrix = New Double(n + (m - 1), m - 1) {}
			If k > 0 Then
				cmatrix = New Double(k - 1, m) {}
			End If
			If st = 0 Then

				'
				' allocate space for cubic spline
				'
				sx = New Double(m - 3) {}
				sy = New Double(m - 3) {}
				For j = 0 To m - 2 - 1
					sx(j) = CDbl(2 * j) / CDbl(m - 2 - 1) - 1
				Next
			End If
			If st = 1 Then

				'
				' allocate space for Hermite spline
				'
				sx = New Double(m \ 2 - 1) {}
				sy = New Double(m \ 2 - 1) {}
				sd = New Double(m \ 2 - 1) {}
				For j = 0 To m \ 2 - 1
					sx(j) = CDbl(2 * j) / CDbl(m \ 2 - 1) - 1
				Next
			End If

			'
			' Prepare design and constraints matrices:
			' * fill constraints matrix
			' * fill first N rows of design matrix with values
			' * fill next M rows of design matrix with regularizing term
			' * append M zeros to Y
			' * append M elements, mean(abs(W)) each, to W
			'
			For j = 0 To m - 1

				'
				' prepare Jth basis function
				'
				If st = 0 Then

					'
					' cubic spline basis
					'
					For i = 0 To m - 2 - 1
						sy(i) = 0
					Next
					bl = 0
					br = 0
					If j < m - 2 Then
						sy(j) = 1
					End If
					If j = m - 2 Then
						bl = 1
					End If
					If j = m - 1 Then
						br = 1
					End If
					spline1d.spline1dbuildcubic(sx, sy, m - 2, 1, bl, 1, _
						br, s2)
				End If
				If st = 1 Then

					'
					' Hermite basis
					'
					For i = 0 To m \ 2 - 1
						sy(i) = 0
						sd(i) = 0
					Next
					If j Mod 2 = 0 Then
						sy(j \ 2) = 1
					Else
						sd(j \ 2) = 1
					End If
					spline1d.spline1dbuildhermite(sx, sy, sd, m \ 2, s2)
				End If

				'
				' values at X[], XC[]
				'
				For i = 0 To n - 1
					fmatrix(i, j) = spline1d.spline1dcalc(s2, x(i))
				Next
				For i = 0 To k - 1
					alglib.ap.assert(dc(i) >= 0 AndAlso dc(i) <= 2, "Spline1DFit: internal error!")
					spline1d.spline1ddiff(s2, xc(i), v0, v1, v2)
					If dc(i) = 0 Then
						cmatrix(i, j) = v0
					End If
					If dc(i) = 1 Then
						cmatrix(i, j) = v1
					End If
					If dc(i) = 2 Then
						cmatrix(i, j) = v2
					End If
				Next
			Next
			For i = 0 To k - 1
				cmatrix(i, m) = yc(i)
			Next
			For i = 0 To m - 1
				For j = 0 To m - 1
					If i = j Then
						fmatrix(n + i, j) = decay
					Else
						fmatrix(n + i, j) = 0
					End If
				Next
			Next
			y2 = New Double(n + (m - 1)) {}
			w2 = New Double(n + (m - 1)) {}
			For i_ = 0 To n - 1
				y2(i_) = y(i_)
			Next
			For i_ = 0 To n - 1
				w2(i_) = w(i_)
			Next
			mx = 0
			For i = 0 To n - 1
				mx = mx + System.Math.Abs(w(i))
			Next
			mx = mx / n
			For i = 0 To m - 1
				y2(n + i) = 0
				w2(n + i) = mx
			Next

			'
			' Solve constrained task
			'
			If k > 0 Then

				'
				' solve using regularization
				'
				lsfitlinearwc(y2, w2, fmatrix, cmatrix, n + m, m, _
					k, info, tmp, lrep)
			Else

				'
				' no constraints, no regularization needed
				'
				lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
					k, info, tmp, lrep)
			End If
			If info < 0 Then
				Return
			End If

			'
			' Generate spline and scale it
			'
			If st = 0 Then

				'
				' cubic spline basis
				'
				For i_ = 0 To m - 2 - 1
					sy(i_) = tmp(i_)
				Next
				spline1d.spline1dbuildcubic(sx, sy, m - 2, 1, tmp(m - 2), 1, _
					tmp(m - 1), s)
			End If
			If st = 1 Then

				'
				' Hermite basis
				'
				For i = 0 To m \ 2 - 1
					sy(i) = tmp(2 * i)
					sd(i) = tmp(2 * i + 1)
				Next
				spline1d.spline1dbuildhermite(sx, sy, sd, m \ 2, s)
			End If
			spline1d.spline1dlintransx(s, 2 / (xb - xa), -((xa + xb) / (xb - xa)))
			spline1d.spline1dlintransy(s, sb - sa, sa)

			'
			' Scale absolute errors obtained from LSFitLinearW.
			' Relative error should be calculated separately
			' (because of shifting/scaling of the task)
			'
			rep.taskrcond = lrep.taskrcond
			rep.rmserror = lrep.rmserror * (sb - sa)
			rep.avgerror = lrep.avgerror * (sb - sa)
			rep.maxerror = lrep.maxerror * (sb - sa)
			rep.avgrelerror = 0
			relcnt = 0
			For i = 0 To n - 1
				If CDbl(yoriginal(i)) <> CDbl(0) Then
					rep.avgrelerror = rep.avgrelerror + System.Math.Abs(spline1d.spline1dcalc(s, xoriginal(i)) - yoriginal(i)) / System.Math.Abs(yoriginal(i))
					relcnt = relcnt + 1
				End If
			Next
			If relcnt <> 0 Then
				rep.avgrelerror = rep.avgrelerror / relcnt
			End If
		End Sub


		'************************************************************************
'        Internal fitting subroutine
'        ************************************************************************

		Private Shared Sub lsfitlinearinternal(y As Double(), w As Double(), fmatrix As Double(,), n As Integer, m As Integer, ByRef info As Integer, _
			ByRef c As Double(), rep As lsfitreport)
			Dim threshold As Double = 0
			Dim ft As Double(,) = New Double(-1, -1) {}
			Dim q As Double(,) = New Double(-1, -1) {}
			Dim l As Double(,) = New Double(-1, -1) {}
			Dim r As Double(,) = New Double(-1, -1) {}
			Dim b As Double() = New Double(-1) {}
			Dim wmod As Double() = New Double(-1) {}
			Dim tau As Double() = New Double(-1) {}
			Dim nzeros As Double() = New Double(-1) {}
			Dim s As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim sv As Double() = New Double(-1) {}
			Dim u As Double(,) = New Double(-1, -1) {}
			Dim vt As Double(,) = New Double(-1, -1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim utb As Double() = New Double(-1) {}
			Dim sutb As Double() = New Double(-1) {}
			Dim relcnt As Integer = 0
			Dim i_ As Integer = 0

			info = 0
			c = New Double(-1) {}

			clearreport(rep)
			If n < 1 OrElse m < 1 Then
				info = -1
				Return
			End If
			info = 1
			threshold = System.Math.sqrt(Math.machineepsilon)

			'
			' Degenerate case, needs special handling
			'
			If n < m Then

				'
				' Create design matrix.
				'
				ft = New Double(n - 1, m - 1) {}
				b = New Double(n - 1) {}
				wmod = New Double(n - 1) {}
				For j = 0 To n - 1
					v = w(j)
					For i_ = 0 To m - 1
						ft(j, i_) = v * fmatrix(j, i_)
					Next
					b(j) = w(j) * y(j)
					wmod(j) = 1
				Next

				'
				' LQ decomposition and reduction to M=N
				'
				c = New Double(m - 1) {}
				For i = 0 To m - 1
					c(i) = 0
				Next
				rep.taskrcond = 0
				ortfac.rmatrixlq(ft, n, m, tau)
				ortfac.rmatrixlqunpackq(ft, n, m, tau, n, q)
				ortfac.rmatrixlqunpackl(ft, n, m, l)
				lsfitlinearinternal(b, wmod, l, n, n, info, _
					tmp, rep)
				If info <= 0 Then
					Return
				End If
				For i = 0 To n - 1
					v = tmp(i)
					For i_ = 0 To m - 1
						c(i_) = c(i_) + v * q(i, i_)
					Next
				Next
				Return
			End If

			'
			' N>=M. Generate design matrix and reduce to N=M using
			' QR decomposition.
			'
			ft = New Double(n - 1, m - 1) {}
			b = New Double(n - 1) {}
			For j = 0 To n - 1
				v = w(j)
				For i_ = 0 To m - 1
					ft(j, i_) = v * fmatrix(j, i_)
				Next
				b(j) = w(j) * y(j)
			Next
			ortfac.rmatrixqr(ft, n, m, tau)
			ortfac.rmatrixqrunpackq(ft, n, m, tau, m, q)
			ortfac.rmatrixqrunpackr(ft, n, m, r)
			tmp = New Double(m - 1) {}
			For i = 0 To m - 1
				tmp(i) = 0
			Next
			For i = 0 To n - 1
				v = b(i)
				For i_ = 0 To m - 1
					tmp(i_) = tmp(i_) + v * q(i, i_)
				Next
			Next
			b = New Double(m - 1) {}
			For i_ = 0 To m - 1
				b(i_) = tmp(i_)
			Next

			'
			' R contains reduced MxM design upper triangular matrix,
			' B contains reduced Mx1 right part.
			'
			' Determine system condition number and decide
			' should we use triangular solver (faster) or
			' SVD-based solver (more stable).
			'
			' We can use LU-based RCond estimator for this task.
			'
			rep.taskrcond = rcond.rmatrixlurcondinf(r, m)
			If CDbl(rep.taskrcond) > CDbl(threshold) Then

				'
				' use QR-based solver
				'
				c = New Double(m - 1) {}
				c(m - 1) = b(m - 1) / r(m - 1, m - 1)
				For i = m - 2 To 0 Step -1
					v = 0.0
					For i_ = i + 1 To m - 1
						v += r(i, i_) * c(i_)
					Next
					c(i) = (b(i) - v) / r(i, i)
				Next
			Else

				'
				' use SVD-based solver
				'
				If Not svd.rmatrixsvd(r, m, m, 1, 1, 2, _
					sv, u, vt) Then
					info = -4
					Return
				End If
				utb = New Double(m - 1) {}
				sutb = New Double(m - 1) {}
				For i = 0 To m - 1
					utb(i) = 0
				Next
				For i = 0 To m - 1
					v = b(i)
					For i_ = 0 To m - 1
						utb(i_) = utb(i_) + v * u(i, i_)
					Next
				Next
				If CDbl(sv(0)) > CDbl(0) Then
					rep.taskrcond = sv(m - 1) / sv(0)
					For i = 0 To m - 1
						If CDbl(sv(i)) > CDbl(threshold * sv(0)) Then
							sutb(i) = utb(i) / sv(i)
						Else
							sutb(i) = 0
						End If
					Next
				Else
					rep.taskrcond = 0
					For i = 0 To m - 1
						sutb(i) = 0
					Next
				End If
				c = New Double(m - 1) {}
				For i = 0 To m - 1
					c(i) = 0
				Next
				For i = 0 To m - 1
					v = sutb(i)
					For i_ = 0 To m - 1
						c(i_) = c(i_) + v * vt(i, i_)
					Next
				Next
			End If

			'
			' calculate errors
			'
			rep.rmserror = 0
			rep.avgerror = 0
			rep.avgrelerror = 0
			rep.maxerror = 0
			relcnt = 0
			For i = 0 To n - 1
				v = 0.0
				For i_ = 0 To m - 1
					v += fmatrix(i, i_) * c(i_)
				Next
				rep.rmserror = rep.rmserror + Math.sqr(v - y(i))
				rep.avgerror = rep.avgerror + System.Math.Abs(v - y(i))
				If CDbl(y(i)) <> CDbl(0) Then
					rep.avgrelerror = rep.avgrelerror + System.Math.Abs(v - y(i)) / System.Math.Abs(y(i))
					relcnt = relcnt + 1
				End If
				rep.maxerror = System.Math.Max(rep.maxerror, System.Math.Abs(v - y(i)))
			Next
			rep.rmserror = System.Math.sqrt(rep.rmserror / n)
			rep.avgerror = rep.avgerror / n
			If relcnt <> 0 Then
				rep.avgrelerror = rep.avgrelerror / relcnt
			End If
			nzeros = New Double(n - 1) {}
			s = New Double(m - 1) {}
			For i = 0 To m - 1
				s(i) = 0
			Next
			For i = 0 To n - 1
				For j = 0 To m - 1
					s(j) = s(j) + Math.sqr(fmatrix(i, j))
				Next
				nzeros(i) = 0
			Next
			For i = 0 To m - 1
				If CDbl(s(i)) <> CDbl(0) Then
					s(i) = System.Math.sqrt(1 / s(i))
				Else
					s(i) = 1
				End If
			Next
			estimateerrors(fmatrix, nzeros, y, w, c, s, _
				n, m, rep, r, 1)
		End Sub


		'************************************************************************
'        Internal subroutine
'        ************************************************************************

		Private Shared Sub lsfitclearrequestfields(state As lsfitstate)
			state.needf = False
			state.needfg = False
			state.needfgh = False
			state.xupdated = False
		End Sub


		'************************************************************************
'        Internal subroutine, calculates barycentric basis functions.
'        Used for efficient simultaneous calculation of N basis functions.
'
'          -- ALGLIB --
'             Copyright 17.08.2009 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub barycentriccalcbasis(b As ratint.barycentricinterpolant, t As Double, ByRef y As Double())
			Dim s2 As Double = 0
			Dim s As Double = 0
			Dim v As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim i_ As Integer = 0


			'
			' special case: N=1
			'
			If b.n = 1 Then
				y(0) = 1
				Return
			End If

			'
			' Here we assume that task is normalized, i.e.:
			' 1. abs(Y[i])<=1
			' 2. abs(W[i])<=1
			' 3. X[] is ordered
			'
			' First, we decide: should we use "safe" formula (guarded
			' against overflow) or fast one?
			'
			s = System.Math.Abs(t - b.x(0))
			For i = 0 To b.n - 1
				v = b.x(i)
				If CDbl(v) = CDbl(t) Then
					For j = 0 To b.n - 1
						y(j) = 0
					Next
					y(i) = 1
					Return
				End If
				v = System.Math.Abs(t - v)
				If CDbl(v) < CDbl(s) Then
					s = v
				End If
			Next
			s2 = 0
			For i = 0 To b.n - 1
				v = s / (t - b.x(i))
				v = v * b.w(i)
				y(i) = v
				s2 = s2 + v
			Next
			v = 1 / s2
			For i_ = 0 To b.n - 1
				y(i_) = v * y(i_)
			Next
		End Sub


		'************************************************************************
'        This is internal function for Chebyshev fitting.
'
'        It assumes that input data are normalized:
'        * X/XC belong to [-1,+1],
'        * mean(Y)=0, stddev(Y)=1.
'
'        It does not checks inputs for errors.
'
'        This function is used to fit general (shifted) Chebyshev models, power
'        basis models or barycentric models.
'
'        INPUT PARAMETERS:
'            X   -   points, array[0..N-1].
'            Y   -   function values, array[0..N-1].
'            W   -   weights, array[0..N-1]
'            N   -   number of points, N>0.
'            XC  -   points where polynomial values/derivatives are constrained,
'                    array[0..K-1].
'            YC  -   values of constraints, array[0..K-1]
'            DC  -   array[0..K-1], types of constraints:
'                    * DC[i]=0   means that P(XC[i])=YC[i]
'                    * DC[i]=1   means that P'(XC[i])=YC[i]
'            K   -   number of constraints, 0<=K<M.
'                    K=0 means no constraints (XC/YC/DC are not used in such cases)
'            M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'        OUTPUT PARAMETERS:
'            Info-   same format as in LSFitLinearW() subroutine:
'                    * Info>0    task is solved
'                    * Info<=0   an error occured:
'                                -4 means inconvergence of internal SVD
'                                -3 means inconsistent constraints
'            C   -   interpolant in Chebyshev form; [-1,+1] is used as base interval
'            Rep -   report, same format as in LSFitLinearW() subroutine.
'                    Following fields are set:
'                    * RMSError      rms error on the (X,Y).
'                    * AvgError      average error on the (X,Y).
'                    * AvgRelError   average relative error on the non-zero Y
'                    * MaxError      maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'        IMPORTANT:
'            this subroitine doesn't calculate task's condition number for K<>0.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub internalchebyshevfit(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, ByRef info As Integer, ByRef c As Double(), rep As lsfitreport)
			Dim y2 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim tmp2 As Double() = New Double(-1) {}
			Dim tmpdiff As Double() = New Double(-1) {}
			Dim bx As Double() = New Double(-1) {}
			Dim by As Double() = New Double(-1) {}
			Dim bw As Double() = New Double(-1) {}
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim cmatrix As Double(,) = New Double(-1, -1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim mx As Double = 0
			Dim decay As Double = 0
			Dim i_ As Integer = 0

			xc = DirectCast(xc.Clone(), Double())
			yc = DirectCast(yc.Clone(), Double())
			info = 0
			c = New Double(-1) {}

			clearreport(rep)

			'
			' weight decay for correct handling of task which becomes
			' degenerate after constraints are applied
			'
			decay = 10000 * Math.machineepsilon

			'
			' allocate space, initialize/fill:
			' * FMatrix-   values of basis functions at X[]
			' * CMatrix-   values (derivatives) of basis functions at XC[]
			' * fill constraints matrix
			' * fill first N rows of design matrix with values
			' * fill next M rows of design matrix with regularizing term
			' * append M zeros to Y
			' * append M elements, mean(abs(W)) each, to W
			'
			y2 = New Double(n + (m - 1)) {}
			w2 = New Double(n + (m - 1)) {}
			tmp = New Double(m - 1) {}
			tmpdiff = New Double(m - 1) {}
			fmatrix = New Double(n + (m - 1), m - 1) {}
			If k > 0 Then
				cmatrix = New Double(k - 1, m) {}
			End If

			'
			' Fill design matrix, Y2, W2:
			' * first N rows with basis functions for original points
			' * next M rows with decay terms
			'
			For i = 0 To n - 1

				'
				' prepare Ith row
				' use Tmp for calculations to avoid multidimensional arrays overhead
				'
				For j = 0 To m - 1
					If j = 0 Then
						tmp(j) = 1
					Else
						If j = 1 Then
							tmp(j) = x(i)
						Else
							tmp(j) = 2 * x(i) * tmp(j - 1) - tmp(j - 2)
						End If
					End If
				Next
				For i_ = 0 To m - 1
					fmatrix(i, i_) = tmp(i_)
				Next
			Next
			For i = 0 To m - 1
				For j = 0 To m - 1
					If i = j Then
						fmatrix(n + i, j) = decay
					Else
						fmatrix(n + i, j) = 0
					End If
				Next
			Next
			For i_ = 0 To n - 1
				y2(i_) = y(i_)
			Next
			For i_ = 0 To n - 1
				w2(i_) = w(i_)
			Next
			mx = 0
			For i = 0 To n - 1
				mx = mx + System.Math.Abs(w(i))
			Next
			mx = mx / n
			For i = 0 To m - 1
				y2(n + i) = 0
				w2(n + i) = mx
			Next

			'
			' fill constraints matrix
			'
			For i = 0 To k - 1

				'
				' prepare Ith row
				' use Tmp for basis function values,
				' TmpDiff for basos function derivatives
				'
				For j = 0 To m - 1
					If j = 0 Then
						tmp(j) = 1
						tmpdiff(j) = 0
					Else
						If j = 1 Then
							tmp(j) = xc(i)
							tmpdiff(j) = 1
						Else
							tmp(j) = 2 * xc(i) * tmp(j - 1) - tmp(j - 2)
							tmpdiff(j) = 2 * (tmp(j - 1) + xc(i) * tmpdiff(j - 1)) - tmpdiff(j - 2)
						End If
					End If
				Next
				If dc(i) = 0 Then
					For i_ = 0 To m - 1
						cmatrix(i, i_) = tmp(i_)
					Next
				End If
				If dc(i) = 1 Then
					For i_ = 0 To m - 1
						cmatrix(i, i_) = tmpdiff(i_)
					Next
				End If
				cmatrix(i, m) = yc(i)
			Next

			'
			' Solve constrained task
			'
			If k > 0 Then

				'
				' solve using regularization
				'
				lsfitlinearwc(y2, w2, fmatrix, cmatrix, n + m, m, _
					k, info, c, rep)
			Else

				'
				' no constraints, no regularization needed
				'
				lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
					0, info, c, rep)
			End If
			If info < 0 Then
				Return
			End If
		End Sub


		'************************************************************************
'        Internal Floater-Hormann fitting subroutine for fixed D
'        ************************************************************************

		Private Shared Sub barycentricfitwcfixedd(x As Double(), y As Double(), w As Double(), n As Integer, xc As Double(), yc As Double(), _
			dc As Integer(), k As Integer, m As Integer, d As Integer, ByRef info As Integer, b As ratint.barycentricinterpolant, _
			rep As barycentricfitreport)
			Dim fmatrix As Double(,) = New Double(-1, -1) {}
			Dim cmatrix As Double(,) = New Double(-1, -1) {}
			Dim y2 As Double() = New Double(-1) {}
			Dim w2 As Double() = New Double(-1) {}
			Dim sx As Double() = New Double(-1) {}
			Dim sy As Double() = New Double(-1) {}
			Dim sbf As Double() = New Double(-1) {}
			Dim xoriginal As Double() = New Double(-1) {}
			Dim yoriginal As Double() = New Double(-1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim lrep As New lsfitreport()
			Dim v0 As Double = 0
			Dim v1 As Double = 0
			Dim mx As Double = 0
			Dim b2 As New ratint.barycentricinterpolant()
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim relcnt As Integer = 0
			Dim xa As Double = 0
			Dim xb As Double = 0
			Dim sa As Double = 0
			Dim sb As Double = 0
			Dim decay As Double = 0
			Dim i_ As Integer = 0

			x = DirectCast(x.Clone(), Double())
			y = DirectCast(y.Clone(), Double())
			w = DirectCast(w.Clone(), Double())
			xc = DirectCast(xc.Clone(), Double())
			yc = DirectCast(yc.Clone(), Double())
			info = 0

			If ((n < 1 OrElse m < 2) OrElse k < 0) OrElse k >= m Then
				info = -1
				Return
			End If
			For i = 0 To k - 1
				info = 0
				If dc(i) < 0 Then
					info = -1
				End If
				If dc(i) > 1 Then
					info = -1
				End If
				If info < 0 Then
					Return
				End If
			Next

			'
			' weight decay for correct handling of task which becomes
			' degenerate after constraints are applied
			'
			decay = 10000 * Math.machineepsilon

			'
			' Scale X, Y, XC, YC
			'
			lsfitscalexy(x, y, w, n, xc, yc, _
				dc, k, xa, xb, sa, sb, _
				xoriginal, yoriginal)

			'
			' allocate space, initialize:
			' * FMatrix-   values of basis functions at X[]
			' * CMatrix-   values (derivatives) of basis functions at XC[]
			'
			y2 = New Double(n + (m - 1)) {}
			w2 = New Double(n + (m - 1)) {}
			fmatrix = New Double(n + (m - 1), m - 1) {}
			If k > 0 Then
				cmatrix = New Double(k - 1, m) {}
			End If
			y2 = New Double(n + (m - 1)) {}
			w2 = New Double(n + (m - 1)) {}

			'
			' Prepare design and constraints matrices:
			' * fill constraints matrix
			' * fill first N rows of design matrix with values
			' * fill next M rows of design matrix with regularizing term
			' * append M zeros to Y
			' * append M elements, mean(abs(W)) each, to W
			'
			sx = New Double(m - 1) {}
			sy = New Double(m - 1) {}
			sbf = New Double(m - 1) {}
			For j = 0 To m - 1
				sx(j) = CDbl(2 * j) / CDbl(m - 1) - 1
			Next
			For i = 0 To m - 1
				sy(i) = 1
			Next
			ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b2)
			mx = 0
			For i = 0 To n - 1
				barycentriccalcbasis(b2, x(i), sbf)
				For i_ = 0 To m - 1
					fmatrix(i, i_) = sbf(i_)
				Next
				y2(i) = y(i)
				w2(i) = w(i)
				mx = mx + System.Math.Abs(w(i)) / n
			Next
			For i = 0 To m - 1
				For j = 0 To m - 1
					If i = j Then
						fmatrix(n + i, j) = decay
					Else
						fmatrix(n + i, j) = 0
					End If
				Next
				y2(n + i) = 0
				w2(n + i) = mx
			Next
			If k > 0 Then
				For j = 0 To m - 1
					For i = 0 To m - 1
						sy(i) = 0
					Next
					sy(j) = 1
					ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b2)
					For i = 0 To k - 1
						alglib.ap.assert(dc(i) >= 0 AndAlso dc(i) <= 1, "BarycentricFit: internal error!")
						ratint.barycentricdiff1(b2, xc(i), v0, v1)
						If dc(i) = 0 Then
							cmatrix(i, j) = v0
						End If
						If dc(i) = 1 Then
							cmatrix(i, j) = v1
						End If
					Next
				Next
				For i = 0 To k - 1
					cmatrix(i, m) = yc(i)
				Next
			End If

			'
			' Solve constrained task
			'
			If k > 0 Then

				'
				' solve using regularization
				'
				lsfitlinearwc(y2, w2, fmatrix, cmatrix, n + m, m, _
					k, info, tmp, lrep)
			Else

				'
				' no constraints, no regularization needed
				'
				lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, _
					k, info, tmp, lrep)
			End If
			If info < 0 Then
				Return
			End If

			'
			' Generate interpolant and scale it
			'
			For i_ = 0 To m - 1
				sy(i_) = tmp(i_)
			Next
			ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b)
			ratint.barycentriclintransx(b, 2 / (xb - xa), -((xa + xb) / (xb - xa)))
			ratint.barycentriclintransy(b, sb - sa, sa)

			'
			' Scale absolute errors obtained from LSFitLinearW.
			' Relative error should be calculated separately
			' (because of shifting/scaling of the task)
			'
			rep.taskrcond = lrep.taskrcond
			rep.rmserror = lrep.rmserror * (sb - sa)
			rep.avgerror = lrep.avgerror * (sb - sa)
			rep.maxerror = lrep.maxerror * (sb - sa)
			rep.avgrelerror = 0
			relcnt = 0
			For i = 0 To n - 1
				If CDbl(yoriginal(i)) <> CDbl(0) Then
					rep.avgrelerror = rep.avgrelerror + System.Math.Abs(ratint.barycentriccalc(b, xoriginal(i)) - yoriginal(i)) / System.Math.Abs(yoriginal(i))
					relcnt = relcnt + 1
				End If
			Next
			If relcnt <> 0 Then
				rep.avgrelerror = rep.avgrelerror / relcnt
			End If
		End Sub


		Private Shared Sub clearreport(rep As lsfitreport)
			rep.taskrcond = 0
			rep.iterationscount = 0
			rep.varidx = -1
			rep.rmserror = 0
			rep.avgerror = 0
			rep.avgrelerror = 0
			rep.maxerror = 0
			rep.wrmserror = 0
			rep.r2 = 0
			rep.covpar = New Double(-1, -1) {}
			rep.errpar = New Double(-1) {}
			rep.errcurve = New Double(-1) {}
			rep.noise = New Double(-1) {}
		End Sub


		'************************************************************************
'        This internal function estimates covariance matrix and other error-related
'        information for linear/nonlinear least squares model.
'
'        It has a bit awkward interface, but it can be used  for  both  linear  and
'        nonlinear problems.
'
'        INPUT PARAMETERS:
'            F1  -   array[0..N-1,0..K-1]:
'                    * for linear problems - matrix of function values
'                    * for nonlinear problems - Jacobian matrix
'            F0  -   array[0..N-1]:
'                    * for linear problems - must be filled with zeros
'                    * for nonlinear problems - must store values of function being
'                      fitted
'            Y   -   array[0..N-1]:
'                    * for linear and nonlinear problems - must store target values
'            W   -   weights, array[0..N-1]:
'                    * for linear and nonlinear problems - weights
'            X   -   array[0..K-1]:
'                    * for linear and nonlinear problems - current solution
'            S   -   array[0..K-1]:
'                    * its components should be strictly positive
'                    * squared inverse of this diagonal matrix is used as damping
'                      factor for covariance matrix (linear and nonlinear problems)
'                    * for nonlinear problems, when scale of the variables is usually
'                      explicitly given by user, you may use scale vector for this
'                      parameter
'                    * for linear problems you may set this parameter to
'                      S=sqrt(1/diag(F'*F))
'                    * this parameter is automatically rescaled by this function,
'                      only relative magnitudes of its components (with respect to
'                      each other) matter.
'            N   -   number of points, N>0.
'            K   -   number of dimensions
'            Rep -   structure which is used to store results
'            Z   -   additional matrix which, depending on ZKind, may contain some
'                    information used to accelerate calculations - or just can be
'                    temporary buffer:
'                    * for ZKind=0       Z contains no information, just temporary
'                                        buffer which can be resized and used as needed
'                    * for ZKind=1       Z contains triangular matrix from QR
'                                        decomposition of W*F1. This matrix can be used
'                                        to speedup calculation of covariance matrix.
'                                        It should not be changed by algorithm.
'            ZKind-  contents of Z
'
'        OUTPUT PARAMETERS:
'
'        * Rep.CovPar        covariance matrix for parameters, array[K,K].
'        * Rep.ErrPar        errors in parameters, array[K],
'                            errpar = sqrt(diag(CovPar))
'        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
'                            best-fit curve from "ideal" best-fit curve built  with
'                            infinite number of samples, array[N].
'                            errcurve = sqrt(diag(J*CovPar*J')),
'                            where J is Jacobian matrix.
'        * Rep.Noise         vector of per-point estimates of noise, array[N]
'        * Rep.R2            coefficient of determination (non-weighted)
'
'        Other fields of Rep are not changed.
'
'        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
'                    account boundary/linear constraints! Presence  of  constraints
'                    changes distribution of errors, but there is no  easy  way  to
'                    account for constraints when you calculate covariance matrix.
'                    
'        NOTE:       noise in the data is estimated as follows:
'                    * for fitting without user-supplied  weights  all  points  are
'                      assumed to have same level of noise, which is estimated from
'                      the data
'                    * for fitting with user-supplied weights we assume that  noise
'                      level in I-th point is inversely proportional to Ith weight.
'                      Coefficient of proportionality is estimated from the data.
'                    
'        NOTE:       we apply small amount of regularization when we invert squared
'                    Jacobian and calculate covariance matrix. It  guarantees  that
'                    algorithm won't divide by zero  during  inversion,  but  skews
'                    error estimates a bit (fractional error is about 10^-9).
'                    
'                    However, we believe that this difference is insignificant  for
'                    all practical purposes except for the situation when you  want
'                    to compare ALGLIB results with "reference"  implementation  up
'                    to the last significant digit.
'
'          -- ALGLIB PROJECT --
'             Copyright 10.12.2009 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub estimateerrors(f1 As Double(,), f0 As Double(), y As Double(), w As Double(), x As Double(), s As Double(), _
			n As Integer, k As Integer, rep As lsfitreport, ByRef z As Double(,), zkind As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim j1 As Integer = 0
			Dim v As Double = 0
			Dim noisec As Double = 0
			Dim info As Integer = 0
			Dim invrep As New matinv.matinvreport()
			Dim nzcnt As Integer = 0
			Dim avg As Double = 0
			Dim rss As Double = 0
			Dim tss As Double = 0
			Dim sz As Double = 0
			Dim ss As Double = 0
			Dim i_ As Integer = 0

			s = DirectCast(s.Clone(), Double())


			'
			' Compute NZCnt - count of non-zero weights
			'
			nzcnt = 0
			For i = 0 To n - 1
				If CDbl(w(i)) <> CDbl(0) Then
					nzcnt = nzcnt + 1
				End If
			Next

			'
			' Compute R2
			'
			If nzcnt > 0 Then
				avg = 0.0
				For i = 0 To n - 1
					If CDbl(w(i)) <> CDbl(0) Then
						avg = avg + y(i)
					End If
				Next
				avg = avg / nzcnt
				rss = 0.0
				tss = 0.0
				For i = 0 To n - 1
					If CDbl(w(i)) <> CDbl(0) Then
						v = 0.0
						For i_ = 0 To k - 1
							v += f1(i, i_) * x(i_)
						Next
						v = v + f0(i)
						rss = rss + Math.sqr(v - y(i))
						tss = tss + Math.sqr(y(i) - avg)
					End If
				Next
				If CDbl(tss) <> CDbl(0) Then
					rep.r2 = System.Math.Max(1.0 - rss / tss, 0.0)
				Else
					rep.r2 = 1.0
				End If
			Else
				rep.r2 = 0
			End If

			'
			' Compute estimate of proportionality between noise in the data and weights:
			'     NoiseC = mean(per-point-noise*per-point-weight)
			' Noise level (standard deviation) at each point is equal to NoiseC/W[I].
			'
			If nzcnt > k Then
				noisec = 0.0
				For i = 0 To n - 1
					If CDbl(w(i)) <> CDbl(0) Then
						v = 0.0
						For i_ = 0 To k - 1
							v += f1(i, i_) * x(i_)
						Next
						v = v + f0(i)
						noisec = noisec + Math.sqr((v - y(i)) * w(i))
					End If
				Next
				noisec = System.Math.sqrt(noisec / (nzcnt - k))
			Else
				noisec = 0.0
			End If

			'
			' Two branches on noise level:
			' * NoiseC>0   normal situation
			' * NoiseC=0   degenerate case CovPar is filled by zeros
			'
			apserv.rmatrixsetlengthatleast(rep.covpar, k, k)
			If CDbl(noisec) > CDbl(0) Then

				'
				' Normal situation: non-zero noise level
				'
				alglib.ap.assert(zkind = 0 OrElse zkind = 1, "LSFit: internal error in EstimateErrors() function")
				If zkind = 0 Then

					'
					' Z contains no additional information which can be used to speed up
					' calculations. We have to calculate covariance matrix on our own:
					' * Compute scaled Jacobian N*J, where N[i,i]=WCur[I]/NoiseC, store in Z
					' * Compute Z'*Z, store in CovPar
					' * Apply moderate regularization to CovPar and compute matrix inverse.
					'   In case inverse failed, increase regularization parameter and try
					'   again.
					'
					apserv.rmatrixsetlengthatleast(z, n, k)
					For i = 0 To n - 1
						v = w(i) / noisec
						For i_ = 0 To k - 1
							z(i, i_) = v * f1(i, i_)
						Next
					Next

					'
					' Convert S to automatically scaled damped matrix:
					' * calculate SZ - sum of diagonal elements of Z'*Z
					' * calculate SS - sum of diagonal elements of S^(-2)
					' * overwrite S by (SZ/SS)*S^(-2)
					' * now S has approximately same magnitude as giagonal of Z'*Z
					'
					sz = 0
					For i = 0 To n - 1
						For j = 0 To k - 1
							sz = sz + z(i, j) * z(i, j)
						Next
					Next
					If CDbl(sz) = CDbl(0) Then
						sz = 1
					End If
					ss = 0
					For j = 0 To k - 1
						ss = ss + 1 / Math.sqr(s(j))
					Next
					For j = 0 To k - 1
						s(j) = sz / ss / Math.sqr(s(j))
					Next

					'
					' Calculate damped inverse inv(Z'*Z+S).
					' We increase damping factor V until Z'*Z become well-conditioned.
					'
					v = 1000.0 * Math.machineepsilon
					Do
						ablas.rmatrixsyrk(k, n, 1.0, z, 0, 0, _
							2, 0.0, rep.covpar, 0, 0, True)
						For i = 0 To k - 1
							rep.covpar(i, i) = rep.covpar(i, i) + v * s(i)
						Next
						matinv.spdmatrixinverse(rep.covpar, k, True, info, invrep)
						v = 10 * v
					Loop While info <= 0
					For i = 0 To k - 1
						For j = i + 1 To k - 1
							rep.covpar(j, i) = rep.covpar(i, j)
						Next
					Next
				End If
				If zkind = 1 Then

					'
					' We can reuse additional information:
					' * Z contains R matrix from QR decomposition of W*F1 
					' * After multiplication by 1/NoiseC we get Z_mod = N*F1, where diag(N)=w[i]/NoiseC
					' * Such triangular Z_mod is a Cholesky factor from decomposition of J'*N'*N*J.
					'   Thus, we can calculate covariance matrix as inverse of the matrix given by
					'   its Cholesky decomposition. It allow us to avoid time-consuming calculation
					'   of J'*N'*N*J in CovPar - complexity is reduced from O(N*K^2) to O(K^3), which
					'   is quite good because K is usually orders of magnitude smaller than N.
					'
					' First, convert S to automatically scaled damped matrix:
					' * calculate SZ - sum of magnitudes of diagonal elements of Z/NoiseC
					' * calculate SS - sum of diagonal elements of S^(-1)
					' * overwrite S by (SZ/SS)*S^(-1)
					' * now S has approximately same magnitude as giagonal of Z'*Z
					'
					sz = 0
					For j = 0 To k - 1
						sz = sz + System.Math.Abs(z(j, j) / noisec)
					Next
					If CDbl(sz) = CDbl(0) Then
						sz = 1
					End If
					ss = 0
					For j = 0 To k - 1
						ss = ss + 1 / s(j)
					Next
					For j = 0 To k - 1
						s(j) = sz / ss / s(j)
					Next

					'
					' Calculate damped inverse of inv((Z+v*S)'*(Z+v*S))
					' We increase damping factor V until matrix become well-conditioned.
					'
					v = 1000.0 * Math.machineepsilon
					Do
						For i = 0 To k - 1
							For j = i To k - 1
								rep.covpar(i, j) = z(i, j) / noisec
							Next
							rep.covpar(i, i) = rep.covpar(i, i) + v * s(i)
						Next
						matinv.spdmatrixcholeskyinverse(rep.covpar, k, True, info, invrep)
						v = 10 * v
					Loop While info <= 0
					For i = 0 To k - 1
						For j = i + 1 To k - 1
							rep.covpar(j, i) = rep.covpar(i, j)
						Next
					Next
				End If
			Else

				'
				' Degenerate situation: zero noise level, covariance matrix is zero.
				'
				For i = 0 To k - 1
					For j = 0 To k - 1
						rep.covpar(j, i) = 0
					Next
				Next
			End If

			'
			' Estimate erorrs in parameters, curve and per-point noise
			'
			apserv.rvectorsetlengthatleast(rep.errpar, k)
			apserv.rvectorsetlengthatleast(rep.errcurve, n)
			apserv.rvectorsetlengthatleast(rep.noise, n)
			For i = 0 To k - 1
				rep.errpar(i) = System.Math.sqrt(rep.covpar(i, i))
			Next
			For i = 0 To n - 1

				'
				' ErrCurve[I] is sqrt(P[i,i]) where P=J*CovPar*J'
				'
				v = 0.0
				For j = 0 To k - 1
					For j1 = 0 To k - 1
						v = v + f1(i, j) * rep.covpar(j, j1) * f1(i, j1)
					Next
				Next
				rep.errcurve(i) = System.Math.sqrt(v)

				'
				' Noise[i] is filled using weights and current estimate of noise level
				'
				If CDbl(w(i)) <> CDbl(0) Then
					rep.noise(i) = noisec / w(i)
				Else
					rep.noise(i) = 0
				End If
			Next
		End Sub


	End Class
	Public Class parametric
		'************************************************************************
'        Parametric spline inteprolant: 2-dimensional curve.
'
'        You should not try to access its members directly - use PSpline2XXXXXXXX()
'        functions instead.
'        ************************************************************************

		Public Class pspline2interpolant
			Inherits apobject
			Public n As Integer
			Public periodic As Boolean
			Public p As Double()
			Public x As spline1d.spline1dinterpolant
			Public y As spline1d.spline1dinterpolant
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				p = New Double(-1) {}
				x = New spline1d.spline1dinterpolant()
				y = New spline1d.spline1dinterpolant()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New pspline2interpolant()
				_result.n = n
				_result.periodic = periodic
				_result.p = DirectCast(p.Clone(), Double())
				_result.x = DirectCast(x.make_copy(), spline1d.spline1dinterpolant)
				_result.y = DirectCast(y.make_copy(), spline1d.spline1dinterpolant)
				Return _result
			End Function
		End Class


		'************************************************************************
'        Parametric spline inteprolant: 3-dimensional curve.
'
'        You should not try to access its members directly - use PSpline3XXXXXXXX()
'        functions instead.
'        ************************************************************************

		Public Class pspline3interpolant
			Inherits apobject
			Public n As Integer
			Public periodic As Boolean
			Public p As Double()
			Public x As spline1d.spline1dinterpolant
			Public y As spline1d.spline1dinterpolant
			Public z As spline1d.spline1dinterpolant
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				p = New Double(-1) {}
				x = New spline1d.spline1dinterpolant()
				y = New spline1d.spline1dinterpolant()
				z = New spline1d.spline1dinterpolant()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New pspline3interpolant()
				_result.n = n
				_result.periodic = periodic
				_result.p = DirectCast(p.Clone(), Double())
				_result.x = DirectCast(x.make_copy(), spline1d.spline1dinterpolant)
				_result.y = DirectCast(y.make_copy(), spline1d.spline1dinterpolant)
				_result.z = DirectCast(z.make_copy(), spline1d.spline1dinterpolant)
				Return _result
			End Function
		End Class




		'************************************************************************
'        This function  builds  non-periodic 2-dimensional parametric spline  which
'        starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
'
'        INPUT PARAMETERS:
'            XY  -   points, array[0..N-1,0..1].
'                    XY[I,0:1] corresponds to the Ith point.
'                    Order of points is important!
'            N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
'                    splines.
'            ST  -   spline type:
'                    * 0     Akima spline
'                    * 1     parabolically terminated Catmull-Rom spline (Tension=0)
'                    * 2     parabolically terminated cubic spline
'            PT  -   parameterization type:
'                    * 0     uniform
'                    * 1     chord length
'                    * 2     centripetal
'
'        OUTPUT PARAMETERS:
'            P   -   parametric spline interpolant
'
'
'        NOTES:
'        * this function  assumes  that  there all consequent points  are distinct.
'          I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
'          However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'          =(x2,y2).
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2build(xy As Double(,), n As Integer, st As Integer, pt As Integer, p As pspline2interpolant)
			Dim tmp As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			xy = DirectCast(xy.Clone(), Double(,))

			alglib.ap.assert(st >= 0 AndAlso st <= 2, "PSpline2Build: incorrect spline type!")
			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline2Build: incorrect parameterization type!")
			If st = 0 Then
				alglib.ap.assert(n >= 5, "PSpline2Build: N<5 (minimum value for Akima splines)!")
			Else
				alglib.ap.assert(n >= 2, "PSpline2Build: N<2!")
			End If

			'
			' Prepare
			'
			p.n = n
			p.periodic = False
			tmp = New Double(n - 1) {}

			'
			' Build parameterization, check that all parameters are distinct
			'
			pspline2par(xy, n, pt, p.p)
			alglib.ap.assert(apserv.aredistinct(p.p, n), "PSpline2Build: consequent points are too close!")

			'
			' Build splines
			'
			If st = 0 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildakima(p.p, tmp, n, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildakima(p.p, tmp, n, p.y)
			End If
			If st = 1 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.y)
			End If
			If st = 2 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, _
					0.0, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, _
					0.0, p.y)
			End If
		End Sub


		'************************************************************************
'        This function  builds  non-periodic 3-dimensional parametric spline  which
'        starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
'
'        Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'        description here.
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3build(xy As Double(,), n As Integer, st As Integer, pt As Integer, p As pspline3interpolant)
			Dim tmp As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			xy = DirectCast(xy.Clone(), Double(,))

			alglib.ap.assert(st >= 0 AndAlso st <= 2, "PSpline3Build: incorrect spline type!")
			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline3Build: incorrect parameterization type!")
			If st = 0 Then
				alglib.ap.assert(n >= 5, "PSpline3Build: N<5 (minimum value for Akima splines)!")
			Else
				alglib.ap.assert(n >= 2, "PSpline3Build: N<2!")
			End If

			'
			' Prepare
			'
			p.n = n
			p.periodic = False
			tmp = New Double(n - 1) {}

			'
			' Build parameterization, check that all parameters are distinct
			'
			pspline3par(xy, n, pt, p.p)
			alglib.ap.assert(apserv.aredistinct(p.p, n), "PSpline3Build: consequent points are too close!")

			'
			' Build splines
			'
			If st = 0 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildakima(p.p, tmp, n, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildakima(p.p, tmp, n, p.y)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 2)
				Next
				spline1d.spline1dbuildakima(p.p, tmp, n, p.z)
			End If
			If st = 1 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.y)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 2)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.z)
			End If
			If st = 2 Then
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 0)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, _
					0.0, p.x)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 1)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, _
					0.0, p.y)
				For i_ = 0 To n - 1
					tmp(i_) = xy(i_, 2)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, _
					0.0, p.z)
			End If
		End Sub


		'************************************************************************
'        This  function  builds  periodic  2-dimensional  parametric  spline  which
'        starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
'        back to (X[0],Y[0]).
'
'        INPUT PARAMETERS:
'            XY  -   points, array[0..N-1,0..1].
'                    XY[I,0:1] corresponds to the Ith point.
'                    XY[N-1,0:1] must be different from XY[0,0:1].
'                    Order of points is important!
'            N   -   points count, N>=3 for other types of splines.
'            ST  -   spline type:
'                    * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
'                    * 2     cubic spline with cyclic boundary conditions
'            PT  -   parameterization type:
'                    * 0     uniform
'                    * 1     chord length
'                    * 2     centripetal
'
'        OUTPUT PARAMETERS:
'            P   -   parametric spline interpolant
'
'
'        NOTES:
'        * this function  assumes  that there all consequent points  are  distinct.
'          I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
'          However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'          =(x2,y2).
'        * last point of sequence is NOT equal to the first  point.  You  shouldn't
'          make curve "explicitly periodic" by making them equal.
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2buildperiodic(xy As Double(,), n As Integer, st As Integer, pt As Integer, p As pspline2interpolant)
			Dim xyp As Double(,) = New Double(-1, -1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			xy = DirectCast(xy.Clone(), Double(,))

			alglib.ap.assert(st >= 1 AndAlso st <= 2, "PSpline2BuildPeriodic: incorrect spline type!")
			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline2BuildPeriodic: incorrect parameterization type!")
			alglib.ap.assert(n >= 3, "PSpline2BuildPeriodic: N<3!")

			'
			' Prepare
			'
			p.n = n
			p.periodic = True
			tmp = New Double(n) {}
			xyp = New Double(n, 1) {}
			For i_ = 0 To n - 1
				xyp(i_, 0) = xy(i_, 0)
			Next
			For i_ = 0 To n - 1
				xyp(i_, 1) = xy(i_, 1)
			Next
			For i_ = 0 To 1
				xyp(n, i_) = xy(0, i_)
			Next

			'
			' Build parameterization, check that all parameters are distinct
			'
			pspline2par(xyp, n + 1, pt, p.p)
			alglib.ap.assert(apserv.aredistinct(p.p, n + 1), "PSpline2BuildPeriodic: consequent (or first and last) points are too close!")

			'
			' Build splines
			'
			If st = 1 Then
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 0)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n + 1, -1, 0.0, p.x)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 1)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n + 1, -1, 0.0, p.y)
			End If
			If st = 2 Then
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 0)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n + 1, -1, 0.0, -1, _
					0.0, p.x)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 1)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n + 1, -1, 0.0, -1, _
					0.0, p.y)
			End If
		End Sub


		'************************************************************************
'        This  function  builds  periodic  3-dimensional  parametric  spline  which
'        starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
'        and then back to (X[0],Y[0],Z[0]).
'
'        Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'        description here.
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3buildperiodic(xy As Double(,), n As Integer, st As Integer, pt As Integer, p As pspline3interpolant)
			Dim xyp As Double(,) = New Double(-1, -1) {}
			Dim tmp As Double() = New Double(-1) {}
			Dim i_ As Integer = 0

			xy = DirectCast(xy.Clone(), Double(,))

			alglib.ap.assert(st >= 1 AndAlso st <= 2, "PSpline3BuildPeriodic: incorrect spline type!")
			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline3BuildPeriodic: incorrect parameterization type!")
			alglib.ap.assert(n >= 3, "PSpline3BuildPeriodic: N<3!")

			'
			' Prepare
			'
			p.n = n
			p.periodic = True
			tmp = New Double(n) {}
			xyp = New Double(n, 2) {}
			For i_ = 0 To n - 1
				xyp(i_, 0) = xy(i_, 0)
			Next
			For i_ = 0 To n - 1
				xyp(i_, 1) = xy(i_, 1)
			Next
			For i_ = 0 To n - 1
				xyp(i_, 2) = xy(i_, 2)
			Next
			For i_ = 0 To 2
				xyp(n, i_) = xy(0, i_)
			Next

			'
			' Build parameterization, check that all parameters are distinct
			'
			pspline3par(xyp, n + 1, pt, p.p)
			alglib.ap.assert(apserv.aredistinct(p.p, n + 1), "PSplineBuild2Periodic: consequent (or first and last) points are too close!")

			'
			' Build splines
			'
			If st = 1 Then
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 0)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n + 1, -1, 0.0, p.x)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 1)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n + 1, -1, 0.0, p.y)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 2)
				Next
				spline1d.spline1dbuildcatmullrom(p.p, tmp, n + 1, -1, 0.0, p.z)
			End If
			If st = 2 Then
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 0)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n + 1, -1, 0.0, -1, _
					0.0, p.x)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 1)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n + 1, -1, 0.0, -1, _
					0.0, p.y)
				For i_ = 0 To n
					tmp(i_) = xyp(i_, 2)
				Next
				spline1d.spline1dbuildcubic(p.p, tmp, n + 1, -1, 0.0, -1, _
					0.0, p.z)
			End If
		End Sub


		'************************************************************************
'        This function returns vector of parameter values correspoding to points.
'
'        I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
'        have
'            (X[0],Y[0]) = PSpline2Calc(P,U[0]),
'            (X[1],Y[1]) = PSpline2Calc(P,U[1]),
'            (X[2],Y[2]) = PSpline2Calc(P,U[2]),
'            ...
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'
'        OUTPUT PARAMETERS:
'            N   -   array size
'            T   -   array[0..N-1]
'
'
'        NOTES:
'        * for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
'        * for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2parametervalues(p As pspline2interpolant, ByRef n As Integer, ByRef t As Double())
			Dim i_ As Integer = 0

			n = 0
			t = New Double(-1) {}

			alglib.ap.assert(p.n >= 2, "PSpline2ParameterValues: internal error!")
			n = p.n
			t = New Double(n - 1) {}
			For i_ = 0 To n - 1
				t(i_) = p.p(i_)
			Next
			t(0) = 0
			If Not p.periodic Then
				t(n - 1) = 1
			End If
		End Sub


		'************************************************************************
'        This function returns vector of parameter values correspoding to points.
'
'        Same as PSpline2ParameterValues(), but for 3D.
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3parametervalues(p As pspline3interpolant, ByRef n As Integer, ByRef t As Double())
			Dim i_ As Integer = 0

			n = 0
			t = New Double(-1) {}

			alglib.ap.assert(p.n >= 2, "PSpline3ParameterValues: internal error!")
			n = p.n
			t = New Double(n - 1) {}
			For i_ = 0 To n - 1
				t(i_) = p.p(i_)
			Next
			t(0) = 0
			If Not p.periodic Then
				t(n - 1) = 1
			End If
		End Sub


		'************************************************************************
'        This function  calculates  the value of the parametric spline for a  given
'        value of parameter T
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-position
'            Y   -   Y-position
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2calc(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef y As Double)
			x = 0
			y = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			x = spline1d.spline1dcalc(p.x, t)
			y = spline1d.spline1dcalc(p.y, t)
		End Sub


		'************************************************************************
'        This function  calculates  the value of the parametric spline for a  given
'        value of parameter T.
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-position
'            Y   -   Y-position
'            Z   -   Z-position
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3calc(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef y As Double, ByRef z As Double)
			x = 0
			y = 0
			z = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			x = spline1d.spline1dcalc(p.x, t)
			y = spline1d.spline1dcalc(p.y, t)
			z = spline1d.spline1dcalc(p.z, t)
		End Sub


		'************************************************************************
'        This function  calculates  tangent vector for a given value of parameter T
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X    -   X-component of tangent vector (normalized)
'            Y    -   Y-component of tangent vector (normalized)
'            
'        NOTE:
'            X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2tangent(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef y As Double)
			Dim v As Double = 0
			Dim v0 As Double = 0
			Dim v1 As Double = 0

			x = 0
			y = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			pspline2diff(p, t, v0, x, v1, y)
			If CDbl(x) <> CDbl(0) OrElse CDbl(y) <> CDbl(0) Then

				'
				' this code is a bit more complex than X^2+Y^2 to avoid
				' overflow for large values of X and Y.
				'
				v = apserv.safepythag2(x, y)
				x = x / v
				y = y / v
			End If
		End Sub


		'************************************************************************
'        This function  calculates  tangent vector for a given value of parameter T
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X    -   X-component of tangent vector (normalized)
'            Y    -   Y-component of tangent vector (normalized)
'            Z    -   Z-component of tangent vector (normalized)
'
'        NOTE:
'            X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3tangent(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef y As Double, ByRef z As Double)
			Dim v As Double = 0
			Dim v0 As Double = 0
			Dim v1 As Double = 0
			Dim v2 As Double = 0

			x = 0
			y = 0
			z = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			pspline3diff(p, t, v0, x, v1, y, _
				v2, z)
			If (CDbl(x) <> CDbl(0) OrElse CDbl(y) <> CDbl(0)) OrElse CDbl(z) <> CDbl(0) Then
				v = apserv.safepythag3(x, y, z)
				x = x / v
				y = y / v
				z = z / v
			End If
		End Sub


		'************************************************************************
'        This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-value
'            DX  -   X-derivative
'            Y   -   Y-value
'            DY  -   Y-derivative
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2diff(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef y As Double, ByRef dy As Double)
			Dim d2s As Double = 0

			x = 0
			dx = 0
			y = 0
			dy = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			spline1d.spline1ddiff(p.x, t, x, dx, d2s)
			spline1d.spline1ddiff(p.y, t, y, dy, d2s)
		End Sub


		'************************************************************************
'        This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-value
'            DX  -   X-derivative
'            Y   -   Y-value
'            DY  -   Y-derivative
'            Z   -   Z-value
'            DZ  -   Z-derivative
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3diff(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef y As Double, ByRef dy As Double, _
			ByRef z As Double, ByRef dz As Double)
			Dim d2s As Double = 0

			x = 0
			dx = 0
			y = 0
			dy = 0
			z = 0
			dz = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			spline1d.spline1ddiff(p.x, t, x, dx, d2s)
			spline1d.spline1ddiff(p.y, t, y, dy, d2s)
			spline1d.spline1ddiff(p.z, t, z, dz, d2s)
		End Sub


		'************************************************************************
'        This function calculates first and second derivative with respect to T.
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-value
'            DX  -   derivative
'            D2X -   second derivative
'            Y   -   Y-value
'            DY  -   derivative
'            D2Y -   second derivative
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline2diff2(p As pspline2interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef d2x As Double, ByRef y As Double, _
			ByRef dy As Double, ByRef d2y As Double)
			x = 0
			dx = 0
			d2x = 0
			y = 0
			dy = 0
			d2y = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			spline1d.spline1ddiff(p.x, t, x, dx, d2x)
			spline1d.spline1ddiff(p.y, t, y, dy, d2y)
		End Sub


		'************************************************************************
'        This function calculates first and second derivative with respect to T.
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            T   -   point:
'                    * T in [0,1] corresponds to interval spanned by points
'                    * for non-periodic splines T<0 (or T>1) correspond to parts of
'                      the curve before the first (after the last) point
'                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'                      by making T=T-floor(T).
'
'        OUTPUT PARAMETERS:
'            X   -   X-value
'            DX  -   derivative
'            D2X -   second derivative
'            Y   -   Y-value
'            DY  -   derivative
'            D2Y -   second derivative
'            Z   -   Z-value
'            DZ  -   derivative
'            D2Z -   second derivative
'
'
'          -- ALGLIB PROJECT --
'             Copyright 28.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub pspline3diff2(p As pspline3interpolant, t As Double, ByRef x As Double, ByRef dx As Double, ByRef d2x As Double, ByRef y As Double, _
			ByRef dy As Double, ByRef d2y As Double, ByRef z As Double, ByRef dz As Double, ByRef d2z As Double)
			x = 0
			dx = 0
			d2x = 0
			y = 0
			dy = 0
			d2y = 0
			z = 0
			dz = 0
			d2z = 0

			If p.periodic Then
				t = t - CInt(System.Math.Truncate(System.Math.Floor(t)))
			End If
			spline1d.spline1ddiff(p.x, t, x, dx, d2x)
			spline1d.spline1ddiff(p.y, t, y, dy, d2y)
			spline1d.spline1ddiff(p.z, t, z, dz, d2z)
		End Sub


		'************************************************************************
'        This function  calculates  arc length, i.e. length of  curve  between  t=a
'        and t=b.
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            A,B -   parameter values corresponding to arc ends:
'                    * B>A will result in positive length returned
'                    * B<A will result in negative length returned
'
'        RESULT:
'            length of arc starting at T=A and ending at T=B.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 30.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function pspline2arclength(p As pspline2interpolant, a As Double, b As Double) As Double
			Dim result As Double = 0
			Dim state As New autogk.autogkstate()
			Dim rep As New autogk.autogkreport()
			Dim sx As Double = 0
			Dim dsx As Double = 0
			Dim d2sx As Double = 0
			Dim sy As Double = 0
			Dim dsy As Double = 0
			Dim d2sy As Double = 0

			autogk.autogksmooth(a, b, state)
			While autogk.autogkiteration(state)
				spline1d.spline1ddiff(p.x, state.x, sx, dsx, d2sx)
				spline1d.spline1ddiff(p.y, state.x, sy, dsy, d2sy)
				state.f = apserv.safepythag2(dsx, dsy)
			End While
			autogk.autogkresults(state, result, rep)
			alglib.ap.assert(rep.terminationtype > 0, "PSpline2ArcLength: internal error!")
			Return result
		End Function


		'************************************************************************
'        This function  calculates  arc length, i.e. length of  curve  between  t=a
'        and t=b.
'
'        INPUT PARAMETERS:
'            P   -   parametric spline interpolant
'            A,B -   parameter values corresponding to arc ends:
'                    * B>A will result in positive length returned
'                    * B<A will result in negative length returned
'
'        RESULT:
'            length of arc starting at T=A and ending at T=B.
'
'
'          -- ALGLIB PROJECT --
'             Copyright 30.05.2010 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function pspline3arclength(p As pspline3interpolant, a As Double, b As Double) As Double
			Dim result As Double = 0
			Dim state As New autogk.autogkstate()
			Dim rep As New autogk.autogkreport()
			Dim sx As Double = 0
			Dim dsx As Double = 0
			Dim d2sx As Double = 0
			Dim sy As Double = 0
			Dim dsy As Double = 0
			Dim d2sy As Double = 0
			Dim sz As Double = 0
			Dim dsz As Double = 0
			Dim d2sz As Double = 0

			autogk.autogksmooth(a, b, state)
			While autogk.autogkiteration(state)
				spline1d.spline1ddiff(p.x, state.x, sx, dsx, d2sx)
				spline1d.spline1ddiff(p.y, state.x, sy, dsy, d2sy)
				spline1d.spline1ddiff(p.z, state.x, sz, dsz, d2sz)
				state.f = apserv.safepythag3(dsx, dsy, dsz)
			End While
			autogk.autogkresults(state, result, rep)
			alglib.ap.assert(rep.terminationtype > 0, "PSpline3ArcLength: internal error!")
			Return result
		End Function


		'************************************************************************
'        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
'        Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
'        used to fit curves like circles.
'
'        On  input  it  accepts dataset which describes parametric multidimensional
'        curve X(t), with X being vector, and t taking values in [0,N), where N  is
'        a number of points in dataset. As result, it returns reduced  dataset  X2,
'        which can be used to build  parametric  curve  X2(t),  which  approximates
'        X(t) with desired precision (or has specified number of sections).
'
'
'        INPUT PARAMETERS:
'            X       -   array of multidimensional points:
'                        * at least N elements, leading N elements are used if more
'                          than N elements were specified
'                        * order of points is IMPORTANT because  it  is  parametric
'                          fit
'                        * each row of array is one point which has D coordinates
'            N       -   number of elements in X
'            D       -   number of dimensions (elements per row of X)
'            StopM   -   stopping condition - desired number of sections:
'                        * at most M sections are generated by this function
'                        * less than M sections can be generated if we have N<M
'                          (or some X are non-distinct).
'                        * zero StopM means that algorithm does not stop after
'                          achieving some pre-specified section count
'            StopEps -   stopping condition - desired precision:
'                        * algorithm stops after error in each section is at most Eps
'                        * zero Eps means that algorithm does not stop after
'                          achieving some pre-specified precision
'
'        OUTPUT PARAMETERS:
'            X2      -   array of corner points for piecewise approximation,
'                        has length NSections+1 or zero (for NSections=0).
'            Idx2    -   array of indexes (parameter values):
'                        * has length NSections+1 or zero (for NSections=0).
'                        * each element of Idx2 corresponds to same-numbered
'                          element of X2
'                        * each element of Idx2 is index of  corresponding  element
'                          of X2 at original array X, i.e. I-th  row  of  X2  is
'                          Idx2[I]-th row of X.
'                        * elements of Idx2 can be treated as parameter values
'                          which should be used when building new parametric curve
'                        * Idx2[0]=0, Idx2[NSections]=N-1
'            NSections-  number of sections found by algorithm, NSections<=M,
'                        NSections can be zero for degenerate datasets
'                        (N<=1 or all X[] are non-distinct).
'
'        NOTE: algorithm stops after:
'              a) dividing curve into StopM sections 
'              b) achieving required precision StopEps
'              c) dividing curve into N-1 sections
'              If both StopM and StopEps are non-zero, algorithm is stopped by  the
'              FIRST criterion which is satisfied. In case both StopM  and  StopEps
'              are zero, algorithm stops because of (c).
'                        
'          -- ALGLIB --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub parametricrdpfixed(x As Double(,), n As Integer, d As Integer, stopm As Integer, stopeps As Double, ByRef x2 As Double(,), _
			ByRef idx2 As Integer(), ByRef nsections As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim allsame As New Boolean()
			Dim k0 As Integer = 0
			Dim k1 As Integer = 0
			Dim k2 As Integer = 0
			Dim e0 As Double = 0
			Dim e1 As Double = 0
			Dim idx0 As Integer = 0
			Dim idx1 As Integer = 0
			Dim worstidx As Integer = 0
			Dim worsterror As Double = 0
			Dim sections As Double(,) = New Double(-1, -1) {}
			Dim heaperrors As Double() = New Double(-1) {}
			Dim heaptags As Integer() = New Integer(-1) {}
			Dim buf0 As Double() = New Double(-1) {}
			Dim buf1 As Double() = New Double(-1) {}

			x2 = New Double(-1, -1) {}
			idx2 = New Integer(-1) {}
			nsections = 0

			alglib.ap.assert(n >= 0, "LSTFitPiecewiseLinearParametricRDP: N<0")
			alglib.ap.assert(d >= 1, "LSTFitPiecewiseLinearParametricRDP: D<=0")
			alglib.ap.assert(stopm >= 0, "LSTFitPiecewiseLinearParametricRDP: StopM<1")
			alglib.ap.assert(Math.isfinite(stopeps) AndAlso CDbl(stopeps) >= CDbl(0), "LSTFitPiecewiseLinearParametricRDP: StopEps<0 or is infinite")
			alglib.ap.assert(alglib.ap.rows(x) >= n, "LSTFitPiecewiseLinearParametricRDP: Rows(X)<N")
			alglib.ap.assert(alglib.ap.cols(x) >= d, "LSTFitPiecewiseLinearParametricRDP: Cols(X)<D")
			alglib.ap.assert(apserv.apservisfinitematrix(x, n, d), "LSTFitPiecewiseLinearParametricRDP: X contains infinite/NAN values")

			'
			' Handle degenerate cases
			'
			If n <= 1 Then
				nsections = 0
				Return
			End If
			allsame = True
			For i = 1 To n - 1
				For j = 0 To d - 1
					allsame = allsame AndAlso CDbl(x(i, j)) = CDbl(x(0, j))
				Next
			Next
			If allsame Then
				nsections = 0
				Return
			End If

			'
			' Prepare first section
			'
			rdpanalyzesectionpar(x, 0, n - 1, d, worstidx, worsterror)
			sections = New Double(n - 1, 3) {}
			heaperrors = New Double(n - 1) {}
			heaptags = New Integer(n - 1) {}
			nsections = 1
			sections(0, 0) = 0
			sections(0, 1) = n - 1
			sections(0, 2) = worstidx
			sections(0, 3) = worsterror
			heaperrors(0) = worsterror
			heaptags(0) = 0
			alglib.ap.assert(CDbl(sections(0, 1)) = CDbl(n - 1), "RDP algorithm: integrity check failed")

			'
			' Main loop.
			' Repeatedly find section with worst error and divide it.
			' Terminate after M-th section, or because of other reasons (see loop internals).
			'
			While True

				'
				' Break loop if one of the stopping conditions was met.
				' Store index of worst section to K.
				'
				If CDbl(heaperrors(0)) = CDbl(0) Then
					Exit While
				End If
				If CDbl(stopeps) > CDbl(0) AndAlso CDbl(heaperrors(0)) <= CDbl(stopeps) Then
					Exit While
				End If
				If stopm > 0 AndAlso nsections >= stopm Then
					Exit While
				End If
				k = heaptags(0)

				'
				' K-th section is divided in two:
				' * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
				' * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
				'
				' First section is stored at K-th position, second one is appended to the table.
				' Then we update heap which stores pairs of (error,section_index)
				'
				k0 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 0))))
				k1 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 1))))
				k2 = CInt(System.Math.Truncate(System.Math.Round(sections(k, 2))))
				rdpanalyzesectionpar(x, k0, k2, d, idx0, e0)
				rdpanalyzesectionpar(x, k2, k1, d, idx1, e1)
				sections(k, 0) = k0
				sections(k, 1) = k2
				sections(k, 2) = idx0
				sections(k, 3) = e0
				tsort.tagheapreplacetopi(heaperrors, heaptags, nsections, e0, k)
				sections(nsections, 0) = k2
				sections(nsections, 1) = k1
				sections(nsections, 2) = idx1
				sections(nsections, 3) = e1
				tsort.tagheappushi(heaperrors, heaptags, nsections, e1, nsections)
			End While

			'
			' Convert from sections to indexes
			'
			buf0 = New Double(nsections) {}
			For i = 0 To nsections - 1
				buf0(i) = CInt(System.Math.Truncate(System.Math.Round(sections(i, 0))))
			Next
			buf0(nsections) = n - 1
			tsort.tagsortfast(buf0, buf1, nsections + 1)
			idx2 = New Integer(nsections) {}
			For i = 0 To nsections
				idx2(i) = CInt(System.Math.Truncate(System.Math.Round(buf0(i))))
			Next
			alglib.ap.assert(idx2(0) = 0, "RDP algorithm: integrity check failed")
			alglib.ap.assert(idx2(nsections) = n - 1, "RDP algorithm: integrity check failed")

			'
			' Output sections:
			' * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
			' * last element of X2/Y2 is filled by right boundary of rightmost section
			' * X2/Y2 is sorted by ascending of X2
			'
			x2 = New Double(nsections, d - 1) {}
			For i = 0 To nsections
				For j = 0 To d - 1
					x2(i, j) = x(idx2(i), j)
				Next
			Next
		End Sub


		'************************************************************************
'        Builds non-periodic parameterization for 2-dimensional spline
'        ************************************************************************

		Private Shared Sub pspline2par(xy As Double(,), n As Integer, pt As Integer, ByRef p As Double())
			Dim v As Double = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			p = New Double(-1) {}

			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline2Par: internal error!")

			'
			' Build parameterization:
			' * fill by non-normalized values
			' * normalize them so we have P[0]=0, P[N-1]=1.
			'
			p = New Double(n - 1) {}
			If pt = 0 Then
				For i = 0 To n - 1
					p(i) = i
				Next
			End If
			If pt = 1 Then
				p(0) = 0
				For i = 1 To n - 1
					p(i) = p(i - 1) + apserv.safepythag2(xy(i, 0) - xy(i - 1, 0), xy(i, 1) - xy(i - 1, 1))
				Next
			End If
			If pt = 2 Then
				p(0) = 0
				For i = 1 To n - 1
					p(i) = p(i - 1) + System.Math.sqrt(apserv.safepythag2(xy(i, 0) - xy(i - 1, 0), xy(i, 1) - xy(i - 1, 1)))
				Next
			End If
			v = 1 / p(n - 1)
			For i_ = 0 To n - 1
				p(i_) = v * p(i_)
			Next
		End Sub


		'************************************************************************
'        Builds non-periodic parameterization for 3-dimensional spline
'        ************************************************************************

		Private Shared Sub pspline3par(xy As Double(,), n As Integer, pt As Integer, ByRef p As Double())
			Dim v As Double = 0
			Dim i As Integer = 0
			Dim i_ As Integer = 0

			p = New Double(-1) {}

			alglib.ap.assert(pt >= 0 AndAlso pt <= 2, "PSpline3Par: internal error!")

			'
			' Build parameterization:
			' * fill by non-normalized values
			' * normalize them so we have P[0]=0, P[N-1]=1.
			'
			p = New Double(n - 1) {}
			If pt = 0 Then
				For i = 0 To n - 1
					p(i) = i
				Next
			End If
			If pt = 1 Then
				p(0) = 0
				For i = 1 To n - 1
					p(i) = p(i - 1) + apserv.safepythag3(xy(i, 0) - xy(i - 1, 0), xy(i, 1) - xy(i - 1, 1), xy(i, 2) - xy(i - 1, 2))
				Next
			End If
			If pt = 2 Then
				p(0) = 0
				For i = 1 To n - 1
					p(i) = p(i - 1) + System.Math.sqrt(apserv.safepythag3(xy(i, 0) - xy(i - 1, 0), xy(i, 1) - xy(i - 1, 1), xy(i, 2) - xy(i - 1, 2)))
				Next
			End If
			v = 1 / p(n - 1)
			For i_ = 0 To n - 1
				p(i_) = v * p(i_)
			Next
		End Sub


		'************************************************************************
'        This function analyzes section of curve for processing by RDP algorithm:
'        given set of points X,Y with indexes [I0,I1] it returns point with
'        worst deviation from linear model (PARAMETRIC version which sees curve
'        as X(t) with vector X).
'
'        Input parameters:
'            XY          -   array
'            I0,I1       -   interval (boundaries included) to process
'            D           -   number of dimensions
'            
'        OUTPUT PARAMETERS:
'            WorstIdx    -   index of worst point
'            WorstError  -   error at worst point
'            
'        NOTE: this function guarantees that it returns exactly zero for a section
'              with less than 3 points.
'
'          -- ALGLIB PROJECT --
'             Copyright 02.10.2014 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rdpanalyzesectionpar(xy As Double(,), i0 As Integer, i1 As Integer, d As Integer, ByRef worstidx As Integer, ByRef worsterror As Double)
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim v As Double = 0
			Dim d2 As Double = 0
			Dim ts As Double = 0
			Dim vv As Double = 0

			worstidx = 0
			worsterror = 0


			'
			' Quick exit for 0, 1, 2 points
			'
			If i1 - i0 + 1 < 3 Then
				worstidx = i0
				worsterror = 0.0
				Return
			End If

			'
			' Estimate D2 - squared distance between XY[I1] and XY[I0].
			' In case D2=0 handle it as special case.
			'
			d2 = 0.0
			For j = 0 To d - 1
				d2 = d2 + Math.sqr(xy(i1, j) - xy(i0, j))
			Next
			If CDbl(d2) = CDbl(0) Then

				'
				' First and last points are equal, interval evaluation is
				' trivial - we just calculate distance from all points to
				' the first/last one.
				'
				worstidx = i0
				worsterror = 0.0
				For i = i0 + 1 To i1 - 1
					vv = 0.0
					For j = 0 To d - 1
						v = xy(i, j) - xy(i0, j)
						vv = vv + v * v
					Next
					vv = System.Math.sqrt(vv)
					If CDbl(vv) > CDbl(worsterror) Then
						worsterror = vv
						worstidx = i
					End If
				Next
				Return
			End If

			'
			' General case
			'
			' Current section of curve is modeled as x(t) = d*t+c, where
			'     d = XY[I1]-XY[I0]
			'     c = XY[I0]
			'     t is in [0,1]
			'
			worstidx = i0
			worsterror = 0.0
			For i = i0 + 1 To i1 - 1

				'
				' Determine t_s - parameter value for projected point.
				'
				ts = CDbl(i - i0) / CDbl(i1 - i0)

				'
				' Estimate error norm
				'
				vv = 0.0
				For j = 0 To d - 1
					v = (xy(i1, j) - xy(i0, j)) * ts - (xy(i, j) - xy(i0, j))
					vv = vv + Math.sqr(v)
				Next
				vv = System.Math.sqrt(vv)
				If CDbl(vv) > CDbl(worsterror) Then
					worsterror = vv
					worstidx = i
				End If
			Next
		End Sub


	End Class
	Public Class rbf
		'************************************************************************
'        RBF model.
'
'        Never try to directly work with fields of this object - always use  ALGLIB
'        functions to use this object.
'        ************************************************************************

		Public Class rbfmodel
			Inherits apobject
			Public ny As Integer
			Public nx As Integer
			Public nc As Integer
			Public nl As Integer
			Public tree As nearestneighbor.kdtree
			Public xc As Double(,)
			Public wr As Double(,)
			Public rmax As Double
			Public v As Double(,)
			Public gridtype As Integer
			Public fixrad As Boolean
			Public lambdav As Double
			Public radvalue As Double
			Public radzvalue As Double
			Public nlayers As Integer
			Public aterm As Integer
			Public algorithmtype As Integer
			Public epsort As Double
			Public epserr As Double
			Public maxits As Integer
			Public h As Double
			Public n As Integer
			Public x As Double(,)
			Public y As Double(,)
			Public calcbufxcx As Double()
			Public calcbufx As Double(,)
			Public calcbuftags As Integer()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				tree = New nearestneighbor.kdtree()
				xc = New Double(-1, -1) {}
				wr = New Double(-1, -1) {}
				v = New Double(-1, -1) {}
				x = New Double(-1, -1) {}
				y = New Double(-1, -1) {}
				calcbufxcx = New Double(-1) {}
				calcbufx = New Double(-1, -1) {}
				calcbuftags = New Integer(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New rbfmodel()
				_result.ny = ny
				_result.nx = nx
				_result.nc = nc
				_result.nl = nl
				_result.tree = DirectCast(tree.make_copy(), nearestneighbor.kdtree)
				_result.xc = DirectCast(xc.Clone(), Double(,))
				_result.wr = DirectCast(wr.Clone(), Double(,))
				_result.rmax = rmax
				_result.v = DirectCast(v.Clone(), Double(,))
				_result.gridtype = gridtype
				_result.fixrad = fixrad
				_result.lambdav = lambdav
				_result.radvalue = radvalue
				_result.radzvalue = radzvalue
				_result.nlayers = nlayers
				_result.aterm = aterm
				_result.algorithmtype = algorithmtype
				_result.epsort = epsort
				_result.epserr = epserr
				_result.maxits = maxits
				_result.h = h
				_result.n = n
				_result.x = DirectCast(x.Clone(), Double(,))
				_result.y = DirectCast(y.Clone(), Double(,))
				_result.calcbufxcx = DirectCast(calcbufxcx.Clone(), Double())
				_result.calcbufx = DirectCast(calcbufx.Clone(), Double(,))
				_result.calcbuftags = DirectCast(calcbuftags.Clone(), Integer())
				Return _result
			End Function
		End Class


		'************************************************************************
'        RBF solution report:
'        * TerminationType   -   termination type, positive values - success,
'                                non-positive - failure.
'        ************************************************************************

		Public Class rbfreport
			Inherits apobject
			Public arows As Integer
			Public acols As Integer
			Public annz As Integer
			Public iterationscount As Integer
			Public nmv As Integer
			Public terminationtype As Integer
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New rbfreport()
				_result.arows = arows
				_result.acols = acols
				_result.annz = annz
				_result.iterationscount = iterationscount
				_result.nmv = nmv
				_result.terminationtype = terminationtype
				Return _result
			End Function
		End Class




		Public Const eps As Double = 1E-06
		Public Const mxnx As Integer = 3
		Public Const rbffarradius As Double = 6
		Public Const rbfnearradius As Double = 2.1
		Public Const rbfmlradius As Double = 3
		Public Const rbffirstversion As Integer = 0


		'************************************************************************
'        This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
'        function in a NX-dimensional space (NX=2 or NX=3).
'
'        Newly created model is empty. It can be used for interpolation right after
'        creation, but it just returns zeros. You have to add points to the  model,
'        tune interpolation settings, and then  call  model  construction  function
'        RBFBuildModel() which will update model according to your specification.
'
'        USAGE:
'        1. User creates model with RBFCreate()
'        2. User adds dataset with RBFSetPoints() (points do NOT have to  be  on  a
'           regular grid)
'        3. (OPTIONAL) User chooses polynomial term by calling:
'           * RBFLinTerm() to set linear term
'           * RBFConstTerm() to set constant term
'           * RBFZeroTerm() to set zero term
'           By default, linear term is used.
'        4. User chooses specific RBF algorithm to use: either QNN (RBFSetAlgoQNN)
'           or ML (RBFSetAlgoMultiLayer).
'        5. User calls RBFBuildModel() function which rebuilds model  according  to
'           the specification
'        6. User may call RBFCalc() to calculate model value at the specified point,
'           RBFGridCalc() to  calculate   model  values at the points of the regular
'           grid. User may extract model coefficients with RBFUnpack() call.
'           
'        INPUT PARAMETERS:
'            NX      -   dimension of the space, NX=2 or NX=3
'            NY      -   function dimension, NY>=1
'
'        OUTPUT PARAMETERS:
'            S       -   RBF model (initially equals to zero)
'
'        NOTE 1: memory requirements. RBF models require amount of memory  which is
'                proportional  to  the  number  of data points. Memory is allocated 
'                during model construction, but most of this memory is freed  after
'                model coefficients are calculated.
'                
'                Some approximate estimates for N centers with default settings are
'                given below:
'                * about 250*N*(sizeof(double)+2*sizeof(int)) bytes  of  memory  is
'                  needed during model construction stage.
'                * about 15*N*sizeof(double) bytes is needed after model is built.
'                For example, for N=100000 we may need 0.6 GB of memory  to  build
'                model, but just about 0.012 GB to store it.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfcreate(nx As Integer, ny As Integer, s As rbfmodel)
			Dim i As Integer = 0
			Dim j As Integer = 0

			alglib.ap.assert(nx = 2 OrElse nx = 3, "RBFCreate: NX<>2 and NX<>3")
			alglib.ap.assert(ny >= 1, "RBFCreate: NY<1")
			s.nx = nx
			s.ny = ny
			s.nl = 0
			s.nc = 0
			s.v = New Double(ny - 1, mxnx) {}
			For i = 0 To ny - 1
				For j = 0 To mxnx
					s.v(i, j) = 0
				Next
			Next
			s.n = 0
			s.rmax = 0
			s.gridtype = 2
			s.fixrad = False
			s.radvalue = 1
			s.radzvalue = 5
			s.aterm = 1
			s.algorithmtype = 1

			'
			' stopping criteria
			'
			s.epsort = eps
			s.epserr = eps
			s.maxits = 0
		End Sub


		'************************************************************************
'        This function adds dataset.
'
'        This function overrides results of the previous calls, i.e. multiple calls
'        of this function will result in only the last set being added.
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call.
'            XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
'                        in the dataset. First NX elements  are  coordinates,  next
'                        NY elements are function values. Array may  be larger than 
'                        specific,  in  this  case  only leading [N,NX+NY] elements 
'                        will be used.
'            N       -   number of points in the dataset
'
'        After you've added dataset and (optionally) tuned algorithm  settings  you
'        should call RBFBuildModel() in order to build a model for you.
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'              
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetpoints(s As rbfmodel, xy As Double(,), n As Integer)
			Dim i As Integer = 0
			Dim j As Integer = 0

			alglib.ap.assert(n > 0, "RBFSetPoints: N<0")
			alglib.ap.assert(alglib.ap.rows(xy) >= n, "RBFSetPoints: Rows(XY)<N")
			alglib.ap.assert(alglib.ap.cols(xy) >= s.nx + s.ny, "RBFSetPoints: Cols(XY)<NX+NY")
			s.n = n
			s.x = New Double(s.n - 1, mxnx - 1) {}
			s.y = New Double(s.n - 1, s.ny - 1) {}
			For i = 0 To s.n - 1
				For j = 0 To mxnx - 1
					s.x(i, j) = 0
				Next
				For j = 0 To s.nx - 1
					s.x(i, j) = xy(i, j)
				Next
				For j = 0 To s.ny - 1
					s.y(i, j) = xy(i, j + s.nx)
				Next
			Next
		End Sub


		'************************************************************************
'        This  function  sets  RBF interpolation algorithm. ALGLIB supports several
'        RBF algorithms with different properties.
'
'        This algorithm is called RBF-QNN and  it  is  good  for  point  sets  with
'        following properties:
'        a) all points are distinct
'        b) all points are well separated.
'        c) points  distribution  is  approximately  uniform.  There is no "contour
'           lines", clusters of points, or other small-scale structures.
'
'        Algorithm description:
'        1) interpolation centers are allocated to data points
'        2) interpolation radii are calculated as distances to the  nearest centers
'           times Q coefficient (where Q is a value from [0.75,1.50]).
'        3) after  performing (2) radii are transformed in order to avoid situation
'           when single outlier has very large radius and  influences  many  points
'           across all dataset. Transformation has following form:
'               new_r[i] = min(r[i],Z*median(r[]))
'           where r[i] is I-th radius, median()  is a median  radius across  entire
'           dataset, Z is user-specified value which controls amount  of  deviation
'           from median radius.
'
'        When (a) is violated,  we  will  be unable to build RBF model. When (b) or
'        (c) are violated, model will be built, but interpolation quality  will  be
'        low. See http://www.alglib.net/interpolation/ for more information on this
'        subject.
'
'        This algorithm is used by default.
'
'        Additional Q parameter controls smoothness properties of the RBF basis:
'        * Q<0.75 will give perfectly conditioned basis,  but  terrible  smoothness
'          properties (RBF interpolant will have sharp peaks around function values)
'        * Q around 1.0 gives good balance between smoothness and condition number
'        * Q>1.5 will lead to badly conditioned systems and slow convergence of the
'          underlying linear solver (although smoothness will be very good)
'        * Q>2.0 will effectively make optimizer useless because it won't  converge
'          within reasonable amount of iterations. It is possible to set such large
'          Q, but it is advised not to do so.
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'            Q       -   Q parameter, Q>0, recommended value - 1.0
'            Z       -   Z parameter, Z>0, recommended value - 5.0
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetalgoqnn(s As rbfmodel, q As Double, z As Double)
			alglib.ap.assert(Math.isfinite(q), "RBFSetAlgoQNN: Q is infinite or NAN")
			alglib.ap.assert(CDbl(q) > CDbl(0), "RBFSetAlgoQNN: Q<=0")
			rbfgridpoints(s)
			rbfradnn(s, q, z)
			s.algorithmtype = 1
		End Sub


		'************************************************************************
'        This  function  sets  RBF interpolation algorithm. ALGLIB supports several
'        RBF algorithms with different properties.
'
'        This  algorithm is called RBF-ML. It builds  multilayer  RBF  model,  i.e.
'        model with subsequently decreasing  radii,  which  allows  us  to  combine
'        smoothness (due to  large radii of  the first layers) with  exactness (due
'        to small radii of the last layers) and fast convergence.
'
'        Internally RBF-ML uses many different  means  of acceleration, from sparse
'        matrices  to  KD-trees,  which  results in algorithm whose working time is
'        roughly proportional to N*log(N)*Density*RBase^2*NLayers,  where  N  is  a
'        number of points, Density is an average density if points per unit of  the
'        interpolation space, RBase is an initial radius, NLayers is  a  number  of
'        layers.
'
'        RBF-ML is good for following kinds of interpolation problems:
'        1. "exact" problems (perfect fit) with well separated points
'        2. least squares problems with arbitrary distribution of points (algorithm
'           gives  perfect  fit  where it is possible, and resorts to least squares
'           fit in the hard areas).
'        3. noisy problems where  we  want  to  apply  some  controlled  amount  of
'           smoothing.
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'            RBase   -   RBase parameter, RBase>0
'            NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
'                        with - about 5.
'            LambdaV -   regularization value, can be useful when  solving  problem
'                        in the least squares sense.  Optimal  lambda  is  problem-
'                        dependent and require trial and error. In our  experience,
'                        good lambda can be as large as 0.1, and you can use  0.001
'                        as initial guess.
'                        Default  value  - 0.01, which is used when LambdaV is  not
'                        given.  You  can  specify  zero  value,  but  it  is   not
'                        recommended to do so.
'
'        TUNING ALGORITHM
'
'        In order to use this algorithm you have to choose three parameters:
'        * initial radius RBase
'        * number of layers in the model NLayers
'        * regularization coefficient LambdaV
'
'        Initial radius is easy to choose - you can pick any number  several  times
'        larger  than  the  average  distance between points. Algorithm won't break
'        down if you choose radius which is too large (model construction time will
'        increase, but model will be built correctly).
'
'        Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
'        by  the  last  layer)  will  be  smaller than the typical distance between
'        points.  In  case  model  error  is  too large, you can increase number of
'        layers.  Having  more  layers  will make model construction and evaluation
'        proportionally slower, but it will allow you to have model which precisely
'        fits your data. From the other side, if you want to  suppress  noise,  you
'        can DECREASE number of layers to make your model less flexible.
'
'        Regularization coefficient LambdaV controls smoothness of  the  individual
'        models built for each layer. We recommend you to use default value in case
'        you don't want to tune this parameter,  because  having  non-zero  LambdaV
'        accelerates and stabilizes internal iterative algorithm. In case you  want
'        to suppress noise you can use  LambdaV  as  additional  parameter  (larger
'        value = more smoothness) to tune.
'
'        TYPICAL ERRORS
'
'        1. Using  initial  radius  which is too large. Memory requirements  of the
'           RBF-ML are roughly proportional to N*Density*RBase^2 (where Density  is
'           an average density of points per unit of the interpolation  space).  In
'           the extreme case of the very large RBase we will need O(N^2)  units  of
'           memory - and many layers in order to decrease radius to some reasonably
'           small value.
'
'        2. Using too small number of layers - RBF models with large radius are not
'           flexible enough to reproduce small variations in the  target  function.
'           You  need  many  layers  with  different radii, from large to small, in
'           order to have good model.
'
'        3. Using  initial  radius  which  is  too  small.  You will get model with
'           "holes" in the areas which are too far away from interpolation centers.
'           However, algorithm will work correctly (and quickly) in this case.
'
'        4. Using too many layers - you will get too large and too slow model. This
'           model  will  perfectly  reproduce  your function, but maybe you will be
'           able to achieve similar results with less layers (and less memory).
'           
'          -- ALGLIB --
'             Copyright 02.03.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetalgomultilayer(s As rbfmodel, rbase As Double, nlayers As Integer, lambdav As Double)
			alglib.ap.assert(Math.isfinite(rbase), "RBFSetAlgoMultiLayer: RBase is infinite or NaN")
			alglib.ap.assert(CDbl(rbase) > CDbl(0), "RBFSetAlgoMultiLayer: RBase<=0")
			alglib.ap.assert(nlayers >= 0, "RBFSetAlgoMultiLayer: NLayers<0")
			alglib.ap.assert(Math.isfinite(lambdav), "RBFSetAlgoMultiLayer: LambdaV is infinite or NAN")
			alglib.ap.assert(CDbl(lambdav) >= CDbl(0), "RBFSetAlgoMultiLayer: LambdaV<0")
			s.radvalue = rbase
			s.nlayers = nlayers
			s.algorithmtype = 2
			s.lambdav = lambdav
		End Sub


		'************************************************************************
'        This function sets linear term (model is a sum of radial  basis  functions
'        plus linear polynomial). This function won't have effect until  next  call 
'        to RBFBuildModel().
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetlinterm(s As rbfmodel)
			s.aterm = 1
		End Sub


		'************************************************************************
'        This function sets constant term (model is a sum of radial basis functions
'        plus constant).  This  function  won't  have  effect  until  next  call to 
'        RBFBuildModel().
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetconstterm(s As rbfmodel)
			s.aterm = 2
		End Sub


		'************************************************************************
'        This  function  sets  zero  term (model is a sum of radial basis functions 
'        without polynomial term). This function won't have effect until next  call
'        to RBFBuildModel().
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetzeroterm(s As rbfmodel)
			s.aterm = 3
		End Sub


		'************************************************************************
'        This function sets stopping criteria of the underlying linear solver.
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'            EpsOrt  -   orthogonality stopping criterion, EpsOrt>=0. Algorithm will
'                        stop when ||A'*r||<=EpsOrt where A' is a transpose of  the 
'                        system matrix, r is a residual vector.
'                        Recommended value of EpsOrt is equal to 1E-6.
'                        This criterion will stop algorithm when we have "bad fit"
'                        situation, i.e. when we should stop in a point with large,
'                        nonzero residual.
'            EpsErr  -   residual stopping  criterion.  Algorithm  will  stop  when
'                        ||r||<=EpsErr*||b||, where r is a residual vector, b is  a
'                        right part of the system (function values).
'                        Recommended value of EpsErr is equal to 1E-3 or 1E-6.
'                        This  criterion  will  stop  algorithm  in  a  "good  fit" 
'                        situation when we have near-zero residual near the desired
'                        solution.
'            MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
'                        It should be used for debugging purposes only!
'                        Zero MaxIts means that no limit is placed on the number of
'                        iterations.
'
'        We  recommend  to  set  moderate  non-zero  values   EpsOrt   and   EpsErr 
'        simultaneously. Values equal to 10E-6 are good to start with. In case  you
'        need high performance and do not need high precision ,  you  may  decrease
'        EpsErr down to 0.001. However, we do not recommend decreasing EpsOrt.
'
'        As for MaxIts, we recommend to leave it zero unless you know what you do.
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfsetcond(s As rbfmodel, epsort As Double, epserr As Double, maxits As Integer)
			alglib.ap.assert(Math.isfinite(epsort) AndAlso CDbl(epsort) >= CDbl(0), "RBFSetCond: EpsOrt is negative, INF or NAN")
			alglib.ap.assert(Math.isfinite(epserr) AndAlso CDbl(epserr) >= CDbl(0), "RBFSetCond: EpsB is negative, INF or NAN")
			alglib.ap.assert(maxits >= 0, "RBFSetCond: MaxIts is negative")
			If (CDbl(epsort) = CDbl(0) AndAlso CDbl(epserr) = CDbl(0)) AndAlso maxits = 0 Then
				s.epsort = eps
				s.epserr = eps
				s.maxits = 0
			Else
				s.epsort = epsort
				s.epserr = epserr
				s.maxits = maxits
			End If
		End Sub


		'************************************************************************
'        This   function  builds  RBF  model  and  returns  report  (contains  some 
'        information which can be used for evaluation of the algorithm properties).
'
'        Call to this function modifies RBF model by calculating its centers/radii/
'        weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel 
'        contain zero coefficients, but after call to this function  we  will  have
'        coefficients which were calculated in order to fit our dataset.
'
'        After you called this function you can call RBFCalc(),  RBFGridCalc()  and
'        other model calculation functions.
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'            Rep     -   report:
'                        * Rep.TerminationType:
'                          * -5 - non-distinct basis function centers were detected,
'                                 interpolation aborted
'                          * -4 - nonconvergence of the internal SVD solver
'                          *  1 - successful termination
'                        Fields are used for debugging purposes:
'                        * Rep.IterationsCount - iterations count of the LSQR solver
'                        * Rep.NMV - number of matrix-vector products
'                        * Rep.ARows - rows count for the system matrix
'                        * Rep.ACols - columns count for the system matrix
'                        * Rep.ANNZ - number of significantly non-zero elements
'                          (elements above some algorithm-determined threshold)
'
'        NOTE:  failure  to  build  model will leave current state of the structure
'        unchanged.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfbuildmodel(s As rbfmodel, rep As rbfreport)
			Dim tree As New nearestneighbor.kdtree()
			Dim ctree As New nearestneighbor.kdtree()
			Dim dist As Double() = New Double(-1) {}
			Dim xcx As Double() = New Double(-1) {}
			Dim a As Double(,) = New Double(-1, -1) {}
			Dim v As Double(,) = New Double(-1, -1) {}
			Dim omega As Double(,) = New Double(-1, -1) {}
			Dim y As Double() = New Double(-1) {}
			Dim residualy As Double(,) = New Double(-1, -1) {}
			Dim radius As Double() = New Double(-1) {}
			Dim xc As Double(,) = New Double(-1, -1) {}
			Dim mnx As Double() = New Double(-1) {}
			Dim mxx As Double() = New Double(-1) {}
			Dim edge As Double() = New Double(-1) {}
			Dim mxsteps As Integer() = New Integer(-1) {}
			Dim nc As Integer = 0
			Dim rmax As Double = 0
			Dim tags As Integer() = New Integer(-1) {}
			Dim ctags As Integer() = New Integer(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim k2 As Integer = 0
			Dim snnz As Integer = 0
			Dim tmp0 As Double() = New Double(-1) {}
			Dim tmp1 As Double() = New Double(-1) {}
			Dim layerscnt As Integer = 0

			alglib.ap.assert(s.nx = 2 OrElse s.nx = 3, "RBFBuildModel: S.NX<>2 or S.NX<>3!")

			'
			' Quick exit when we have no points
			'
			If s.n = 0 Then
				rep.terminationtype = 1
				rep.iterationscount = 0
				rep.nmv = 0
				rep.arows = 0
				rep.acols = 0
				nearestneighbor.kdtreebuildtagged(s.xc, tags, 0, mxnx, 0, 2, _
					s.tree)
				s.xc = New Double(-1, -1) {}
				s.wr = New Double(-1, -1) {}
				s.nc = 0
				s.rmax = 0
				s.v = New Double(s.ny - 1, mxnx) {}
				For i = 0 To s.ny - 1
					For j = 0 To mxnx
						s.v(i, j) = 0
					Next
				Next
				Return
			End If

			'
			' General case, N>0
			'
			rep.annz = 0
			rep.iterationscount = 0
			rep.nmv = 0
			xcx = New Double(mxnx - 1) {}

			'
			' First model in a sequence - linear model.
			' Residuals from linear regression are stored in the ResidualY variable
			' (used later to build RBF models).
			'
			residualy = New Double(s.n - 1, s.ny - 1) {}
			For i = 0 To s.n - 1
				For j = 0 To s.ny - 1
					residualy(i, j) = s.y(i, j)
				Next
			Next
			If Not buildlinearmodel(s.x, residualy, s.n, s.ny, s.aterm, v) Then
				rep.terminationtype = -5
				Return
			End If

			'
			' Handle special case: multilayer model with NLayers=0.
			' Quick exit.
			'
			If s.algorithmtype = 2 AndAlso s.nlayers = 0 Then
				rep.terminationtype = 1
				rep.iterationscount = 0
				rep.nmv = 0
				rep.arows = 0
				rep.acols = 0
				nearestneighbor.kdtreebuildtagged(s.xc, tags, 0, mxnx, 0, 2, _
					s.tree)
				s.xc = New Double(-1, -1) {}
				s.wr = New Double(-1, -1) {}
				s.nc = 0
				s.rmax = 0
				s.v = New Double(s.ny - 1, mxnx) {}
				For i = 0 To s.ny - 1
					For j = 0 To mxnx
						s.v(i, j) = v(i, j)
					Next
				Next
				Return
			End If

			'
			' Second model in a sequence - RBF term.
			'
			' NOTE: assignments below are not necessary, but without them
			'       MSVC complains about unitialized variables.
			'
			nc = 0
			rmax = 0
			layerscnt = 0
			If s.algorithmtype = 1 Then

				'
				' Add RBF model.
				' This model uses local KD-trees to speed-up nearest neighbor searches.
				'
				If s.gridtype = 1 Then
					mxx = New Double(s.nx - 1) {}
					mnx = New Double(s.nx - 1) {}
					mxsteps = New Integer(s.nx - 1) {}
					edge = New Double(s.nx - 1) {}
					For i = 0 To s.nx - 1
						mxx(i) = s.x(0, i)
						mnx(i) = s.x(0, i)
					Next
					For i = 0 To s.n - 1
						For j = 0 To s.nx - 1
							If CDbl(mxx(j)) < CDbl(s.x(i, j)) Then
								mxx(j) = s.x(i, j)
							End If
							If CDbl(mnx(j)) > CDbl(s.x(i, j)) Then
								mnx(j) = s.x(i, j)
							End If
						Next
					Next
					For i = 0 To s.nx - 1
						mxsteps(i) = CInt(System.Math.Truncate((mxx(i) - mnx(i)) / (2 * s.h))) + 1
						edge(i) = (mxx(i) + mnx(i)) / 2 - s.h * mxsteps(i)
					Next
					nc = 1
					For i = 0 To s.nx - 1
						mxsteps(i) = 2 * mxsteps(i) + 1
						nc = nc * mxsteps(i)
					Next
					xc = New Double(nc - 1, mxnx - 1) {}
					If s.nx = 2 Then
						For i = 0 To mxsteps(0) - 1
							For j = 0 To mxsteps(1) - 1
								For k2 = 0 To mxnx - 1
									xc(i * mxsteps(1) + j, k2) = 0
								Next
								xc(i * mxsteps(1) + j, 0) = edge(0) + s.h * i
								xc(i * mxsteps(1) + j, 1) = edge(1) + s.h * j
							Next
						Next
					End If
					If s.nx = 3 Then
						For i = 0 To mxsteps(0) - 1
							For j = 0 To mxsteps(1) - 1
								For k = 0 To mxsteps(2) - 1
									For k2 = 0 To mxnx - 1
										xc(i * mxsteps(1) + j, k2) = 0
									Next
									xc((i * mxsteps(1) + j) * mxsteps(2) + k, 0) = edge(0) + s.h * i
									xc((i * mxsteps(1) + j) * mxsteps(2) + k, 1) = edge(1) + s.h * j
									xc((i * mxsteps(1) + j) * mxsteps(2) + k, 2) = edge(2) + s.h * k
								Next
							Next
						Next
					End If
				Else
					If s.gridtype = 2 Then
						nc = s.n
						xc = New Double(nc - 1, mxnx - 1) {}
						For i = 0 To nc - 1
							For j = 0 To mxnx - 1
								xc(i, j) = s.x(i, j)
							Next
						Next
					Else
						If s.gridtype = 3 Then
							nc = s.nc
							xc = New Double(nc - 1, mxnx - 1) {}
							For i = 0 To nc - 1
								For j = 0 To mxnx - 1
									xc(i, j) = s.xc(i, j)
								Next
							Next
						Else
							alglib.ap.assert(False, "RBFBuildModel: either S.GridType<1 or S.GridType>3!")
						End If
					End If
				End If
				rmax = 0
				radius = New Double(nc - 1) {}
				ctags = New Integer(nc - 1) {}
				For i = 0 To nc - 1
					ctags(i) = i
				Next
				nearestneighbor.kdtreebuildtagged(xc, ctags, nc, mxnx, 0, 2, _
					ctree)
				If s.fixrad Then

					'
					' Fixed radius
					'
					For i = 0 To nc - 1
						radius(i) = s.radvalue
					Next
					rmax = radius(0)
				Else

					'
					' Dynamic radius
					'
					If nc = 0 Then
						rmax = 1
					Else
						If nc = 1 Then
							radius(0) = s.radvalue
							rmax = radius(0)
						Else

							'
							' NC>1, calculate radii using distances to nearest neigbors
							'
							For i = 0 To nc - 1
								For j = 0 To mxnx - 1
									xcx(j) = xc(i, j)
								Next
								If nearestneighbor.kdtreequeryknn(ctree, xcx, 1, False) > 0 Then
									nearestneighbor.kdtreequeryresultsdistances(ctree, dist)
									radius(i) = s.radvalue * dist(0)
								Else

									'
									' No neighbors found (it will happen when we have only one center).
									' Initialize radius with default value.
									'
									radius(i) = 1.0
								End If
							Next

							'
							' Apply filtering
							'
							apserv.rvectorsetlengthatleast(tmp0, nc)
							For i = 0 To nc - 1
								tmp0(i) = radius(i)
							Next
							tsort.tagsortfast(tmp0, tmp1, nc)
							For i = 0 To nc - 1
								radius(i) = System.Math.Min(radius(i), s.radzvalue * tmp0(nc \ 2))
							Next

							'
							' Calculate RMax, check that all radii are non-zero
							'
							For i = 0 To nc - 1
								rmax = System.Math.Max(rmax, radius(i))
							Next
							For i = 0 To nc - 1
								If CDbl(radius(i)) = CDbl(0) Then
									rep.terminationtype = -5
									Return
								End If
							Next
						End If
					End If
				End If
				apserv.ivectorsetlengthatleast(tags, s.n)
				For i = 0 To s.n - 1
					tags(i) = i
				Next
				nearestneighbor.kdtreebuildtagged(s.x, tags, s.n, mxnx, 0, 2, _
					tree)
				buildrbfmodellsqr(s.x, residualy, xc, radius, s.n, nc, _
					s.ny, tree, ctree, s.epsort, s.epserr, s.maxits, _
					rep.annz, snnz, omega, rep.terminationtype, rep.iterationscount, rep.nmv)
				layerscnt = 1
			Else
				If s.algorithmtype = 2 Then
					rmax = s.radvalue
					buildrbfmlayersmodellsqr(s.x, residualy, xc, s.radvalue, radius, s.n, _
						nc, s.ny, s.nlayers, ctree, 1E-06, 1E-06, _
						50, s.lambdav, rep.annz, omega, rep.terminationtype, rep.iterationscount, _
						rep.nmv)
					layerscnt = s.nlayers
				Else
					alglib.ap.assert(False, "RBFBuildModel: internal error(AlgorithmType neither 1 nor 2)")
				End If
			End If
			If rep.terminationtype <= 0 Then
				Return
			End If

			'
			' Model is built
			'
			s.nc = nc \ layerscnt
			s.rmax = rmax
			s.nl = layerscnt
			s.xc = New Double(s.nc - 1, mxnx - 1) {}
			s.wr = New Double(s.nc - 1, 1 + (s.nl * s.ny - 1)) {}
			s.v = New Double(s.ny - 1, mxnx) {}
			For i = 0 To s.nc - 1
				For j = 0 To mxnx - 1
					s.xc(i, j) = xc(i, j)
				Next
			Next
			apserv.ivectorsetlengthatleast(tags, s.nc)
			For i = 0 To s.nc - 1
				tags(i) = i
			Next
			nearestneighbor.kdtreebuildtagged(s.xc, tags, s.nc, mxnx, 0, 2, _
				s.tree)
			For i = 0 To s.nc - 1
				s.wr(i, 0) = radius(i)
				For k = 0 To layerscnt - 1
					For j = 0 To s.ny - 1
						s.wr(i, 1 + k * s.ny + j) = omega(k * s.nc + i, j)
					Next
				Next
			Next
			For i = 0 To s.ny - 1
				For j = 0 To mxnx
					s.v(i, j) = v(i, j)
				Next
			Next
			rep.terminationtype = 1
			rep.arows = s.n
			rep.acols = s.nc
		End Sub


		'************************************************************************
'        This function calculates values of the RBF model in the given point.
'
'        This function should be used when we have NY=1 (scalar function) and  NX=2
'        (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
'        you have general situation (NX-dimensional space, NY-dimensional function)
'        you should use general, less efficient implementation RBFCalc().
'
'        If  you  want  to  calculate  function  values  many times, consider using 
'        RBFGridCalc2(), which is far more efficient than many subsequent calls  to
'        RBFCalc2().
'
'        This function returns 0.0 when:
'        * model is not initialized
'        * NX<>2
'         *NY<>1
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'            X0      -   first coordinate, finite number
'            X1      -   second coordinate, finite number
'
'        RESULT:
'            value of the model or 0.0 (as defined above)
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function rbfcalc2(s As rbfmodel, x0 As Double, x1 As Double) As Double
			Dim result As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lx As Integer = 0
			Dim tg As Integer = 0
			Dim d2 As Double = 0
			Dim t As Double = 0
			Dim bfcur As Double = 0
			Dim rcur As Double = 0

			alglib.ap.assert(Math.isfinite(x0), "RBFCalc2: invalid value for X0 (X0 is Inf)!")
			alglib.ap.assert(Math.isfinite(x1), "RBFCalc2: invalid value for X1 (X1 is Inf)!")
			If s.ny <> 1 OrElse s.nx <> 2 Then
				result = 0
				Return result
			End If
			result = s.v(0, 0) * x0 + s.v(0, 1) * x1 + s.v(0, mxnx)
			If s.nc = 0 Then
				Return result
			End If
			apserv.rvectorsetlengthatleast(s.calcbufxcx, mxnx)
			For i = 0 To mxnx - 1
				s.calcbufxcx(i) = 0.0
			Next
			s.calcbufxcx(0) = x0
			s.calcbufxcx(1) = x1
			lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax * rbffarradius, True)
			nearestneighbor.kdtreequeryresultsx(s.tree, s.calcbufx)
			nearestneighbor.kdtreequeryresultstags(s.tree, s.calcbuftags)
			For i = 0 To lx - 1
				tg = s.calcbuftags(i)
				d2 = Math.sqr(x0 - s.calcbufx(i, 0)) + Math.sqr(x1 - s.calcbufx(i, 1))
				rcur = s.wr(tg, 0)
				bfcur = System.Math.Exp(-(d2 / (rcur * rcur)))
				For j = 0 To s.nl - 1
					result = result + bfcur * s.wr(tg, 1 + j)
					rcur = 0.5 * rcur
					t = bfcur * bfcur
					bfcur = t * t
				Next
			Next
			Return result
		End Function


		'************************************************************************
'        This function calculates values of the RBF model in the given point.
'
'        This function should be used when we have NY=1 (scalar function) and  NX=3
'        (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
'        you have general situation (NX-dimensional space, NY-dimensional function)
'        you should use general, less efficient implementation RBFCalc().
'
'        This function returns 0.0 when:
'        * model is not initialized
'        * NX<>3
'         *NY<>1
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'            X0      -   first coordinate, finite number
'            X1      -   second coordinate, finite number
'            X2      -   third coordinate, finite number
'
'        RESULT:
'            value of the model or 0.0 (as defined above)
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function rbfcalc3(s As rbfmodel, x0 As Double, x1 As Double, x2 As Double) As Double
			Dim result As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim lx As Integer = 0
			Dim tg As Integer = 0
			Dim t As Double = 0
			Dim rcur As Double = 0
			Dim bf As Double = 0

			alglib.ap.assert(Math.isfinite(x0), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!")
			alglib.ap.assert(Math.isfinite(x1), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!")
			alglib.ap.assert(Math.isfinite(x2), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!")
			If s.ny <> 1 OrElse s.nx <> 3 Then
				result = 0
				Return result
			End If
			result = s.v(0, 0) * x0 + s.v(0, 1) * x1 + s.v(0, 2) * x2 + s.v(0, mxnx)
			If s.nc = 0 Then
				Return result
			End If

			'
			' calculating value for F(X)
			'
			apserv.rvectorsetlengthatleast(s.calcbufxcx, mxnx)
			For i = 0 To mxnx - 1
				s.calcbufxcx(i) = 0.0
			Next
			s.calcbufxcx(0) = x0
			s.calcbufxcx(1) = x1
			s.calcbufxcx(2) = x2
			lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax * rbffarradius, True)
			nearestneighbor.kdtreequeryresultsx(s.tree, s.calcbufx)
			nearestneighbor.kdtreequeryresultstags(s.tree, s.calcbuftags)
			For i = 0 To lx - 1
				tg = s.calcbuftags(i)
				rcur = s.wr(tg, 0)
				bf = System.Math.Exp(-((Math.sqr(x0 - s.calcbufx(i, 0)) + Math.sqr(x1 - s.calcbufx(i, 1)) + Math.sqr(x2 - s.calcbufx(i, 2))) / Math.sqr(rcur)))
				For j = 0 To s.nl - 1
					result = result + bf * s.wr(tg, 1 + j)
					t = bf * bf
					bf = t * t
				Next
			Next
			Return result
		End Function


		'************************************************************************
'        This function calculates values of the RBF model at the given point.
'
'        This is general function which can be used for arbitrary NX (dimension  of 
'        the space of arguments) and NY (dimension of the function itself). However
'        when  you  have  NY=1  you  may  find more convenient to use RBFCalc2() or 
'        RBFCalc3().
'
'        This function returns 0.0 when model is not initialized.
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'            X       -   coordinates, array[NX].
'                        X may have more than NX elements, in this case only 
'                        leading NX will be used.
'
'        OUTPUT PARAMETERS:
'            Y       -   function value, array[NY]. Y is out-parameter and 
'                        reallocated after call to this function. In case you  want
'                        to reuse previously allocated Y, you may use RBFCalcBuf(),
'                        which reallocates Y only when it is too small.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfcalc(s As rbfmodel, x As Double(), ByRef y As Double())
			y = New Double(-1) {}

			alglib.ap.assert(alglib.ap.len(x) >= s.nx, "RBFCalc: Length(X)<NX")
			alglib.ap.assert(apserv.isfinitevector(x, s.nx), "RBFCalc: X contains infinite or NaN values")
			rbfcalcbuf(s, x, y)
		End Sub


		'************************************************************************
'        This function calculates values of the RBF model at the given point.
'
'        Same as RBFCalc(), but does not reallocate Y when in is large enough to 
'        store function values.
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'            X       -   coordinates, array[NX].
'                        X may have more than NX elements, in this case only 
'                        leading NX will be used.
'            Y       -   possibly preallocated array
'
'        OUTPUT PARAMETERS:
'            Y       -   function value, array[NY]. Y is not reallocated when it
'                        is larger than NY.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfcalcbuf(s As rbfmodel, x As Double(), ByRef y As Double())
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim lx As Integer = 0
			Dim tg As Integer = 0
			Dim t As Double = 0
			Dim rcur As Double = 0
			Dim bf As Double = 0

			alglib.ap.assert(alglib.ap.len(x) >= s.nx, "RBFCalcBuf: Length(X)<NX")
			alglib.ap.assert(apserv.isfinitevector(x, s.nx), "RBFCalcBuf: X contains infinite or NaN values")
			If alglib.ap.len(y) < s.ny Then
				y = New Double(s.ny - 1) {}
			End If
			For i = 0 To s.ny - 1
				y(i) = s.v(i, mxnx)
				For j = 0 To s.nx - 1
					y(i) = y(i) + s.v(i, j) * x(j)
				Next
			Next
			If s.nc = 0 Then
				Return
			End If
			apserv.rvectorsetlengthatleast(s.calcbufxcx, mxnx)
			For i = 0 To mxnx - 1
				s.calcbufxcx(i) = 0.0
			Next
			For i = 0 To s.nx - 1
				s.calcbufxcx(i) = x(i)
			Next
			lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax * rbffarradius, True)
			nearestneighbor.kdtreequeryresultsx(s.tree, s.calcbufx)
			nearestneighbor.kdtreequeryresultstags(s.tree, s.calcbuftags)
			For i = 0 To s.ny - 1
				For j = 0 To lx - 1
					tg = s.calcbuftags(j)
					rcur = s.wr(tg, 0)
					bf = System.Math.Exp(-((Math.sqr(s.calcbufxcx(0) - s.calcbufx(j, 0)) + Math.sqr(s.calcbufxcx(1) - s.calcbufx(j, 1)) + Math.sqr(s.calcbufxcx(2) - s.calcbufx(j, 2))) / Math.sqr(rcur)))
					For k = 0 To s.nl - 1
						y(i) = y(i) + bf * s.wr(tg, 1 + k * s.ny + i)
						t = bf * bf
						bf = t * t
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        This function calculates values of the RBF model at the regular grid.
'
'        Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])
'
'        This function returns 0.0 when:
'        * model is not initialized
'        * NX<>2
'         *NY<>1
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'            X0      -   array of grid nodes, first coordinates, array[N0]
'            N0      -   grid size (number of nodes) in the first dimension
'            X1      -   array of grid nodes, second coordinates, array[N1]
'            N1      -   grid size (number of nodes) in the second dimension
'
'        OUTPUT PARAMETERS:
'            Y       -   function values, array[N0,N1]. Y is out-variable and 
'                        is reallocated by this function.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfgridcalc2(s As rbfmodel, x0 As Double(), n0 As Integer, x1 As Double(), n1 As Integer, ByRef y As Double(,))
			Dim cpx0 As Double() = New Double(-1) {}
			Dim cpx1 As Double() = New Double(-1) {}
			Dim p01 As Integer() = New Integer(-1) {}
			Dim p11 As Integer() = New Integer(-1) {}
			Dim p2 As Integer() = New Integer(-1) {}
			Dim rlimit As Double = 0
			Dim xcnorm2 As Double = 0
			Dim hp01 As Integer = 0
			Dim hcpx0 As Double = 0
			Dim xc0 As Double = 0
			Dim xc1 As Double = 0
			Dim omega As Double = 0
			Dim radius As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim d As Integer = 0
			Dim i00 As Integer = 0
			Dim i01 As Integer = 0
			Dim i10 As Integer = 0
			Dim i11 As Integer = 0

			y = New Double(-1, -1) {}

			alglib.ap.assert(n0 > 0, "RBFGridCalc2: invalid value for N0 (N0<=0)!")
			alglib.ap.assert(n1 > 0, "RBFGridCalc2: invalid value for N1 (N1<=0)!")
			alglib.ap.assert(alglib.ap.len(x0) >= n0, "RBFGridCalc2: Length(X0)<N0")
			alglib.ap.assert(alglib.ap.len(x1) >= n1, "RBFGridCalc2: Length(X1)<N1")
			alglib.ap.assert(apserv.isfinitevector(x0, n0), "RBFGridCalc2: X0 contains infinite or NaN values!")
			alglib.ap.assert(apserv.isfinitevector(x1, n1), "RBFGridCalc2: X1 contains infinite or NaN values!")
			y = New Double(n0 - 1, n1 - 1) {}
			For i = 0 To n0 - 1
				For j = 0 To n1 - 1
					y(i, j) = 0
				Next
			Next
			If (s.ny <> 1 OrElse s.nx <> 2) OrElse s.nc = 0 Then
				Return
			End If

			'
			'create and sort arrays
			'
			cpx0 = New Double(n0 - 1) {}
			For i = 0 To n0 - 1
				cpx0(i) = x0(i)
			Next
			tsort.tagsort(cpx0, n0, p01, p2)
			cpx1 = New Double(n1 - 1) {}
			For i = 0 To n1 - 1
				cpx1(i) = x1(i)
			Next
			tsort.tagsort(cpx1, n1, p11, p2)

			'
			'calculate function's value
			'
			For i = 0 To s.nc - 1
				radius = s.wr(i, 0)
				For d = 0 To s.nl - 1
					omega = s.wr(i, 1 + d)
					rlimit = radius * rbffarradius

					'
					'search lower and upper indexes
					'
					i00 = tsort.lowerbound(cpx0, n0, s.xc(i, 0) - rlimit)
					i01 = tsort.upperbound(cpx0, n0, s.xc(i, 0) + rlimit)
					i10 = tsort.lowerbound(cpx1, n1, s.xc(i, 1) - rlimit)
					i11 = tsort.upperbound(cpx1, n1, s.xc(i, 1) + rlimit)
					xc0 = s.xc(i, 0)
					xc1 = s.xc(i, 1)
					For j = i00 To i01 - 1
						hcpx0 = cpx0(j)
						hp01 = p01(j)
						For k = i10 To i11 - 1
							xcnorm2 = Math.sqr(hcpx0 - xc0) + Math.sqr(cpx1(k) - xc1)
							If CDbl(xcnorm2) <= CDbl(rlimit * rlimit) Then
								y(hp01, p11(k)) = y(hp01, p11(k)) + System.Math.Exp(-(xcnorm2 / Math.sqr(radius))) * omega
							End If
						Next
					Next
					radius = 0.5 * radius
				Next
			Next

			'
			'add linear term
			'
			For i = 0 To n0 - 1
				For j = 0 To n1 - 1
					y(i, j) = y(i, j) + s.v(0, 0) * x0(i) + s.v(0, 1) * x1(j) + s.v(0, mxnx)
				Next
			Next
		End Sub


		'************************************************************************
'        This function "unpacks" RBF model by extracting its coefficients.
'
'        INPUT PARAMETERS:
'            S       -   RBF model
'
'        OUTPUT PARAMETERS:
'            NX      -   dimensionality of argument
'            NY      -   dimensionality of the target function
'            XWR     -   model information, array[NC,NX+NY+1].
'                        One row of the array corresponds to one basis function:
'                        * first NX columns  - coordinates of the center 
'                        * next NY columns   - weights, one per dimension of the 
'                                              function being modelled
'                        * last column       - radius, same for all dimensions of
'                                              the function being modelled
'            NC      -   number of the centers
'            V       -   polynomial  term , array[NY,NX+1]. One row per one 
'                        dimension of the function being modelled. First NX 
'                        elements are linear coefficients, V[NX] is equal to the 
'                        constant part.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfunpack(s As rbfmodel, ByRef nx As Integer, ByRef ny As Integer, ByRef xwr As Double(,), ByRef nc As Integer, ByRef v As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim rcur As Double = 0
			Dim i_ As Integer = 0
			Dim i1_ As Integer = 0

			nx = 0
			ny = 0
			xwr = New Double(-1, -1) {}
			nc = 0
			v = New Double(-1, -1) {}

			nx = s.nx
			ny = s.ny
			nc = s.nc

			'
			' Fill V
			'
			v = New Double(s.ny - 1, s.nx) {}
			For i = 0 To s.ny - 1
				For i_ = 0 To s.nx - 1
					v(i, i_) = s.v(i, i_)
				Next
				v(i, s.nx) = s.v(i, mxnx)
			Next

			'
			' Fill XWR and V
			'
			If nc * s.nl > 0 Then
				xwr = New Double(s.nc * s.nl - 1, s.nx + s.ny) {}
				For i = 0 To s.nc - 1
					rcur = s.wr(i, 0)
					For j = 0 To s.nl - 1
						For i_ = 0 To s.nx - 1
							xwr(i * s.nl + j, i_) = s.xc(i, i_)
						Next
						i1_ = (1 + j * s.ny) - (s.nx)
						For i_ = s.nx To s.nx + s.ny - 1
							xwr(i * s.nl + j, i_) = s.wr(i, i_ + i1_)
						Next
						xwr(i * s.nl + j, s.nx + s.ny) = rcur
						rcur = 0.5 * rcur
					Next
				Next
			End If
		End Sub


		'************************************************************************
'        Serializer: allocation
'
'          -- ALGLIB --
'             Copyright 02.02.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfalloc(s As alglib.serializer, model As rbfmodel)

			'
			' Header
			'
			s.alloc_entry()
			s.alloc_entry()

			'
			' Data
			'
			s.alloc_entry()
			s.alloc_entry()
			s.alloc_entry()
			s.alloc_entry()
			nearestneighbor.kdtreealloc(s, model.tree)
			apserv.allocrealmatrix(s, model.xc, -1, -1)
			apserv.allocrealmatrix(s, model.wr, -1, -1)
			s.alloc_entry()
			apserv.allocrealmatrix(s, model.v, -1, -1)
		End Sub


		'************************************************************************
'        Serializer: serialization
'
'          -- ALGLIB --
'             Copyright 02.02.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfserialize(s As alglib.serializer, model As rbfmodel)

			'
			' Header
			'
			s.serialize_int(scodes.getrbfserializationcode())
			s.serialize_int(rbffirstversion)

			'
			' Data
			'
			s.serialize_int(model.nx)
			s.serialize_int(model.ny)
			s.serialize_int(model.nc)
			s.serialize_int(model.nl)
			nearestneighbor.kdtreeserialize(s, model.tree)
			apserv.serializerealmatrix(s, model.xc, -1, -1)
			apserv.serializerealmatrix(s, model.wr, -1, -1)
			s.serialize_double(model.rmax)
			apserv.serializerealmatrix(s, model.v, -1, -1)
		End Sub


		'************************************************************************
'        Serializer: unserialization
'
'          -- ALGLIB --
'             Copyright 02.02.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub rbfunserialize(s As alglib.serializer, model As rbfmodel)
			Dim i0 As Integer = 0
			Dim i1 As Integer = 0
			Dim nx As Integer = 0
			Dim ny As Integer = 0


			'
			' Header
			'
			i0 = s.unserialize_int()
			alglib.ap.assert(i0 = scodes.getrbfserializationcode(), "RBFUnserialize: stream header corrupted")
			i1 = s.unserialize_int()
			alglib.ap.assert(i1 = rbffirstversion, "RBFUnserialize: stream header corrupted")

			'
			' Unserialize primary model parameters, initialize model.
			'
			' It is necessary to call RBFCreate() because some internal fields
			' which are NOT unserialized will need initialization.
			'
			nx = s.unserialize_int()
			ny = s.unserialize_int()
			rbfcreate(nx, ny, model)
			model.nc = s.unserialize_int()
			model.nl = s.unserialize_int()
			nearestneighbor.kdtreeunserialize(s, model.tree)
			apserv.unserializerealmatrix(s, model.xc)
			apserv.unserializerealmatrix(s, model.wr)
			model.rmax = s.unserialize_double()
			apserv.unserializerealmatrix(s, model.v)
		End Sub


		'************************************************************************
'        This function changes centers allocation algorithm to one which  allocates
'        centers exactly at the dataset points (one input point = one center). This
'        function won't have effect until next call to RBFBuildModel().
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rbfgridpoints(s As rbfmodel)
			s.gridtype = 2
		End Sub


		'************************************************************************
'        This function changes radii  calculation  algorithm  to  one  which  makes
'        radius for I-th node equal to R[i]=DistNN[i]*Q, where:
'        * R[i] is a radius calculated by the algorithm
'        * DistNN[i] is distance from I-th center to its nearest neighbor center
'        * Q is a scale parameter, which should be within [0.75,1.50], with
'          recommended value equal to 1.0
'        * after performing radii calculation, radii are transformed  in  order  to
'          avoid situation when single outlier has very large radius and influences
'          many points across entire dataset. Transformation has following form:
'               new_r[i] = min(r[i],Z*median(r[]))
'           where r[i] is I-th radius, median()  is  a median  radius across entire
'           dataset, Z is user-specified value which controls amount  of  deviation
'           from median radius.
'
'        This function won't have effect until next call to RBFBuildModel().
'
'        The idea behind this algorithm is to choose radii corresponding  to  basis
'        functions is such way that I-th radius is approximately equal to  distance
'        from I-th center to its nearest neighbor. In this case  interactions  with
'        distant points will be insignificant, and we  will  get  well  conditioned
'        basis.
'
'        Properties of this basis depend on the value of Q:
'        * Q<0.75 will give perfectly conditioned basis,  but  terrible  smoothness
'          properties (RBF interpolant will have sharp peaks around function values)
'        * Q>1.5 will lead to badly conditioned systems and slow convergence of the
'          underlying linear solver (although smoothness will be very good)
'        * Q around 1.0 gives good balance between smoothness and condition number
'
'
'        INPUT PARAMETERS:
'            S       -   RBF model, initialized by RBFCreate() call
'            Q       -   radius coefficient, Q>0
'            Z       -   z-parameter, Z>0
'            
'        Default value of Q is equal to 1.0
'        Default value of Z is equal to 5.0
'
'        NOTE: this   function  has   some   serialization-related  subtleties.  We
'              recommend you to study serialization examples from ALGLIB  Reference
'              Manual if you want to perform serialization of your models.
'
'          -- ALGLIB --
'             Copyright 13.12.2011 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub rbfradnn(s As rbfmodel, q As Double, z As Double)
			alglib.ap.assert(Math.isfinite(q) AndAlso CDbl(q) > CDbl(0), "RBFRadNN: Q<=0, infinite or NAN")
			alglib.ap.assert(Math.isfinite(z) AndAlso CDbl(z) > CDbl(0), "RBFRadNN: Z<=0, infinite or NAN")
			s.fixrad = False
			s.radvalue = q
			s.radzvalue = z
		End Sub


		Private Shared Function buildlinearmodel(x As Double(,), ByRef y As Double(,), n As Integer, ny As Integer, modeltype As Integer, ByRef v As Double(,)) As Boolean
			Dim result As New Boolean()
			Dim tmpy As Double() = New Double(-1) {}
			Dim a As Double(,) = New Double(-1, -1) {}
			Dim scaling As Double = 0
			Dim shifting As Double() = New Double(-1) {}
			Dim mn As Double = 0
			Dim mx As Double = 0
			Dim c As Double() = New Double(-1) {}
			Dim rep As New lsfit.lsfitreport()
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim info As Integer = 0

			v = New Double(-1, -1) {}

			alglib.ap.assert(n >= 0, "BuildLinearModel: N<0")
			alglib.ap.assert(ny > 0, "BuildLinearModel: NY<=0")

			'
			' Handle degenerate case (N=0)
			'
			result = True
			v = New Double(ny - 1, mxnx) {}
			If n = 0 Then
				For j = 0 To mxnx
					For i = 0 To ny - 1
						v(i, j) = 0
					Next
				Next
				Return result
			End If

			'
			' Allocate temporaries
			'
			tmpy = New Double(n - 1) {}

			'
			' General linear model.
			'
			If modeltype = 1 Then

				'
				' Calculate scaling/shifting, transform variables, prepare LLS problem
				'
				a = New Double(n - 1, mxnx) {}
				shifting = New Double(mxnx - 1) {}
				scaling = 0
				For i = 0 To mxnx - 1
					mn = x(0, i)
					mx = mn
					For j = 1 To n - 1
						If CDbl(mn) > CDbl(x(j, i)) Then
							mn = x(j, i)
						End If
						If CDbl(mx) < CDbl(x(j, i)) Then
							mx = x(j, i)
						End If
					Next
					scaling = System.Math.Max(scaling, mx - mn)
					shifting(i) = 0.5 * (mx + mn)
				Next
				If CDbl(scaling) = CDbl(0) Then
					scaling = 1
				Else
					scaling = 0.5 * scaling
				End If
				For i = 0 To n - 1
					For j = 0 To mxnx - 1
						a(i, j) = (x(i, j) - shifting(j)) / scaling
					Next
				Next
				For i = 0 To n - 1
					a(i, mxnx) = 1
				Next

				'
				' Solve linear system in transformed variables, make backward 
				'
				For i = 0 To ny - 1
					For j = 0 To n - 1
						tmpy(j) = y(j, i)
					Next
					lsfit.lsfitlinear(tmpy, a, n, mxnx + 1, info, c, _
						rep)
					If info <= 0 Then
						result = False
						Return result
					End If
					For j = 0 To mxnx - 1
						v(i, j) = c(j) / scaling
					Next
					v(i, mxnx) = c(mxnx)
					For j = 0 To mxnx - 1
						v(i, mxnx) = v(i, mxnx) - shifting(j) * v(i, j)
					Next
					For j = 0 To n - 1
						For k = 0 To mxnx - 1
							y(j, i) = y(j, i) - x(j, k) * v(i, k)
						Next
						y(j, i) = y(j, i) - v(i, mxnx)
					Next
				Next
				Return result
			End If

			'
			' Constant model, very simple
			'
			If modeltype = 2 Then
				For i = 0 To ny - 1
					For j = 0 To mxnx
						v(i, j) = 0
					Next
					For j = 0 To n - 1
						v(i, mxnx) = v(i, mxnx) + y(j, i)
					Next
					If n > 0 Then
						v(i, mxnx) = v(i, mxnx) / n
					End If
					For j = 0 To n - 1
						y(j, i) = y(j, i) - v(i, mxnx)
					Next
				Next
				Return result
			End If

			'
			' Zero model
			'
			alglib.ap.assert(modeltype = 3, "BuildLinearModel: unknown model type")
			For i = 0 To ny - 1
				For j = 0 To mxnx
					v(i, j) = 0
				Next
			Next
			Return result
		End Function


		Private Shared Sub buildrbfmodellsqr(x As Double(,), ByRef y As Double(,), xc As Double(,), r As Double(), n As Integer, nc As Integer, _
			ny As Integer, pointstree As nearestneighbor.kdtree, centerstree As nearestneighbor.kdtree, epsort As Double, epserr As Double, maxits As Integer, _
			ByRef gnnz As Integer, ByRef snnz As Integer, ByRef w As Double(,), ByRef info As Integer, ByRef iterationscount As Integer, ByRef nmv As Integer)
			Dim state As New linlsqr.linlsqrstate()
			Dim lsqrrep As New linlsqr.linlsqrreport()
			Dim spg As New sparse.sparsematrix()
			Dim sps As New sparse.sparsematrix()
			Dim nearcenterscnt As Integer() = New Integer(-1) {}
			Dim nearpointscnt As Integer() = New Integer(-1) {}
			Dim skipnearpointscnt As Integer() = New Integer(-1) {}
			Dim farpointscnt As Integer() = New Integer(-1) {}
			Dim maxnearcenterscnt As Integer = 0
			Dim maxnearpointscnt As Integer = 0
			Dim maxfarpointscnt As Integer = 0
			Dim sumnearcenterscnt As Integer = 0
			Dim sumnearpointscnt As Integer = 0
			Dim sumfarpointscnt As Integer = 0
			Dim maxrad As Double = 0
			Dim pointstags As Integer() = New Integer(-1) {}
			Dim centerstags As Integer() = New Integer(-1) {}
			Dim nearpoints As Double(,) = New Double(-1, -1) {}
			Dim nearcenters As Double(,) = New Double(-1, -1) {}
			Dim farpoints As Double(,) = New Double(-1, -1) {}
			Dim tmpi As Integer = 0
			Dim pointscnt As Integer = 0
			Dim centerscnt As Integer = 0
			Dim xcx As Double() = New Double(-1) {}
			Dim tmpy As Double() = New Double(-1) {}
			Dim tc As Double() = New Double(-1) {}
			Dim g As Double() = New Double(-1) {}
			Dim c As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim sind As Integer = 0
			Dim a As Double(,) = New Double(-1, -1) {}
			Dim vv As Double = 0
			Dim vx As Double = 0
			Dim vy As Double = 0
			Dim vz As Double = 0
			Dim vr As Double = 0
			Dim gnorm2 As Double = 0
			Dim tmp0 As Double() = New Double(-1) {}
			Dim tmp1 As Double() = New Double(-1) {}
			Dim tmp2 As Double() = New Double(-1) {}
			Dim fx As Double = 0
			Dim xx As Double(,) = New Double(-1, -1) {}
			Dim cx As Double(,) = New Double(-1, -1) {}
			Dim mrad As Double = 0
			Dim i_ As Integer = 0

			gnnz = 0
			snnz = 0
			w = New Double(-1, -1) {}
			info = 0
			iterationscount = 0
			nmv = 0


			'
			' Handle special cases: NC=0
			'
			If nc = 0 Then
				info = 1
				iterationscount = 0
				nmv = 0
				Return
			End If

			'
			' Prepare for general case, NC>0
			'
			xcx = New Double(mxnx - 1) {}
			pointstags = New Integer(n - 1) {}
			centerstags = New Integer(nc - 1) {}
			info = -1
			iterationscount = 0
			nmv = 0

			'
			' This block prepares quantities used to compute approximate cardinal basis functions (ACBFs):
			' * NearCentersCnt[]   -   array[NC], whose elements store number of near centers used to build ACBF
			' * NearPointsCnt[]    -   array[NC], number of near points used to build ACBF
			' * FarPointsCnt[]     -   array[NC], number of far points (ones where ACBF is nonzero)
			' * MaxNearCentersCnt  -   max(NearCentersCnt)
			' * MaxNearPointsCnt   -   max(NearPointsCnt)
			' * SumNearCentersCnt  -   sum(NearCentersCnt)
			' * SumNearPointsCnt   -   sum(NearPointsCnt)
			' * SumFarPointsCnt    -   sum(FarPointsCnt)
			'
			nearcenterscnt = New Integer(nc - 1) {}
			nearpointscnt = New Integer(nc - 1) {}
			skipnearpointscnt = New Integer(nc - 1) {}
			farpointscnt = New Integer(nc - 1) {}
			maxnearcenterscnt = 0
			maxnearpointscnt = 0
			maxfarpointscnt = 0
			sumnearcenterscnt = 0
			sumnearpointscnt = 0
			sumfarpointscnt = 0
			For i = 0 To nc - 1
				For j = 0 To mxnx - 1
					xcx(j) = xc(i, j)
				Next

				'
				' Determine number of near centers and maximum radius of near centers
				'
				nearcenterscnt(i) = nearestneighbor.kdtreequeryrnn(centerstree, xcx, r(i) * rbfnearradius, True)
				nearestneighbor.kdtreequeryresultstags(centerstree, centerstags)
				maxrad = 0
				For j = 0 To nearcenterscnt(i) - 1
					maxrad = System.Math.Max(maxrad, System.Math.Abs(r(centerstags(j))))
				Next

				'
				' Determine number of near points (ones which used to build ACBF)
				' and skipped points (the most near points which are NOT used to build ACBF
				' and are NOT included in the near points count
				'
				skipnearpointscnt(i) = nearestneighbor.kdtreequeryrnn(pointstree, xcx, 0.1 * r(i), True)
				nearpointscnt(i) = nearestneighbor.kdtreequeryrnn(pointstree, xcx, (r(i) + maxrad) * rbfnearradius, True) - skipnearpointscnt(i)
				alglib.ap.assert(nearpointscnt(i) >= 0, "BuildRBFModelLSQR: internal error")

				'
				' Determine number of far points
				'
				farpointscnt(i) = nearestneighbor.kdtreequeryrnn(pointstree, xcx, System.Math.Max(r(i) * rbfnearradius + maxrad * rbffarradius, r(i) * rbffarradius), True)

				'
				' calculate sum and max, make some basic checks
				'
				alglib.ap.assert(nearcenterscnt(i) > 0, "BuildRBFModelLSQR: internal error")
				maxnearcenterscnt = System.Math.Max(maxnearcenterscnt, nearcenterscnt(i))
				maxnearpointscnt = System.Math.Max(maxnearpointscnt, nearpointscnt(i))
				maxfarpointscnt = System.Math.Max(maxfarpointscnt, farpointscnt(i))
				sumnearcenterscnt = sumnearcenterscnt + nearcenterscnt(i)
				sumnearpointscnt = sumnearpointscnt + nearpointscnt(i)
				sumfarpointscnt = sumfarpointscnt + farpointscnt(i)
			Next
			snnz = sumnearcenterscnt
			gnnz = sumfarpointscnt
			alglib.ap.assert(maxnearcenterscnt > 0, "BuildRBFModelLSQR: internal error")

			'
			' Allocate temporaries.
			'
			' NOTE: we want to avoid allocation of zero-size arrays, so we
			'       use max(desired_size,1) instead of desired_size when performing
			'       memory allocation.
			'
			a = New Double(maxnearpointscnt + (maxnearcenterscnt - 1), maxnearcenterscnt - 1) {}
			tmpy = New Double(maxnearpointscnt + (maxnearcenterscnt - 1)) {}
			g = New Double(maxnearcenterscnt - 1) {}
			c = New Double(maxnearcenterscnt - 1) {}
			nearcenters = New Double(maxnearcenterscnt - 1, mxnx - 1) {}
			nearpoints = New Double(System.Math.Max(maxnearpointscnt, 1) - 1, mxnx - 1) {}
			farpoints = New Double(System.Math.Max(maxfarpointscnt, 1) - 1, mxnx - 1) {}

			'
			' fill matrix SpG
			'
			sparse.sparsecreate(n, nc, gnnz, spg)
			sparse.sparsecreate(nc, nc, snnz, sps)
			For i = 0 To nc - 1
				centerscnt = nearcenterscnt(i)

				'
				' main center
				'
				For j = 0 To mxnx - 1
					xcx(j) = xc(i, j)
				Next

				'
				' center's tree
				'
				tmpi = nearestneighbor.kdtreequeryknn(centerstree, xcx, centerscnt, True)
				alglib.ap.assert(tmpi = centerscnt, "BuildRBFModelLSQR: internal error")
				nearestneighbor.kdtreequeryresultsx(centerstree, cx)
				nearestneighbor.kdtreequeryresultstags(centerstree, centerstags)

				'
				' point's tree
				'
				mrad = 0
				For j = 0 To centerscnt - 1
					mrad = System.Math.Max(mrad, r(centerstags(j)))
				Next

				'
				' we need to be sure that 'CTree' contains
				' at least one side center
				'
				sparse.sparseset(sps, i, i, 1)
				c(0) = 1.0
				For j = 1 To centerscnt - 1
					c(j) = 0.0
				Next
				If centerscnt > 1 AndAlso nearpointscnt(i) > 0 Then

					'
					' first KDTree request for points
					'
					pointscnt = nearpointscnt(i)
					tmpi = nearestneighbor.kdtreequeryknn(pointstree, xcx, skipnearpointscnt(i) + nearpointscnt(i), True)
					alglib.ap.assert(tmpi = skipnearpointscnt(i) + nearpointscnt(i), "BuildRBFModelLSQR: internal error")
					nearestneighbor.kdtreequeryresultsx(pointstree, xx)
					sind = skipnearpointscnt(i)
					For j = 0 To pointscnt - 1
						vx = xx(sind + j, 0)
						vy = xx(sind + j, 1)
						vz = xx(sind + j, 2)
						For k = 0 To centerscnt - 1
							vr = 0.0
							vv = vx - cx(k, 0)
							vr = vr + vv * vv
							vv = vy - cx(k, 1)
							vr = vr + vv * vv
							vv = vz - cx(k, 2)
							vr = vr + vv * vv
							vv = r(centerstags(k))
							a(j, k) = System.Math.Exp(-(vr / (vv * vv)))
						Next
					Next
					For j = 0 To centerscnt - 1
						g(j) = System.Math.Exp(-((Math.sqr(xcx(0) - cx(j, 0)) + Math.sqr(xcx(1) - cx(j, 1)) + Math.sqr(xcx(2) - cx(j, 2))) / Math.sqr(r(centerstags(j)))))
					Next

					'
					' calculate the problem
					'
					gnorm2 = 0.0
					For i_ = 0 To centerscnt - 1
						gnorm2 += g(i_) * g(i_)
					Next
					For j = 0 To pointscnt - 1
						vv = 0.0
						For i_ = 0 To centerscnt - 1
							vv += a(j, i_) * g(i_)
						Next
						vv = vv / gnorm2
						tmpy(j) = -vv
						For i_ = 0 To centerscnt - 1
							a(j, i_) = a(j, i_) - vv * g(i_)
						Next
					Next
					For j = pointscnt To pointscnt + centerscnt - 1
						For k = 0 To centerscnt - 1
							a(j, k) = 0.0
						Next
						a(j, j - pointscnt) = 1E-06
						tmpy(j) = 0.0
					Next
					fbls.fblssolvels(a, tmpy, pointscnt + centerscnt, centerscnt, tmp0, tmp1, _
						tmp2)
					For i_ = 0 To centerscnt - 1
						c(i_) = tmpy(i_)
					Next
					vv = 0.0
					For i_ = 0 To centerscnt - 1
						vv += g(i_) * c(i_)
					Next
					vv = vv / gnorm2
					For i_ = 0 To centerscnt - 1
						c(i_) = c(i_) - vv * g(i_)
					Next
					vv = 1 / gnorm2
					For i_ = 0 To centerscnt - 1
						c(i_) = c(i_) + vv * g(i_)
					Next
					For j = 0 To centerscnt - 1
						sparse.sparseset(sps, i, centerstags(j), c(j))
					Next
				End If

				'
				' second KDTree request for points
				'
				pointscnt = farpointscnt(i)
				tmpi = nearestneighbor.kdtreequeryknn(pointstree, xcx, pointscnt, True)
				alglib.ap.assert(tmpi = pointscnt, "BuildRBFModelLSQR: internal error")
				nearestneighbor.kdtreequeryresultsx(pointstree, xx)
				nearestneighbor.kdtreequeryresultstags(pointstree, pointstags)

				'
				'fill SpG matrix
				'
				For j = 0 To pointscnt - 1
					fx = 0
					vx = xx(j, 0)
					vy = xx(j, 1)
					vz = xx(j, 2)
					For k = 0 To centerscnt - 1
						vr = 0.0
						vv = vx - cx(k, 0)
						vr = vr + vv * vv
						vv = vy - cx(k, 1)
						vr = vr + vv * vv
						vv = vz - cx(k, 2)
						vr = vr + vv * vv
						vv = r(centerstags(k))
						vv = vv * vv
						fx = fx + c(k) * System.Math.Exp(-(vr / vv))
					Next
					sparse.sparseset(spg, pointstags(j), i, fx)
				Next
			Next
			sparse.sparseconverttocrs(spg)
			sparse.sparseconverttocrs(sps)

			'
			' solve by LSQR method
			'
			tmpy = New Double(n - 1) {}
			tc = New Double(nc - 1) {}
			w = New Double(nc - 1, ny - 1) {}
			linlsqr.linlsqrcreate(n, nc, state)
			linlsqr.linlsqrsetcond(state, epsort, epserr, maxits)
			For i = 0 To ny - 1
				For j = 0 To n - 1
					tmpy(j) = y(j, i)
				Next
				linlsqr.linlsqrsolvesparse(state, spg, tmpy)
				linlsqr.linlsqrresults(state, c, lsqrrep)
				If lsqrrep.terminationtype <= 0 Then
					info = -4
					Return
				End If
				sparse.sparsemtv(sps, c, tc)
				For j = 0 To nc - 1
					w(j, i) = tc(j)
				Next
				iterationscount = iterationscount + lsqrrep.iterationscount
				nmv = nmv + lsqrrep.nmv
			Next
			info = 1
		End Sub


		Private Shared Sub buildrbfmlayersmodellsqr(x As Double(,), ByRef y As Double(,), ByRef xc As Double(,), rval As Double, ByRef r As Double(), n As Integer, _
			ByRef nc As Integer, ny As Integer, nlayers As Integer, centerstree As nearestneighbor.kdtree, epsort As Double, epserr As Double, _
			maxits As Integer, lambdav As Double, ByRef annz As Integer, ByRef w As Double(,), ByRef info As Integer, ByRef iterationscount As Integer, _
			ByRef nmv As Integer)
			Dim state As New linlsqr.linlsqrstate()
			Dim lsqrrep As New linlsqr.linlsqrreport()
			Dim spa As New sparse.sparsematrix()
			Dim anorm As Double = 0
			Dim omega As Double() = New Double(-1) {}
			Dim xx As Double() = New Double(-1) {}
			Dim tmpy As Double() = New Double(-1) {}
			Dim cx As Double(,) = New Double(-1, -1) {}
			Dim yval As Double = 0
			Dim nec As Integer = 0
			Dim centerstags As Integer() = New Integer(-1) {}
			Dim layer As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim v As Double = 0
			Dim rmaxbefore As Double = 0
			Dim rmaxafter As Double = 0

			xc = New Double(-1, -1) {}
			r = New Double(-1) {}
			nc = 0
			annz = 0
			w = New Double(-1, -1) {}
			info = 0
			iterationscount = 0
			nmv = 0

			alglib.ap.assert(nlayers >= 0, "BuildRBFMLayersModelLSQR: invalid argument(NLayers<0)")
			alglib.ap.assert(n >= 0, "BuildRBFMLayersModelLSQR: invalid argument(N<0)")
			alglib.ap.assert(mxnx > 0 AndAlso mxnx <= 3, "BuildRBFMLayersModelLSQR: internal error(invalid global const MxNX: either MxNX<=0 or MxNX>3)")
			annz = 0
			If n = 0 OrElse nlayers = 0 Then
				info = 1
				iterationscount = 0
				nmv = 0
				Return
			End If
			nc = n * nlayers
			xx = New Double(mxnx - 1) {}
			centerstags = New Integer(n - 1) {}
			xc = New Double(nc - 1, mxnx - 1) {}
			r = New Double(nc - 1) {}
			For i = 0 To nc - 1
				For j = 0 To mxnx - 1
					xc(i, j) = x(i Mod n, j)
				Next
			Next
			For i = 0 To nc - 1
				r(i) = rval / System.Math.Pow(2, i \ n)
			Next
			For i = 0 To n - 1
				centerstags(i) = i
			Next
			nearestneighbor.kdtreebuildtagged(xc, centerstags, n, mxnx, 0, 2, _
				centerstree)
			omega = New Double(n - 1) {}
			tmpy = New Double(n - 1) {}
			w = New Double(nc - 1, ny - 1) {}
			info = -1
			iterationscount = 0
			nmv = 0
			linlsqr.linlsqrcreate(n, n, state)
			linlsqr.linlsqrsetcond(state, epsort, epserr, maxits)
			linlsqr.linlsqrsetlambdai(state, 1E-06)

			'
			' calculate number of non-zero elements for sparse matrix
			'
			For i = 0 To n - 1
				For j = 0 To mxnx - 1
					xx(j) = x(i, j)
				Next
				annz = annz + nearestneighbor.kdtreequeryrnn(centerstree, xx, r(0) * rbfmlradius, True)
			Next
			For layer = 0 To nlayers - 1

				'
				' Fill sparse matrix, calculate norm(A)
				'
				anorm = 0.0
				sparse.sparsecreate(n, n, annz, spa)
				For i = 0 To n - 1
					For j = 0 To mxnx - 1
						xx(j) = x(i, j)
					Next
					nec = nearestneighbor.kdtreequeryrnn(centerstree, xx, r(layer * n) * rbfmlradius, True)
					nearestneighbor.kdtreequeryresultsx(centerstree, cx)
					nearestneighbor.kdtreequeryresultstags(centerstree, centerstags)
					For j = 0 To nec - 1
						v = System.Math.Exp(-((Math.sqr(xx(0) - cx(j, 0)) + Math.sqr(xx(1) - cx(j, 1)) + Math.sqr(xx(2) - cx(j, 2))) / Math.sqr(r(layer * n + centerstags(j)))))
						sparse.sparseset(spa, i, centerstags(j), v)
						anorm = anorm + Math.sqr(v)
					Next
				Next
				anorm = System.Math.sqrt(anorm)
				sparse.sparseconverttocrs(spa)

				'
				' Calculate maximum residual before adding new layer.
				' This value is not used by algorithm, the only purpose is to make debugging easier.
				'
				rmaxbefore = 0.0
				For j = 0 To n - 1
					For i = 0 To ny - 1
						rmaxbefore = System.Math.Max(rmaxbefore, System.Math.Abs(y(j, i)))
					Next
				Next

				'
				' Process NY dimensions of the target function
				'
				For i = 0 To ny - 1
					For j = 0 To n - 1
						tmpy(j) = y(j, i)
					Next

					'
					' calculate Omega for current layer
					'
					linlsqr.linlsqrsetlambdai(state, lambdav * anorm / n)
					linlsqr.linlsqrsolvesparse(state, spa, tmpy)
					linlsqr.linlsqrresults(state, omega, lsqrrep)
					If lsqrrep.terminationtype <= 0 Then
						info = -4
						Return
					End If

					'
					' calculate error for current layer
					'
					For j = 0 To n - 1
						yval = 0
						For k = 0 To mxnx - 1
							xx(k) = x(j, k)
						Next
						nec = nearestneighbor.kdtreequeryrnn(centerstree, xx, r(layer * n) * rbffarradius, True)
						nearestneighbor.kdtreequeryresultsx(centerstree, cx)
						nearestneighbor.kdtreequeryresultstags(centerstree, centerstags)
						For k = 0 To nec - 1
							yval = yval + omega(centerstags(k)) * System.Math.Exp(-((Math.sqr(xx(0) - cx(k, 0)) + Math.sqr(xx(1) - cx(k, 1)) + Math.sqr(xx(2) - cx(k, 2))) / Math.sqr(r(layer * n + centerstags(k)))))
						Next
						y(j, i) = y(j, i) - yval
					Next

					'
					' write Omega in out parameter W
					'
					For j = 0 To n - 1
						w(layer * n + j, i) = omega(j)
					Next
					iterationscount = iterationscount + lsqrrep.iterationscount
					nmv = nmv + lsqrrep.nmv
				Next

				'
				' Calculate maximum residual before adding new layer.
				' This value is not used by algorithm, the only purpose is to make debugging easier.
				'
				rmaxafter = 0.0
				For j = 0 To n - 1
					For i = 0 To ny - 1
						rmaxafter = System.Math.Max(rmaxafter, System.Math.Abs(y(j, i)))
					Next
				Next
			Next
			info = 1
		End Sub


	End Class
	Public Class spline2d
		'************************************************************************
'        2-dimensional spline inteprolant
'        ************************************************************************

		Public Class spline2dinterpolant
			Inherits apobject
			Public k As Integer
			Public stype As Integer
			Public n As Integer
			Public m As Integer
			Public d As Integer
			Public x As Double()
			Public y As Double()
			Public f As Double()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x = New Double(-1) {}
				y = New Double(-1) {}
				f = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New spline2dinterpolant()
				_result.k = k
				_result.stype = stype
				_result.n = n
				_result.m = m
				_result.d = d
				_result.x = DirectCast(x.Clone(), Double())
				_result.y = DirectCast(y.Clone(), Double())
				_result.f = DirectCast(f.Clone(), Double())
				Return _result
			End Function
		End Class




		'************************************************************************
'        This subroutine calculates the value of the bilinear or bicubic spline  at
'        the given point X.
'
'        Input parameters:
'            C   -   coefficients table.
'                    Built by BuildBilinearSpline or BuildBicubicSpline.
'            X, Y-   point
'
'        Result:
'            S(x,y)
'
'          -- ALGLIB PROJECT --
'             Copyright 05.07.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spline2dcalc(c As spline2dinterpolant, x As Double, y As Double) As Double
			Dim result As Double = 0
			Dim v As Double = 0
			Dim vx As Double = 0
			Dim vy As Double = 0
			Dim vxy As Double = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline2DCalc: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(x) AndAlso Math.isfinite(y), "Spline2DCalc: X or Y contains NaN or Infinite value")
			If c.d <> 1 Then
				result = 0
				Return result
			End If
			spline2ddiff(c, x, y, v, vx, vy, _
				vxy)
			result = v
			Return result
		End Function


		'************************************************************************
'        This subroutine calculates the value of the bilinear or bicubic spline  at
'        the given point X and its derivatives.
'
'        Input parameters:
'            C   -   spline interpolant.
'            X, Y-   point
'
'        Output parameters:
'            F   -   S(x,y)
'            FX  -   dS(x,y)/dX
'            FY  -   dS(x,y)/dY
'            FXY -   d2S(x,y)/dXdY
'
'          -- ALGLIB PROJECT --
'             Copyright 05.07.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2ddiff(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double, ByRef fx As Double, ByRef fy As Double, _
			ByRef fxy As Double)
			Dim t As Double = 0
			Dim dt As Double = 0
			Dim u As Double = 0
			Dim du As Double = 0
			Dim ix As Integer = 0
			Dim iy As Integer = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim h As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim s3 As Integer = 0
			Dim s4 As Integer = 0
			Dim sfx As Integer = 0
			Dim sfy As Integer = 0
			Dim sfxy As Integer = 0
			Dim y1 As Double = 0
			Dim y2 As Double = 0
			Dim y3 As Double = 0
			Dim y4 As Double = 0
			Dim v As Double = 0
			Dim t0 As Double = 0
			Dim t1 As Double = 0
			Dim t2 As Double = 0
			Dim t3 As Double = 0
			Dim u0 As Double = 0
			Dim u1 As Double = 0
			Dim u2 As Double = 0
			Dim u3 As Double = 0

			f = 0
			fx = 0
			fy = 0
			fxy = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline2DDiff: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(x) AndAlso Math.isfinite(y), "Spline2DDiff: X or Y contains NaN or Infinite value")

			'
			' Prepare F, dF/dX, dF/dY, d2F/dXdY
			'
			f = 0
			fx = 0
			fy = 0
			fxy = 0
			If c.d <> 1 Then
				Return
			End If

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = c.n - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.x(h)) >= CDbl(x) Then
					r = h
				Else
					l = h
				End If
			End While
			t = (x - c.x(l)) / (c.x(l + 1) - c.x(l))
			dt = 1.0 / (c.x(l + 1) - c.x(l))
			ix = l

			'
			' Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
			'
			l = 0
			r = c.m - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.y(h)) >= CDbl(y) Then
					r = h
				Else
					l = h
				End If
			End While
			u = (y - c.y(l)) / (c.y(l + 1) - c.y(l))
			du = 1.0 / (c.y(l + 1) - c.y(l))
			iy = l

			'
			' Bilinear interpolation
			'
			If c.stype = -1 Then
				y1 = c.f(c.n * iy + ix)
				y2 = c.f(c.n * iy + (ix + 1))
				y3 = c.f(c.n * (iy + 1) + (ix + 1))
				y4 = c.f(c.n * (iy + 1) + ix)
				f = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4
				fx = (-((1 - u) * y1) + (1 - u) * y2 + u * y3 - u * y4) * dt
				fy = (-((1 - t) * y1) - t * y2 + t * y3 + (1 - t) * y4) * du
				fxy = (y1 - y2 + y3 - y4) * du * dt
				Return
			End If

			'
			' Bicubic interpolation
			'
			If c.stype = -3 Then

				'
				' Prepare info
				'
				t0 = 1
				t1 = t
				t2 = Math.sqr(t)
				t3 = t * t2
				u0 = 1
				u1 = u
				u2 = Math.sqr(u)
				u3 = u * u2
				sfx = c.n * c.m
				sfy = 2 * c.n * c.m
				sfxy = 3 * c.n * c.m
				s1 = c.n * iy + ix
				s2 = c.n * iy + (ix + 1)
				s3 = c.n * (iy + 1) + (ix + 1)
				s4 = c.n * (iy + 1) + ix

				'
				' Calculate
				'
				v = c.f(s1)
				f = f + v * t0 * u0
				v = c.f(sfy + s1) / du
				f = f + v * t0 * u1
				fy = fy + v * t0 * u0 * du
				v = -(3 * c.f(s1)) + 3 * c.f(s4) - 2 * c.f(sfy + s1) / du - c.f(sfy + s4) / du
				f = f + v * t0 * u2
				fy = fy + 2 * v * t0 * u1 * du
				v = 2 * c.f(s1) - 2 * c.f(s4) + c.f(sfy + s1) / du + c.f(sfy + s4) / du
				f = f + v * t0 * u3
				fy = fy + 3 * v * t0 * u2 * du
				v = c.f(sfx + s1) / dt
				f = f + v * t1 * u0
				fx = fx + v * t0 * u0 * dt
				v = c.f(sfxy + s1) / (dt * du)
				f = f + v * t1 * u1
				fx = fx + v * t0 * u1 * dt
				fy = fy + v * t1 * u0 * du
				fxy = fxy + v * t0 * u0 * dt * du
				v = -(3 * c.f(sfx + s1) / dt) + 3 * c.f(sfx + s4) / dt - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s4) / (dt * du)
				f = f + v * t1 * u2
				fx = fx + v * t0 * u2 * dt
				fy = fy + 2 * v * t1 * u1 * du
				fxy = fxy + 2 * v * t0 * u1 * dt * du
				v = 2 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s4) / dt + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s4) / (dt * du)
				f = f + v * t1 * u3
				fx = fx + v * t0 * u3 * dt
				fy = fy + 3 * v * t1 * u2 * du
				fxy = fxy + 3 * v * t0 * u2 * dt * du
				v = -(3 * c.f(s1)) + 3 * c.f(s2) - 2 * c.f(sfx + s1) / dt - c.f(sfx + s2) / dt
				f = f + v * t2 * u0
				fx = fx + 2 * v * t1 * u0 * dt
				v = -(3 * c.f(sfy + s1) / du) + 3 * c.f(sfy + s2) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du)
				f = f + v * t2 * u1
				fx = fx + 2 * v * t1 * u1 * dt
				fy = fy + v * t2 * u0 * du
				fxy = fxy + 2 * v * t1 * u0 * dt * du
				v = 9 * c.f(s1) - 9 * c.f(s2) + 9 * c.f(s3) - 9 * c.f(s4) + 6 * c.f(sfx + s1) / dt + 3 * c.f(sfx + s2) / dt - 3 * c.f(sfx + s3) / dt - 6 * c.f(sfx + s4) / dt + 6 * c.f(sfy + s1) / du - 6 * c.f(sfy + s2) / du - 3 * c.f(sfy + s3) / du + 3 * c.f(sfy + s4) / du + 4 * c.f(sfxy + s1) / (dt * du) + 2 * c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + 2 * c.f(sfxy + s4) / (dt * du)
				f = f + v * t2 * u2
				fx = fx + 2 * v * t1 * u2 * dt
				fy = fy + 2 * v * t2 * u1 * du
				fxy = fxy + 4 * v * t1 * u1 * dt * du
				v = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 4 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s2) / dt + 2 * c.f(sfx + s3) / dt + 4 * c.f(sfx + s4) / dt - 3 * c.f(sfy + s1) / du + 3 * c.f(sfy + s2) / du + 3 * c.f(sfy + s3) / du - 3 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - 2 * c.f(sfxy + s4) / (dt * du)
				f = f + v * t2 * u3
				fx = fx + 2 * v * t1 * u3 * dt
				fy = fy + 3 * v * t2 * u2 * du
				fxy = fxy + 6 * v * t1 * u2 * dt * du
				v = 2 * c.f(s1) - 2 * c.f(s2) + c.f(sfx + s1) / dt + c.f(sfx + s2) / dt
				f = f + v * t3 * u0
				fx = fx + 3 * v * t2 * u0 * dt
				v = 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du)
				f = f + v * t3 * u1
				fx = fx + 3 * v * t2 * u1 * dt
				fy = fy + v * t3 * u0 * du
				fxy = fxy + 3 * v * t2 * u0 * dt * du
				v = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 3 * c.f(sfx + s1) / dt - 3 * c.f(sfx + s2) / dt + 3 * c.f(sfx + s3) / dt + 3 * c.f(sfx + s4) / dt - 4 * c.f(sfy + s1) / du + 4 * c.f(sfy + s2) / du + 2 * c.f(sfy + s3) / du - 2 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - 2 * c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - c.f(sfxy + s4) / (dt * du)
				f = f + v * t3 * u2
				fx = fx + 3 * v * t2 * u2 * dt
				fy = fy + 2 * v * t3 * u1 * du
				fxy = fxy + 6 * v * t2 * u1 * dt * du
				v = 4 * c.f(s1) - 4 * c.f(s2) + 4 * c.f(s3) - 4 * c.f(s4) + 2 * c.f(sfx + s1) / dt + 2 * c.f(sfx + s2) / dt - 2 * c.f(sfx + s3) / dt - 2 * c.f(sfx + s4) / dt + 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du - 2 * c.f(sfy + s3) / du + 2 * c.f(sfy + s4) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + c.f(sfxy + s4) / (dt * du)
				f = f + v * t3 * u3
				fx = fx + 3 * v * t2 * u3 * dt
				fy = fy + 3 * v * t3 * u2 * du
				fxy = fxy + 9 * v * t2 * u2 * dt * du
				Return
			End If
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the spline argument.
'
'        Input parameters:
'            C       -   spline interpolant
'            AX, BX  -   transformation coefficients: x = A*t + B
'            AY, BY  -   transformation coefficients: y = A*u + B
'        Result:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 30.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dlintransxy(c As spline2dinterpolant, ax As Double, bx As Double, ay As Double, by As Double)
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim f As Double() = New Double(-1) {}
			Dim v As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline2DLinTransXY: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(ax), "Spline2DLinTransXY: AX is infinite or NaN")
			alglib.ap.assert(Math.isfinite(bx), "Spline2DLinTransXY: BX is infinite or NaN")
			alglib.ap.assert(Math.isfinite(ay), "Spline2DLinTransXY: AY is infinite or NaN")
			alglib.ap.assert(Math.isfinite(by), "Spline2DLinTransXY: BY is infinite or NaN")
			x = New Double(c.n - 1) {}
			y = New Double(c.m - 1) {}
			f = New Double(c.m * c.n * c.d - 1) {}
			For j = 0 To c.n - 1
				x(j) = c.x(j)
			Next
			For i = 0 To c.m - 1
				y(i) = c.y(i)
			Next
			For i = 0 To c.m - 1
				For j = 0 To c.n - 1
					For k = 0 To c.d - 1
						f(c.d * (i * c.n + j) + k) = c.f(c.d * (i * c.n + j) + k)
					Next
				Next
			Next

			'
			' Handle different combinations of AX/AY
			'
			If CDbl(ax) = CDbl(0) AndAlso CDbl(ay) <> CDbl(0) Then
				For i = 0 To c.m - 1
					spline2dcalcvbuf(c, bx, y(i), v)
					y(i) = (y(i) - by) / ay
					For j = 0 To c.n - 1
						For k = 0 To c.d - 1
							f(c.d * (i * c.n + j) + k) = v(k)
						Next
					Next
				Next
			End If
			If CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) = CDbl(0) Then
				For j = 0 To c.n - 1
					spline2dcalcvbuf(c, x(j), by, v)
					x(j) = (x(j) - bx) / ax
					For i = 0 To c.m - 1
						For k = 0 To c.d - 1
							f(c.d * (i * c.n + j) + k) = v(k)
						Next
					Next
				Next
			End If
			If CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) <> CDbl(0) Then
				For j = 0 To c.n - 1
					x(j) = (x(j) - bx) / ax
				Next
				For i = 0 To c.m - 1
					y(i) = (y(i) - by) / ay
				Next
			End If
			If CDbl(ax) = CDbl(0) AndAlso CDbl(ay) = CDbl(0) Then
				spline2dcalcvbuf(c, bx, by, v)
				For i = 0 To c.m - 1
					For j = 0 To c.n - 1
						For k = 0 To c.d - 1
							f(c.d * (i * c.n + j) + k) = v(k)
						Next
					Next
				Next
			End If

			'
			' Rebuild spline
			'
			If c.stype = -3 Then
				spline2dbuildbicubicv(x, c.n, y, c.m, f, c.d, _
					c)
			End If
			If c.stype = -1 Then
				spline2dbuildbilinearv(x, c.n, y, c.m, f, c.d, _
					c)
			End If
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the spline.
'
'        Input parameters:
'            C   -   spline interpolant.
'            A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
'            
'        Output parameters:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 30.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dlintransf(c As spline2dinterpolant, a As Double, b As Double)
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim f As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline2DLinTransF: incorrect C (incorrect parameter C.SType)")
			x = New Double(c.n - 1) {}
			y = New Double(c.m - 1) {}
			f = New Double(c.m * c.n * c.d - 1) {}
			For j = 0 To c.n - 1
				x(j) = c.x(j)
			Next
			For i = 0 To c.m - 1
				y(i) = c.y(i)
			Next
			For i = 0 To c.m * c.n * c.d - 1
				f(i) = a * c.f(i) + b
			Next
			If c.stype = -3 Then
				spline2dbuildbicubicv(x, c.n, y, c.m, f, c.d, _
					c)
			End If
			If c.stype = -1 Then
				spline2dbuildbilinearv(x, c.n, y, c.m, f, c.d, _
					c)
			End If
		End Sub


		'************************************************************************
'        This subroutine makes the copy of the spline model.
'
'        Input parameters:
'            C   -   spline interpolant
'
'        Output parameters:
'            CC  -   spline copy
'
'          -- ALGLIB PROJECT --
'             Copyright 29.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dcopy(c As spline2dinterpolant, cc As spline2dinterpolant)
			Dim tblsize As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(c.k = 1 OrElse c.k = 3, "Spline2DCopy: incorrect C (incorrect parameter C.K)")
			cc.k = c.k
			cc.n = c.n
			cc.m = c.m
			cc.d = c.d
			cc.stype = c.stype
			tblsize = -1
			If c.stype = -3 Then
				tblsize = 4 * c.n * c.m * c.d
			End If
			If c.stype = -1 Then
				tblsize = c.n * c.m * c.d
			End If
			alglib.ap.assert(tblsize > 0, "Spline2DCopy: internal error")
			cc.x = New Double(cc.n - 1) {}
			cc.y = New Double(cc.m - 1) {}
			cc.f = New Double(tblsize - 1) {}
			For i_ = 0 To cc.n - 1
				cc.x(i_) = c.x(i_)
			Next
			For i_ = 0 To cc.m - 1
				cc.y(i_) = c.y(i_)
			Next
			For i_ = 0 To tblsize - 1
				cc.f(i_) = c.f(i_)
			Next
		End Sub


		'************************************************************************
'        Bicubic spline resampling
'
'        Input parameters:
'            A           -   function values at the old grid,
'                            array[0..OldHeight-1, 0..OldWidth-1]
'            OldHeight   -   old grid height, OldHeight>1
'            OldWidth    -   old grid width, OldWidth>1
'            NewHeight   -   new grid height, NewHeight>1
'            NewWidth    -   new grid width, NewWidth>1
'            
'        Output parameters:
'            B           -   function values at the new grid,
'                            array[0..NewHeight-1, 0..NewWidth-1]
'
'          -- ALGLIB routine --
'             15 May, 2007
'             Copyright by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dresamplebicubic(a As Double(,), oldheight As Integer, oldwidth As Integer, ByRef b As Double(,), newheight As Integer, newwidth As Integer)
			Dim buf As Double(,) = New Double(-1, -1) {}
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim c As New spline1d.spline1dinterpolant()
			Dim mw As Integer = 0
			Dim mh As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			b = New Double(-1, -1) {}

			alglib.ap.assert(oldwidth > 1 AndAlso oldheight > 1, "Spline2DResampleBicubic: width/height less than 1")
			alglib.ap.assert(newwidth > 1 AndAlso newheight > 1, "Spline2DResampleBicubic: width/height less than 1")

			'
			' Prepare
			'
			mw = System.Math.Max(oldwidth, newwidth)
			mh = System.Math.Max(oldheight, newheight)
			b = New Double(newheight - 1, newwidth - 1) {}
			buf = New Double(oldheight - 1, newwidth - 1) {}
			x = New Double(System.Math.Max(mw, mh) - 1) {}
			y = New Double(System.Math.Max(mw, mh) - 1) {}

			'
			' Horizontal interpolation
			'
			For i = 0 To oldheight - 1

				'
				' Fill X, Y
				'
				For j = 0 To oldwidth - 1
					x(j) = CDbl(j) / CDbl(oldwidth - 1)
					y(j) = a(i, j)
				Next

				'
				' Interpolate and place result into temporary matrix
				'
				spline1d.spline1dbuildcubic(x, y, oldwidth, 0, 0.0, 0, _
					0.0, c)
				For j = 0 To newwidth - 1
					buf(i, j) = spline1d.spline1dcalc(c, CDbl(j) / CDbl(newwidth - 1))
				Next
			Next

			'
			' Vertical interpolation
			'
			For j = 0 To newwidth - 1

				'
				' Fill X, Y
				'
				For i = 0 To oldheight - 1
					x(i) = CDbl(i) / CDbl(oldheight - 1)
					y(i) = buf(i, j)
				Next

				'
				' Interpolate and place result into B
				'
				spline1d.spline1dbuildcubic(x, y, oldheight, 0, 0.0, 0, _
					0.0, c)
				For i = 0 To newheight - 1
					b(i, j) = spline1d.spline1dcalc(c, CDbl(i) / CDbl(newheight - 1))
				Next
			Next
		End Sub


		'************************************************************************
'        Bilinear spline resampling
'
'        Input parameters:
'            A           -   function values at the old grid,
'                            array[0..OldHeight-1, 0..OldWidth-1]
'            OldHeight   -   old grid height, OldHeight>1
'            OldWidth    -   old grid width, OldWidth>1
'            NewHeight   -   new grid height, NewHeight>1
'            NewWidth    -   new grid width, NewWidth>1
'
'        Output parameters:
'            B           -   function values at the new grid,
'                            array[0..NewHeight-1, 0..NewWidth-1]
'
'          -- ALGLIB routine --
'             09.07.2007
'             Copyright by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dresamplebilinear(a As Double(,), oldheight As Integer, oldwidth As Integer, ByRef b As Double(,), newheight As Integer, newwidth As Integer)
			Dim l As Integer = 0
			Dim c As Integer = 0
			Dim t As Double = 0
			Dim u As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			b = New Double(-1, -1) {}

			alglib.ap.assert(oldwidth > 1 AndAlso oldheight > 1, "Spline2DResampleBilinear: width/height less than 1")
			alglib.ap.assert(newwidth > 1 AndAlso newheight > 1, "Spline2DResampleBilinear: width/height less than 1")
			b = New Double(newheight - 1, newwidth - 1) {}
			For i = 0 To newheight - 1
				For j = 0 To newwidth - 1
					l = i * (oldheight - 1) \ (newheight - 1)
					If l = oldheight - 1 Then
						l = oldheight - 2
					End If
					u = CDbl(i) / CDbl(newheight - 1) * (oldheight - 1) - l
					c = j * (oldwidth - 1) \ (newwidth - 1)
					If c = oldwidth - 1 Then
						c = oldwidth - 2
					End If
					t = CDbl(j * (oldwidth - 1)) / CDbl(newwidth - 1) - c
					b(i, j) = (1 - t) * (1 - u) * a(l, c) + t * (1 - u) * a(l, c + 1) + t * u * a(l + 1, c + 1) + (1 - t) * u * a(l + 1, c)
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine builds bilinear vector-valued spline.
'
'        Input parameters:
'            X   -   spline abscissas, array[0..N-1]
'            Y   -   spline ordinates, array[0..M-1]
'            F   -   function values, array[0..M*N*D-1]:
'                    * first D elements store D values at (X[0],Y[0])
'                    * next D elements store D values at (X[1],Y[0])
'                    * general form - D function values at (X[i],Y[j]) are stored
'                      at F[D*(J*N+I)...D*(J*N+I)+D-1].
'            M,N -   grid size, M>=2, N>=2
'            D   -   vector dimension, D>=1
'
'        Output parameters:
'            C   -   spline interpolant
'
'          -- ALGLIB PROJECT --
'             Copyright 16.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dbuildbilinearv(x As Double(), n As Integer, y As Double(), m As Integer, f As Double(), d As Integer, _
			c As spline2dinterpolant)
			Dim t As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim i0 As Integer = 0

			alglib.ap.assert(n >= 2, "Spline2DBuildBilinearV: N is less then 2")
			alglib.ap.assert(m >= 2, "Spline2DBuildBilinearV: M is less then 2")
			alglib.ap.assert(d >= 1, "Spline2DBuildBilinearV: invalid argument D (D<1)")
			alglib.ap.assert(alglib.ap.len(x) >= n AndAlso alglib.ap.len(y) >= m, "Spline2DBuildBilinearV: length of X or Y is too short (Length(X/Y)<N/M)")
			alglib.ap.assert(apserv.isfinitevector(x, n) AndAlso apserv.isfinitevector(y, m), "Spline2DBuildBilinearV: X or Y contains NaN or Infinite value")
			k = n * m * d
			alglib.ap.assert(alglib.ap.len(f) >= k, "Spline2DBuildBilinearV: length of F is too short (Length(F)<N*M*D)")
			alglib.ap.assert(apserv.isfinitevector(f, k), "Spline2DBuildBilinearV: F contains NaN or Infinite value")

			'
			' Fill interpolant
			'
			c.k = 1
			c.n = n
			c.m = m
			c.d = d
			c.stype = -1
			c.x = New Double(c.n - 1) {}
			c.y = New Double(c.m - 1) {}
			c.f = New Double(k - 1) {}
			For i = 0 To c.n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To c.m - 1
				c.y(i) = y(i)
			Next
			For i = 0 To k - 1
				c.f(i) = f(i)
			Next

			'
			' Sort points
			'
			For j = 0 To c.n - 1
				k = j
				For i = j + 1 To c.n - 1
					If CDbl(c.x(i)) < CDbl(c.x(k)) Then
						k = i
					End If
				Next
				If k <> j Then
					For i = 0 To c.m - 1
						For i0 = 0 To c.d - 1
							t = c.f(c.d * (i * c.n + j) + i0)
							c.f(c.d * (i * c.n + j) + i0) = c.f(c.d * (i * c.n + k) + i0)
							c.f(c.d * (i * c.n + k) + i0) = t
						Next
					Next
					t = c.x(j)
					c.x(j) = c.x(k)
					c.x(k) = t
				End If
			Next
			For i = 0 To c.m - 1
				k = i
				For j = i + 1 To c.m - 1
					If CDbl(c.y(j)) < CDbl(c.y(k)) Then
						k = j
					End If
				Next
				If k <> i Then
					For j = 0 To c.n - 1
						For i0 = 0 To c.d - 1
							t = c.f(c.d * (i * c.n + j) + i0)
							c.f(c.d * (i * c.n + j) + i0) = c.f(c.d * (k * c.n + j) + i0)
							c.f(c.d * (k * c.n + j) + i0) = t
						Next
					Next
					t = c.y(i)
					c.y(i) = c.y(k)
					c.y(k) = t
				End If
			Next
		End Sub


		'************************************************************************
'        This subroutine builds bicubic vector-valued spline.
'
'        Input parameters:
'            X   -   spline abscissas, array[0..N-1]
'            Y   -   spline ordinates, array[0..M-1]
'            F   -   function values, array[0..M*N*D-1]:
'                    * first D elements store D values at (X[0],Y[0])
'                    * next D elements store D values at (X[1],Y[0])
'                    * general form - D function values at (X[i],Y[j]) are stored
'                      at F[D*(J*N+I)...D*(J*N+I)+D-1].
'            M,N -   grid size, M>=2, N>=2
'            D   -   vector dimension, D>=1
'
'        Output parameters:
'            C   -   spline interpolant
'
'          -- ALGLIB PROJECT --
'             Copyright 16.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dbuildbicubicv(x As Double(), n As Integer, y As Double(), m As Integer, f As Double(), d As Integer, _
			c As spline2dinterpolant)
			Dim tf As Double(,) = New Double(-1, -1) {}
			Dim dx As Double(,) = New Double(-1, -1) {}
			Dim dy As Double(,) = New Double(-1, -1) {}
			Dim dxy As Double(,) = New Double(-1, -1) {}
			Dim t As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim di As Integer = 0

			f = DirectCast(f.Clone(), Double())

			alglib.ap.assert(n >= 2, "Spline2DBuildBicubicV: N is less than 2")
			alglib.ap.assert(m >= 2, "Spline2DBuildBicubicV: M is less than 2")
			alglib.ap.assert(d >= 1, "Spline2DBuildBicubicV: invalid argument D (D<1)")
			alglib.ap.assert(alglib.ap.len(x) >= n AndAlso alglib.ap.len(y) >= m, "Spline2DBuildBicubicV: length of X or Y is too short (Length(X/Y)<N/M)")
			alglib.ap.assert(apserv.isfinitevector(x, n) AndAlso apserv.isfinitevector(y, m), "Spline2DBuildBicubicV: X or Y contains NaN or Infinite value")
			k = n * m * d
			alglib.ap.assert(alglib.ap.len(f) >= k, "Spline2DBuildBicubicV: length of F is too short (Length(F)<N*M*D)")
			alglib.ap.assert(apserv.isfinitevector(f, k), "Spline2DBuildBicubicV: F contains NaN or Infinite value")

			'
			' Fill interpolant:
			'  F[0]...F[N*M*D-1]:
			'      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
			'  F[N*M*D]...F[2*N*M*D-1]:
			'      df(i,j)/dx table.
			'  F[2*N*M*D]...F[3*N*M*D-1]:
			'      df(i,j)/dy table.
			'  F[3*N*M*D]...F[4*N*M*D-1]:
			'      d2f(i,j)/dxdy table.
			'
			c.k = 3
			c.d = d
			c.n = n
			c.m = m
			c.stype = -3
			k = 4 * k
			c.x = New Double(c.n - 1) {}
			c.y = New Double(c.m - 1) {}
			c.f = New Double(k - 1) {}
			tf = New Double(c.m - 1, c.n - 1) {}
			For i = 0 To c.n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To c.m - 1
				c.y(i) = y(i)
			Next

			'
			' Sort points
			'
			For j = 0 To c.n - 1
				k = j
				For i = j + 1 To c.n - 1
					If CDbl(c.x(i)) < CDbl(c.x(k)) Then
						k = i
					End If
				Next
				If k <> j Then
					For i = 0 To c.m - 1
						For di = 0 To c.d - 1
							t = f(c.d * (i * c.n + j) + di)
							f(c.d * (i * c.n + j) + di) = f(c.d * (i * c.n + k) + di)
							f(c.d * (i * c.n + k) + di) = t
						Next
					Next
					t = c.x(j)
					c.x(j) = c.x(k)
					c.x(k) = t
				End If
			Next
			For i = 0 To c.m - 1
				k = i
				For j = i + 1 To c.m - 1
					If CDbl(c.y(j)) < CDbl(c.y(k)) Then
						k = j
					End If
				Next
				If k <> i Then
					For j = 0 To c.n - 1
						For di = 0 To c.d - 1
							t = f(c.d * (i * c.n + j) + di)
							f(c.d * (i * c.n + j) + di) = f(c.d * (k * c.n + j) + di)
							f(c.d * (k * c.n + j) + di) = t
						Next
					Next
					t = c.y(i)
					c.y(i) = c.y(k)
					c.y(k) = t
				End If
			Next
			For di = 0 To c.d - 1
				For i = 0 To c.m - 1
					For j = 0 To c.n - 1
						tf(i, j) = f(c.d * (i * c.n + j) + di)
					Next
				Next
				bicubiccalcderivatives(tf, c.x, c.y, c.m, c.n, dx, _
					dy, dxy)
				For i = 0 To c.m - 1
					For j = 0 To c.n - 1
						k = c.d * (i * c.n + j) + di
						c.f(k) = tf(i, j)
						c.f(c.n * c.m * c.d + k) = dx(i, j)
						c.f(2 * c.n * c.m * c.d + k) = dy(i, j)
						c.f(3 * c.n * c.m * c.d + k) = dxy(i, j)
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine calculates bilinear or bicubic vector-valued spline at the
'        given point (X,Y).
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X, Y-   point
'            F   -   output buffer, possibly preallocated array. In case array size
'                    is large enough to store result, it is not reallocated.  Array
'                    which is too short will be reallocated
'
'        OUTPUT PARAMETERS:
'            F   -   array[D] (or larger) which stores function values
'
'          -- ALGLIB PROJECT --
'             Copyright 16.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dcalcvbuf(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double())
			Dim t As Double = 0
			Dim dt As Double = 0
			Dim u As Double = 0
			Dim du As Double = 0
			Dim ix As Integer = 0
			Dim iy As Integer = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim h As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim s3 As Integer = 0
			Dim s4 As Integer = 0
			Dim sfx As Integer = 0
			Dim sfy As Integer = 0
			Dim sfxy As Integer = 0
			Dim y1 As Double = 0
			Dim y2 As Double = 0
			Dim y3 As Double = 0
			Dim y4 As Double = 0
			Dim v As Double = 0
			Dim t0 As Double = 0
			Dim t1 As Double = 0
			Dim t2 As Double = 0
			Dim t3 As Double = 0
			Dim u0 As Double = 0
			Dim u1 As Double = 0
			Dim u2 As Double = 0
			Dim u3 As Double = 0
			Dim i As Integer = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline2DCalcVBuf: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(x) AndAlso Math.isfinite(y), "Spline2DCalcVBuf: either X=NaN/Infinite or Y=NaN/Infinite")
			apserv.rvectorsetlengthatleast(f, c.d)

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = c.n - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.x(h)) >= CDbl(x) Then
					r = h
				Else
					l = h
				End If
			End While
			t = (x - c.x(l)) / (c.x(l + 1) - c.x(l))
			dt = 1.0 / (c.x(l + 1) - c.x(l))
			ix = l

			'
			' Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
			'
			l = 0
			r = c.m - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.y(h)) >= CDbl(y) Then
					r = h
				Else
					l = h
				End If
			End While
			u = (y - c.y(l)) / (c.y(l + 1) - c.y(l))
			du = 1.0 / (c.y(l + 1) - c.y(l))
			iy = l

			'
			' Bilinear interpolation
			'
			If c.stype = -1 Then
				For i = 0 To c.d - 1
					y1 = c.f(c.d * (c.n * iy + ix) + i)
					y2 = c.f(c.d * (c.n * iy + (ix + 1)) + i)
					y3 = c.f(c.d * (c.n * (iy + 1) + (ix + 1)) + i)
					y4 = c.f(c.d * (c.n * (iy + 1) + ix) + i)
					f(i) = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4
				Next
				Return
			End If

			'
			' Bicubic interpolation
			'
			If c.stype = -3 Then

				'
				' Prepare info
				'
				t0 = 1
				t1 = t
				t2 = Math.sqr(t)
				t3 = t * t2
				u0 = 1
				u1 = u
				u2 = Math.sqr(u)
				u3 = u * u2
				sfx = c.n * c.m * c.d
				sfy = 2 * c.n * c.m * c.d
				sfxy = 3 * c.n * c.m * c.d
				For i = 0 To c.d - 1

					'
					' Prepare F, dF/dX, dF/dY, d2F/dXdY
					'
					f(i) = 0
					s1 = c.d * (c.n * iy + ix) + i
					s2 = c.d * (c.n * iy + (ix + 1)) + i
					s3 = c.d * (c.n * (iy + 1) + (ix + 1)) + i
					s4 = c.d * (c.n * (iy + 1) + ix) + i

					'
					' Calculate
					'
					v = c.f(s1)
					f(i) = f(i) + v * t0 * u0
					v = c.f(sfy + s1) / du
					f(i) = f(i) + v * t0 * u1
					v = -(3 * c.f(s1)) + 3 * c.f(s4) - 2 * c.f(sfy + s1) / du - c.f(sfy + s4) / du
					f(i) = f(i) + v * t0 * u2
					v = 2 * c.f(s1) - 2 * c.f(s4) + c.f(sfy + s1) / du + c.f(sfy + s4) / du
					f(i) = f(i) + v * t0 * u3
					v = c.f(sfx + s1) / dt
					f(i) = f(i) + v * t1 * u0
					v = c.f(sfxy + s1) / (dt * du)
					f(i) = f(i) + v * t1 * u1
					v = -(3 * c.f(sfx + s1) / dt) + 3 * c.f(sfx + s4) / dt - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t1 * u2
					v = 2 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s4) / dt + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t1 * u3
					v = -(3 * c.f(s1)) + 3 * c.f(s2) - 2 * c.f(sfx + s1) / dt - c.f(sfx + s2) / dt
					f(i) = f(i) + v * t2 * u0
					v = -(3 * c.f(sfy + s1) / du) + 3 * c.f(sfy + s2) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du)
					f(i) = f(i) + v * t2 * u1
					v = 9 * c.f(s1) - 9 * c.f(s2) + 9 * c.f(s3) - 9 * c.f(s4) + 6 * c.f(sfx + s1) / dt + 3 * c.f(sfx + s2) / dt - 3 * c.f(sfx + s3) / dt - 6 * c.f(sfx + s4) / dt + 6 * c.f(sfy + s1) / du - 6 * c.f(sfy + s2) / du - 3 * c.f(sfy + s3) / du + 3 * c.f(sfy + s4) / du + 4 * c.f(sfxy + s1) / (dt * du) + 2 * c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + 2 * c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t2 * u2
					v = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 4 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s2) / dt + 2 * c.f(sfx + s3) / dt + 4 * c.f(sfx + s4) / dt - 3 * c.f(sfy + s1) / du + 3 * c.f(sfy + s2) / du + 3 * c.f(sfy + s3) / du - 3 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - 2 * c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t2 * u3
					v = 2 * c.f(s1) - 2 * c.f(s2) + c.f(sfx + s1) / dt + c.f(sfx + s2) / dt
					f(i) = f(i) + v * t3 * u0
					v = 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du)
					f(i) = f(i) + v * t3 * u1
					v = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 3 * c.f(sfx + s1) / dt - 3 * c.f(sfx + s2) / dt + 3 * c.f(sfx + s3) / dt + 3 * c.f(sfx + s4) / dt - 4 * c.f(sfy + s1) / du + 4 * c.f(sfy + s2) / du + 2 * c.f(sfy + s3) / du - 2 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - 2 * c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t3 * u2
					v = 4 * c.f(s1) - 4 * c.f(s2) + 4 * c.f(s3) - 4 * c.f(s4) + 2 * c.f(sfx + s1) / dt + 2 * c.f(sfx + s2) / dt - 2 * c.f(sfx + s3) / dt - 2 * c.f(sfx + s4) / dt + 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du - 2 * c.f(sfy + s3) / du + 2 * c.f(sfy + s4) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + c.f(sfxy + s4) / (dt * du)
					f(i) = f(i) + v * t3 * u3
				Next
				Return
			End If
		End Sub


		'************************************************************************
'        This subroutine calculates bilinear or bicubic vector-valued spline at the
'        given point (X,Y).
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X, Y-   point
'
'        OUTPUT PARAMETERS:
'            F   -   array[D] which stores function values.  F is out-parameter and
'                    it  is  reallocated  after  call to this function. In case you
'                    want  to    reuse  previously  allocated  F,   you   may   use
'                    Spline2DCalcVBuf(),  which  reallocates  F only when it is too
'                    small.
'
'          -- ALGLIB PROJECT --
'             Copyright 16.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dcalcv(c As spline2dinterpolant, x As Double, y As Double, ByRef f As Double())
			f = New Double(-1) {}

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline2DCalcV: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(x) AndAlso Math.isfinite(y), "Spline2DCalcV: either X=NaN/Infinite or Y=NaN/Infinite")
			f = New Double(c.d - 1) {}
			spline2dcalcvbuf(c, x, y, f)
		End Sub


		'************************************************************************
'        This subroutine unpacks two-dimensional spline into the coefficients table
'
'        Input parameters:
'            C   -   spline interpolant.
'
'        Result:
'            M, N-   grid size (x-axis and y-axis)
'            D   -   number of components
'            Tbl -   coefficients table, unpacked format,
'                    D - components: [0..(N-1)*(M-1)*D-1, 0..19].
'                    For T=0..D-1 (component index), I = 0...N-2 (x index),
'                    J=0..M-2 (y index):
'                        K :=  T + I*D + J*D*(N-1)
'                        
'                        K-th row stores decomposition for T-th component of the
'                        vector-valued function
'                        
'                        Tbl[K,0] = X[i]
'                        Tbl[K,1] = X[i+1]
'                        Tbl[K,2] = Y[j]
'                        Tbl[K,3] = Y[j+1]
'                        Tbl[K,4] = C00
'                        Tbl[K,5] = C01
'                        Tbl[K,6] = C02
'                        Tbl[K,7] = C03
'                        Tbl[K,8] = C10
'                        Tbl[K,9] = C11
'                        ...
'                        Tbl[K,19] = C33
'                    On each grid square spline is equals to:
'                        S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
'                        t = x-x[j]
'                        u = y-y[i]
'
'          -- ALGLIB PROJECT --
'             Copyright 16.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dunpackv(c As spline2dinterpolant, ByRef m As Integer, ByRef n As Integer, ByRef d As Integer, ByRef tbl As Double(,))
			Dim k As Integer = 0
			Dim p As Integer = 0
			Dim ci As Integer = 0
			Dim cj As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim s3 As Integer = 0
			Dim s4 As Integer = 0
			Dim sfx As Integer = 0
			Dim sfy As Integer = 0
			Dim sfxy As Integer = 0
			Dim y1 As Double = 0
			Dim y2 As Double = 0
			Dim y3 As Double = 0
			Dim y4 As Double = 0
			Dim dt As Double = 0
			Dim du As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k0 As Integer = 0

			m = 0
			n = 0
			d = 0
			tbl = New Double(-1, -1) {}

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline2DUnpackV: incorrect C (incorrect parameter C.SType)")
			n = c.n
			m = c.m
			d = c.d
			tbl = New Double((n - 1) * (m - 1) * d - 1, 19) {}
			sfx = n * m * d
			sfy = 2 * n * m * d
			sfxy = 3 * n * m * d
			For i = 0 To m - 2
				For j = 0 To n - 2
					For k = 0 To d - 1
						p = d * (i * (n - 1) + j) + k
						tbl(p, 0) = c.x(j)
						tbl(p, 1) = c.x(j + 1)
						tbl(p, 2) = c.y(i)
						tbl(p, 3) = c.y(i + 1)
						dt = 1 / (tbl(p, 1) - tbl(p, 0))
						du = 1 / (tbl(p, 3) - tbl(p, 2))

						'
						' Bilinear interpolation
						'
						If c.stype = -1 Then
							For k0 = 4 To 19
								tbl(p, k0) = 0
							Next
							y1 = c.f(d * (n * i + j) + k)
							y2 = c.f(d * (n * i + (j + 1)) + k)
							y3 = c.f(d * (n * (i + 1) + (j + 1)) + k)
							y4 = c.f(d * (n * (i + 1) + j) + k)
							tbl(p, 4) = y1
							tbl(p, 4 + 1 * 4 + 0) = y2 - y1
							tbl(p, 4 + 0 * 4 + 1) = y4 - y1
							tbl(p, 4 + 1 * 4 + 1) = y3 - y2 - y4 + y1
						End If

						'
						' Bicubic interpolation
						'
						If c.stype = -3 Then
							s1 = d * (n * i + j) + k
							s2 = d * (n * i + (j + 1)) + k
							s3 = d * (n * (i + 1) + (j + 1)) + k
							s4 = d * (n * (i + 1) + j) + k
							tbl(p, 4 + 0 * 4 + 0) = c.f(s1)
							tbl(p, 4 + 0 * 4 + 1) = c.f(sfy + s1) / du
							tbl(p, 4 + 0 * 4 + 2) = -(3 * c.f(s1)) + 3 * c.f(s4) - 2 * c.f(sfy + s1) / du - c.f(sfy + s4) / du
							tbl(p, 4 + 0 * 4 + 3) = 2 * c.f(s1) - 2 * c.f(s4) + c.f(sfy + s1) / du + c.f(sfy + s4) / du
							tbl(p, 4 + 1 * 4 + 0) = c.f(sfx + s1) / dt
							tbl(p, 4 + 1 * 4 + 1) = c.f(sfxy + s1) / (dt * du)
							tbl(p, 4 + 1 * 4 + 2) = -(3 * c.f(sfx + s1) / dt) + 3 * c.f(sfx + s4) / dt - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s4) / (dt * du)
							tbl(p, 4 + 1 * 4 + 3) = 2 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s4) / dt + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s4) / (dt * du)
							tbl(p, 4 + 2 * 4 + 0) = -(3 * c.f(s1)) + 3 * c.f(s2) - 2 * c.f(sfx + s1) / dt - c.f(sfx + s2) / dt
							tbl(p, 4 + 2 * 4 + 1) = -(3 * c.f(sfy + s1) / du) + 3 * c.f(sfy + s2) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du)
							tbl(p, 4 + 2 * 4 + 2) = 9 * c.f(s1) - 9 * c.f(s2) + 9 * c.f(s3) - 9 * c.f(s4) + 6 * c.f(sfx + s1) / dt + 3 * c.f(sfx + s2) / dt - 3 * c.f(sfx + s3) / dt - 6 * c.f(sfx + s4) / dt + 6 * c.f(sfy + s1) / du - 6 * c.f(sfy + s2) / du - 3 * c.f(sfy + s3) / du + 3 * c.f(sfy + s4) / du + 4 * c.f(sfxy + s1) / (dt * du) + 2 * c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + 2 * c.f(sfxy + s4) / (dt * du)
							tbl(p, 4 + 2 * 4 + 3) = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 4 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s2) / dt + 2 * c.f(sfx + s3) / dt + 4 * c.f(sfx + s4) / dt - 3 * c.f(sfy + s1) / du + 3 * c.f(sfy + s2) / du + 3 * c.f(sfy + s3) / du - 3 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - 2 * c.f(sfxy + s4) / (dt * du)
							tbl(p, 4 + 3 * 4 + 0) = 2 * c.f(s1) - 2 * c.f(s2) + c.f(sfx + s1) / dt + c.f(sfx + s2) / dt
							tbl(p, 4 + 3 * 4 + 1) = 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du)
							tbl(p, 4 + 3 * 4 + 2) = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 3 * c.f(sfx + s1) / dt - 3 * c.f(sfx + s2) / dt + 3 * c.f(sfx + s3) / dt + 3 * c.f(sfx + s4) / dt - 4 * c.f(sfy + s1) / du + 4 * c.f(sfy + s2) / du + 2 * c.f(sfy + s3) / du - 2 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - 2 * c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - c.f(sfxy + s4) / (dt * du)
							tbl(p, 4 + 3 * 4 + 3) = 4 * c.f(s1) - 4 * c.f(s2) + 4 * c.f(s3) - 4 * c.f(s4) + 2 * c.f(sfx + s1) / dt + 2 * c.f(sfx + s2) / dt - 2 * c.f(sfx + s3) / dt - 2 * c.f(sfx + s4) / dt + 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du - 2 * c.f(sfy + s3) / du + 2 * c.f(sfy + s4) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + c.f(sfxy + s4) / (dt * du)
						End If

						'
						' Rescale Cij
						'
						For ci = 0 To 3
							For cj = 0 To 3
								tbl(p, 4 + ci * 4 + cj) = tbl(p, 4 + ci * 4 + cj) * System.Math.Pow(dt, ci) * System.Math.Pow(du, cj)
							Next
						Next
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine was deprecated in ALGLIB 3.6.0
'
'        We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
'        flexible and accepts its arguments in more convenient order.
'
'          -- ALGLIB PROJECT --
'             Copyright 05.07.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dbuildbilinear(x As Double(), y As Double(), f As Double(,), m As Integer, n As Integer, c As spline2dinterpolant)
			Dim t As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			alglib.ap.assert(n >= 2, "Spline2DBuildBilinear: N<2")
			alglib.ap.assert(m >= 2, "Spline2DBuildBilinear: M<2")
			alglib.ap.assert(alglib.ap.len(x) >= n AndAlso alglib.ap.len(y) >= m, "Spline2DBuildBilinear: length of X or Y is too short (Length(X/Y)<N/M)")
			alglib.ap.assert(apserv.isfinitevector(x, n) AndAlso apserv.isfinitevector(y, m), "Spline2DBuildBilinear: X or Y contains NaN or Infinite value")
			alglib.ap.assert(alglib.ap.rows(f) >= m AndAlso alglib.ap.cols(f) >= n, "Spline2DBuildBilinear: size of F is too small (rows(F)<M or cols(F)<N)")
			alglib.ap.assert(apserv.apservisfinitematrix(f, m, n), "Spline2DBuildBilinear: F contains NaN or Infinite value")

			'
			' Fill interpolant
			'
			c.k = 1
			c.n = n
			c.m = m
			c.d = 1
			c.stype = -1
			c.x = New Double(c.n - 1) {}
			c.y = New Double(c.m - 1) {}
			c.f = New Double(c.n * c.m - 1) {}
			For i = 0 To c.n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To c.m - 1
				c.y(i) = y(i)
			Next
			For i = 0 To c.m - 1
				For j = 0 To c.n - 1
					c.f(i * c.n + j) = f(i, j)
				Next
			Next

			'
			' Sort points
			'
			For j = 0 To c.n - 1
				k = j
				For i = j + 1 To c.n - 1
					If CDbl(c.x(i)) < CDbl(c.x(k)) Then
						k = i
					End If
				Next
				If k <> j Then
					For i = 0 To c.m - 1
						t = c.f(i * c.n + j)
						c.f(i * c.n + j) = c.f(i * c.n + k)
						c.f(i * c.n + k) = t
					Next
					t = c.x(j)
					c.x(j) = c.x(k)
					c.x(k) = t
				End If
			Next
			For i = 0 To c.m - 1
				k = i
				For j = i + 1 To c.m - 1
					If CDbl(c.y(j)) < CDbl(c.y(k)) Then
						k = j
					End If
				Next
				If k <> i Then
					For j = 0 To c.n - 1
						t = c.f(i * c.n + j)
						c.f(i * c.n + j) = c.f(k * c.n + j)
						c.f(k * c.n + j) = t
					Next
					t = c.y(i)
					c.y(i) = c.y(k)
					c.y(k) = t
				End If
			Next
		End Sub


		'************************************************************************
'        This subroutine was deprecated in ALGLIB 3.6.0
'
'        We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
'        flexible and accepts its arguments in more convenient order.
'
'          -- ALGLIB PROJECT --
'             Copyright 05.07.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dbuildbicubic(x As Double(), y As Double(), f As Double(,), m As Integer, n As Integer, c As spline2dinterpolant)
			Dim sfx As Integer = 0
			Dim sfy As Integer = 0
			Dim sfxy As Integer = 0
			Dim dx As Double(,) = New Double(-1, -1) {}
			Dim dy As Double(,) = New Double(-1, -1) {}
			Dim dxy As Double(,) = New Double(-1, -1) {}
			Dim t As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			f = DirectCast(f.Clone(), Double(,))

			alglib.ap.assert(n >= 2, "Spline2DBuildBicubicSpline: N<2")
			alglib.ap.assert(m >= 2, "Spline2DBuildBicubicSpline: M<2")
			alglib.ap.assert(alglib.ap.len(x) >= n AndAlso alglib.ap.len(y) >= m, "Spline2DBuildBicubic: length of X or Y is too short (Length(X/Y)<N/M)")
			alglib.ap.assert(apserv.isfinitevector(x, n) AndAlso apserv.isfinitevector(y, m), "Spline2DBuildBicubic: X or Y contains NaN or Infinite value")
			alglib.ap.assert(alglib.ap.rows(f) >= m AndAlso alglib.ap.cols(f) >= n, "Spline2DBuildBicubic: size of F is too small (rows(F)<M or cols(F)<N)")
			alglib.ap.assert(apserv.apservisfinitematrix(f, m, n), "Spline2DBuildBicubic: F contains NaN or Infinite value")

			'
			' Fill interpolant:
			'  F[0]...F[N*M-1]:
			'      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
			'  F[N*M]...F[2*N*M-1]:
			'      df(i,j)/dx table.
			'  F[2*N*M]...F[3*N*M-1]:
			'      df(i,j)/dy table.
			'  F[3*N*M]...F[4*N*M-1]:
			'      d2f(i,j)/dxdy table.
			'
			c.k = 3
			c.d = 1
			c.n = n
			c.m = m
			c.stype = -3
			sfx = c.n * c.m
			sfy = 2 * c.n * c.m
			sfxy = 3 * c.n * c.m
			c.x = New Double(c.n - 1) {}
			c.y = New Double(c.m - 1) {}
			c.f = New Double(4 * c.n * c.m - 1) {}
			For i = 0 To c.n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To c.m - 1
				c.y(i) = y(i)
			Next

			'
			' Sort points
			'
			For j = 0 To c.n - 1
				k = j
				For i = j + 1 To c.n - 1
					If CDbl(c.x(i)) < CDbl(c.x(k)) Then
						k = i
					End If
				Next
				If k <> j Then
					For i = 0 To c.m - 1
						t = f(i, j)
						f(i, j) = f(i, k)
						f(i, k) = t
					Next
					t = c.x(j)
					c.x(j) = c.x(k)
					c.x(k) = t
				End If
			Next
			For i = 0 To c.m - 1
				k = i
				For j = i + 1 To c.m - 1
					If CDbl(c.y(j)) < CDbl(c.y(k)) Then
						k = j
					End If
				Next
				If k <> i Then
					For j = 0 To c.n - 1
						t = f(i, j)
						f(i, j) = f(k, j)
						f(k, j) = t
					Next
					t = c.y(i)
					c.y(i) = c.y(k)
					c.y(k) = t
				End If
			Next
			bicubiccalcderivatives(f, c.x, c.y, c.m, c.n, dx, _
				dy, dxy)
			For i = 0 To c.m - 1
				For j = 0 To c.n - 1
					k = i * c.n + j
					c.f(k) = f(i, j)
					c.f(sfx + k) = dx(i, j)
					c.f(sfy + k) = dy(i, j)
					c.f(sfxy + k) = dxy(i, j)
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine was deprecated in ALGLIB 3.6.0
'
'        We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
'        and accepts its arguments in more convenient order.
'
'          -- ALGLIB PROJECT --
'             Copyright 29.06.2007 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline2dunpack(c As spline2dinterpolant, ByRef m As Integer, ByRef n As Integer, ByRef tbl As Double(,))
			Dim k As Integer = 0
			Dim p As Integer = 0
			Dim ci As Integer = 0
			Dim cj As Integer = 0
			Dim s1 As Integer = 0
			Dim s2 As Integer = 0
			Dim s3 As Integer = 0
			Dim s4 As Integer = 0
			Dim sfx As Integer = 0
			Dim sfy As Integer = 0
			Dim sfxy As Integer = 0
			Dim y1 As Double = 0
			Dim y2 As Double = 0
			Dim y3 As Double = 0
			Dim y4 As Double = 0
			Dim dt As Double = 0
			Dim du As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0

			m = 0
			n = 0
			tbl = New Double(-1, -1) {}

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline2DUnpack: incorrect C (incorrect parameter C.SType)")
			If c.d <> 1 Then
				n = 0
				m = 0
				Return
			End If
			n = c.n
			m = c.m
			tbl = New Double((n - 1) * (m - 1) - 1, 19) {}
			sfx = n * m
			sfy = 2 * n * m
			sfxy = 3 * n * m

			'
			' Fill
			'
			For i = 0 To m - 2
				For j = 0 To n - 2
					p = i * (n - 1) + j
					tbl(p, 0) = c.x(j)
					tbl(p, 1) = c.x(j + 1)
					tbl(p, 2) = c.y(i)
					tbl(p, 3) = c.y(i + 1)
					dt = 1 / (tbl(p, 1) - tbl(p, 0))
					du = 1 / (tbl(p, 3) - tbl(p, 2))

					'
					' Bilinear interpolation
					'
					If c.stype = -1 Then
						For k = 4 To 19
							tbl(p, k) = 0
						Next
						y1 = c.f(n * i + j)
						y2 = c.f(n * i + (j + 1))
						y3 = c.f(n * (i + 1) + (j + 1))
						y4 = c.f(n * (i + 1) + j)
						tbl(p, 4) = y1
						tbl(p, 4 + 1 * 4 + 0) = y2 - y1
						tbl(p, 4 + 0 * 4 + 1) = y4 - y1
						tbl(p, 4 + 1 * 4 + 1) = y3 - y2 - y4 + y1
					End If

					'
					' Bicubic interpolation
					'
					If c.stype = -3 Then
						s1 = n * i + j
						s2 = n * i + (j + 1)
						s3 = n * (i + 1) + (j + 1)
						s4 = n * (i + 1) + j
						tbl(p, 4 + 0 * 4 + 0) = c.f(s1)
						tbl(p, 4 + 0 * 4 + 1) = c.f(sfy + s1) / du
						tbl(p, 4 + 0 * 4 + 2) = -(3 * c.f(s1)) + 3 * c.f(s4) - 2 * c.f(sfy + s1) / du - c.f(sfy + s4) / du
						tbl(p, 4 + 0 * 4 + 3) = 2 * c.f(s1) - 2 * c.f(s4) + c.f(sfy + s1) / du + c.f(sfy + s4) / du
						tbl(p, 4 + 1 * 4 + 0) = c.f(sfx + s1) / dt
						tbl(p, 4 + 1 * 4 + 1) = c.f(sfxy + s1) / (dt * du)
						tbl(p, 4 + 1 * 4 + 2) = -(3 * c.f(sfx + s1) / dt) + 3 * c.f(sfx + s4) / dt - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s4) / (dt * du)
						tbl(p, 4 + 1 * 4 + 3) = 2 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s4) / dt + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s4) / (dt * du)
						tbl(p, 4 + 2 * 4 + 0) = -(3 * c.f(s1)) + 3 * c.f(s2) - 2 * c.f(sfx + s1) / dt - c.f(sfx + s2) / dt
						tbl(p, 4 + 2 * 4 + 1) = -(3 * c.f(sfy + s1) / du) + 3 * c.f(sfy + s2) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du)
						tbl(p, 4 + 2 * 4 + 2) = 9 * c.f(s1) - 9 * c.f(s2) + 9 * c.f(s3) - 9 * c.f(s4) + 6 * c.f(sfx + s1) / dt + 3 * c.f(sfx + s2) / dt - 3 * c.f(sfx + s3) / dt - 6 * c.f(sfx + s4) / dt + 6 * c.f(sfy + s1) / du - 6 * c.f(sfy + s2) / du - 3 * c.f(sfy + s3) / du + 3 * c.f(sfy + s4) / du + 4 * c.f(sfxy + s1) / (dt * du) + 2 * c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + 2 * c.f(sfxy + s4) / (dt * du)
						tbl(p, 4 + 2 * 4 + 3) = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 4 * c.f(sfx + s1) / dt - 2 * c.f(sfx + s2) / dt + 2 * c.f(sfx + s3) / dt + 4 * c.f(sfx + s4) / dt - 3 * c.f(sfy + s1) / du + 3 * c.f(sfy + s2) / du + 3 * c.f(sfy + s3) / du - 3 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - 2 * c.f(sfxy + s4) / (dt * du)
						tbl(p, 4 + 3 * 4 + 0) = 2 * c.f(s1) - 2 * c.f(s2) + c.f(sfx + s1) / dt + c.f(sfx + s2) / dt
						tbl(p, 4 + 3 * 4 + 1) = 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du)
						tbl(p, 4 + 3 * 4 + 2) = -(6 * c.f(s1)) + 6 * c.f(s2) - 6 * c.f(s3) + 6 * c.f(s4) - 3 * c.f(sfx + s1) / dt - 3 * c.f(sfx + s2) / dt + 3 * c.f(sfx + s3) / dt + 3 * c.f(sfx + s4) / dt - 4 * c.f(sfy + s1) / du + 4 * c.f(sfy + s2) / du + 2 * c.f(sfy + s3) / du - 2 * c.f(sfy + s4) / du - 2 * c.f(sfxy + s1) / (dt * du) - 2 * c.f(sfxy + s2) / (dt * du) - c.f(sfxy + s3) / (dt * du) - c.f(sfxy + s4) / (dt * du)
						tbl(p, 4 + 3 * 4 + 3) = 4 * c.f(s1) - 4 * c.f(s2) + 4 * c.f(s3) - 4 * c.f(s4) + 2 * c.f(sfx + s1) / dt + 2 * c.f(sfx + s2) / dt - 2 * c.f(sfx + s3) / dt - 2 * c.f(sfx + s4) / dt + 2 * c.f(sfy + s1) / du - 2 * c.f(sfy + s2) / du - 2 * c.f(sfy + s3) / du + 2 * c.f(sfy + s4) / du + c.f(sfxy + s1) / (dt * du) + c.f(sfxy + s2) / (dt * du) + c.f(sfxy + s3) / (dt * du) + c.f(sfxy + s4) / (dt * du)
					End If

					'
					' Rescale Cij
					'
					For ci = 0 To 3
						For cj = 0 To 3
							tbl(p, 4 + ci * 4 + cj) = tbl(p, 4 + ci * 4 + cj) * System.Math.Pow(dt, ci) * System.Math.Pow(du, cj)
						Next
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        Internal subroutine.
'        Calculation of the first derivatives and the cross-derivative.
'        ************************************************************************

		Private Shared Sub bicubiccalcderivatives(a As Double(,), x As Double(), y As Double(), m As Integer, n As Integer, ByRef dx As Double(,), _
			ByRef dy As Double(,), ByRef dxy As Double(,))
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim xt As Double() = New Double(-1) {}
			Dim ft As Double() = New Double(-1) {}
			Dim s As Double = 0
			Dim ds As Double = 0
			Dim d2s As Double = 0
			Dim c As New spline1d.spline1dinterpolant()

			dx = New Double(-1, -1) {}
			dy = New Double(-1, -1) {}
			dxy = New Double(-1, -1) {}

			dx = New Double(m - 1, n - 1) {}
			dy = New Double(m - 1, n - 1) {}
			dxy = New Double(m - 1, n - 1) {}

			'
			' dF/dX
			'
			xt = New Double(n - 1) {}
			ft = New Double(n - 1) {}
			For i = 0 To m - 1
				For j = 0 To n - 1
					xt(j) = x(j)
					ft(j) = a(i, j)
				Next
				spline1d.spline1dbuildcubic(xt, ft, n, 0, 0.0, 0, _
					0.0, c)
				For j = 0 To n - 1
					spline1d.spline1ddiff(c, x(j), s, ds, d2s)
					dx(i, j) = ds
				Next
			Next

			'
			' dF/dY
			'
			xt = New Double(m - 1) {}
			ft = New Double(m - 1) {}
			For j = 0 To n - 1
				For i = 0 To m - 1
					xt(i) = y(i)
					ft(i) = a(i, j)
				Next
				spline1d.spline1dbuildcubic(xt, ft, m, 0, 0.0, 0, _
					0.0, c)
				For i = 0 To m - 1
					spline1d.spline1ddiff(c, y(i), s, ds, d2s)
					dy(i, j) = ds
				Next
			Next

			'
			' d2F/dXdY
			'
			xt = New Double(n - 1) {}
			ft = New Double(n - 1) {}
			For i = 0 To m - 1
				For j = 0 To n - 1
					xt(j) = x(j)
					ft(j) = dy(i, j)
				Next
				spline1d.spline1dbuildcubic(xt, ft, n, 0, 0.0, 0, _
					0.0, c)
				For j = 0 To n - 1
					spline1d.spline1ddiff(c, x(j), s, ds, d2s)
					dxy(i, j) = ds
				Next
			Next
		End Sub


	End Class
	Public Class spline3d
		'************************************************************************
'        3-dimensional spline inteprolant
'        ************************************************************************

		Public Class spline3dinterpolant
			Inherits apobject
			Public k As Integer
			Public stype As Integer
			Public n As Integer
			Public m As Integer
			Public l As Integer
			Public d As Integer
			Public x As Double()
			Public y As Double()
			Public z As Double()
			Public f As Double()
			Public Sub New()
				init()
			End Sub
			Public Overrides Sub init()
				x = New Double(-1) {}
				y = New Double(-1) {}
				z = New Double(-1) {}
				f = New Double(-1) {}
			End Sub
			Public Overrides Function make_copy() As alglib.apobject
				Dim _result As New spline3dinterpolant()
				_result.k = k
				_result.stype = stype
				_result.n = n
				_result.m = m
				_result.l = l
				_result.d = d
				_result.x = DirectCast(x.Clone(), Double())
				_result.y = DirectCast(y.Clone(), Double())
				_result.z = DirectCast(z.Clone(), Double())
				_result.f = DirectCast(f.Clone(), Double())
				Return _result
			End Function
		End Class




		'************************************************************************
'        This subroutine calculates the value of the trilinear or tricubic spline at
'        the given point (X,Y,Z).
'
'        INPUT PARAMETERS:
'            C   -   coefficients table.
'                    Built by BuildBilinearSpline or BuildBicubicSpline.
'            X, Y,
'            Z   -   point
'
'        Result:
'            S(x,y,z)
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Function spline3dcalc(c As spline3dinterpolant, x As Double, y As Double, z As Double) As Double
			Dim result As Double = 0
			Dim v As Double = 0
			Dim vx As Double = 0
			Dim vy As Double = 0
			Dim vxy As Double = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline3DCalc: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert((Math.isfinite(x) AndAlso Math.isfinite(y)) AndAlso Math.isfinite(z), "Spline3DCalc: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite")
			If c.d <> 1 Then
				result = 0
				Return result
			End If
			spline3ddiff(c, x, y, z, v, vx, _
				vy, vxy)
			result = v
			Return result
		End Function


		'************************************************************************
'        This subroutine performs linear transformation of the spline argument.
'
'        INPUT PARAMETERS:
'            C       -   spline interpolant
'            AX, BX  -   transformation coefficients: x = A*u + B
'            AY, BY  -   transformation coefficients: y = A*v + B
'            AZ, BZ  -   transformation coefficients: z = A*w + B
'            
'        OUTPUT PARAMETERS:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dlintransxyz(c As spline3dinterpolant, ax As Double, bx As Double, ay As Double, by As Double, az As Double, _
			bz As Double)
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim z As Double() = New Double(-1) {}
			Dim f As Double() = New Double(-1) {}
			Dim v As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim di As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline3DLinTransXYZ: incorrect C (incorrect parameter C.SType)")
			x = New Double(c.n - 1) {}
			y = New Double(c.m - 1) {}
			z = New Double(c.l - 1) {}
			f = New Double(c.m * c.n * c.l * c.d - 1) {}
			For j = 0 To c.n - 1
				x(j) = c.x(j)
			Next
			For i = 0 To c.m - 1
				y(i) = c.y(i)
			Next
			For i = 0 To c.l - 1
				z(i) = c.z(i)
			Next

			'
			' Handle different combinations of zero/nonzero AX/AY/AZ
			'
			If (CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) <> CDbl(0)) AndAlso CDbl(az) <> CDbl(0) Then
				For i_ = 0 To c.m * c.n * c.l * c.d - 1
					f(i_) = c.f(i_)
				Next
			End If
			If (CDbl(ax) = CDbl(0) AndAlso CDbl(ay) <> CDbl(0)) AndAlso CDbl(az) <> CDbl(0) Then
				For i = 0 To c.m - 1
					For j = 0 To c.l - 1
						spline3dcalcv(c, bx, y(i), z(j), v)
						For k = 0 To c.n - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * j + i) + k) + di) = v(di)
							Next
						Next
					Next
				Next
				ax = 1
				bx = 0
			End If
			If (CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) = CDbl(0)) AndAlso CDbl(az) <> CDbl(0) Then
				For i = 0 To c.n - 1
					For j = 0 To c.l - 1
						spline3dcalcv(c, x(i), by, z(j), v)
						For k = 0 To c.m - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * j + k) + i) + di) = v(di)
							Next
						Next
					Next
				Next
				ay = 1
				by = 0
			End If
			If (CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) <> CDbl(0)) AndAlso CDbl(az) = CDbl(0) Then
				For i = 0 To c.n - 1
					For j = 0 To c.m - 1
						spline3dcalcv(c, x(i), y(j), bz, v)
						For k = 0 To c.l - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * k + j) + i) + di) = v(di)
							Next
						Next
					Next
				Next
				az = 1
				bz = 0
			End If
			If (CDbl(ax) = CDbl(0) AndAlso CDbl(ay) = CDbl(0)) AndAlso CDbl(az) <> CDbl(0) Then
				For i = 0 To c.l - 1
					spline3dcalcv(c, bx, by, z(i), v)
					For k = 0 To c.m - 1
						For j = 0 To c.n - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * i + k) + j) + di) = v(di)
							Next
						Next
					Next
				Next
				ax = 1
				bx = 0
				ay = 1
				by = 0
			End If
			If (CDbl(ax) = CDbl(0) AndAlso CDbl(ay) <> CDbl(0)) AndAlso CDbl(az) = CDbl(0) Then
				For i = 0 To c.m - 1
					spline3dcalcv(c, bx, y(i), bz, v)
					For k = 0 To c.l - 1
						For j = 0 To c.n - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * k + i) + j) + di) = v(di)
							Next
						Next
					Next
				Next
				ax = 1
				bx = 0
				az = 1
				bz = 0
			End If
			If (CDbl(ax) <> CDbl(0) AndAlso CDbl(ay) = CDbl(0)) AndAlso CDbl(az) = CDbl(0) Then
				For i = 0 To c.n - 1
					spline3dcalcv(c, x(i), by, bz, v)
					For k = 0 To c.l - 1
						For j = 0 To c.m - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * k + j) + i) + di) = v(di)
							Next
						Next
					Next
				Next
				ay = 1
				by = 0
				az = 1
				bz = 0
			End If
			If (CDbl(ax) = CDbl(0) AndAlso CDbl(ay) = CDbl(0)) AndAlso CDbl(az) = CDbl(0) Then
				spline3dcalcv(c, bx, by, bz, v)
				For k = 0 To c.l - 1
					For j = 0 To c.m - 1
						For i = 0 To c.n - 1
							For di = 0 To c.d - 1
								f(c.d * (c.n * (c.m * k + j) + i) + di) = v(di)
							Next
						Next
					Next
				Next
				ax = 1
				bx = 0
				ay = 1
				by = 0
				az = 1
				bz = 0
			End If

			'
			' General case: AX<>0, AY<>0, AZ<>0
			' Unpack, scale and pack again.
			'
			For i = 0 To c.n - 1
				x(i) = (x(i) - bx) / ax
			Next
			For i = 0 To c.m - 1
				y(i) = (y(i) - by) / ay
			Next
			For i = 0 To c.l - 1
				z(i) = (z(i) - bz) / az
			Next
			If c.stype = -1 Then
				spline3dbuildtrilinearv(x, c.n, y, c.m, z, c.l, _
					f, c.d, c)
			End If
		End Sub


		'************************************************************************
'        This subroutine performs linear transformation of the spline.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B
'            
'        OUTPUT PARAMETERS:
'            C   -   transformed spline
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dlintransf(c As spline3dinterpolant, a As Double, b As Double)
			Dim x As Double() = New Double(-1) {}
			Dim y As Double() = New Double(-1) {}
			Dim z As Double() = New Double(-1) {}
			Dim f As Double() = New Double(-1) {}
			Dim i As Integer = 0
			Dim j As Integer = 0

			alglib.ap.assert(c.stype = -3 OrElse c.stype = -1, "Spline3DLinTransF: incorrect C (incorrect parameter C.SType)")
			x = New Double(c.n - 1) {}
			y = New Double(c.m - 1) {}
			z = New Double(c.l - 1) {}
			f = New Double(c.m * c.n * c.l * c.d - 1) {}
			For j = 0 To c.n - 1
				x(j) = c.x(j)
			Next
			For i = 0 To c.m - 1
				y(i) = c.y(i)
			Next
			For i = 0 To c.l - 1
				z(i) = c.z(i)
			Next
			For i = 0 To c.m * c.n * c.l * c.d - 1
				f(i) = a * c.f(i) + b
			Next
			If c.stype = -1 Then
				spline3dbuildtrilinearv(x, c.n, y, c.m, z, c.l, _
					f, c.d, c)
			End If
		End Sub


		'************************************************************************
'        This subroutine makes the copy of the spline model.
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant
'
'        OUTPUT PARAMETERS:
'            CC  -   spline copy
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dcopy(c As spline3dinterpolant, cc As spline3dinterpolant)
			Dim tblsize As Integer = 0
			Dim i_ As Integer = 0

			alglib.ap.assert(c.k = 1 OrElse c.k = 3, "Spline3DCopy: incorrect C (incorrect parameter C.K)")
			cc.k = c.k
			cc.n = c.n
			cc.m = c.m
			cc.l = c.l
			cc.d = c.d
			tblsize = c.n * c.m * c.l * c.d
			cc.stype = c.stype
			cc.x = New Double(cc.n - 1) {}
			cc.y = New Double(cc.m - 1) {}
			cc.z = New Double(cc.l - 1) {}
			cc.f = New Double(tblsize - 1) {}
			For i_ = 0 To cc.n - 1
				cc.x(i_) = c.x(i_)
			Next
			For i_ = 0 To cc.m - 1
				cc.y(i_) = c.y(i_)
			Next
			For i_ = 0 To cc.l - 1
				cc.z(i_) = c.z(i_)
			Next
			For i_ = 0 To tblsize - 1
				cc.f(i_) = c.f(i_)
			Next
		End Sub


		'************************************************************************
'        Trilinear spline resampling
'
'        INPUT PARAMETERS:
'            A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
'                            values at the old grid, :
'                                A[0]        x=0,y=0,z=0
'                                A[1]        x=1,y=0,z=0
'                                A[..]       ...
'                                A[..]       x=oldxcount-1,y=0,z=0
'                                A[..]       x=0,y=1,z=0
'                                A[..]       ...
'                                ...
'            OldZCount   -   old Z-count, OldZCount>1
'            OldYCount   -   old Y-count, OldYCount>1
'            OldXCount   -   old X-count, OldXCount>1
'            NewZCount   -   new Z-count, NewZCount>1
'            NewYCount   -   new Y-count, NewYCount>1
'            NewXCount   -   new X-count, NewXCount>1
'
'        OUTPUT PARAMETERS:
'            B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
'                            values at the new grid:
'                                B[0]        x=0,y=0,z=0
'                                B[1]        x=1,y=0,z=0
'                                B[..]       ...
'                                B[..]       x=newxcount-1,y=0,z=0
'                                B[..]       x=0,y=1,z=0
'                                B[..]       ...
'                                ...
'
'          -- ALGLIB routine --
'             26.04.2012
'             Copyright by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dresampletrilinear(a As Double(), oldzcount As Integer, oldycount As Integer, oldxcount As Integer, newzcount As Integer, newycount As Integer, _
			newxcount As Integer, ByRef b As Double())
			Dim xd As Double = 0
			Dim yd As Double = 0
			Dim zd As Double = 0
			Dim c0 As Double = 0
			Dim c1 As Double = 0
			Dim c2 As Double = 0
			Dim c3 As Double = 0
			Dim ix As Integer = 0
			Dim iy As Integer = 0
			Dim iz As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0

			b = New Double(-1) {}

			alglib.ap.assert((oldycount > 1 AndAlso oldzcount > 1) AndAlso oldxcount > 1, "Spline3DResampleTrilinear: length/width/height less than 1")
			alglib.ap.assert((newycount > 1 AndAlso newzcount > 1) AndAlso newxcount > 1, "Spline3DResampleTrilinear: length/width/height less than 1")
			alglib.ap.assert(alglib.ap.len(a) >= oldycount * oldzcount * oldxcount, "Spline3DResampleTrilinear: length/width/height less than 1")
			b = New Double(newxcount * newycount * newzcount - 1) {}
			For i = 0 To newxcount - 1
				For j = 0 To newycount - 1
					For k = 0 To newzcount - 1
						ix = i * (oldxcount - 1) \ (newxcount - 1)
						If ix = oldxcount - 1 Then
							ix = oldxcount - 2
						End If
						xd = CDbl(i * (oldxcount - 1)) / CDbl(newxcount - 1) - ix
						iy = j * (oldycount - 1) \ (newycount - 1)
						If iy = oldycount - 1 Then
							iy = oldycount - 2
						End If
						yd = CDbl(j * (oldycount - 1)) / CDbl(newycount - 1) - iy
						iz = k * (oldzcount - 1) \ (newzcount - 1)
						If iz = oldzcount - 1 Then
							iz = oldzcount - 2
						End If
						zd = CDbl(k * (oldzcount - 1)) / CDbl(newzcount - 1) - iz
						c0 = a(oldxcount * (oldycount * iz + iy) + ix) * (1 - xd) + a(oldxcount * (oldycount * iz + iy) + (ix + 1)) * xd
						c1 = a(oldxcount * (oldycount * iz + (iy + 1)) + ix) * (1 - xd) + a(oldxcount * (oldycount * iz + (iy + 1)) + (ix + 1)) * xd
						c2 = a(oldxcount * (oldycount * (iz + 1) + iy) + ix) * (1 - xd) + a(oldxcount * (oldycount * (iz + 1) + iy) + (ix + 1)) * xd
						c3 = a(oldxcount * (oldycount * (iz + 1) + (iy + 1)) + ix) * (1 - xd) + a(oldxcount * (oldycount * (iz + 1) + (iy + 1)) + (ix + 1)) * xd
						c0 = c0 * (1 - yd) + c1 * yd
						c1 = c2 * (1 - yd) + c3 * yd
						b(newxcount * (newycount * k + j) + i) = c0 * (1 - zd) + c1 * zd
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine builds trilinear vector-valued spline.
'
'        INPUT PARAMETERS:
'            X   -   spline abscissas,  array[0..N-1]
'            Y   -   spline ordinates,  array[0..M-1]
'            Z   -   spline applicates, array[0..L-1] 
'            F   -   function values, array[0..M*N*L*D-1]:
'                    * first D elements store D values at (X[0],Y[0],Z[0])
'                    * next D elements store D values at (X[1],Y[0],Z[0])
'                    * next D elements store D values at (X[2],Y[0],Z[0])
'                    * ...
'                    * next D elements store D values at (X[0],Y[1],Z[0])
'                    * next D elements store D values at (X[1],Y[1],Z[0])
'                    * next D elements store D values at (X[2],Y[1],Z[0])
'                    * ...
'                    * next D elements store D values at (X[0],Y[0],Z[1])
'                    * next D elements store D values at (X[1],Y[0],Z[1])
'                    * next D elements store D values at (X[2],Y[0],Z[1])
'                    * ...
'                    * general form - D function values at (X[i],Y[j]) are stored
'                      at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
'            M,N,
'            L   -   grid size, M>=2, N>=2, L>=2
'            D   -   vector dimension, D>=1
'
'        OUTPUT PARAMETERS:
'            C   -   spline interpolant
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dbuildtrilinearv(x As Double(), n As Integer, y As Double(), m As Integer, z As Double(), l As Integer, _
			f As Double(), d As Integer, c As spline3dinterpolant)
			Dim t As Double = 0
			Dim tblsize As Integer = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim i0 As Integer = 0
			Dim j0 As Integer = 0

			alglib.ap.assert(m >= 2, "Spline3DBuildTrilinearV: M<2")
			alglib.ap.assert(n >= 2, "Spline3DBuildTrilinearV: N<2")
			alglib.ap.assert(l >= 2, "Spline3DBuildTrilinearV: L<2")
			alglib.ap.assert(d >= 1, "Spline3DBuildTrilinearV: D<1")
			alglib.ap.assert((alglib.ap.len(x) >= n AndAlso alglib.ap.len(y) >= m) AndAlso alglib.ap.len(z) >= l, "Spline3DBuildTrilinearV: length of X, Y or Z is too short (Length(X/Y/Z)<N/M/L)")
			alglib.ap.assert((apserv.isfinitevector(x, n) AndAlso apserv.isfinitevector(y, m)) AndAlso apserv.isfinitevector(z, l), "Spline3DBuildTrilinearV: X, Y or Z contains NaN or Infinite value")
			tblsize = n * m * l * d
			alglib.ap.assert(alglib.ap.len(f) >= tblsize, "Spline3DBuildTrilinearV: length of F is too short (Length(F)<N*M*L*D)")
			alglib.ap.assert(apserv.isfinitevector(f, tblsize), "Spline3DBuildTrilinearV: F contains NaN or Infinite value")

			'
			' Fill interpolant
			'
			c.k = 1
			c.n = n
			c.m = m
			c.l = l
			c.d = d
			c.stype = -1
			c.x = New Double(c.n - 1) {}
			c.y = New Double(c.m - 1) {}
			c.z = New Double(c.l - 1) {}
			c.f = New Double(tblsize - 1) {}
			For i = 0 To c.n - 1
				c.x(i) = x(i)
			Next
			For i = 0 To c.m - 1
				c.y(i) = y(i)
			Next
			For i = 0 To c.l - 1
				c.z(i) = z(i)
			Next
			For i = 0 To tblsize - 1
				c.f(i) = f(i)
			Next

			'
			' Sort points:
			'  * sort x;
			'  * sort y;
			'  * sort z.
			'
			For j = 0 To c.n - 1
				k = j
				For i = j + 1 To c.n - 1
					If CDbl(c.x(i)) < CDbl(c.x(k)) Then
						k = i
					End If
				Next
				If k <> j Then
					For i = 0 To c.m - 1
						For j0 = 0 To c.l - 1
							For i0 = 0 To c.d - 1
								t = c.f(c.d * (c.n * (c.m * j0 + i) + j) + i0)
								c.f(c.d * (c.n * (c.m * j0 + i) + j) + i0) = c.f(c.d * (c.n * (c.m * j0 + i) + k) + i0)
								c.f(c.d * (c.n * (c.m * j0 + i) + k) + i0) = t
							Next
						Next
					Next
					t = c.x(j)
					c.x(j) = c.x(k)
					c.x(k) = t
				End If
			Next
			For i = 0 To c.m - 1
				k = i
				For j = i + 1 To c.m - 1
					If CDbl(c.y(j)) < CDbl(c.y(k)) Then
						k = j
					End If
				Next
				If k <> i Then
					For j = 0 To c.n - 1
						For j0 = 0 To c.l - 1
							For i0 = 0 To c.d - 1
								t = c.f(c.d * (c.n * (c.m * j0 + i) + j) + i0)
								c.f(c.d * (c.n * (c.m * j0 + i) + j) + i0) = c.f(c.d * (c.n * (c.m * j0 + k) + j) + i0)
								c.f(c.d * (c.n * (c.m * j0 + k) + j) + i0) = t
							Next
						Next
					Next
					t = c.y(i)
					c.y(i) = c.y(k)
					c.y(k) = t
				End If
			Next
			For k = 0 To c.l - 1
				i = k
				For j = i + 1 To c.l - 1
					If CDbl(c.z(j)) < CDbl(c.z(i)) Then
						i = j
					End If
				Next
				If i <> k Then
					For j = 0 To c.m - 1
						For j0 = 0 To c.n - 1
							For i0 = 0 To c.d - 1
								t = c.f(c.d * (c.n * (c.m * k + j) + j0) + i0)
								c.f(c.d * (c.n * (c.m * k + j) + j0) + i0) = c.f(c.d * (c.n * (c.m * i + j) + j0) + i0)
								c.f(c.d * (c.n * (c.m * i + j) + j0) + i0) = t
							Next
						Next
					Next
					t = c.z(k)
					c.z(k) = c.z(i)
					c.z(i) = t
				End If
			Next
		End Sub


		'************************************************************************
'        This subroutine calculates bilinear or bicubic vector-valued spline at the
'        given point (X,Y,Z).
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X, Y,
'            Z   -   point
'            F   -   output buffer, possibly preallocated array. In case array size
'                    is large enough to store result, it is not reallocated.  Array
'                    which is too short will be reallocated
'
'        OUTPUT PARAMETERS:
'            F   -   array[D] (or larger) which stores function values
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dcalcvbuf(c As spline3dinterpolant, x As Double, y As Double, z As Double, ByRef f As Double())
			Dim xd As Double = 0
			Dim yd As Double = 0
			Dim zd As Double = 0
			Dim c0 As Double = 0
			Dim c1 As Double = 0
			Dim c2 As Double = 0
			Dim c3 As Double = 0
			Dim ix As Integer = 0
			Dim iy As Integer = 0
			Dim iz As Integer = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim h As Integer = 0
			Dim i As Integer = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline3DCalcVBuf: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert((Math.isfinite(x) AndAlso Math.isfinite(y)) AndAlso Math.isfinite(z), "Spline3DCalcVBuf: X, Y or Z contains NaN/Infinite")
			apserv.rvectorsetlengthatleast(f, c.d)

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = c.n - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.x(h)) >= CDbl(x) Then
					r = h
				Else
					l = h
				End If
			End While
			ix = l

			'
			' Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
			'
			l = 0
			r = c.m - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.y(h)) >= CDbl(y) Then
					r = h
				Else
					l = h
				End If
			End While
			iy = l

			'
			' Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
			'
			l = 0
			r = c.l - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.z(h)) >= CDbl(z) Then
					r = h
				Else
					l = h
				End If
			End While
			iz = l
			xd = (x - c.x(ix)) / (c.x(ix + 1) - c.x(ix))
			yd = (y - c.y(iy)) / (c.y(iy + 1) - c.y(iy))
			zd = (z - c.z(iz)) / (c.z(iz + 1) - c.z(iz))
			For i = 0 To c.d - 1

				'
				' Trilinear interpolation
				'
				If c.stype = -1 Then
					c0 = c.f(c.d * (c.n * (c.m * iz + iy) + ix) + i) * (1 - xd) + c.f(c.d * (c.n * (c.m * iz + iy) + (ix + 1)) + i) * xd
					c1 = c.f(c.d * (c.n * (c.m * iz + (iy + 1)) + ix) + i) * (1 - xd) + c.f(c.d * (c.n * (c.m * iz + (iy + 1)) + (ix + 1)) + i) * xd
					c2 = c.f(c.d * (c.n * (c.m * (iz + 1) + iy) + ix) + i) * (1 - xd) + c.f(c.d * (c.n * (c.m * (iz + 1) + iy) + (ix + 1)) + i) * xd
					c3 = c.f(c.d * (c.n * (c.m * (iz + 1) + (iy + 1)) + ix) + i) * (1 - xd) + c.f(c.d * (c.n * (c.m * (iz + 1) + (iy + 1)) + (ix + 1)) + i) * xd
					c0 = c0 * (1 - yd) + c1 * yd
					c1 = c2 * (1 - yd) + c3 * yd
					f(i) = c0 * (1 - zd) + c1 * zd
				End If
			Next
		End Sub


		'************************************************************************
'        This subroutine calculates trilinear or tricubic vector-valued spline at the
'        given point (X,Y,Z).
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'            X, Y,
'            Z   -   point
'
'        OUTPUT PARAMETERS:
'            F   -   array[D] which stores function values.  F is out-parameter and
'                    it  is  reallocated  after  call to this function. In case you
'                    want  to    reuse  previously  allocated  F,   you   may   use
'                    Spline2DCalcVBuf(),  which  reallocates  F only when it is too
'                    small.
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dcalcv(c As spline3dinterpolant, x As Double, y As Double, z As Double, ByRef f As Double())
			f = New Double(-1) {}

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline3DCalcV: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert((Math.isfinite(x) AndAlso Math.isfinite(y)) AndAlso Math.isfinite(z), "Spline3DCalcV: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite")
			f = New Double(c.d - 1) {}
			spline3dcalcvbuf(c, x, y, z, f)
		End Sub


		'************************************************************************
'        This subroutine unpacks tri-dimensional spline into the coefficients table
'
'        INPUT PARAMETERS:
'            C   -   spline interpolant.
'
'        Result:
'            N   -   grid size (X)
'            M   -   grid size (Y)
'            L   -   grid size (Z)
'            D   -   number of components
'            SType-  spline type. Currently, only one spline type is supported:
'                    trilinear spline, as indicated by SType=1.
'            Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
'                    For T=0..D-1 (component index), I = 0...N-2 (x index),
'                    J=0..M-2 (y index), K=0..L-2 (z index):
'                        Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),
'                        
'                        Q-th row stores decomposition for T-th component of the
'                        vector-valued function
'                        
'                        Tbl[Q,0] = X[i]
'                        Tbl[Q,1] = X[i+1]
'                        Tbl[Q,2] = Y[j]
'                        Tbl[Q,3] = Y[j+1]
'                        Tbl[Q,4] = Z[k]
'                        Tbl[Q,5] = Z[k+1]
'                        
'                        Tbl[Q,6] = C000
'                        Tbl[Q,7] = C100
'                        Tbl[Q,8] = C010
'                        Tbl[Q,9] = C110
'                        Tbl[Q,10]= C001
'                        Tbl[Q,11]= C101
'                        Tbl[Q,12]= C011
'                        Tbl[Q,13]= C111
'                    On each grid square spline is equals to:
'                        S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
'                        t = x-x[j]
'                        u = y-y[i]
'                        v = z-z[k]
'                    
'                    NOTE: format of Tbl is given for SType=1. Future versions of
'                          ALGLIB can use different formats for different values of
'                          SType.
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Public Shared Sub spline3dunpackv(c As spline3dinterpolant, ByRef n As Integer, ByRef m As Integer, ByRef l As Integer, ByRef d As Integer, ByRef stype As Integer, _
			ByRef tbl As Double(,))
			Dim p As Integer = 0
			Dim ci As Integer = 0
			Dim cj As Integer = 0
			Dim ck As Integer = 0
			Dim du As Double = 0
			Dim dv As Double = 0
			Dim dw As Double = 0
			Dim i As Integer = 0
			Dim j As Integer = 0
			Dim k As Integer = 0
			Dim di As Integer = 0
			Dim i0 As Integer = 0

			n = 0
			m = 0
			l = 0
			d = 0
			stype = 0
			tbl = New Double(-1, -1) {}

			alglib.ap.assert(c.stype = -1, "Spline3DUnpackV: incorrect C (incorrect parameter C.SType)")
			n = c.n
			m = c.m
			l = c.l
			d = c.d
			stype = System.Math.Abs(c.stype)
			tbl = New Double((n - 1) * (m - 1) * (l - 1) * d - 1, 13) {}

			'
			' Fill
			'
			For i = 0 To n - 2
				For j = 0 To m - 2
					For k = 0 To l - 2
						For di = 0 To d - 1
							p = d * ((n - 1) * ((m - 1) * k + j) + i) + di
							tbl(p, 0) = c.x(i)
							tbl(p, 1) = c.x(i + 1)
							tbl(p, 2) = c.y(j)
							tbl(p, 3) = c.y(j + 1)
							tbl(p, 4) = c.z(k)
							tbl(p, 5) = c.z(k + 1)
							du = 1 / (tbl(p, 1) - tbl(p, 0))
							dv = 1 / (tbl(p, 3) - tbl(p, 2))
							dw = 1 / (tbl(p, 5) - tbl(p, 4))

							'
							' Trilinear interpolation
							'
							If c.stype = -1 Then
								For i0 = 6 To 13
									tbl(p, i0) = 0
								Next
								tbl(p, 6 + 2 * (2 * 0 + 0) + 0) = c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 0 + 0) + 1) = c.f(d * (n * (m * k + j) + (i + 1)) + di) - c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 0 + 1) + 0) = c.f(d * (n * (m * k + (j + 1)) + i) + di) - c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 0 + 1) + 1) = c.f(d * (n * (m * k + (j + 1)) + (i + 1)) + di) - c.f(d * (n * (m * k + (j + 1)) + i) + di) - c.f(d * (n * (m * k + j) + (i + 1)) + di) + c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 1 + 0) + 0) = c.f(d * (n * (m * (k + 1) + j) + i) + di) - c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 1 + 0) + 1) = c.f(d * (n * (m * (k + 1) + j) + (i + 1)) + di) - c.f(d * (n * (m * (k + 1) + j) + i) + di) - c.f(d * (n * (m * k + j) + (i + 1)) + di) + c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 1 + 1) + 0) = c.f(d * (n * (m * (k + 1) + (j + 1)) + i) + di) - c.f(d * (n * (m * (k + 1) + j) + i) + di) - c.f(d * (n * (m * k + (j + 1)) + i) + di) + c.f(d * (n * (m * k + j) + i) + di)
								tbl(p, 6 + 2 * (2 * 1 + 1) + 1) = c.f(d * (n * (m * (k + 1) + (j + 1)) + (i + 1)) + di) - c.f(d * (n * (m * (k + 1) + (j + 1)) + i) + di) - c.f(d * (n * (m * (k + 1) + j) + (i + 1)) + di) + c.f(d * (n * (m * (k + 1) + j) + i) + di) - c.f(d * (n * (m * k + (j + 1)) + (i + 1)) + di) + c.f(d * (n * (m * k + (j + 1)) + i) + di) + c.f(d * (n * (m * k + j) + (i + 1)) + di) - c.f(d * (n * (m * k + j) + i) + di)
							End If

							'
							' Rescale Cij
							'
							For ci = 0 To 1
								For cj = 0 To 1
									For ck = 0 To 1
										tbl(p, 6 + 2 * (2 * ck + cj) + ci) = tbl(p, 6 + 2 * (2 * ck + cj) + ci) * System.Math.Pow(du, ci) * System.Math.Pow(dv, cj) * System.Math.Pow(dw, ck)
									Next
								Next
							Next
						Next
					Next
				Next
			Next
		End Sub


		'************************************************************************
'        This subroutine calculates the value of the trilinear(or tricubic;possible
'        will be later) spline  at the given point X(and its derivatives; possible
'        will be later).
'
'        INPUT PARAMETERS:
'            C       -   spline interpolant.
'            X, Y, Z -   point
'
'        OUTPUT PARAMETERS:
'            F   -   S(x,y,z)
'            FX  -   dS(x,y,z)/dX
'            FY  -   dS(x,y,z)/dY
'            FXY -   d2S(x,y,z)/dXdY
'
'          -- ALGLIB PROJECT --
'             Copyright 26.04.2012 by Bochkanov Sergey
'        ************************************************************************

		Private Shared Sub spline3ddiff(c As spline3dinterpolant, x As Double, y As Double, z As Double, ByRef f As Double, ByRef fx As Double, _
			ByRef fy As Double, ByRef fxy As Double)
			Dim xd As Double = 0
			Dim yd As Double = 0
			Dim zd As Double = 0
			Dim c0 As Double = 0
			Dim c1 As Double = 0
			Dim c2 As Double = 0
			Dim c3 As Double = 0
			Dim ix As Integer = 0
			Dim iy As Integer = 0
			Dim iz As Integer = 0
			Dim l As Integer = 0
			Dim r As Integer = 0
			Dim h As Integer = 0

			f = 0
			fx = 0
			fy = 0
			fxy = 0

			alglib.ap.assert(c.stype = -1 OrElse c.stype = -3, "Spline3DDiff: incorrect C (incorrect parameter C.SType)")
			alglib.ap.assert(Math.isfinite(x) AndAlso Math.isfinite(y), "Spline3DDiff: X or Y contains NaN or Infinite value")

			'
			' Prepare F, dF/dX, dF/dY, d2F/dXdY
			'
			f = 0
			fx = 0
			fy = 0
			fxy = 0
			If c.d <> 1 Then
				Return
			End If

			'
			' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
			'
			l = 0
			r = c.n - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.x(h)) >= CDbl(x) Then
					r = h
				Else
					l = h
				End If
			End While
			ix = l

			'
			' Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
			'
			l = 0
			r = c.m - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.y(h)) >= CDbl(y) Then
					r = h
				Else
					l = h
				End If
			End While
			iy = l

			'
			' Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
			'
			l = 0
			r = c.l - 1
			While l <> r - 1
				h = (l + r) \ 2
				If CDbl(c.z(h)) >= CDbl(z) Then
					r = h
				Else
					l = h
				End If
			End While
			iz = l
			xd = (x - c.x(ix)) / (c.x(ix + 1) - c.x(ix))
			yd = (y - c.y(iy)) / (c.y(iy + 1) - c.y(iy))
			zd = (z - c.z(iz)) / (c.z(iz + 1) - c.z(iz))

			'
			' Trilinear interpolation
			'
			If c.stype = -1 Then
				c0 = c.f(c.n * (c.m * iz + iy) + ix) * (1 - xd) + c.f(c.n * (c.m * iz + iy) + (ix + 1)) * xd
				c1 = c.f(c.n * (c.m * iz + (iy + 1)) + ix) * (1 - xd) + c.f(c.n * (c.m * iz + (iy + 1)) + (ix + 1)) * xd
				c2 = c.f(c.n * (c.m * (iz + 1) + iy) + ix) * (1 - xd) + c.f(c.n * (c.m * (iz + 1) + iy) + (ix + 1)) * xd
				c3 = c.f(c.n * (c.m * (iz + 1) + (iy + 1)) + ix) * (1 - xd) + c.f(c.n * (c.m * (iz + 1) + (iy + 1)) + (ix + 1)) * xd
				c0 = c0 * (1 - yd) + c1 * yd
				c1 = c2 * (1 - yd) + c3 * yd
				f = c0 * (1 - zd) + c1 * zd
			End If
		End Sub


	End Class
End Class

