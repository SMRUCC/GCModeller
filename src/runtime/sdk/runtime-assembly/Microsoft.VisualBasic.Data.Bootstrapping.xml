<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Data.Bootstrapping
</name>
</assembly>
<members>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator">
 <summary>
 参数估计的过程之中的迭代器，这个模块内的函数主要是用来产生数据源的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator.Bootstrapping``1(Microsoft.VisualBasic.Mathematical.PreciseRandom,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Int64,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean)">
 <summary>
 这个更加适合没有任何参数信息的时候的情况
 </summary>
 <typeparam name="T"></typeparam>
 <param name="range"></param>
 <param name="vars"></param>
 <param name="yinit"></param>
 <param name="k"></param>
 <param name="n"></param>
 <param name="a"></param>
 <param name="b"></param>
 <param name="trimNaN"></param>
 <param name="parallel">并行计算模式有极大的内存泄漏的危险</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator.Bootstrapping(System.Type,System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Mathematical.INextRandomNumber}},System.Int64,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 For populates the random system status
 </summary>
 <param name="model"></param>
 <param name="args"></param>
 <param name="y0"></param>
 <param name="k"></param>
 <param name="n"></param>
 <param name="a"></param>
 <param name="b"></param>
 <param name="trimNaN"></param>
 <param name="parallel"></param>
 <param name="echo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator.Bootstrapping(System.Type,System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Mathematical.INextRandomNumber}},System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Mathematical.INextRandomNumber}},System.Int64,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Bootstrapping 参数估计分析，这个函数用于生成基本的采样数据
 </summary>
 <param name="vars">各个参数的变化范围</param>
 <param name="model">具体的求解方程组</param>
 <param name="k">重复的次数</param>
 <param name="y0">
 ``Y0``初值，在进行参数估计的时候应该是被固定的，在进行系统状态分布的计算的时候才是随机的
 </param>
 <param name="parallel">并行计算模式有极大的内存泄漏的危险</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator.iterate(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Mathematical.INextRandomNumber}[],System.Type,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Mathematical.INextRandomNumber}[],System.Collections.Generic.Dictionary{System.String,System.Action{System.Object,System.Double}},System.Int32,System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="vars"></param>
 <param name="yinis"></param>
 <param name="ps"></param>
 <param name="n"></param>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
 <remarks>在Linux服务器上面有内存泄漏的危险</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.BootstrapIterator.SetParameters(System.Collections.Generic.IEnumerable{System.String},System.Type)">
 <summary>
 
 </summary>
 <param name="model"><see cref="T:Microsoft.VisualBasic.Mathematical.Calculus.ODEs"/>类型</param>
 <param name="vars"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.DifferentialEvolutionSolver">
 <summary>
 Differential Evolution estimates solver.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.DifferentialEvolutionSolver.Fitting``1(Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Double,System.Double,System.Double,System.Int32,System.Int32,Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint}@,System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double},System.String[],System.Boolean,System.Boolean,Microsoft.VisualBasic.Mathematical.IRandomSeeds)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="observation"></param>
 <param name="F"></param>
 <param name="CR"></param>
 <param name="threshold#">
 现实的曲线太复杂了，因为模型是简单方程，只能够计算出简单的曲线，所以肯定不能完全拟合，
 最终的结果fitness也会较大，默认的0.1的fitness这个要求肯定不能够达到，
 所以只要达到一定次数的迭代就足够了，这个fitness的阈值参数值可以设置大一些
 </param>
 <param name="maxIterations%"></param>
 <param name="PopulationSize%"></param>
 <param name="iteratePrints"></param>
 <param name="initOverrides"></param>
 <param name="isRefModel"></param>
 <param name="parallel">并行化计算要在种群的规模足够大的情况下才会有性能上的提升</param>
 <param name="ignores">在计算fitness的时候将要被忽略掉的函数变量的名称</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.FitnessCompute">
 <summary>
 计算当前的最好的参数的fitness
 </summary>
 <param name="best">当前代之中的最好的参数</param>
 <param name="fit"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.observation">
 <summary>
 真实的实验观察数据
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.Model">
 <summary>
 具体的计算模型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.samples">
 <summary>
 计算的采样数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.ref">
 <summary>
 样本列表部分计算的参考值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.modelVariables">
 <summary>
 模型之中所定义的y变量
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.y0">
 <summary>
 ODEs y0
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.n">
 <summary>
 RK4 parameters
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.a">
 <summary>
 RK4 parameters
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.b">
 <summary>
 RK4 parameters
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.Ignores">
 <summary>
 被忽略比较的y变量名称
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.#ctor(System.Collections.Generic.Dictionary{System.String,System.Double},Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model,System.Int32,System.Double,System.Double)">
 <summary>
 从真实的实验观察数据来构建出拟合(这个构造函数是测试用的)
 </summary>
 <param name="observation"></param>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.__init">
 <summary>
 初始化一些共同的数据
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.#ctor(System.Type,Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Collections.Generic.Dictionary{System.String,System.Double},System.Boolean)">
 <summary>
 从真实的实验观察数据来构建出拟合(这个构造函数是测试用的)
 </summary>
 <param name="observation">只需要其中的<see cref="P:Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut.y"/>有数据就行了</param>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness.RunTest(System.Collections.Generic.Dictionary{System.String,System.Double})">
 <summary>
 使用指定的参数测试计算模型的输出
 </summary>
 <param name="parms"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol">
 <summary>
 参数拟合的方法
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.y0(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double[]}})">
 <summary>
 Gets the first value as ``y0`` from the inputs samples
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.Mutate(System.Double[]@,System.Random)">
 <summary>
 Mutate a bit in an array.
 </summary>
 <param name="array#">The abstraction of a chromosome(parameter list).
 (需要被拟合的参数列表，在这个函数里面会被修改一点产生突变)
 </param>
 <param name="rnd"></param>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.Fitting(Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model,System.Int32,System.Double,System.Double,System.Int32,System.Int32,Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint}@,System.Double,System.Collections.Generic.Dictionary{System.String,System.Double},System.Boolean,Microsoft.VisualBasic.Mathematical.IRandomSeeds,Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.MutateLevels,System.Action{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint})">
 <summary>
 Using for model testing debug.(测试用)
 </summary>
 <param name="model"></param>
 <param name="n%"></param>
 <param name="a#"></param>
 <param name="b#"></param>
 <param name="popSize%"></param>
 <param name="evolIterations%"></param>
 <param name="outPrint"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.__runInternal(System.String[],System.Int32,System.Double,System.Int32,Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.GAFFitness,Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint}@,System.Collections.Generic.Dictionary{System.String,System.Double},Microsoft.VisualBasic.Mathematical.IRandomSeeds,Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.MutateLevels,System.Action{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint})">
 <summary>
 
 </summary>
 <param name="vars$">从模型内部定义所解析出来的需要进行拟合的参数的名称列表</param>
 <param name="popSize%"></param>
 <param name="threshold#"></param>
 <param name="evolIterations%"></param>
 <param name="fitness"></param>
 <param name="outPrint"></param>
 <param name="argsInit"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.Fitting``1(Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Int32,System.Int32,Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint}@,System.Double,System.Boolean,System.String[],System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double},System.Boolean,Microsoft.VisualBasic.Mathematical.IRandomSeeds,Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.MutateLevels,System.Action{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint})">
 <summary>
 用于实际分析的GAF工具
 </summary>
 <param name="observation">用于进行拟合的目标真实的实验数据，模型计算所使用的y0初值从这里面来，这个数据对象只要求y属性具有实验数据就行了</param>
 <param name="popSize%"></param>
 <param name="evolIterations%"></param>
 <param name="outPrint"></param>
 <param name="threshold#"></param>
 <param name="log10Fit"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.Protocol.Fitting``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double[]}},System.Double[],System.Int32,System.Int32,Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint}@,System.Double,System.Boolean,System.String[],System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double},System.Boolean,Microsoft.VisualBasic.Mathematical.IRandomSeeds,Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.MutateLevels,System.Action{Microsoft.VisualBasic.DataMining.Darwinism.GAF.Helper.ListenerHelper.outPrint})">
 <summary>
 用于实际分析的GAF工具
 </summary>
 <param name="observation">用于进行拟合的目标真实的实验数据，模型计算所使用的y0初值从这里面来</param>
 <param name="popSize%"></param>
 <param name="evolIterations%"></param>
 <param name="outPrint"></param>
 <param name="threshold#"></param>
 <param name="log10Fit"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector">
 <summary>
 Parameters that wait for bootstrapping estimates
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.vars">
 <summary>
 The function variable parameter that needs to fit, not includes the ``y0``.
 (只需要在这里调整参数就行了，y0初始值不需要)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.Vector">
 <summary>
 Transform as a vector for the mutation and crossover function.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.Clone">
 <summary>
 按值复制
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.Crossover(Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector)">
 <summary>
 Clone and crossover and last assign the vector value.(结果是按值复制的)
 </summary>
 <param name="anotherChromosome"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.Mutate">
 <summary>
 Clone and mutation a bit and last assign the vector value.(会按值复制)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.ToString">
 <summary>
 这个函数生成的字符串是和<see cref="M:Microsoft.VisualBasic.Data.Bootstrapping.Darwinism.GAF.ParameterVector.Parse(System.String)"/>解析函数所使用的格式是相对应的
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.StatesCharacters">
 <summary>
 Search for all possible system status clusters
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.StatesCharacters.KMeansCluster(System.Type,System.Int64,System.Int32,System.Double,System.Double,System.Collections.Generic.Dictionary{System.String,System.Double},System.Int32,System.Int32,System.Int32)">
 <summary>
 Search for all possible system status clusters by using MonteCarlo method from random system inits.
 (使用蒙特卡洛的方法来搜索可能的系统状态空间)
 </summary>
 <param name="model"></param>
 <returns>可能的系统状态的KMeans聚类结果</returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.RefModel">
 <summary>
 Sample partial reference model
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.RefModel.func(System.Double,Microsoft.VisualBasic.Mathematical.BasicR.Vector@)">
 <summary>
 RK4每一次迭代会调用这个函数计算4次
 </summary>
 <param name="dx"></param>
 <param name="dy"></param>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol">
 <summary>
 使用蒙特卡洛的方法估算出系统的参数，不过这个方法的效率太低了，没有遗传算法的效率好
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.DllParser(System.String)">
 <summary>
 加载dll文件之中的计算模型
 </summary>
 <param name="dll"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.GetEigenvector(System.Type)">
 <summary>
 Sampling method of the y output values.(假若模型定义之中没有定义这个特征向量的构建方法的话，则使用默认的方法：平均数+标准差)
 </summary>
 <param name="def"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.Run(System.String,System.Int64,System.Int32,System.Int32,System.Int32)">
 <summary>
 加载目标dll之中的计算模型然后提供计算数据
 </summary>
 <param name="dll"></param>
 <param name="k"></param>
 <param name="n"></param>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.Sampling(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut},System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Data.Bootstrapping.Eigenvector},System.Int32,System.Boolean,System.Boolean)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="eigenvector"></param>
 <param name="partN"></param>
 <param name="merge">
 + 假若是从文件之中加在的数据，则这个默认参数值不需要进行设置
 + 假若是直接赋值，则需要设置本参数为True进行y0和参数的合并操作
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.Sampling(Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Data.Bootstrapping.Eigenvector},System.Int32,System.String)">
 <summary>

 </summary>
 <param name="x"></param>
 <param name="eigenvector"></param>
 <param name="partN"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.Iterations(System.Type,Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Int64,System.Int32,System.Int32,System.Int32,System.Double,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Double}[]}@)">
 <summary>
 k是采样的次数， n,a,b 是进行ODEs计算的参数，可以直接从观测数据之中提取出来，<paramref name="expected"/>是期望的cluster数量
 </summary>
 <param name="model">必须是继承自<see cref="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model"/>类型</param>
 <param name="observation">实验观察里面只需要y值列表就足够了，不需要参数信息</param>
 <param name="k"></param>
 <param name="expected"></param>
 <param name="[stop]"></param>
 <param name="work">工作的临时文件夹工作区间，默认使用dll的文件夹</param>
 <param name="outIterates">每一次的迭代结果都会从这里返回</param>
 <returns>函数返回收敛成功了之后的最后一次迭代的参数数据</returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.EstimatesProtocol.Iterations(System.String,Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut,System.Int64,System.Int32,System.Int32,System.Int32,System.Double,System.String)">
 <summary>
 k是采样的次数， n,a,b 是进行ODEs计算的参数，可以直接从观测数据之中提取出来，<paramref name="expected"/>是期望的cluster数量
 </summary>
 <param name="dll"></param>
 <param name="observation">实验观察里面只需要y值列表就足够了，不需要参数信息</param>
 <param name="k"></param>
 <param name="expected"></param>
 <param name="[stop]"></param>
 <param name="work">工作的临时文件夹工作区间，默认使用dll的文件夹</param>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model">
 <summary>
 ``y`` 声明的类型为<see cref="T:Microsoft.VisualBasic.Mathematical.Calculus.var"/>类型的域;
 ``parameter`` 声明的类型为<see cref="T:System.Double"/>类型的域
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.yinit">
 <summary>
 系统的初始值列表(应用于系统状态随机聚类)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.params">
 <summary>
 系统的状态列表，即方程里面的参数(应用于参数估计)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.eigenvector">
 <summary>
 在计算聚类的相似度的时候对y变量的特征提取
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.RunTest(System.Collections.Generic.Dictionary{System.String,System.Double},System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="estimates">新的方程参数，这里面需要同时包括了参数和y初始值</param>
 <param name="n%"></param>
 <param name="a%"></param>
 <param name="b%"></param>
 <returns></returns>
 <remarks>线程不安全的</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.RunTest(System.Type,System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double},System.Int32,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut)">
 <summary>
 这个函数是为并行化而设计的，线程安全的
 </summary>
 <param name="model"></param>
 <param name="estimates">新的方程参数，这里面需要同时包括了参数和y初始值</param>
 <param name="n%"></param>
 <param name="a%"></param>
 <param name="b%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.RunTest(System.Type,System.Collections.Generic.Dictionary{System.String,System.Double},Microsoft.VisualBasic.Mathematical.Calculus.var[],System.Int32,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.Calculus.ODEsOut)">
 <summary>
 这个函数是为并行化而设计的，线程安全的
 </summary>
 <param name="model"></param>
 <param name="estimates">新的方程参数，这里面需要同时包括了参数和y初始值</param>
 <param name="n%"></param>
 <param name="a%"></param>
 <param name="b%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model.RunTest(System.Collections.Generic.Dictionary{System.String,System.Double}[],System.Int32,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.String,System.Double})">
 <summary>
 
 </summary>
 <param name="estimates"></param>
 <param name="n%"></param>
 <param name="a%"></param>
 <param name="b%"></param>
 <param name="modify">修改部分数据</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Example.Example">
 <summary>
 计算步骤
 
 1. 继承<see cref="T:Microsoft.VisualBasic.Data.Bootstrapping.MonteCarlo.Model"/>对象并实现具体的过程
 2. 设置好大概的参数的变化区间
 3. 设置好大概的函数初始值的变化区间
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Normalization">
 <summary>
 Methods for raw data processing
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Normalization.Normalize(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Data.Bootstrapping.Normalization.TimeValue[]}},System.Int32)">
 <summary>
 
 </summary>
 <param name="data">raw data</param>
 <param name="expected%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.Normalization.Trim(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Drawing.PointF[]},Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{Microsoft.VisualBasic.Data.Bootstrapping.Normalization.TimeValue[]})">
 <summary>
 默认假设raw数据里面的时间点都是不重复的
 </summary>
 <param name="intr"></param>
 <param name="raw"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.EigenvectorBootstrapping.LoadData(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Data.Bootstrapping.Eigenvector},System.Int32)">
 <summary>
 
 </summary>
 <param name="DIR"></param>
 <param name="eigenvector"></param>
 <param name="partN">将原始数据分解为多少个数据块来抽取特征向量从而进行数据采样</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.EigenvectorBootstrapping.KMeans(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.TagData.VectorTagged{System.Collections.Generic.Dictionary{System.String,System.Double}}},System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="data"><see cref="M:Microsoft.VisualBasic.Data.Bootstrapping.EigenvectorBootstrapping.LoadData(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Data.Bootstrapping.Eigenvector},System.Int32)"/>的输出数据</param>
 <param name="n">所期望的Kmeans集合的数量</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Bootstrapping.EigenvectorBootstrapping.DefaultEigenvector(System.Double[])">
 <summary>
 默认的特征向量: ``{data.Average, data.StdError}``
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Bootstrapping.Eigenvector">
 <summary>
 从目标数据集合之中抽取特征向量
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
</members>
</doc>
