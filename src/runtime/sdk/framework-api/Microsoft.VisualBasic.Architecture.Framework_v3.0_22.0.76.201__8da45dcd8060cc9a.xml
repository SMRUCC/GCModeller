<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Architecture.Framework_v3.0_22.0.76.201__8da45dcd8060cc9a
</name>
</assembly>
<members>
<member name="T:Microsoft.VisualBasic.CommandLine.CLIMapper">
 <summary>
 从可写属性之中赋值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIMapper.Maps``1(Microsoft.VisualBasic.CommandLine.CommandLine,System.Boolean)">
 <summary>
 The properties in the class type needs decorating with attribute <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.CLIParameter"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="args"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService">
 <summary>
 The class object which can interact with the target commandline program.(与目标命令行程序进行命令行交互的编程接口，本类型的对象的作用主要是生成命令行参数)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService._executableAssembly">
 <summary>
 Assembly path for the target invoked program.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIBuildMethod.GetCLI``1(``0)">
 <summary>
 Generates the command line string value for the invoked target cli program using this interop services object instance.
 (生成命令行参数)
 </summary>
 <typeparam name="TInteropService">
 A class type object for interaction with a commandline program.
 (与命令行程序进行交互的模块对象类型)
 </typeparam>
 <param name="Instance">目标交互对象的实例</param>
 <returns></returns>
 <remarks>
 依照类型<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes"/>来生成参数字符串
 
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Boolean"/>, True => 参数名；
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Double"/>, <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Integer"/>, <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String"/>, => 参数名 + 参数值，假若字符串为空则不添加；
 （假若是枚举值类型，可能还需要再枚举值之中添加<see cref="T:System.ComponentModel.DescriptionAttribute"/>属性）
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File"/>, 假若字符串为空则不添加，有空格自动添加双引号，相对路径会自动转换为全路径。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIBuildMethod.__pathRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Optional,System.Reflection.PropertyInfo)">
 <summary>
 
 </summary>
 <param name="value">只能是<see cref="T:System.String"/>类型的</param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIBuildMethod.__stringRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Optional,System.Reflection.PropertyInfo)">
 <summary>
 可能包含有枚举值
 </summary>
 <param name="value"></param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIBuildMethod.ClearParameters``1(``0)">
 <summary>
 
 </summary>
 <typeparam name="TInteropService"></typeparam>
 <param name="inst"></param>
 <returns>返回所重置的参数的个数</returns>
 <remarks></remarks>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.(目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.StandardOutput">
 <summary>
 Gets the standard output for the target invoke process.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Start(System.Boolean)">
 <summary>
 Start the target process. If the target invoked process is currently on the running state, 
 then this function will returns the -100 value as error code and print the warning 
 information on the system console.(启动目标进程)
 </summary>
 <param name="WaitForExit">Indicate that the program code wait for the target process exit or not?(参数指示应用程序代码是否等待目标进程的结束)</param>
 <returns>当发生错误的时候会返回错误代码，当当前的进程任然处于运行的状态的时候，程序会返回-100错误代码并在终端之上打印出警告信息</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Run">
 <summary>
 启动目标子进程，然后等待执行完毕并返回退出代码(请注意，在进程未执行完毕之前，整个线程会阻塞在这里)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.IORedirectFile">
 <summary>
 Using this class object rather than <see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/> is more encouraged.
 (假若所建立的子进程并不需要进行终端交互，相较于<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>对象，更加推荐使用本对象类型来执行。
 似乎<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>对象在创建一个子进程的时候的对象IO重定向的句柄的处理有问题，所以在这里构建一个更加简单的类型对象，
 这个IO重定向对象不具备终端交互功能)
 </summary>
 <remarks>先重定向到一个临时文件之中，然后再返回临时文件给用户代码</remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirectFile._TempRedirect">
 <summary>
 重定向的临时文件
 </summary>
 <remarks>当使用.tmp拓展名的时候会由于APP框架里面的GC线程里面的自动临时文件清理而产生冲突，所以这里需要其他的文件拓展名来避免这个冲突</remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirectFile.ProcessBAT">
 <summary>
 shell文件接口
 </summary>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IORedirectFile.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.(目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IORedirectFile.StandardOutput">
 <summary>
 目标子进程的终端标准输出
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.CopyRedirect(System.String)">
 <summary>
 将目标子进程的标准终端输出文件复制到一个新的文本文件之中
 </summary>
 <param name="CopyToPath"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.#ctor(System.String,System.String,System.Collections.Generic.KeyValuePair{System.String,System.String}[],System.Boolean,System.String)">
 <summary>
 Using this class object rather than <see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/> is more encouraged if there is no console interactive with your folked process.
 </summary>
 <param name="File">The program file.(请注意检查路径参数，假若路径之中包含有%这个符号的话，在调用cmd的时候会失败)</param>
 <param name="argv">The program commandline arguments.(请注意检查路径参数，假若路径之中包含有%这个符号的话，在调用cmd的时候会失败)</param>
 <param name="environment">Temporary environment variable</param>
 <param name="FolkNew">Folk the process on a new console window if this parameter value is TRUE</param>
 <param name="stdRedirect">If not want to redirect the std out to your file, just leave this value blank.</param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.Run">
 <summary>
 Start target child process and then wait for the child process exits. 
 So that the thread will be stuck at here until the sub process is 
 job done!
 (启动目标子进程，然后等待执行完毕并返回退出代码(请注意，在进程未执行完毕
 之前，整个线程会阻塞在这里))
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.Start(System.Action)">
 <summary>
 启动子进程，但是不等待执行完毕，当目标子进程退出的时候，回调<paramref name="procExitCallback"/>函数句柄
 </summary>
 <param name="procExitCallback"></param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CLITools">
 <summary>
 CLI parser and <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> object creates.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.CreateParameterValues(System.String[],System.Boolean)">
 <summary>
 Parsing parameters from a specific tokens.
 (从给定的词组之中解析出参数的结构)
 </summary>
 <param name="Tokens">个数为偶数的，但是假若含有开关的时候，则可能为奇数了</param>
 <param name="IncludeLogicSW">返回来的列表之中是否包含有逻辑开关</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.GetLogicSWs(System.String[],System.String@)">
 <summary>
 Get all of the logical parameters from the input tokens
 </summary>
 <param name="Tokens">要求第一个对象不能够是命令的名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 Try parsing the cli command string from the string value.(尝试着从文本行之中解析出命令行参数信息)
 </summary>
 <param name="args">The commandline arguments which is user inputs from the terminal.</param>
 <param name="DuplicatedAllowed">Allow the duplicated command parameter argument name in the input, 
 default is not allowed the duplication.(是否允许有重复名称的参数名出现，默认是不允许的)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Args">
 <summary>
 Gets the commandline object for the current program.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.String,System.Boolean)">
 <summary>
 Try parsing the cli command string from the string value.(尝试着从文本行之中解析出命令行参数信息)
 </summary>
 <param name="CLI">The commandline arguments which is user inputs from the terminal.</param>
 <param name="DuplicatedAllowed">Allow the duplicated command parameter argument name in the input, 
 default is not allowed the duplication.(是否允许有重复名称的参数名出现，默认是不允许的)</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.IsPossibleLogicFlag(System.String)">
 <summary>
 Is this string tokens is a possible <see cref="T:System.Boolean"/> value flag
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.IsNumeric(System.String)">
 <summary>
 Is this token value string is a number?
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Join(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 ReGenerate the cli command line argument string text.(重新生成命令行字符串)
 </summary>
 <param name="tokens">If the token value have a space character, then this function will be wrap that token with quot character automatically.</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CLITools.SPLIT_REGX_EXPRESSION">
 <summary>
 A regex expression string that use for split the commandline text.
 (用于分析命令行字符串的正则表达式)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.GetTokens(System.String)">
 <summary>
 Try parse the argument tokens which comes from the user input commandline string. 
 (尝试从用户输入的命令行字符串之中解析出所有的参数)
 </summary>
 <param name="CLI"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CLITools.TokenSplitRegex">
 <summary>
 会对%进行替换的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.String,System.String,System.Char)">
 <summary>
 尝试从输入的语句之中解析出词法单元，注意，这个函数不是处理从操作系统所传递进入的命令行语句
 </summary>
 <param name="CommandLine"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.CreateObject(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Creates command line object from a set obj <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
 </summary>
 <param name="Name"></param>
 <param name="args"></param>
 <param name="bFlags"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TrimParamPrefix(System.String)">
 <summary>
 修剪命令行参数名称的前置符号
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Equals(Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 请注意，这个是有方向性的，由于是依照参数1来进行比较的，假若args2里面的参数要多于第一个参数，但是第一个参数里面的所有参数值都可以被参数2完全比对得上的话，就认为二者是相等的
 </summary>
 <param name="args1"></param>
 <param name="args2"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ProcExtensions">
 <summary>
 How to found the process by CLI
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ProcExtensions.GetProc(System.String)">
 <summary>
 Get process by command line parameter.(按照命令行参数来获取进程实例)
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ProcExtensions.FindProc(Microsoft.VisualBasic.CommandLine.IIORedirectAbstract)">
 <summary>
 这个主要是为了<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirectFile"/>对象进行相关进程的查找而设置的，
 对于<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>而言则直接可以从其属性<see cref="P:Microsoft.VisualBasic.CommandLine.IORedirect.ProcessInfo"/>之中获取相关的进程信息
 </summary>
 <param name="IO"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ProcExtensions.ExecSub(System.String,System.String,Microsoft.VisualBasic.CommandLine.ProcExtensions.dReadLine,System.String)">
 <summary>
 执行CMD命令
 Example:excuteCommand("ipconfig", "/all", AddressOf PrintMessage)
 </summary>
 <param name="app">命令</param>
 <param name="args">参数</param>
 <param name="onReadLine">行信息（委托）</param>
 <remarks>https://github.com/lishewen/LSWFramework/blob/master/LSWClassLib/CMD/CMDHelper.vb</remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ProcExtensions.Call(System.String,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="app">The file path of the application to be called by its parent process.</param>
 <param name="args">CLI arguments</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.__ExecuteFile">
 <summary>
 假若所传入的命令行的name是文件路径，解释器就会执行这个函数指针
 </summary>
 <param name="path"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI">
 <summary>
 假若所传入的命令行是空的，就会执行这个函数指针
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.__ExecuteNotFound">
 <summary>
 假若查找不到命令的话，执行这个函数
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes">
 <summary>
 The data type enumeration of the target optional parameter switch.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String">
 <summary>
 String.(对于指定为字符串类型的参数，在调用的时候回自动调用<see cref="M:Microsoft.VisualBasic.Extensions.CliToken(System.String)"/>函数)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Integer">
 <summary>
 Int
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Double">
 <summary>
 Real
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Boolean">
 <summary>
 This is a flag value, if this flag presents in the CLI, then this named Boolean value is TRUE, otherwise is FALSE.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File">
 <summary>
 File path, is equals most string.(对于指定为路径类型的参数值，在生成命令行的时候会自动调用<see cref="M:Microsoft.VisualBasic.Extensions.CliPath(System.String)"/>函数)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.SDKManual.LaunchManual(Microsoft.VisualBasic.CommandLine.Interpreter)">
 <summary>
 这个是用于在终端上面显示的无格式的文本输出
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.SDKManual.MarkdownDoc(Microsoft.VisualBasic.CommandLine.Interpreter)">
 <summary>
 这个是用于保存于文件之中的markdown格式的有格式标记的文本输出
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.SDKManual.HelpSummary(Microsoft.VisualBasic.CommandLine.Interpreter,System.Boolean)">
 <summary>
 Returns the summary brief help information of all of the commands in current cli interpreter.
 (枚举出本CLI解释器之中的所有的命令的帮助的摘要信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
 <param name="markdown">Output in markdown format?</param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken">
 <summary>
 A very basically type in the <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.Name">
 <summary>
 Name of this token object, this can be parameter name or api name.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.#ctor(System.String)">
 <summary>
 Init this token by using <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.Name"/> value.
 </summary>
 <param name="name">Token name</param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute">
 <summary>
 A command object that with a specific name.(一个具有特定名称命令执行对象)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Name">
 <summary>
 The name of the commandline object.(这个命令的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Info">
 <summary>
 Something detail of help information.(详细的帮助信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Usage">
 <summary>
 The usage of this command.(这个命令的用法，本属性仅仅是一个助记符，当用户没有编写任何的使用方法信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Example">
 <summary>
 A example that to useing this command.(对这个命令的使用示例，本属性仅仅是一个助记符，当用户没有编写任何示例信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.#ctor(System.String)">
 <summary>
 You are going to define a available export api for you application to another language or scripting program environment.
 (定义一个命令行程序之中可以使用的命令)
 </summary>
 <param name="Name">The name of the commandline object or you define the exported API name here.(这个命令的名称)</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Name">
 <summary>
 The name of the commandline object.(这个命令的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Info">
 <summary>
 Something detail of help information.(详细的帮助信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Usage">
 <summary>
 The usage of this command.(这个命令的用法，本属性仅仅是一个助记符，当用户没有编写任何的使用方法信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Example">
 <summary>
 A example that to useing this command.(对这个命令的使用示例，本属性仅仅是一个助记符，当用户没有编写任何示例信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ManualBuilder">
 <summary>
 用来生成帮助信息
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ManualBuilder.PrintHelp(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint)">
 <summary>
 Prints the formatted help information on the console.
 </summary>
 <param name="api"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.Name">
 <summary>
 The usage name of this command line entry point.(本命令行对象的调用命令名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.#ctor(Microsoft.VisualBasic.ComponentModel.Binding{Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute,System.Reflection.MethodInfo},System.Func{System.Object[],System.Int32})">
 <summary>
 不可以使用本方法初始化目标对象为实例方法的类型
 </summary>
 <param name="attribute"></param>
 <param name="Invoke"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.Execute(System.Object[])">
 <summary>
 
 </summary>
 <param name="parameters">数组的长度必须与目标函数的参数的数目一致，否则短于目标函数的参数的数目的数组会使用Nothing来填充缺少的部分，而多于目标函数的参数会被截断</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint">
 <summary>
 The entry point data of the commands in the command line which was original loaded 
 from the source meta data in the compiled target.
 (命令行命令的执行入口点)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPoint">
 <summary>
 The reflection entry point in the assembly for the target method object.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.InvokeOnObject">
 <summary>
 If the target invoked <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPoint">method delegate</see> is a instance method, 
 then this property value should be the target object instance which has the method delegate.
 (假若目标方法不是共享的方法，则必须要使用本对象来进行Invoke的调用)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.IsInstanceMethod">
 <summary>
 The shared method did not requires of the object instance.(这个方法是否为实例方法)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPointFullName(System.Boolean)">
 <summary>
 The full name path of the target invoked method delegate in the namespace library.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.#ctor(Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute,System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 Instance method can be initialize from this constructor.
 (假若目标方法为实例方法，请使用本方法进行初始化)
 </summary>
 <param name="attribute"></param>
 <param name="Invoke"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.HelpInformation(System.Boolean)">
 <summary>
 Returns the help information details for this command line entry object.(获取本命令行执行入口点的详细帮助信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.Invoke(System.Object[],System.Boolean)">
 <summary>
 Invoke this command line and returns the function value.(函数会补齐可选参数)
 </summary>
 <param name="parameters">The function parameter for the target invoked method, the optional value will be filled 
 using the paramter default value if you are not specific the optional paramter value is the element position of 
 this paramter value.</param>
 <param name="Throw">If throw then if the exception happened from delegate invocation then the program will throw an 
 exception and terminated, if not then the program will save the exception information into a log file and then 
 returns a failure status.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.DirectInvoke(System.Object[],System.Boolean)">
 <summary>
 不会自动调整补齐参数
 </summary>
 <param name="callParameters"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.__directInvoke(System.Object[],System.Object,System.Boolean)">
 <summary>
 记录错误信息的最上层的堆栈
 </summary>
 <param name="callParameters"></param>
 <param name="target"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.Invoke(System.Object[],System.Object,System.Boolean)">
 <summary>
 Invoke this command line and returns the function value.
 (函数会补齐可选参数)
 </summary>
 <param name="parameters">The function parameter for the target invoked method, the optional value will be filled 
 using the paramter default value if you are not specific the optional paramter value is the element position of 
 this paramter value.</param>
 <param name="target">Target entry pointer of this function method delegate.</param>
 <param name="Throw">If throw then if the exception happened from delegate invocation then the program will throw an 
 exception and terminated, if not then the program will save the exception information into a log file and then 
 returns a failure status.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.InvokeCLI(System.Object[],System.Object,System.Boolean)">
 <summary>
 Invoke this command line but returns the function execute success, Zero for success and -1 for failure.
 (函数会补齐可选参数)
 </summary>
 <param name="parameters"></param>
 <param name="target"></param>
 <param name="Throw"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.Namespace">
 <summary>
 (<see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter">CommandLine interpreter</see> executation Entry and the ShellScript software packages namespace.)这是一个命令行解释器所使用的执行入口点的集合
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.Description">
 <summary>
 A brief description text about the function of this namespace.(关于本模块之中的描述性的摘要文本)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.Namespace">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.#ctor(System.String,System.String)">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <param name="Namespace">The name value of this namespace module.(本命名空间模块的名称值)</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.TypeInfo">
 <summary>
 Constant of type information for the reflection
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.CreateInstance(System.Type)">
 <summary>
 从目标类型之中构造出一个命令行解释器
 </summary>
 <param name="Type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.Optional">
 <summary>
 Optional commandline arguments.(本属性标记一个命令行字符串之中的可选参数)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Optional.#ctor(System.String,Microsoft.VisualBasic.CommandLine.Reflection.CLITypes)">
 <summary>
 
 </summary>
 <param name="Name">The name value of the target parameter switch which will be marked as an optional parameter.
 (目标将要被标记为可选参数的命令行参数开关对象)</param>
 <param name="Type">The data type of the target command line parameter switch, default type is string type.</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo">
 <summary>
 Use for the detail description for a specific commandline switch.(用于对某一个命令的开关参数的具体描述帮助信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Name">
 <summary>
 The name of this command line parameter switch.(该命令开关的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Description">
 <summary>
 The description and brief help information about this parameter switch, 
 you can using the \n escape string to gets a VbCrLf value.
 (对这个开关参数的具体的描述以及帮助信息，可以使用\n转义字符进行换行)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Example">
 <summary>
 The usage example of this parameter switch.(该开关的值的示例)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Usage">
 <summary>
 The usage syntax information about this parameter switch.(本开关参数的使用语法)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Optional">
 <summary>
 Is this parameter switch is an optional value.(本开关是否为可选的参数)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Out">
 <summary>
 Is this parameter is using for the output
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.AcceptTypes">
 <summary>
 Accept these types as input or output data in this types if <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.Out"/> is true.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfo.#ctor(System.String,System.Boolean)">
 <summary>
 对命令行之中的某一个参数进行描述性信息的创建，包括用法和含义
 </summary>
 <param name="Name">The name of this command line parameter switch.(该命令开关的名称)</param>
 <param name="Optional">Is this parameter switch is an optional value.(本开关是否为可选的参数)</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfoCollection">
 <summary>
 The help information for a specific command line parameter switch.(某一个指定的命令的开关的帮助信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfoCollection.Count">
 <summary>
 本命令行对象中的包含有帮助信息的开关参数的数目
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfoCollection.Parameter(System.String)">
 <summary>
 Returns the parameter switch help information with the specific name value.(显示某一个指定名称的开关信息)
 </summary>
 <param name="Name"></param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfoCollection.GetExample">
 <summary>
 Gets the usage example of this parameter switch.(获取本参数开关的帮助信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ParameterInfoCollection.ToString">
 <summary>
 显示所有的开关信息
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CliResCommon">
 <summary>
 CLI resources manager
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CliResCommon.#ctor(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="EXPORT">资源文件的数据缓存文件夹</param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CliResCommon.TryRelease(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="Name">使用 NameOf 操作符来获取资源</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ActivityInstance">
 <summary>
 Interpreter for object instance.(对于<see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter"></see>而言，其仅解析静态的方法，二本对象则实例方法和静态方法都进行解析)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ActivityInstance.#ctor(System.Object)">
 <summary>
 
 </summary>
 <param name="obj">An instance object.</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ActivityInstance.__getsAllCommands(System.Type,System.Boolean)">
 <summary>
 静态加实例方法
 </summary>
 <param name="Type"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Interpreter">
 <summary>
 Command line interpreter for your cli program.(命令行解释器，请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Interpreter.__API_InfoHash">
 <summary>
 在添加之前请确保键名是小写的字符串
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteFile">
 <summary>
 Public Delegate Function __ExecuteFile(path As String, args As String()) As Integer,
 (<seealso cref="T:Microsoft.VisualBasic.CommandLine.__ExecuteFile"/>: 假若所传入的命令行的name是文件路径，解释器就会执行这个函数指针)
 这个函数指针一般是用作于执行脚本程序的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteEmptyCli">
 <summary>
 Public Delegate Function __ExecuteEmptyCli() As Integer,
 (<seealso cref="T:Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI"/>: 假若所传入的命令行是空的，就会执行这个函数指针)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ToDictionary">
 <summary>
 Gets the dictionary data which contains all of the available command information in this assembly module.
 (获取从本模块之中获取得到的所有的命令行信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Execute(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Execute the specific command line using this interpreter.
 </summary>
 <param name="args">The user input command line string.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.__executeEmpty">
 <summary>
 命令行是空的
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.__methodInvoke(System.String,System.Object[],System.String[])">
 <summary>
 The interpreter runs all of the command from here.(所有的命令行都从这里开始执行)
 </summary>
 <param name="commandName"></param>
 <param name="argvs">就只有一个命令行对象</param>
 <param name="help_argvs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.SDKdocs">
 <summary>
 Generate the sdk document for the target program assembly.(生成目标应用程序的命令行帮助文档，markdown格式的)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Execute(System.String[])">
 <summary>
 Process the command option arguments of the main function:
 <code>Public Function Main(argvs As String()) As Integer
 </code>
 </summary>
 <param name="CommandLineArgs">The cli command line parameter string value collection.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.AddCommand(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint)">
 <summary>
 Add a command in current cli interpreter.(x向当前的这个CLI命令行解释器之中添加一个命令)
 </summary>
 <param name="Command"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Help(System.String)">
 <summary>
 Gets the help information of a specific command using its name property value.(获取某一个命令的帮助信息)
 </summary>
 <param name="CommandName">If the paramteer command name value is a empty string then this function
 will list all of the commands' help information.(假若本参数为空则函数会列出所有的命令的帮助信息)</param>
 <returns>Error code, ZERO for no error</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ListCommandInfo">
 <summary>
 Returns the command entry info list array.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.#ctor(System.Type,System.String)">
 <summary>

 </summary>
 <param name="type">A module or a class which contains some shared method for the command entry.
 (包含有若干使用<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute"></see>进行标记的命令行执行入口点的Module或者Class对象类型，
 可以使用 Object.GetType/GetType 关键词操作来获取所需要的类型信息)</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.__getsAllCommands(System.Type,System.Boolean)">
 <summary>
 导出所有符合条件的静态方法
 </summary>
 <param name="Type"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.GetAllCommands(System.Type,System.Boolean)">
 <summary>
 导出所有符合条件的静态方法，请注意，在这里已经将外部的属性标记和所属的函数的入口点进行连接了
 </summary>
 <param name="Type"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateEmptyCLIObject">
 <summary>
 Create an empty cli command line interpreter object which contains no commands entry.
 (创建一个没有包含有任何命令入口点的空的CLI命令行解释器)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance(System.Type)">
 <summary>
 Create a new interpreter instance from a specific type information.
 (从目标类型之中构造出一个命令行解释器)
 </summary>
 <param name="Type"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance``1">
 <summary>
 Create a new interpreter instance using the specific type information.
 (使用所制定的目标类型信息构造出一个CLI命令行解释器)
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance(System.String)">
 <summary>
 Create a new interpreter instance from a specific dll/exe path, this program assembly file should be a standard .NET assembly.
 (从一个标准的.NET程序文件之中构建出一个命令行解释器)
 </summary>
 <param name="assmPath">DLL/EXE file path.(标准的.NET程序集文件的文件路径)</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Clear">
 <summary>
 Clear the hash table of the cli command line interpreter command entry points.(清除本CLI解释器之中的所有的命令行执行入口点的哈希数据信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.Count">
 <summary>
 Gets the command counts in current cli interpreter.(返回本CLI命令行解释器之中所包含有的命令的数目)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ExistsCommand(System.String)">
 <summary>
 The target command line command is exists in this cli interpreter using it name property?(判断目标命令行命令是否存在于本CLI命令行解释器之中)
 </summary>
 <param name="CommandName">The command name value is not case sensitive.(命令的名称对大小写不敏感的)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.Item(System.String)">
 <summary>

 </summary>
 <param name="key">调用前需要转换为小写字母的形式</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ListPossible(System.String)">
 <summary>
 列举出所有可能的命令
 </summary>
 <param name="Name">模糊匹配</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ListCommandsEntryName">
 <summary>
 List all of the command line entry point name which were contains in this cli interpreter.
 (列举出本CLI命令行解释器之中的所有的命令行执行入口点的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CommandLine">
 <summary>
 A command line object that parse from the user input commandline string.
 (从用户所输入的命令行字符串之中解析出来的命令行对象，标准的命令行格式为：
 <example>&lt;EXE> &lt;CLI_Name> ["Parameter" "Value"]</example>)
 </summary>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CommandLine._CLICommandArgvs">
 <summary>
 原始的命令行字符串
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Name">
 <summary>
 The command name that parse from the input command line.
 (从输入的命令行中所解析出来的命令的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Tokens">
 <summary>
 The command tokens that were parsed from the input commandline.
 (从所输入的命令行之中所解析出来的命令参数单元)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Parameters">
 <summary>
 The parameters in the commandline without the first token of the command name.
 (将命令行解析为词元之后去掉命令的名称之后所剩下的所有的字符串列表)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.BoolFlags">
 <summary>
 对于参数而言，都是--或者-或者/或者\开头的，下一个单词为单引号或者非上面的字符开头的，例如/o &lt;path>
 对于开关而言，与参数相同的其实符号，但是后面不跟参数而是其他的开关，通常开关用来进行简要表述一个逻辑值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.CLICommandArgvs">
 <summary>
 Get the original command line string.(获取所输入的命令行对象的原始的字符串)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Item(System.String)">
 <summary>
 开关的名称是不区分大小写的
 </summary>
 <param name="paramName"></param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.HavebFlag(System.String)">
 <summary>
 查看命令行之中是否存在某一个逻辑开关
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ToString">
 <summary>
 Returns the original cli command line argument string.(返回所传入的命令行的原始字符串)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetCommandsOverview">
 <summary>
 Gets the brief summary information of current cli command line object.(获取当前的命令行对象的参数摘要信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.CheckMissingRequiredParameters(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Checking for the missing required parameter, this function will returns the missing parameter
 in the current cli command line object using a specific parameter name list.
 (检查<paramref name="list"></paramref>之中的所有参数是否存在，函数会返回不存在的参数名)
 </summary>
 <param name="list"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNullOrEmpty">
 <summary>
 Does this cli command line object contains any parameter argument information.(查看本命令行参数对象之中是否存在有参数信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNothing">
 <summary>
 <see cref="T:System.String"/> of <see cref="P:Microsoft.VisualBasic.CommandLine.CommandLine.Name"/> AndAlso <see cref="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNullOrEmpty"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ContainsParameter(System.String,System.Boolean)">
 <summary>
 大小写不敏感，
 </summary>
 <param name="parameterName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Assert(System.String,System.String)">
 <summary>
 Determined that the specific Boolean flag is exists or not? 
 if not then returns <paramref name="failure"/>, if exists such flag, then returns the <paramref name="name"/>.
 </summary>
 <param name="name">Boolean flag name</param>
 <param name="failure"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamInput(System.String)">
 <summary>
 [管道函数] 假若参数名存在并且所指向的文件也存在，则返回本地文件的文件指针，否则返回标准输入的指针
 </summary>
 <param name="param"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamOutput(System.String)">
 <summary>
 [管道函数] 假若参数名存在，则返回本地文件的文件指针，否则返回标准输出的指针
 </summary>
 <param name="param"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetBoolean(System.String)">
 <summary>
 Gets the value Of the specified column As a Boolean.
 (这个函数也同时包含有开关参数的，开关参数默认为逻辑值类型，当包含有开关参数的时候，其逻辑值为True，反之函数会检查参数列表，参数不存在则为空值字符串，则也为False)
 </summary>
 <param name="parameter">可以包含有开关参数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetByte(System.String)">
 <summary>
 Gets the 8-bit unsigned Integer value Of the specified column.
 </summary>
 <param name="parameter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetBytes(System.String)">
 <summary>
 Reads a stream Of bytes from the specified column offset into the buffer As an array, starting at the given buffer offset.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetChar(System.String)">
 <summary>
 Gets the character value Of the specified column.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetChars(System.String)">
 <summary>
 Reads a stream Of characters from the specified column offset into the buffer As an array, starting at the given buffer offset.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetDateTime(System.String)">
 <summary>
 Gets the Date And time data value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetDecimal(System.String)">
 <summary>
 Gets the fixed-position numeric value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetDouble(System.String)">
 <summary>
 Gets the Double-precision floating point number Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetFloat(System.String)">
 <summary>
 Gets the Single-precision floating point number Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetGuid(System.String)">
 <summary>
 Returns the GUID value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetInt16(System.String)">
 <summary>
 Gets the 16-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetInt32(System.String)">
 <summary>
 Gets the 32-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetInt64(System.String)">
 <summary>
 Gets the 64-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetOrdinal(System.String)">
 <summary>
 Return the index Of the named field. If the name is not exists in the parameter list, then a -1 value will be return.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetString(System.String)">
 <summary>
 Gets the String value Of the specified field.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.IsNull(System.String)">
 <summary>
 Return whether the specified field Is Set To null.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetObject``1(System.String,System.Func{System.String,``0})">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="parameter">Command parameter name in the command line inputs.</param>
 <param name="__getObject"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetValue``1(System.String,``0,System.Func{System.String,``0})">
 <summary>
 If the given parameter is not exists in the user input arguments, then a developer specific default value will be return.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name"></param>
 <param name="[default]">The default value for returns when the parameter is not exists in the user input.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetEnumerator">
 <summary>
 这个枚举函数也会将开关给包含进来，与<see cref="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetValueArray"/>方法所不同的是，这个函数里面的逻辑值开关的名称没有被修饰剪裁
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Add(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 Adds an item to the System.Collections.Generic.ICollection`1.
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Add(System.String,System.String)">
 <summary>
 Add a parameter with name and its value.
 </summary>
 <param name="key"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Clear">
 <summary>
 Clear the inner list buffer
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Contains(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 只是通过比较名称来判断是否存在，值没有进行比较
 </summary>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Count">
 <summary>
 Get the switch counts in this commandline object.(获取本命令行对象中的所定义的开关的数目)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Remove(System.String)">
 <summary>
 Removes a parameter by name
 </summary>
 <param name="paramName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Remove(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 Removes a parameter by <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>
 </summary>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetValueArray">
 <summary>
 ToArray拓展好像是有BUG的，所以请使用这个函数来获取所有的参数信息，请注意，逻辑值开关的名称会被去掉前缀
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Addition(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Open a handle for a file system object.
 </summary>
 <param name="args"></param>
 <param name="fs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_LessThanOrEqual(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Gets the CLI parameter value.
 </summary>
 <param name="args"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Subtraction(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Try get parameter value.
 </summary>
 <param name="args"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Subtraction(Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Try get parameter value.
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.IORedirect">
 <summary>
 A communication fundation class type for the commandline program interop.
 (一个简单的用于从当前进程派生子进程的Wrapper对象，假若需要folk出来的子进程对象
 不需要终端交互功能，则更加推荐使用<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirectFile"/>对象来进行调用)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirect._processStateRunning">
 <summary>
 当前的这个进程实例是否处于运行的状态
 </summary>
 <remarks></remarks>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IORedirect.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.
 (目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IORedirect.ProcessInfo">
 <summary>
 The process invoke interface of current IO redirect operation.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IORedirect.StandardOutput">
 <summary>
 Gets the standard output for the target invoke process.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.IORedirect.ProcessExitCallBack">
 <summary>
 A function pointer for process the events when the target invoked child process was terminated and exit.
 (当目标进程退出的时候所调用的过程)
 </summary>
 <param name="exitCode">The exit code for the target sub invoke process.进程的退出代码</param>
 <param name="exitTime">The exit time for the target sub invoke process.(进程的退出时间)</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.GetError">
 <summary>
 Gets a <see cref="T:System.String"/> used to read the error output of the application.
 </summary>
 <returns>A <see cref="T:System.String"/> text value that read from the std_error of <see cref="T:System.IO.StreamReader"/> 
 that can be used to read the standard error stream of the application.</returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(System.Boolean,System.String[],System.Boolean)">
 <summary>
 Start the target process. If the target invoked process is currently on the running state, 
 then this function will returns the -100 value as error code and print the warning 
 information on the system console.(启动目标进程)
 </summary>
 <param name="WaitForExit">
 Indicate that the program code wait for the target process exit or not?
 (参数指示应用程序代码是否等待目标进程的结束)
 </param>
 <returns>
 当发生错误的时候会返回错误代码，当当前的进程任然处于运行的状态的时候，程序会返回-100错误代码并在终端之上打印出警告信息
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(Microsoft.VisualBasic.CommandLine.IORedirect.ProcessExitCallBack,System.String[],System.Boolean)">
 <summary>
 Start the target process.(启动目标进程)
 </summary>
 <returns>当发生错误的时候会返回错误代码</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.__listenSTDOUT">
 <summary>
 输出目标子进程的标准输出设备的内容
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.__detectProcessExit">
 <summary>
 检测目标子进程是否已经结束
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.op_Implicit(System.String)~Microsoft.VisualBasic.CommandLine.IORedirect">
 <summary>
 在进行隐士转换的时候，假若可执行文件的文件路径之中含有空格，则这个时候应该要特别的小心
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Creates a <see cref="T:System.Diagnostics.Process"/> wrapper for the CLI program operations.
 (在服务器上面可能会有一些线程方面的兼容性BUG的问题，不太清楚为什么会导致这样)
 </summary>
 <param name="Exe">The file path of the executable file.</param>
 <param name="args">The CLI arguments for the folked program.</param>
 <param name="envir">Set up the environment variable for the target invoked child process.</param>
 <param name="_disp_debug"></param>
 <param name="disp_STDOUT">是否显示目标被调用的外部程序的标准输出</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(System.Boolean)">
 <summary>
 Gets the value that the associated process specified when it terminated.
 </summary>
 <param name="WaitForExit"></param>
 <returns>The code that the associated process specified when it terminated.</returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Run">
 <summary>
 线程会被阻塞在这里，直到外部应用程序执行完毕
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1">
 <summary>
 Schema for <see cref="T:System.Attribute"/> and its bind <see cref="T:System.Reflection.PropertyInfo"/> object target
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Property">
 <summary>
 The property object that bind with its custom attribute <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Column"/> of type <typeparamref name="T"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Type">
 <summary>
 Gets the type of this property.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Identity">
 <summary>
 The map name or the <see cref="P:System.Reflection.MemberInfo.Name"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.IsNull">
 <summary>
 Is this map data is null on its attribute or property data?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.IsPrimitive">
 <summary>
 Gets a value indicating whether the <see cref="T:System.Type"/> is one of the primitive types.
 </summary>
 <returns>true if the <see cref="T:System.Type"/> is one of the primitive types; otherwise, false.</returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Identifier">
 <summary>
 Just enable readonly
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.SetValue(System.Object,System.Object)">
 <summary>
 Sets the property value of a specified object with optional index values for
 index properties.
 </summary>
 <param name="obj">The object whose property value will be set.</param>
 <param name="value">The new property value.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.GetValue(System.Object)">
 <summary>
 Returns the property value of a specified object with optional index values for
 indexed properties.
 </summary>
 <param name="x">The object whose property value will be returned.</param>
 <returns>The property value of the specified object.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.ToString">
 <summary>
 Display this schema maps in Visualbasic style.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable">
 <summary>
 SQL之中的一个数据表的抽象描述接口
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetInsertSQL">
 <summary>
 INSERT INTO table_name (field1, field2,...) VALUES (value1, value2,....)
 </summary>
 <returns></returns>
 <remarks>http://www.w3school.com.cn/sql/sql_insert.asp</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetUpdateSQL">
 <summary>
 UPDATE table_name SET field = &lt;new value> WHERE field = &lt;value>
 </summary>
 <returns></returns>
 <remarks>http://www.w3school.com.cn/sql/sql_update.asp</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetDeleteSQL">
 <summary>
 DELETE FROM table_name WHERE field = value;
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.ToString">
 <summary>
 Display the INSERT INTO sql from function <see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetInsertSQL"/>.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetFields``1(System.Type,System.Func{``0,System.String},System.Boolean)">
 <summary>
 这个只是得到最上面的一层属性值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="type"></param>
 <param name="getFieldName"></param>
 <param name="explict"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Schema`1">
 <summary>
 Schema for two dimension table.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field">
 <summary>
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>属性的别称
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field.#ctor(System.String)">
 <summary>
 Initializes a new instance by name.
 </summary>
 <param name="FieldName">The name.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute">
 <summary>
 Represents a column of certain data frames. The mapping between to schema is also can be represent by this attribute. 
 (也可以使用这个对象来完成在两个数据源之间的属性的映射，由于对于一些列名称的属性值缺失的映射而言，
 其是使用属性名来作为列映射名称的，故而在修改这些没有预设的列名称的映射属性的属性名的时候，请注意
 要小心维护这种映射关系)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.Index">
 <summary>
 Gets the index.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.Name">
 <summary>
 Gets the name.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.String)">
 <summary>
 Initializes a new instance by name.
 </summary>
 <param name="FieldName">The name.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.Int32)">
 <summary>
 Initializes a new instance by index.
 </summary>
 <param name="index">The index.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor">
 <summary>
 会默认使用目标对象的反射的Name属性作为映射的名称
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="Name">列名称，假若本参数为空的话，则使用属性名称</param>
 <param name="index">从1开始的下标，表示为第几列</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.LoadMapping``1(System.String[],System.Boolean)">
 <summary>
 没有名称属性的映射使用属性名来表述
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.LoadMapping(System.Type,System.String[],System.Boolean)">
 <summary>
 Load the mapping property, if the custom attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see> 
 have no name value, then the property name will be used as the mapping name.
 (这个函数会自动给空名称值进行属性名的赋值操作的)
 </summary>
 <param name="typeInfo">The type should be a class type or its properties should have the 
 mapping option which was created by the custom attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see>
 </param>
 <param name="ignores">这个是大小写敏感的</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameIO`1.InitializeSchema``1">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IMatched">
 <summary>
 The object implements on this interface can be matched with some rules.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IMatched.IsMatched">
 <summary>
 Is this object matched the condition?
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1">
 <summary>
 Interface defining any item we can store in a repository and can identify by
 an unique key
 </summary>
 <remarks>
 This interface is typed so we can make type-safe code for retrieving the entity
 (don't pass in an integer if the entity is keyed by string etc.)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key">
 <summary>
 Get the key to find the entity by
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord">
 <summary>
 Record for storing a client record in the common database
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord.ClientUniqueKey">
 <summary>
 The unique number by which we know this client
 </summary>
 <remarks>
 Every client has an unique id but this is not needed publically
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord.Code">
 <summary>
 The short code for the client
 </summary>
 <remarks>
 e.g. MCL for Merrion Computing Ltd etc.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2">
 <summary>
 Interface to support reading entities from the backing store
 </summary>
 <typeparam name="TEntity">
 The key-identified type of entity we are reading
 </typeparam>
 <typeparam name="TKey">
 The type of the key
 </typeparam>
 <remarks>
 In this architecture there is a seperate read and write interface but often this
 pattern has just the one interface for both functions
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.Exists(`0)">
 <summary>
 Does a record exist in the repository identified by this key
 </summary>
 <param name="key">
 The unique identifier of the entity we are looking for
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetByKey(`0)">
 <summary>
 Get the entity uniquely identified by the given key
 </summary>
 <param name="key">
 The unique identifier to use to get the entity
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetWhere(System.Func{`1,System.Boolean})">
 <summary>
 Get a set of entities from the repository that match the where clause
 </summary>
 <param name="clause">
 A function to apply to filter the results from the repository
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetAll">
 <summary>
 Get all of this type of thing from the repository
 </summary>
 <remarks>
 returns an IQueryable so this request can be filtered further
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2">
 <summary>
 Interface to support writing (and deletes) to a typed repository
 </summary>
 <typeparam name="TEntity">
 The type of entity in the repository
 </typeparam>
 <typeparam name="TKey">
 The type of the key to uniquely identify the entity
 </typeparam>
 <remarks>
 In this architecture there is a seperate read and write interface but often this
 pattern has just the one interface for both functions
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.Delete(`0)">
 <summary>
 Delete the entity uniquely identified by this key
 </summary>
 <param name="key">
 The unique identifier of the record to delete
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.AddOrUpdate(`1,`0)">
 <summary>
 Add or update the entity
 </summary>
 <param name="entity">
 The record to add or update on the repository
 </param>
 <param name="key" >
 The key that uniquely identifies the record to add or update
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.AddNew(`1)">
 <summary>
 Adds an entity that we know to be new and returns its assigned key
 </summary>
 <param name="entity">
 The entity we are adding to the repository
 </param>
 <returns>
 The unique identifier for the entity
 </returns>
 <remarks>
 This is useful if the unique identifier is not an intrinsic property of
 the entity - for example if it is a memory address or a GUID
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepository`2">
 <summary>
 Read/write repository of typed entites
 </summary>
 <typeparam name="TKey">
 The type by which the entity is uniquely identified
 </typeparam>
 <typeparam name="TEntity">
 The type of entity in the repository
 </typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.RepositoryReadException">
 <summary>
 An exception that occured when reading from the repository backing store
 </summary>
 <remarks>
 The inner exception is from whatever
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataSample`1">
 <summary>
 Numeric value statics property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1">
 <summary>
 The <see cref="T:System.Reflection.PropertyInfo"/> like definition of the extension property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Value">
 <summary>
 The Extension property value.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.obj">
 <summary>
 The instance object for this extension property
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.#ctor(System.Func{`0},System.Action{`0})">
 <summary>
 Custom property value.(value generated based on the extension property host <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.obj"/>)
 </summary>
 <param name="[get]">请勿使用<see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.GetValue``1(``0,System.String)"/></param>函数，否则会出现栈空间溢出
 <param name="[set]">请勿使用<see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.SetValue(`0)"/></param>方法，否则会出现栈空间溢出
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.#ctor">
 <summary>
 Tag property value.(默认是将数据写入到基本类型的值之中)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.SetValue(`0)">
 <summary>
 这个主要是应用于Linq表达式之中，将属性值设置之后返回宿主对象实例
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.op_Explicit(Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue{`0})~`0">
 <summary>
 Property Get Value
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.ToString">
 <summary>
 <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Value"/> -> <see cref="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetJson(System.Object,System.Type,System.Boolean)"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.New``1(``0,System.String)">
 <summary>
 Creates a new extension property for the target <see cref="T:Microsoft.VisualBasic.Language.ClassObject"/>
 </summary>
 <typeparam name="Cls"></typeparam>
 <param name="x"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Read``1(``0,System.String)">
 <summary>
 Gets the tag property value from the <see cref="T:Microsoft.VisualBasic.Language.ClassObject"/>.(读取<see cref="T:Microsoft.VisualBasic.Language.ClassObject"/>对象之中的一个拓展属性)
 </summary>
 <typeparam name="Cls"></typeparam>
 <param name="x"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicMeta`1">
 <summary>
 Abstracts for the dynamics property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicMeta`1.Properties">
 <summary>
 Properties
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1">
 <summary>
 Has a dictionary as a dynamics property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Properties">
 <summary>
 The dynamics property object with specific type of value.
 </summary>
 <returns></returns>
 <remarks>Can not serialize the dictionary object in to xml document.</remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Value(System.String)">
 <summary>
 Get value by property name.
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1">
 <summary>
 Dictionary for [<see cref="T:System.String"/>, <typeparamref name="T"/>]
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1.#ctor(System.String,`0)">
 <summary>
 New with a init property value
 </summary>
 <param name="initKey"></param>
 <param name="initValue"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1.source">
 <summary>
 
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1">
 <summary>
 The value object have a name string.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name">
 <summary>
 Identifier tag data. you can using this property value as a dictionary key.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.x">
 <summary>
 Object value
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.IsEmpty">
 <summary>
 Does this object have value?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.#ctor(System.String,`0)">
 <summary>
 Creates a object bind with a specific <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>.
 </summary>
 <param name="name"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.ToString">
 <summary>
 View object.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator`1">
 <summary>
 在<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator"/>的基础之上所构建出来的一个泛型化的迭代器对象.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator">
 <summary>
 Implements for the <see cref="T:System.Collections.Generic.IEnumerable`1"/>, Supports a simple iteration over a non-generic collection.
 (这个迭代器对象主要是用在远程数据源之中的，对于本地的数据源而言，使用这个迭代器的效率太低了，但是对于远程数据源而言，由于存在网络延迟，所以这个迭代器的效率影响将可以被忽略不计)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Current">
 <summary>
 Gets the current element in the collection.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.ReadDone">
 <summary>
 Indicates that there are no more characters in the string and tokenizer is finished.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.GetEnumerator">
 <summary>
 Exposes an enumerator, which supports a simple iteration over a non-generic collection.To
 browse the .NET Framework source code for this type, see the Reference Source.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Read">
 <summary>
 Returns current and then automatically move to next position
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Reset">
 <summary>
 Sets the enumerator to its initial position, which is before the first element in the collection.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.MoveNext">
 <summary>
 Advances the enumerator to the next element of the collection.
 </summary>
 <returns>
 true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IObjectModel_Driver">
 <summary>
 Driver abstract model
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IObjectModel_Driver.Run">
 <summary>
 Start run this driver object.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework">
 <summary>
 在目标对象中必须要具有一个属性有自定义属性<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see>
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.Flags">
 <summary>
 Controls for <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.PropertyAccessibilityControls"/> on <see cref="T:System.Reflection.PropertyInfo"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.PrimitiveFromString">
 <summary>
 Converts the .NET primitive types from string.(将字符串数据类型转换为其他的数据类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.ToStrings">
 <summary>
 Object <see cref="T:System.Object"/> methods.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.ValueToString(System.Object)">
 <summary>
 Call <see cref="T:System.Object"/> of the value types
 </summary>
 <param name="x">Object should be <see cref="T:System.Data.ValueType"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.__toStringInternal(System.Object)">
 <summary>
 出现错误的时候总是会返回空字符串的
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.CreateObject``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Convert target data object collection into a datatable for the data source of the <see cref="T:System.Windows.Forms.DataGridView"></see>>.
 (将目标对象集合转换为一个数据表对象，用作DataGridView控件的数据源)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.GetValue``1(System.Data.DataTable)">
 <summary>
 Retrive data from a specific datatable object.(从目标数据表中获取数据)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="DataTable"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.ClusterParts``1(Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.IsType{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.IsType{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.GetEntities{``0})">
 <summary>
 {最开始的节点，实体列表}
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.__hashLeaf``1(Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.IsType{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.ClusterParts.IsType{``0})">
 <summary>
 最远只允许隔着一层Path，这些就可以看作为一个cluster
 </summary>
 <param name="node"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.NewickParser">
 <summary>
 http://www.evolgenius.info/evolview/
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.NewickParser.TreeParser``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="input"></param>
 <param name="hashTranslate">可以通过这个对象将节点编号映射为名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.NewickParser.TreeParser``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0}@)">
 <summary>
 created: Oct 20, 2013 : a better and easier to maintain parser for newick and nexus trees
 NOTE: this is a recursive function </summary>
 <param name="inputstr"> : input tree string </param>
 <param name="hashTranslate"> : aliases for lead nodes (for nexsus format) </param>
 <param name="iNode"> : current internal node; == rootNode the first time 'newickParser' is called  </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.NewickParser.__makeInternalNode``1(System.String,System.Boolean,Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0}@)">
 <summary>
 Dec 5, 2011; can be used to make rootnode
 </summary>
 <param name="id"></param>
 <param name="isroot"></param>
 <param name="parentnode"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.NewickParser.parseInforAndMakeNewLeafNode``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0})">
 <summary>
 created on Oct 20, 2013 
 input: the leafstr to be parsed, the internal node the leaf node has to be added to 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1">
 <summary>
 Define tree nodes
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.#ctor(System.String,`0)">
 <summary>
 Constructor  to create a single node 
 </summary>
 <param name="name"></param>
 <param name="d"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.Count">
 <summary>
 递归的得到子节点的数目
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.GetEnumerator">
 <summary>
 最多只有两个元素
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1">
 <summary>
 The Binary tree itself.
 
 A very basic Binary Search Tree. Not generalized, stores
 name/value pairs in the tree nodes. name is the node key.
 The advantage of a binary tree is its fast insert and lookup
 characteristics. This version does not deal with tree balancing.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1._Count">
 <summary>
 Points to the root of the tree
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.#ctor(System.String,`0)">
 <summary>
 初始化有一个根节点
 </summary>
 <param name="ROOT"></param>
 <param name="obj"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.clear">
 <summary>
 Clear the binary tree.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.Add(System.String,Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0},System.Boolean)">
 <summary>
 Manual add tree node
 </summary>
 <param name="parent"></param>
 <param name="node"></param>
 <param name="left"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.Add(System.String,Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0})">
 <summary>
 Manual add tree node
 </summary>
 <param name="parent"></param>
 <param name="node"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.Length">
 <summary>
 Returns the number of nodes in the tree
 </summary>
 <returns>Number of nodes in the tree</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.DirectFind(System.String)">
 <summary>
 假若节点是不适用标识符来标识自己的左右的位置，则必须要使用这个方法才可以查找成功
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.FindSymbol(System.String)">
 <summary>
 Find name in tree. Return a reference to the node
 if symbol found else return null to indicate failure.
 </summary>
 <param name="name">Name of node to locate</param>
 <returns>Returns null if it fails to find the node, else returns reference to node</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.Add(Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0}@,System.Int32)">
 <summary>
 Recursively locates an empty slot in the binary tree and inserts the node
 </summary>
 <param name="node"></param>
 <param name="tree"></param>
 <param name="[overrides]">
 0不复写，函数自动处理
 &lt;0  LEFT
 >0 RIGHT
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.insert(System.String,`0,System.Boolean)">
 <summary>
 Add a symbol to the tree if it's a new one. Returns reference to the new
 node if a new node inserted, else returns null to indicate node already present.
 </summary>
 <param name="name">Name of node to add to tree</param>
 <param name="d">Value of node</param>
 <returns> Returns reference to the new node is the node was inserted.
 If a duplicate node (same name was located then returns null</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.insert(System.String,`0)">
 <summary>
 Add a symbol to the tree if it's a new one. Returns reference to the new
 node if a new node inserted, else returns null to indicate node already present.
 </summary>
 <param name="name">Name of node to add to tree</param>
 <param name="d">Value of node</param>
 <returns> Returns reference to the new node is the node was inserted.
 If a duplicate node (same name was located then returns null</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.findSuccessor(Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{`0}@)">
 <summary>
 Find the next ordinal node starting at node startNode.
 Due to the structure of a binary search tree, the
 successor node is simply the left most node on the right branch.
 </summary>
 <param name="startNode">Name key to use for searching</param>
 <param name="parent">Returns the parent node if search successful</param>
 <returns>Returns a reference to the node if successful, else null</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.delete(System.String)">
 <summary>
 Delete a given node. This is the more complex method in the binary search
 class. The method considers three senarios, 1) the deleted node has no
 children; 2) the deleted node as one child; 3) the deleted node has two
 children. Case one and two are relatively simple to handle, the only
 unusual considerations are when the node is the root node. Case 3) is
 much more complicated. It requires the location of the successor node.
 The node to be deleted is then replaced by the sucessor node and the
 successor node itself deleted. Throws an exception if the method fails
 to locate the node for deletion.
 </summary>
 <param name="key">Name key of node to delete</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.BinaryTree`1.ToString">
 <summary>
 Return the tree depicted as a simple string, useful for debugging, eg
 50(40(30(20, 35), 45(44, 46)), 60)
 </summary>
 <returns>Returns the tree</returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">
 <summary>
 Represents an unordered grouping of unique hetrogenous members.
 (这个对象的功能和List类似，但是这个对象的主要的作用是进行一些集合运算：使用AND求交集以及使用OR求并集的)
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.BadBehaviourResponses">
 <summary>
 Enum of values to determine the aggressiveness of the response of the
 class to bad data.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.BadBehaviourResponses.BeAggressive">
 <summary>
 If the user enters bad data, throw an exception they have to deal with.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.BadBehaviourResponses.BeCool">
 <summary>
 If the user enters bad data, just eat it quietly.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.#ctor">
 <summary>
 Default constructor.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.#ctor(Microsoft.VisualBasic.ComponentModel.DataStructures.Set[])">
 <summary>
 Constructor called when the source data is an array of <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Sets</see>.  They will
 be unioned together, with addition exceptions quietly eaten.
 </summary>
 <param name="sources">The source array of <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> objects.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Clear">
 <summary>
 Empty the set of all members.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.IsEmpty">
 <summary>
 A method to determine whether the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> has members.
 </summary>
 <returns>True is there are members, false if there are 0 members.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Remove(System.Object)">
 <summary>
 Remove a member from the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
 <param name="target">The member to remove.</param>
 <returns>True if a member was removed, false if nothing was found that 
 was removed.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Add(System.Object)">
 <summary>
 Method to add an <see cref="T:System.Object">Object</see> to the set.  The new member 
 must be unique.
 </summary>
 <param name="member"><see cref="T:System.Object">Object</see> to add.</param>
 <exception cref="T:System.InvalidOperationException">If the member being added is
 already a member of the set an InvalidOperationException is thrown.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Contains(System.Object)">
 <summary>
 Method to determine if a given object is a member of the set.
 </summary>
 <param name="target">The object to look for in the set.</param>
 <returns>True if it is a member of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>, false if not.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.ToArray">
 <summary>
 Copies the members of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> to an array of 
 <see cref="T:System.Object">Objects</see>.
 </summary>
 <returns>An <see cref="T:System.Object">Object</see> array copies of the 
 elements of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Item(System.Int32)">
 <summary>
 Public accessor for the members of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Length">
 <summary>
 The number of members of the set.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.ToArray``1">
 <summary>
 DirectCast
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Explicit(System.Array)~Microsoft.VisualBasic.ComponentModel.DataStructures.Set">
 <summary>
 If the Set is created by casting an array to it, add the members of
 the array through the Add method, so if the array has dupes an error
 will occur.
 </summary>
 <param name="array">The array with the objects to initialize the array.</param>
 <returns>A new Set object based on the members of the array.</returns>
 <exception cref="T:System.InvalidCastException">If the array contains duplicate
 elements, an InvalidCastException will result.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_BitwiseOr(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs a union of two sets.(求并集)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains all of the
 members of each of the input sets.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_BitwiseAnd(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs an intersection of two sets.(求交集)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Addition(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 求两个集合的并集，将两个集合之中的所有元素都合并在一起，这个操作符会忽略掉重复出现的元素
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Subtraction(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 except(差集)集合运算：先将其中完全重复的数据行删除，再返回只在第一个集合中出现，在第二个集合中不出现的所有行。
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Equality(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Overloaded == operator to determine if 2 sets are equal.
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>True if the two comparison sets have the same number of elements, and
 all of the elements of set s1 are contained in s2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Inequality(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Overloaded != operator to determine if 2 sets are unequal.
 </summary>
 <param name="s1">A benchmark set.</param>
 <param name="s2">The set to compare against the benchmark.</param>
 <returns>True if the two comparison sets fail the equality (==) test,
 false if the pass the equality test.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Equals(System.Object)">
 <summary>
 Determines whether two <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> instances are equal.
 </summary>
 <param name="obj">The <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> to compare to the current Set.</param>
 <returns>true if the specified <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> is equal to the current 
 Set; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.GetHashCode">
 <summary>
 Serves as a hash function for a particular type, suitable for use in hashing 
 algorithms and data structures like a hash table.
 </summary>
 <returns>A hash code for the current <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.ToString">
 <summary>
 Returns a <see cref="T:System.String">String</see> that represents the current
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
 <returns>A <see cref="T:System.String">String</see> that represents the current
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.IEnumerable_GetEnumerator">
 <summary>
 Returns an enumerator that can iterate through a collection.
 </summary>
 <returns>An <see cref="T:System.Collections.IEnumerator">IEnumerator</see> that can be 
 used to iterate through the collection.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Dispose">
 <summary>
 Performs cleanup tasks on the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindowHandle`1">
 <summary>
 A slide window data model.(滑窗操作的数据模型)
 </summary>
 <typeparam name="T"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindowHandle`1.p">
 <summary>
 The position of the current Windows in the Windows list.(在创建的滑窗的队列之中当前的窗口对象的位置)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindowHandle`1.Elements">
 <summary>
 The elements in this slide window.(这个划窗之中的元素的列表)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindowHandle`1.Left">
 <summary>
 The left start position of the current slide Windows segment on the original sequence.
 (当前窗口在原始的序列之中的左端起始位点)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindowHandle`1.Length">
 <summary>
 The length of the slide window.(窗口长度)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindow">
 <summary>
 Create a collection of slide Windows data for the target collection object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindow.CreateSlideWindows``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean)">
 <summary>
 Create a collection of slide Windows data for the target collection object.(创建一个滑窗集合)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="slideWindowSize">The windows size of the created slide window.(窗口的大小)</param>
 <param name="offset">在序列之上移动的步长</param>
 <returns></returns>
 <param name="extTails">引用类型不建议打开这个参数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SlideWindow.SlideWindows``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean)">
 <summary>
 Create a collection of slide Windows data for the target collection object.(创建一个滑窗集合)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="slideWindowSize">The windows size of the created slide window.(窗口的大小)</param>
 <param name="offset">在序列之上移动的步长</param>
 <returns></returns>
 <param name="extTails">引用类型不建议打开这个参数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.GET">
 <summary>
 Gets the next elements in the array, is move to end, then the index will moves to the array begining position.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer">
 <summary>
 Type of <see cref="T:System.Int32"/> pointer class to the <see cref="T:System.Array"/> class.
 (<see cref="T:System.Int32"/>类型，一般用来进行数组操作的)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.__index">
 <summary>
 Current read position
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.#ctor(System.Int32)">
 <summary>
 Construct a pointer class and then assign a initial <see cref="T:System.Int32"/> value.(构造一个指针对象，并且赋值其初始值)
 </summary>
 <param name="n">The initial value.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.#ctor">
 <summary>
 Creates a new <see cref="T:System.Int32"/> type pointer object in VisualBasic with its initial value is ZERO.(构造一个初始值为零的整形数指针对象)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.op_LeftShift(Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer,System.Int32)">
 <summary>
 移动n，然后返回之前的数值
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.op_UnaryPlus(Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer)">
 <summary>
 Automatically increasing self +1 and then returns the previous value.(自增1，然后返回之前的数值)
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.op_UnaryNegation(Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer)">
 <summary>
 自减1，然后返回之前的数值
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.op_LessThanOrEqual(Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer,System.Int32)">
 <summary>
 Less than or equals
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer.op_GreaterThanOrEqual(Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer,System.Int32)">
 <summary>
 Greater than or equals
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer`1.op_Addition(`0[],Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer{`0})">
 <summary>
 Returns current line in the array and then pointer moves to next.
 </summary>
 <param name="array"></param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CapacityQueue`1.#ctor(System.Int32)">
 <summary>
 
 </summary>
 <param name="capacity">The initial number of elements that the System.Collections.Generic.Queue`1 can
 contain.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup">
 <summary>
 对数据进行分组，通过标签数据的相似度
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.FuzzyGroups``1(System.Collections.Generic.IEnumerable{``0},System.Double,System.Boolean)">
 <summary>
 Grouping objects in a collection based on their <see cref="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable.Identifier"/> string Fuzzy equals to others'.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="cut">字符串相似度的阈值</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.FuzzyGroups``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Double,System.Boolean)">
 <summary>
 Grouping objects in a collection based on their unique key string Fuzzy equals to others'.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="getKey">The unique key provider</param>
 <param name="cut">字符串相似度的阈值</param>
 <returns></returns>
 <remarks>
 由于list在查找方面的速度非常的慢，而字典可能在生成的时候会慢一些，但是查找很快，所以在这里函数里面使用字典来替代列表
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1">
 <summary>
 分组操作的内部帮助类
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.key">
 <summary>
 Key for represent this object.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.x">
 <summary>
 Target element object in the grouping 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.keyASC">
 <summary>
 Key cache
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.Equals(Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper{`0})">
 <summary>
 判断Key是否模糊相等
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.ILocalSearchHandle.Matches(System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 
 </summary>
 <param name="Keyword"></param>
 <param name="CaseSensitive">是否大小写敏感，默认不敏感</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.ILocalSearchHandle.Match(System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 
 </summary>
 <param name="Keyword"></param>
 <param name="CaseSensitive">是否大小写敏感，默认不敏感</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2">
 <summary>
 Defines a key/value pair that can be set or retrieved.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2.Identifier">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2.Value">
 <summary>
 Gets the value in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyDataSource`1">
 <summary>
 Defines a key/value pair that only can be retrieved.
 </summary>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2">
 <summary>
 Defines a key/value pair that can be set or retrieved.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2.Key">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2.Value">
 <summary>
 Gets the value in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1">
 <summary>
 The key of the dictionary is string value and the keys is not sensitive to the character case.
 (字典的键名为字符串，大小写不敏感，行为和哈希表类型)
 </summary>
 <typeparam name="T"></typeparam>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.#ctor">
 <summary>
 Initializes a new instance of the System.Collections.Generic.Dictionary`2 class
 that is empty, has the default initial capacity, and uses the default equality
 comparer for the key type.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.ContainsKey(System.String)">
 <summary>
 
 </summary>
 <param name="key">大小写不敏感</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.Item(System.String)">
 <summary>
 添加<see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.Add(System.Collections.Generic.KeyValuePair{System.String,`0})"></see>和替换操作主要在这里进行
 </summary>
 <param name="key">大小写不敏感</param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IPairItem`2.Equals(Microsoft.VisualBasic.ComponentModel.Collection.Generic.IPairItem{`0,`1})">
 <summary>
 Call by the method <see cref="M:Microsoft.VisualBasic.IEnumerations.GetItem``1(System.Collections.Generic.IEnumerable{``0},System.String)"></see>
 </summary>
 <param name="pairItem"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable">
 <summary>
 This type of object have a <see cref="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable.Identifier"></see> property to unique identified itself in a collection.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable.Identifier">
 <summary>
 The unique identifer in the object collection. Unique-Id of the target implements object
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyId.Identity">
 <summary>
 The unique identifer in the object collection. Unique-Id of the target implements object
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.ITrigger.TestRun">
 <summary>
 Test if success then run callback
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.Interval">
 <summary>
 ms
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.#ctor(System.DateTime,System.Action,System.Int32)">
 <summary>
 
 </summary>
 <param name="time"></param>
 <param name="task"></param>
 <param name="interval">ms</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.__test">
 <summary>
 不计算毫秒
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.node">
 <summary>
 Current node in the chain list
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.Next">
 <summary>
 The next element in the chain after this element
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.Previous">
 <summary>
 The previous element in the chain before this element
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HashHandle`1.__allocate">
 <summary>
 Allocate memory
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.BufferedStream">
 <summary>
 Buffered large text dataset reader
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.BufferedStream.FileName">
 <summary>
 The File location of this text file.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BufferedStream.#ctor(System.String,System.Text.Encoding,System.Int32)">
 <summary>
 
 </summary>
 <param name="path"></param>
 <param name="encoding"><see cref="P:System.Text.Encoding.Default"/>, if null</param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.BufferedStream.EndRead">
 <summary>
 End of buffer read?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BufferedStream.Reset">
 <summary>
 Reset the stream buffer reader to its initial state.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BufferedStream.BufferProvider">
 <summary>
 当<see cref="P:Microsoft.VisualBasic.ComponentModel.BufferedStream.EndRead"/>之后，这个函数将不会返回任何值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
 <summary>
 
 </summary>
 <param name="source"></param>
 <param name="asc">当这个参数为真的时候</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.SelectUntilGreaterThan(`0)">
 <summary>
 直到当前元素大于指定值
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.SelectUntilLessThan(`0)">
 <summary>
 直到当前元素小于指定值
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1">
 <summary>
 Represents a generic range with minimum and maximum values
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1.Min">
 <summary>
 Minimum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1.Max">
 <summary>
 Maximum value
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1.IsInside(`0)">
 <summary>
 Check if the specified value is inside this range
 </summary>
 <param name="x">Value to check</param>
 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.IRanges{`0})">
 <summary>
 Check if the specified range is inside this range
 </summary>
 <param name="range">Range to check</param>
 <returns><b>True</b> if the specified range is inside this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IRanges`1.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.IRanges{`0})">
 <summary>
 Check if the specified range overlaps with this range
 </summary>
 <param name="range">Range to check for overlapping</param>
 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange">
 <summary>
 Represents a double range with minimum and maximum values
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.Min">
 <summary>
 Minimum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.Max">
 <summary>
 Maximum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.Length">
 <summary>
 Length of the range (deffirence between maximum and minimum values)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.#ctor(System.Double,System.Double)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange"/> class
 </summary>
 
 <param name="min">Minimum value of the range</param>
 <param name="max">Maximum value of the range</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.IsInside(System.Double)">
 <summary>
 Check if the specified value is inside this range
 </summary>
 
 <param name="x">Value to check</param>
 
 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange)">
 <summary>
 Check if the specified range is inside this range
 </summary>
 
 <param name="range">Range to check</param>
 
 <returns><b>True</b> if the specified range is inside this range or
 <b>false</b> otherwise.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.DoubleRange)">
 <summary>
 Check if the specified range overlaps with this range
 </summary>
 
 <param name="range">Range to check for overlapping</param>
 
 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange">
 <summary>
 Represents an integer range with minimum and maximum values
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.Min">
 <summary>
 Minimum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.Max">
 <summary>
 Maximum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.Length">
 <summary>
 Length of the range (deffirence between maximum and minimum values)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.#ctor(System.Int32,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange"/> class
 </summary>

 <param name="min">Minimum value of the range</param>
 <param name="max">Maximum value of the range</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.IsInside(System.Int32)">
 <summary>
 Check if the specified value is inside this range
 </summary>

 <param name="x">Value to check</param>

 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.IntRange)">
 <summary>
 Check if the specified range is inside this range
 </summary>

 <param name="range">Range to check</param>

 <returns><b>True</b> if the specified range is inside this range or
 <b>false</b> otherwise.</returns>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IntRange.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.IntRange)">
 <summary>
 Check if the specified range overlaps with this range
 </summary>

 <param name="range">Range to check for overlapping</param>

 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>

</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile">
 <summary>
 Ini file I/O handler
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.WritePrivateProfileString(System.String,System.String,System.String,System.String)">
 <summary>
 Write a string value into a specific section in a specifc ini profile.(在初始化文件指定小节内设置一个字串)
 </summary>
 <param name="section">
 <see cref="T:System.String"/>，要在其中写入新字串的小节名称。这个字串不区分大小写
 </param>
 <param name="key">
 <see cref="T:System.String"/>，要设置的项名或条目名。这个字串不区分大小写。
 用<see cref="F:Microsoft.VisualBasic.Constants.vbNullString"/>可删除这个小节的所有设置项
 </param>
 <param name="val">
 <see cref="T:System.String"/>，指定为这个项写入的字串值。用<see cref="F:Microsoft.VisualBasic.Constants.vbNullString"/>表示删除这个项现有的字串
 </param>
 <param name="filePath">
 <see cref="T:System.String"/>，初始化文件的名字。如果没有指定完整路径名，则windows会在windows目录查找文件。
 如果文件没有找到，则函数会创建它</param>
 <returns>Long，非零表示成功，零表示失败。会设置<see cref="M:Microsoft.VisualBasic.Win32.GetLastErrorAPI.GetLastError"/></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.GetPrivateProfileString(System.String,System.String,System.String,System.Text.StringBuilder,System.Int32,System.String)">
 <summary>
 为初始化文件中指定的条目取得字串
 </summary>
 <param name="section">
 String，欲在其中查找条目的小节名称。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString
 缓冲区内装载这个ini文件所有小节的列表。
 </param>
 <param name="key">
 String，欲获取的项名或条目名。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString
 缓冲区内装载指定小节所有项的列表
 </param>
 <param name="def">String，指定的条目没有找到时返回的默认值。可设为空（""）</param>
 <param name="retVal">String，指定一个字串缓冲区，长度至少为nSize</param>
 <param name="size">Long，指定装载到lpReturnedString缓冲区的最大字符数量</param>
 <param name="filePath">
 String，初始化文件的名字。如没有指定一个完整路径名，windows就在Windows目录中查找文件
 </param>
 <returns>
 Long，复制到lpReturnedString缓冲区的字节数量，其中不包括那些NULL中止字符。如lpReturnedString
 缓冲区不够大，不能容下全部信息，就返回nSize-1（若lpApplicationName或lpKeyName为NULL，则返回nSize-2）
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.#ctor(System.String)">
 <summary>
 Open a ini file handle.
 </summary>
 <param name="INIPath"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName">
 <summary>
 定义在Ini配置文件之中的Section的名称
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName.#ctor(System.String)">
 <summary>
 Defines the section name in the ini profile data.(定义在Ini配置文件之中的Section的名称)
 </summary>
 <param name="name"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper">
 <summary>
 使用这个属性来标记需要进行序列化的对象属性: <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.MapParser(System.Type)">
 <summary>
 Get mapping data, includes section name and keys
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.ClassWriter``1(Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile)">
 <summary>
 Read data from ini file.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="ini"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.LoadIni``1(System.String)">
 <summary>
 Load a ini section profile data from a ini file.
 </summary>
 <typeparam name="T">The section mapper</typeparam>
 <param name="path">*.ini file</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.WriteClass``1(``0,System.String)">
 <summary>
 Write ini section into data file.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x">A section class in the ini profile file.</param>
 <param name="ini"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniMapIO.#ctor(System.String)">
 <summary>
 The path parameter can be shortcut by method <see cref="M:Microsoft.VisualBasic.Language.UnixBash.PathMapper.GetMapPath(System.String)"/>
 </summary>
 <param name="path"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.WriteProfile``1(``0)">
 <summary>
 属性的类型需要定义<see cref="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName"/>，Section类型里面的属性还需要定义<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section.SetValue(System.String,System.String)">
 <summary>
 不存在则自动添加
 </summary>
 <param name="Name"></param>
 <param name="value"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile">
 <summary>
 Wrapper class for *.ini and *.inf configure file.(可能文件中的注释行会受到影响，所以请尽量使用本类型中的两个静态函数来操作INI文件)
 </summary>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.GetValue(System.String,System.String,System.String)">
 <summary>
 Get the value from a specific section/key in a file of path 
 </summary>
 <param name="path"></param>
 <param name="key"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions">
 <summary>
 读写Ini文件的拓展
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions.WriteIni``1(Microsoft.VisualBasic.ComponentModel.Settings.IProfile,System.String)">
 <summary>
 The section name of the profile data is the type name
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="path"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions.LoadIni``1(System.String)">
 <summary>
 The section name of the profile data is the type name
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine">
 <summary>
 只包含有对数据映射目标对象的属性读写，并不包含有文件数据的读写操作
 </summary>
 
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine._SettingsData">
 <summary>
 所映射的数据源
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.ProfileItemCollection">
 <summary>
 键名都是小写的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.AllItems">
 <summary>
 List all of the available settings nodes in this profile data session.
 (枚举出当前配置会话之中的所有可用的配置节点)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.ExistsNode(System.String)">
 <summary>
 大小写不敏感
 </summary>
 <param name="Name"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.Set(System.String,System.String)">
 <summary>
 请注意，<paramref name="name"/>必须是小写的
 </summary>
 <param name="Name">The name of the configuration entry should be in lower case.</param>
 <param name="Value"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.View(System.String)">
 <summary>
假若函数参数<paramref name="name"/>为空，则函数输出所有的变量的值，请注意，这个函数并不在终端上面显示任何消息
 </summary>
 <param name="name">假若本参数为空，则函数输出所有的变量的值，大小写不敏感的</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.GetSettingsNode(System.String)">
 <summary>
 大小写不敏感的
 </summary>
 <param name="Name"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.BindMapping.AsOutString">
 <summary>
 打印在终端窗口上面的字符串
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.BindMapping.IsFsysValid">
 <summary>
 这个方法只是针对<see cref="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.File"/>和<see cref="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Directory"/>这两种类型而言才有效的
 对于其他的类型数据，都是返回False
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.IProfile">
 <summary>
 具备有保存数据功能的可配置数据文件的基本定义
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.IProfile.FilePath">
 <summary>
 本属性不能够被设置为只读属性是因为 Settings.Settings(Of IProfile).LoadFile 函数的需要
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes">
 <summary>
 这个并不是指宿主属性的数据类型，而是指代这一数据类型所代表的具体的实际对象
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Directory">
 <summary>
 这个字符串的值是一个文件夹
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.File">
 <summary>
 这个字符串的值是一个文件的路径
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Text">
 <summary>
 普通的文本字符串
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Double">
 <summary>
 带有小数的数值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Integer">
 <summary>
 整数
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem">
 <summary>
 The simple configuration mapping node in the current profile data, the data type of this node 
 object should be just the simplest data type such as String, Integer, Long, Double, Boolean.
 (当前的配置节点为一个简单节点，即目标属性的属性值类型的字符串，数字或者逻辑值等最基本的数据类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem.Type">
 <summary>
 默认的数据类型是字符串类型
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem.#ctor(System.String,System.String)">
 <summary>
 Initialize a node in the settings xml document.
 </summary>
 <param name="NodeName">The name of the node in the document xml file</param>
 <param name="NodeDescription">The brief introduction information about this profile node.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ProfileNodeItem">
 <summary>
 当前的配置节点为一个复杂数据类型的配置节点，即目标属性的属性类型为一个Class对象
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.TryParse``2(System.Boolean,System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TConfig"></typeparam>
 <param name="canRead">向文件之中写数据的时候，需要设置为真</param>
 <param name="canWrite">从文件之中读取数据的时候，需要设置为真</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.GenerateConfigurations``1(``0)">
 <summary>
 从类型实体生成配置文件数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="target"></param>
 <returns></returns>
 <remarks>类型实体之中的简单属性，只要具备可读属性即可被解析出来</remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.SettingsData">
 <summary>
 The target object instance that provides the data source for this config engine.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.#ctor(`0)">
 <summary>
 从配置数据的实例对象创建配置映射
 </summary>
 <param name="config"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.LoadFile(System.String,System.Action{`0,System.String})">
 <summary>

 </summary>
 <param name="XmlFile">目标配置文件的Xml文件的文件名</param>
 <returns>可以调用的配置项的数目，解析失败则返回0</returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.SingletonHolder`1">
 <summary>
 An Interface for the SingletonHolder Class.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.ISaveHandle">
 <summary>
 This is a file object which have a handle to save its data to the filesystem.(这是一个带有文件数据保存方法的文件模型)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.ISaveHandle.Save(System.String,System.Text.Encoding)">
 <summary>
 Handle for saving the file data.(保存文件的方法)
 </summary>
 <param name="Path">The file path that will save data to.(进行文件数据保存的文件路径)</param>
 <param name="encoding">The text encoding value for the text document.(文本文档的编码格式)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.LazyLoader`2">
 <summary>
 当所需要进行加载的数据的量非常大的时候，则可以使用本方法进行延时按需加载
 </summary>
 <typeparam name="TOutput"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.Value">
 <summary>
 Gets the value from the data source <see cref="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.URL"></see>
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.URL">
 <summary>
 The data source.(数据源)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.WriteData(Microsoft.VisualBasic.ComponentModel.LazyLoader{`0,`1}.DataWriteMethod)">
 <summary>
 Write the data back onto the filesystem.(将数据回写进入文件系统之中)
 </summary>
 <param name="WriteMethod"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Lazy`1">
 <summary>
 The layze loader.
 </summary>
 <typeparam name="TOut"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Lazy`1._dataTask">
 <summary>
 the data source handler.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Lazy`1._outCache">
 <summary>
 The output result cache data.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Lazy`1.Value">
 <summary>
 Get cache data if it exists, or the data will be loaded first.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Lazy`1.#ctor(System.Func{`0})">
 <summary>
 Init this lazy loader with the data source handler.
 </summary>
 <param name="Source">the data source handler.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Value`1">
 <summary>
 you can applying this data type into a dictionary object to makes the mathematics calculation more easily.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Value`1.Value">
 <summary>
 The object value with a specific type define.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TripleKeyValuesPair">
 <summary>
 The key has 2 string value collection.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.RelayCommand">
 <summary>
 Taken from http://msdn.microsoft.com/en-us/magazine/dd419663.aspx
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TimeInterval.ToString">
 <summary>
 (dd hh:mm:ss) 输出可以被MySQL数据库所识别的字符串格式
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Href">
 <summary>
 Resource link data.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Href.ResourceId">
 <summary>
 资源的名称
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Href.Value">
 <summary>
 The relative path of the target resource object in the file system.(资源对象在文件系统之中的相对路径)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Href.Annotations">
 <summary>
 注释数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Href.GetFullPath(System.String)">
 <summary>
 获取<see cref="P:Microsoft.VisualBasic.ComponentModel.Href.Value"></see>所指向的资源文件的完整路径
 </summary>
 <param name="DIR"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.KeyValuePair">
 <summary>
 An object for the text file format xml data storage.(用于存储与XML文件之中的字符串键值对对象)
 </summary>
 <remarks>
 20160524 为了更好的构建GCModeller项目的数据文档的格式，本类型对象不再继承自<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2"/>类型
 </remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.KeyValuePair.IKeyValuePair">
 <summary>
 Defines a key/value pair that can be set or retrieved.(特化的<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2"></see>字符串属性类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.KeyValuePair.Key">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>在这里可能用不了<see cref="T:System.Xml.Serialization.XmlAttributeAttribute"></see>自定义属性，因为其基本类型之中的Key和Value可以是任意的类型的，Attribute格式无法序列化复杂的数据类型</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.KeyValuePair.Equals(Microsoft.VisualBasic.ComponentModel.KeyValuePair,System.Boolean)">
 <summary>
 
 </summary>
 <param name="obj"></param>
 <param name="strict">If strict is TRUE then the function of the string compares will case sensitive.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Key_strArrayValuePair">
 <summary>
 {Key, strArray()} The value of this data type object is a string collection.(本类型对象的值属性类型为一个字符串集合)
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.ITextFile">
 <summary>
 Object model of the text file doucment.(文本文件的对象模型，这个文本文件对象在Disposed的时候会自动保存其中的数据)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.ITextFile.FilePath">
 <summary>
 The storage filepath of this text file.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.ITextFile.getPath(System.String)">
 <summary>
 Automatically determine the path paramater: If the target path is empty, then return
 the file object path <see cref="P:Microsoft.VisualBasic.ComponentModel.ITextFile.FilePath"></see> property, if not then return the
 <paramref name="path"></paramref> directly.
 (当<paramref name="path"></paramref>的值不为空的时候，本对象之中的路径参数将会被替换，反之返回本对象的路径参数)
 </summary>
 <param name="path">用户所输入的文件路径</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Comb`1">
 <summary>
 对象类型的组合输出工具，即目标类型的集合之中的元素两两组合配对
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Comb`1.EOL">
 <summary>
 对象列表是否已经完全组合输出
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Comb`1.NewLine">
 <summary>
 是否已经开始读取新的一行数据
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Comb`1.CreateCompleteObjectPairs(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Creates the completely combination of the elements in the target input collection source.
 (创建完完全全的两两配对)
 </summary>
 <param name="Collection"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Comb">
 <summary>
 任意多个集合之间的对象之间相互组成组合输出
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IAddressHandle">
 <summary>
 This object gets a object handle value to indicated that the position this object exists 
 in the list collection structure. 
 (这个对象具有一个用于指明该对象在列表对象中的位置的对象句柄值)
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IAddress`1">
 <summary>
 This object gets a object handle value to indicated that the position this object exists 
 in the list collection structure. 
 (这个对象具有一个用于指明该对象在列表对象中的位置的对象句柄值)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.IAddress`1.Address">
 <summary>
 The ID that this object in a list instance.
 (本对象在一个列表对象中的位置索引号) 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.HandledList`1">
 <summary>
 
 </summary>
 <typeparam name="T">
 Class object that can be dispose by the system automatically and the class object that should 
 have a handle property to specific its position in this list class. 
 (能够被系统所自动销毁的对象类型，并且该类型的对象必须含有一个Handle属性来指明其在本列表中的位置)
 </typeparam>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.HandledList`1._ListData">
 <summary>
 Object instances data physical storage position, element may be null after 
 remove a specify object handle. 
 (列表中的元素对象实例的实际存储位置，当对象元素从列表之中被移除了之后，其将会被销毁)
 </summary>
 <remarks>
 即与只读属性'ListData'相比，这个字段的列表中可能含有空引用的元素对象.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.HandledList`1._EmptyListStack">
 <summary>
 Stack list that store the empty pointer
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.HandledList`1._HandleList">
 <summary>
 Exists handle that store in this list
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.HandledList`1.ListData">
 <summary>
 Get the logical list of the data store in this list object instance.
 (获取逻辑形式的列表数据)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.HandledList`1.Count">
 <summary>
 Get the logical list length 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.HandledList`1.Item(System.Int64)">
 <summary>
 Get or set a object instance data that has specify handle value
 </summary>
 <param name="Handle">Target object handle value</param>
 <value>It is not recommend that you use this property to set the data element as the list object's capacity may not cover your handle</value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.#ctor(System.Int32)">
 <summary>
 Construct a new list object
 </summary>
 <param name="Capacity">The initialize size of this list object, Optional parameter, default value is 2048</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.Append(`0@)">
 <summary>
 Add a disposable object instance element into this list object and return its object handle value in this list object    
 </summary>
 <param name="e">Object instance that will be store in this list object</param>
 <returns>Object handle in this list object instance</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.AppendRange(System.Collections.Generic.IEnumerable{`0}@)">
 <summary>
 Append a list of object instance
 </summary>
 <param name="list"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.RemoveAt(System.Int64)">
 <summary>
 Remove a object instance element in this list object that have a specify handler
 </summary>
 <param name="Handle">Object handle value that specify the target object</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.Exists(System.Int64)">
 <summary>
 Know that the specify handle pointe object is null or not? 
 </summary>
 <param name="Handle">Object handle</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.Exists(`0)">
 <summary>
 Know that a specify object instance exists in this list object or not? 
 (判断某一个指定的对象实例是否存在于列表对象之中)
 </summary>
 <param name="e">Target object instance(目标要进行查找的对象实例)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.Remove(`0)">
 <summary>
 Remove a specify object in this list object using its hashcode and return its handle value.
 (使用对象的哈希值来查找目标对象并对其进行移除，之后返回其句柄值) 
 </summary>
 <param name="e"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HandledList`1.Flush">
 <summary>
 Clear all of the data in this list object instance.
 (清除本列表对象中的所有数据)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SetAPI.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.SetAPI.GetUid{``0})">
<summary>
 Performs an intersection of two sets.(求交集，这个函数总是会挑选出<paramref name="s1"/>集合之中的元素的)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="M:Microsoft.VisualBasic.Extensions.Set``1(``0[]@,System.Int32,``0)">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.SetAPI.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.SetAPI.IEquals{``0})">
<summary>
 Performs an intersection of two sets.(求交集)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="M:Microsoft.VisualBasic.Extensions.Set``1(``0[]@,System.Int32,``0)">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Dictionary`1">
 <summary>
 Represents a collection of keys and values.To browse the .NET Framework source
 code for this type, see the Reference Source.
 </summary>
 <typeparam name="V"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.#ctor(System.Collections.Generic.Dictionary{System.String,`0})">
 <summary>
 Initializes a new instance of the System.Collections.Generic.SortedDictionary`2
 class that contains elements copied from the specified System.Collections.Generic.IDictionary`2
 and uses the default System.Collections.Generic.IComparer`1 implementation for
 the key type.
 </summary>
 <param name="source">
 The System.Collections.Generic.IDictionary`2 whose elements are copied to the
 new System.Collections.Generic.SortedDictionary`2.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.Add(`0)">
 <summary>
 Adds an element with the specified key and value into the System.Collections.Generic.SortedDictionary`2.
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.Find(System.String)">
 <summary>

 </summary>
 <param name="name">不区分大小写的</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.SafeGetValue(System.String,`0@,System.Boolean@)">
 <summary>
 If the value is not found in the hash directionary, then the default value will be returns, and the default value is nothing.
 </summary>
 <param name="name"></param>
 <param name="[default]"></param>
 <param name="success">可能value本身就是空值，所以在这里使用这个参数来判断是否存在</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.TryGetValue(System.String,System.Boolean@)">
 <summary>
 Gets the value associated with the specified key.
 </summary>
 <param name="name">The key of the value to get.</param>
 <param name="success">true if the System.Collections.Generic.SortedDictionary`2 contains an element
 with the specified key; otherwise, false.</param>
 <returns>When this method returns, the value associated with the specified key, if the
 key is found; otherwise, the default value for the type of the value parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.Remove(`0)">
 <summary>
 假若目标元素不存在于本字典之中，则会返回False
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.op_Addition(Microsoft.VisualBasic.Dictionary{`0},`0)">
 <summary>
 Adds an element with the specified key and value into the System.Collections.Generic.SortedDictionary`2.
 </summary>
 <param name="hash"></param>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Dictionary`1.op_Exponent(Microsoft.VisualBasic.Dictionary{`0},System.String)">
 <summary>
 Find a variable in the hash table
 </summary>
 <param name="hash"></param>
 <param name="uid"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.List`1">
 <summary>
 Represents a strongly typed list of objects that can be accessed by index. Provides
 methods to search, sort, and manipulate lists.To browse the .NET Framework source
 code for this type, see the Reference Source.
 </summary>
 <typeparam name="T">The type of elements in the list.</typeparam>
</member>
<member name="M:Microsoft.VisualBasic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.List`1.#ctor(`0[])">
 <summary>
 Initializes a new instance of the List`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="x">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.List`1.#ctor">
 <summary>
 Initializes a new instance of the List`1 class that
 is empty and has the default initial capacity.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.List`1.#ctor(System.Int32)">
 <summary>
 Initializes a new instance of the List`1 class that
 is empty and has the specified initial capacity.
 </summary>
 <param name="capacity">The number of elements that the new list can initially store.</param>
</member>
<member name="M:Microsoft.VisualBasic.List`1.PopAll">
 <summary>
 Pop all of the elements value in to array from the list object and then clear all of the list data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_UnaryPlus(Microsoft.VisualBasic.List{`0})">
 <summary>
 Move Next
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Addition(Microsoft.VisualBasic.List{`0},`0)">
 <summary>
 Adds an object to the end of the List`1.
 </summary>
 <param name="list"></param>
 <param name="x">The object to be added to the end of the List`1. The
 value can be null for reference types.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Addition(`0,Microsoft.VisualBasic.List{`0})">
 <summary>
 Adds an object to the end of the List`1.
 </summary>
 <param name="list"></param>
 <param name="x">The object to be added to the end of the List`1. The
 value can be null for reference types.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Subtraction(Microsoft.VisualBasic.List{`0},`0)">
 <summary>
 Removes the first occurrence of a specific object from the List`1.
 </summary>
 <param name="list"></param>
 <param name="x">The object to remove from the List`1. The value can
 be null for reference types.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Addition(Microsoft.VisualBasic.List{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Adds the elements of the specified collection to the end of the System.Collections.Generic.List`1.
 </summary>
 <param name="list"></param>
 <param name="vals"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Addition(Microsoft.VisualBasic.List{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Adds the elements of the specified collection to the end of the System.Collections.Generic.List`1.
 </summary>
 <param name="list"></param>
 <param name="vals"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Addition(System.Collections.Generic.IEnumerable{`0},Microsoft.VisualBasic.List{`0})">
 <summary>
 Adds the elements of the specified collection to the end of the System.Collections.Generic.List`1.
 </summary>
 <param name="vals"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_Exponent(Microsoft.VisualBasic.List{`0},System.Func{`0,System.Boolean})">
 <summary>
 Find a item in the list
 </summary>
 <param name="list"></param>
 <param name="find"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.List`1.op_GreaterThan(Microsoft.VisualBasic.List{`0},System.String)">
 <summary>
 Dump this collection data to the file system.
 </summary>
 <param name="source"></param>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.CreateDictionary``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 将目标集合对象转换为一个字典对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Collection"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.GetItem``3(``2,System.Collections.Generic.IEnumerable{``2})">
 <summary>
 use the overload method <see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IPairItem`2.Equals(Microsoft.VisualBasic.ComponentModel.Collection.Generic.IPairItem{`0,`1})"></see> of the type
 <see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IPairItem`2"></see>
 </summary>
 <typeparam name="TItem1"></typeparam>
 <typeparam name="TItem2"></typeparam>
 <typeparam name="pairItem"></typeparam>
 <param name="entry"></param>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.Takes``1(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 按照UniqueId列表来筛选出目标集合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="lstId"></param>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CollectionIO">
 <summary>
 Collection IO extensions
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.PipelineCLI">
 <summary>
 a | b - 管道命令在读写方面更加适合于文本数据，由于省去了IO的时间，故而效率较高
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.PipelineCLI.Start(System.IO.Stream,System.String,System.String)">
 <summary>
 使用管道的方法启动下游的应用程序
 </summary>
 <param name="app"></param>
 <param name="args"></param>
 <remarks>
 http://stackoverflow.com/questions/30546522/how-to-use-a-pipe-between-two-processes-in-process-start
 
 let the OS do it. ``StartInfo.FileName = "cmd"`` then prepend ``executablepath`` to params so it looks 
 the way you would enter it in a command window; 
 ``StartInfo.Arguments = params`` then start the process 
 
 – Plutonix May 30 '15 at 15:13
 </remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.Terminal.InnerQueue">
 <summary>
 Task action Queue for terminal QUEUE SOLVER 🙉
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.InnerQueue.WaitQueue">
 <summary>
 Wait for all thread queue job done.(Needed if you are using multiThreaded queue)
 </summary>
</member>
<member name="E:Microsoft.VisualBasic.Terminal.TerminalEvents.Resize">
 <summary>
 Terminal resize event for [<see cref="P:System.Console.WindowWidth"/>, <see cref="P:System.Console.WindowHeight"/>]
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.AbstractBar.PrintMessage(System.String)">
 <summary>
 Prints a simple message 
 </summary>
 <param name="msg">Message to print</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.AnimatedBar.Step">
 <summary>
 prints the character found in the animation according to the current index
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.ProgressBar">
 <summary>
 
 </summary>
 <remarks>
 http://www.cnblogs.com/masonlu/p/4668232.html
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.ProgressBar.SetProgress(System.Int32,System.String)">
 <summary>
 <paramref name="p"/>是进度条的百分比
 </summary>
 <param name="p">Percentage, 假设是从p到current</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.ProgressProvider.Step">
 <summary>
 返回来的百分比小数，还需要乘以100才能得到进度
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Program.Run(Microsoft.VisualBasic.Terminal.AbstractBar,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="bar"></param>
 <param name="wait">Sleep time of the thread</param>
 <param name="[end]">Ends at this iteration</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.SwayBar.BlankPointer">
 <summary>
 sets the atribute blankPointer with a empty string the same length that the pointer
 </summary>
 <returns>A string filled with space characters</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.SwayBar.ClearBar">
 <summary>
 reset the bar to its original state
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.SwayBar.PlacePointer(System.Int32,System.Int32)">
 <summary>
 remove the previous pointer and place it in a new possition
 </summary>
 <param name="start">start index</param>
 <param name="end">end index</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.SwayBar.Step">
 <summary>
 prints the progress bar acorrding to pointers and current direction
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Utility.Constants">
 <summary>
 Constants used with PInvoke methods
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.KEY_EVENT">
 <summary>
 EventType flags.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.MOUSE_EVENT">
 <summary>
 Event contains key event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.WINDOW_BUFFER_SIZE_EVENT">
 <summary>
 Event contains mouse event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.MENU_EVENT">
 <summary>
 Event contains window change event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.FOCUS_EVENT">
 <summary>
 Event contains menu event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.Utility.Constants.INVALID_HANDLE_VALUE">
 <summary>
 Event contains focus change
 Returned by GetStdHandle when an error occurs
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Utility.uCharUnion">
 <summary>
 ' Struct uChar is meant to support the Windows Console API's uChar union.
 ' Unions do not exist in the pure .NET world. We have to use the regular
 ' C# struct and the StructLayout and FieldOffset Attributes to preserve
 ' the memory layout of the unmanaged union.
 '
 ' We specify the "LayoutKind.Explicit" value for the StructLayout attribute
 ' to specify that every field of the struct uChar is marked with a byte offset.
 '
 ' This byte offset is specified by the FieldOffsetAttribute and it indicates
 ' the number of bytes between the beginning of the struct in memory and the
 ' beginning of the field.
 '
 ' As you can see in the struct uChar (below), the fields "UnicodeChar"
 ' and "AsciiChar" have been marked as being of offset 0. This is the only
 ' way that an unmanaged C/C++ union can be represented in C#.
 '
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Utility.KEY_EVENT_RECORD">
 <summary>
 ' The struct KEY_EVENT_RECORD is used to report keyboard input events
 ' in a console INPUT_RECORD structure.
 '
 ' Internally, it uses the structure uChar which is treated as a union
 ' in the unmanaged world.
 '
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Utility.ConsolePasswordInput">
 <summary>
 Summary description for ConsolePasswordInput.
 </summary>
 <remarks>
 .NET Console Password Input By Masking Keyed-In Characters
 http://www.codeproject.com/Articles/8110/NET-Console-Password-Input-By-Masking-Keyed-In-Ch
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.ConsolePasswordInput.PasswordInput(System.String@,System.Int32)">
 <summary>

 </summary>
 <param name="refPasswordToBuild"></param>
 <param name="iMaxNumberOfCharactersSet">The password max length limits.</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.ManualPages.ShowManual(System.Int32,System.Int32)">
 <summary>
 使用回车键或者箭头下显示下一行，字母q或者ESC键退出Manual
 </summary>
 <param name="initLines">最开始显示的行数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.ManualPages.FromFile(System.String)">
 <summary>
 从文本文件之中加载Manual数据
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Utility.IndexedManual">
 <summary>
 有显示标题的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.IndexedManual.#ctor(System.String[],System.String)">
 <summary>
 与<see cref="T:Microsoft.VisualBasic.Terminal.Utility.ManualPages"></see>所不同的是，本对象之中的这个字符串数组表示的是一页帮助，而不是一行帮助信息
 </summary>
 <param name="Pages"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.IndexedManual.ShowManual(System.Int32,System.Int32)">
 <summary>
 使用[Enter][Down_arrow][pagedown]翻下一页[Up_arrow][Pageup]翻上一页，[q]或者[esc]结束，[home]第一页[end]最后一页
 </summary>
 <param name="initLines">无用的参数</param>
 <param name="printLines">无用的参数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.IndexedManual.PrintPrompted(System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="p">Current page index</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Utility.CBusyIndicator.Start(System.Int32)">
 <summary>
 运行进度条
 </summary>
 <param name="Ticks">The total ticking counts of the indicator, Unit is [second].</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Helpers">
 <summary>
 Console helper. http://blogs.microsoft.co.il/blogs/pavely/archive/2009/07/23/changing-console-fonts.aspx
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Helpers.ConsoleFont">
 <summary>
 http://blogs.microsoft.co.il/blogs/pavely/archive/2009/07/23/changing-console-fonts.aspx
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.xConsole">
 <summary>
 Allows you to color and animate the console. ~ overpowered.it ~ TheTrigger - 💸
 </summary>
 <remarks>http://www.codeproject.com/Tips/626856/xConsole-Project</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.xConsole.CoolWriteSettings.CoolWriting">
 <summary>
 Gradual typing the output into console
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.xConsole.CoolWriteSettings.CoolWritingDelay">
 <summary>
 Write speed
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.xConsole.CoolWriteSettings.CWRDDelay">
 <summary>
 Set the delay when write a new line or dots. (Default = 200).
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.CoolWrite(System.Object)">
 <summary>
 Gradual output animation 👍👍
 </summary>
 <param name="obj">The object to convert</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.CoolWrite(System.String,System.Object[])">
 <summary>
 Gradual output animation 👍👍
 </summary>
 <param name="format">The input string</param>
 <param name="args"></param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.CoolWriteLine(System.String,System.Object[])">
 <summary>
 Gradual output animation
 </summary>
 <param name="format">The input string</param>
 <param name="args">Arguments</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.WriteLine">
 <summary>
 Allows you to write in the console-output with custom colors, followed by the current line terminator
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.WriteLine(System.Object)">
 <summary>
 Allows you to write in the console-output with custom colors, followed by the current line terminator
 </summary>
 <param name="obj">The object to convert</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.WriteLine(System.String,System.Object[])">
 <summary>
 Allows you to write in the console-output with custom colors, followed by the current line terminator
 </summary>
 <param name="format">The input string</param>
 <param name="args">Arguments</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Write(System.String,System.Object[])">
 <summary>
 Allows you to write in the console-output with custom colors
 </summary>
 <param name="format">The input string</param>
 <param name="args">Arguments</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Implode(Microsoft.VisualBasic.List{System.String},System.String,System.Int32)">
 <summary>
 (php-like) Implode function
 </summary>
 <param name="args">The list input</param>
 <param name="delimiter">Delimiter</param>
 <param name="start">Index offset</param>
 <returns>Imploded string</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Implode(Microsoft.VisualBasic.List{System.String},System.Int32)">
 <summary>
 (php-like) Implode a List of strings
 </summary>
 <param name="args">The list input</param>
 <param name="start">Index offset</param>
 <returns>Imploded string</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Wait(System.Int32)">
 <summary>
 Just wait. in milliseconds
 </summary>
 <param name="time"></param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.RestoreColors">
 <summary>
 Restore default colors
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Credits">
 <summary>
 Show credits
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ReadLine(System.Boolean)">
 <summary>
 Read the line, then parse it.
 </summary>
 <param name="ClearInput">Clear the buffer input</param>
 <returns>Return a List of strings</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ClearInput(System.Boolean)">
 <summary>
 Give back a ConsoleKeyInfo list
 </summary>
 <param name="Return"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ClearInput">
 <summary>
 Clear the user input in stack
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ParseLine(System.String)">
 <summary>
 Parse the input string
 </summary>
 <param name="s">Input string</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ReadKeys(System.Boolean)">
 <summary>
 Read EACH keys from the buffer input (visible and hidden chars)
 </summary>
 <param name="ClearInput">Clear the buffer input</param>
 <returns>string with all chars</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.getColor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
 <summary>
 Convert input to color
 </summary>
 <param name="s">Input string</param>
 <returns>👽👽👽👾</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Print(System.String)">
 <summary>
 The Parser
 </summary>
 <param name="input">Input string</param>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.xConsole.Comparer">
 <summary>
 This can compute the input then return back the most appropriate word.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Comparer.Word">
 <summary>
 This is the word to find
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Comparer.Description">
 <summary>
 Descrizione
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Comparer.Points">
 <summary>
 Init to 0!
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Comparer.#ctor(System.String,System.Int32)">
 <summary>
 Initliaze a new instance
 </summary>
 <param name="w">The word to find</param>
 <param name="p">It's should be 0</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Comparer.#ctor(System.String)">
 <summary>
 Initliaze a new instance
 </summary>
 <param name="w">The word to find</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Comparer.#ctor(System.String,System.String)">
 <summary>
 Initliaze a new instance
 </summary>
 <param name="w">The word to find</param>
 <param name="desc">Description (do nothing)</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Comparer.Find(System.String,Microsoft.VisualBasic.List{Microsoft.VisualBasic.Terminal.xConsole.Comparer}@)">
 <summary>
 Find a word from an input abbreviation (es n > name)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.xConsole.Spinner">
 <summary>
 A list of spinners for your console ❤
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Spinner.Spinners">
 <summary>
 List of available spinners (you can add new)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Spinner.inLoop">
 <summary>
 looplooplooplooplooplooplooplooplooploop[...]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.Spinner.SpinText">
 <summary>
 The base string for spinning. {0} will display the spinner. COLOR is SUPPORTED! 🆒
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Spinner.#ctor(System.Int32,System.String)">
 <summary>
 Initialize the spinner
 </summary>
 <param name="i">Index of the spinner to use</param>
 <param name="txt">Base string. `{0} show the spinner`</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Spinner.#ctor(System.Char[])">
 <summary>
 Initialize a custom spinner
 </summary>
 <param name="spinner">Set a custom spinner, no size limit.</param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Spinner.Break">
 <summary>
 Breaks the spinner
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.Spinner.Turn(System.Int32)">
 <summary>
 Turn the spin!
 </summary>
 <param name="time">Waiting time. Default 130 ms</param>
 <returns>False if it has been stopped</returns>
 <example>while(spinner.Turn());</example>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ListFonts">
 <summary>
 Show list of fonts
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.SetFont(System.UInt32)">
 <summary>
 Change console font
 </summary>
 <param name="i"></param>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.SetWindowPos(System.Int32,System.Int32)">
 <summary>
 Set new window position
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.MyASM">
 <summary>
 My ASM FILE
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.RDN">
 <summary>
 Random number Generator
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.FONT_COLOR">
 <summary>
 This value is used when restoring the colors of the console.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.BACKGROUND_COLOR">
 <summary>
 This value is used when restoring the colors of the console.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.NEW_LINE">
 <summary>
 Default line terminator
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.CheckForUpdatesEnabled">
 <summary>
 Check for updates every 7days. False to disable. (Default = true);
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.xConsole.ClearColorsAtEnd">
 <summary>
 Clear colors automatically at the end of each Writeline. (Default = false);
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ClosestConsoleColor(System.Byte,System.Byte,System.Byte)">
 <summary>
 Convert rgb color to ConsoleColor. From stackoverflow
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.RetrieveLinkerTimestamp">
 <summary>
 Linker Timestamp
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.xConsole.ConvertHexStringToByteArray(System.String)">
 <summary>
 Convert String to byte array
 </summary>
 <param name="hexString"></param>
 <returns></returns>
</member>
<member name="E:Microsoft.VisualBasic.Terminal.InteractiveDevice.NewOutputMessage">
 <summary>
 
 </summary>
 <param name="s"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.InteractiveDevice.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="HistoryFile">历史数据文件的存放位置，假若为空，则使用默认文件路径</param>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.InteractiveDevice.HistoryCallerStack">
 <summary>
 ReadLine函数的递归返回值
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.InteractiveDevice.Save(System.String,System.Text.Encoding)">
 <summary>
 保存历史数据
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.HistoryStacks.p">
 <summary>
 指向<see cref="F:Microsoft.VisualBasic.Terminal.HistoryStacks._historyList"></see>
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.Terminal">
 <summary>
 Represents the standard input, output, and error streams for console applications. 交互式的命令行终端
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Beep">
 <summary>
 Plays the sound of a beep through the console speaker.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.Security.HostProtectionException">System.Security.HostProtectionException: This method was executed on a server, such as SQL Server, that does not permit access to a user interface.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Beep(System.Int32,System.Int32)">
 <summary>
 Plays the sound of a beep of a specified frequency and duration through the console speaker.
 </summary>
 <param name="frequency">The frequency of the beep, ranging from 37 to 32767 hertz.</param>
 <param name="duration">The duration of the beep measured in milliseconds.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">frequency is less than 37 or more than 32767 hertz.-or-duration is less than or equal to zero.</exception>
 <exception cref="T:System.Security.HostProtectionException">This method was executed on a server, such as SQL Server, that does not permit access to the console.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Clear">
 <summary>
 Clears the console buffer and corresponding console window of display information.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Copies a specified source area of the screen buffer to a specified destination area.
 </summary>
 <param name="sourceLeft">The leftmost column of the source area.</param>
 <param name="sourceTop">The topmost row of the source area.</param>
 <param name="sourceWidth">The number of columns in the source area.</param>
 <param name="sourceHeight">The number of rows in the source area.</param>
 <param name="targetLeft">The leftmost column of the destination area.</param>
 <param name="targetTop">The topmost row of the destination area.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">One or more of the parameters is less than zero.-or- sourceLeft or targetLeft is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth is greater than or equal to System.Console.BufferWidth.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)">
 <summary>
 Copies a specified source area of the screen buffer to a specified destination area.
 </summary>
 <param name="sourceLeft">The leftmost column of the source area.</param>
 <param name="sourceTop">The topmost row of the source area.</param>
 <param name="sourceWidth">The number of columns in the source area.</param>
 <param name="sourceHeight">The number of rows in the source area.</param>
 <param name="targetLeft">The leftmost column of the destination area.</param>
 <param name="targetTop">The topmost row of the destination area.</param>
 <param name="sourceChar">The character used to fill the source area.</param>
 <param name="sourceForeColor">The foreground color used to fill the source area.</param>
 <param name="sourceBackColor">The background color used to fill the source area.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">One or more of the parameters is less than zero.-or- sourceLeft or targetLeft is greater than or equal to System.Console.BufferWidth.-or- sourceTop or targetTop is greater than or equal to System.Console.BufferHeight.-or- sourceTop + sourceHeight is greater than or equal to System.Console.BufferHeight.-or- sourceLeft + sourceWidth is greater than or equal to System.Console.BufferWidth.</exception>
 <exception cref="T:System.ArgumentException">One or both of the color parameters is not a member of the System.ConsoleColor enumeration.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.ResetColor">
 <summary>
 Sets the foreground and background console colors to their defaults.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetBufferSize(System.Int32,System.Int32)">
 <summary>
 Sets the height and width of the screen buffer area to the specified values.
 </summary>
 <param name="width">The width of the buffer area measured in columns.</param>
 <param name="height">The height of the buffer area measured in rows.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">height or width is less than or equal to zero.-or- height or width is greater than or equal to System.Int16.MaxValue.-or- width is less than System.Console.WindowLeft + System.Console.WindowWidth.-or- height is less than System.Console.WindowTop + System.Console.WindowHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetCursorPosition(System.Int32,System.Int32)">
 <summary>
 Sets the position of the cursor.
 </summary>
 <param name="left">The column position of the cursor.</param>
 <param name="top">The row position of the cursor.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">left or top is less than zero.-or- left is greater than or equal to System.Console.BufferWidth.-or- top is greater than or equal to System.Console.BufferHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetError(System.IO.TextWriter)">
 <summary>
 Sets the System.Console.Error property to the specified System.IO.TextWriter object.
 </summary>
 <param name="newError">A stream that is the new standard error output.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newError is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetIn(System.IO.TextReader)">
 <summary>
 Sets the System.Console.In property to the specified System.IO.TextReader object.
 </summary>
 <param name="newIn">A stream that is the new standard input.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newIn is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetOut(System.IO.TextWriter)">
 <summary>
 Sets the System.Console.Out property to the specified System.IO.TextWriter object.
 </summary>
 <param name="newOut">A stream that is the new standard output.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newOut is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetWindowPosition(System.Int32,System.Int32)">
 <summary>
 Sets the position of the console window relative to the screen buffer.
 </summary>
 <param name="left">The column position of the upper left corner of the console window.</param>
 <param name="top">The row position of the upper left corner of the console window.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">left or top is less than zero.-or- left + System.Console.WindowWidth is greater than System.Console.BufferWidth.-or- top + System.Console.WindowHeight is greater than System.Console.BufferHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.SetWindowSize(System.Int32,System.Int32)">
 <summary>
 Sets the height and width of the console window to the specified values.
 </summary>
 <param name="width">The width of the console window measured in columns.</param>
 <param name="height">The height of the console window measured in rows.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">width or height is less than or equal to zero.-or- width plus System.Console.WindowLeft or height plus System.Console.WindowTop is greater than or equal to System.Int16.MaxValue. -or-width or height is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Boolean)">
 <summary>
 Writes the text representation of the specified Boolean value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Char[])">
 <summary>
 Writes the specified array of Unicode characters to the standard output stream.
 </summary>
 <param name="buffer">A Unicode character array.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Char[],System.Int32,System.Int32)">
 <summary>
 Writes the specified subarray of Unicode characters to the standard output stream.
 </summary>
 <param name="buffer">An array of Unicode characters.</param>
 <param name="index">The starting position in buffer.</param>
 <param name="count">The number of characters to write.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">index or count is less than zero.</exception>
 <exception cref="T:System.ArgumentException">index plus count specify a position that is not within buffer.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Char)">
 <summary>
 Writes the specified Unicode character value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Decimal)">
 <summary>
 Writes the text representation of the specified System.Decimal value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Double)">
 <summary>
 Writes the text representation of the specified double-precision floating-point value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Int32)">
 <summary>
 Writes the text representation of the specified 32-bit signed integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Int64)">
 <summary>
 Writes the text representation of the specified 64-bit signed integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Object)">
 <summary>
 Writes the text representation of the specified object to the standard output stream.
 </summary>
 <param name="value">The value to write, or null.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.Single)">
 <summary>
 Writes the text representation of the specified single-precision floating-point value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.String)">
 <summary>
 Writes the specified string value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.String,System.Object)">
 <summary>
 Writes the text representation of the specified object to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">An object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.String,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.String,System.Object,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <param name="arg2">The third object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.String,System.Object[])">
 <summary>
 Writes the text representation of the specified array of objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg">An array of objects to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format or arg is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String,System.String[])">
 <summary>
 Writes the text representation of the specified array of objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="args">An array of objects to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format or arg is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.UInt32)">
 <summary>
 Writes the text representation of the specified 32-bit unsigned integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Write(System.UInt64)">
 <summary>
 Writes the text representation of the specified 64-bit unsigned integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine">
 <summary>
 Writes the current line terminator to the standard output stream.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Boolean)">
 <summary>
 Writes the text representation of the specified Boolean value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Char[])">
 <summary>
 Writes the specified array of Unicode characters, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="buffer">A Unicode character array.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Char[],System.Int32,System.Int32)">
 <summary>
 Writes the specified subarray of Unicode characters, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="buffer">An array of Unicode characters.</param>
 <param name="index">The starting position in buffer.</param>
 <param name="count">The number of characters to write.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">index or count is less than zero.</exception>
 <exception cref="T:System.ArgumentException">index plus count specify a position that is not within buffer.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Char)">
 <summary>
 Writes the specified Unicode character, followed by the current line terminator, value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Decimal)">
 <summary>
 Writes the text representation of the specified System.Decimal value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Double)">
 <summary>
 Writes the text representation of the specified double-precision floating-point value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Int32)">
 <summary>
 Writes the text representation of the specified 32-bit signed integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Int64)">
 <summary>
 Writes the text representation of the specified 64-bit signed integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Object)">
 <summary>
 Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.Single)">
 <summary>
 Writes the text representation of the specified single-precision floating-point value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String)">
 <summary>
 Writes the specified string value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String,System.Object)">
 <summary>
 Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">An object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String,System.Object,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <param name="arg2">The third object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.String,System.Object[])">
 <summary>
 Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg">An array of objects to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format or arg is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.UInt32)">
 <summary>
 Writes the text representation of the specified 32-bit unsigned integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.WriteLine(System.UInt64)">
 <summary>
 Writes the text representation of the specified 64-bit unsigned integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardError">
 <summary>
 Acquires the standard error stream.
 </summary>
 <returns>The standard error stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardError(System.Int32)">
 <summary>
 Acquires the standard error stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard error stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardInput">
 <summary>
 Acquires the standard input stream.
 </summary>
 <returns>The standard input stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardInput(System.Int32)">
 <summary>
 Acquires the standard input stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard input stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardOutput">
 <summary>
 Acquires the standard output stream.
 </summary>
 <returns>The standard output stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.OpenStandardOutput(System.Int32)">
 <summary>
 Acquires the standard output stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard output stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.Read">
 <summary>
 Reads the next character from the standard input stream.
 </summary>
 <returns>The next character from the input stream, or negative one (-1) if there are currently no more characters to be read.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.ReadKey">
 <summary>
 Obtains the next character or function key pressed by the user. The pressed key is displayed in the console window.
 </summary>
 <returns>A System.ConsoleKeyInfo object that describes the System.ConsoleKey constant and Unicode character, if any, that correspond to the pressed console key. The System.ConsoleKeyInfo object also describes, in a bitwise combination of System.ConsoleModifiers values, whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously with the console key.</returns>
 <remarks></remarks>
 <exception cref="T:System.InvalidOperationException">The System.Console.In property is redirected from some stream other than the console.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.ReadKey(System.Boolean)">
 <summary>
 Obtains the next character or function key pressed by the user. The pressed key is optionally displayed in the console window.
 </summary>
 <param name="intercept">Determines whether to display the pressed key in the console window. true to not display the pressed key; otherwise, false.</param>
 <returns>A System.ConsoleKeyInfo object that describes the System.ConsoleKey constant and Unicode character, if any, that correspond to the pressed console key. The System.ConsoleKeyInfo object also describes, in a bitwise combination of System.ConsoleModifiers values, whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously with the console key.</returns>
 <remarks></remarks>
 <exception cref="T:System.InvalidOperationException">The System.Console.In property is redirected from some stream other than the console.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.Terminal.ReadLine">
 <summary>
 Reads the next line of characters from the standard input stream.
 </summary>
 <returns>The next line of characters from the input stream, or null if no more lines are available.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.OutOfMemoryException">There is insufficient memory to allocate a buffer for the returned string.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">The number of characters in the next line of characters is greater than System.Int32.MaxValue.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.BackgroundColor">
 <summary>
 Gets or sets the background color of the console.
 </summary>
 <value></value>
 <returns>A System.ConsoleColor that specifies the background color of the console; that is, the color that appears behind each character. The default is black.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentException">The color specified in a set operation is not a valid Color.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.BufferHeight">
 <summary>
 Gets or sets the height of the buffer area.
 </summary>
 <value></value>
 <returns>The current height, in rows, of the buffer area.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than or equal to zero.-or- The value in a set operation is greater than or equal to System.Int16.MaxValue.-or- The value in a set operation is less than System.Console.WindowTop + System.Console.WindowHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.BufferWidth">
 <summary>
 Gets or sets the width of the buffer area.
 </summary>
 <value></value>
 <returns>The current width, in columns, of the buffer area.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than or equal to zero.-or- The value in a set operation is greater than or equal to System.Int16.MaxValue.-or- The value in a set operation is less than System.Console.WindowLeft + System.Console.WindowWidth.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.CapsLock">
 <summary>
 Gets a value indicating whether the CAPS LOCK keyboard toggle is turned on or turned off.
 </summary>
 <value></value>
 <returns>true if CAPS LOCK is turned on; false if CAPS LOCK is turned off.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.CursorLeft">
 <summary>
 Gets or sets the column position of the cursor within the buffer area.
 </summary>
 <value></value>
 <returns>The current position, in columns, of the cursor.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.-or- The value in a set operation is greater than or equal to System.Console.BufferWidth.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.CursorSize">
 <summary>
 Gets or sets the height of the cursor within a character cell.
 </summary>
 <value></value>
 <returns>The size of the cursor expressed as a percentage of the height of a character cell. The property value ranges from 1 to 100.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value specified in a set operation is less than 1 or greater than 100.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.CursorTop">
 <summary>
 Gets or sets the row position of the cursor within the buffer area.
 </summary>
 <value></value>
 <returns>The current position, in rows, of the cursor.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.-or- The value in a set operation is greater than or equal to System.Console.BufferHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.CursorVisible">
 <summary>
 Gets or sets a value indicating whether the cursor is visible.
 </summary>
 <value></value>
 <returns>true if the cursor is visible; otherwise, false.</returns>
 <remarks></remarks>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.Error">
 <summary>
 Gets the standard error output stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextWriter that represents the standard error output stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.ForegroundColor">
 <summary>
 Gets or sets the foreground color of the console.
 </summary>
 <value></value>
 <returns>A System.ConsoleColor that specifies the foreground color of the console; that is, the color of each character that is displayed. The default is gray.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentException">The color specified in a set operation is not a valid Color.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.In">
 <summary>
 Gets the standard input stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextReader that represents the standard input stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.InputEncoding">
 <summary>
 Gets or sets the encoding the console uses to read input.
 </summary>
 <value></value>
 <returns>The encoding used to read console input.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">The property value in a set operation is null.</exception>
 <exception cref="T:System.IO.IOException">An error occurred during the execution of this operation.</exception>
 <exception cref="T:System.Security.SecurityException">Your application does not have permission to perform this operation.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.IsErrorRedirected">
 <summary>
 Gets a value that indicates whether the error output stream has been redirected from the standard error stream.
 </summary>
 <value></value>
 <returns>true if error output is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.IsInputRedirected">
 <summary>
 Gets a value that indicates whether input has been redirected from the standard input stream.
 </summary>
 <value></value>
 <returns>true if input is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.IsOutputRedirected">
 <summary>
 Gets a value that indicates whether output has been redirected from the standard output stream.
 </summary>
 <value></value>
 <returns>true if output is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.KeyAvailable">
 <summary>
 Gets a value indicating whether a key press is available in the input stream.
 </summary>
 <value></value>
 <returns>true if a key press is available; otherwise, false.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.InvalidOperationException">Standard input is redirected to a file instead of the keyboard.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.LargestWindowHeight">
 <summary>
 Gets the largest possible number of console window rows, based on the current font and screen resolution.
 </summary>
 <value></value>
 <returns>The height of the largest possible console window measured in rows.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.LargestWindowWidth">
 <summary>
 Gets the largest possible number of console window columns, based on the current font and screen resolution.
 </summary>
 <value></value>
 <returns>The width of the largest possible console window measured in columns.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.NumberLock">
 <summary>
 Gets a value indicating whether the NUM LOCK keyboard toggle is turned on or turned off.
 </summary>
 <value></value>
 <returns>true if NUM LOCK is turned on; false if NUM LOCK is turned off.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.Out">
 <summary>
 Gets the standard output stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextWriter that represents the standard output stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.OutputEncoding">
 <summary>
 Gets or sets the encoding the console uses to write output.
 </summary>
 <value></value>
 <returns>The encoding used to write console output.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">The property value in a set operation is null.</exception>
 <exception cref="T:System.IO.IOException">An error occurred during the execution of this operation.</exception>
 <exception cref="T:System.Security.SecurityException">Your application does not have permission to perform this operation.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.Title">
 <summary>
 Gets or sets the title to display in the console title bar.
 </summary>
 <value></value>
 <returns>The string to be displayed in the title bar of the console. The maximum length of the title string is 24500 characters.</returns>
 <remarks></remarks>
 <exception cref="T:System.InvalidOperationException">In a get operation, the retrieved title is longer than 24500 characters.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">In a set operation, the specified title is longer than 24500 characters.</exception>
 <exception cref="T:System.ArgumentNullException">In a set operation, the specified title is null.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.TreatControlCAsInput">
 <summary>
 Gets or sets a value indicating whether the combination of the System.ConsoleModifiers.Control modifier key and System.ConsoleKey.C console key (Ctrl+C) is treated as ordinary input or as an interruption that is handled by the operating system.
 </summary>
 <value></value>
 <returns>true if Ctrl+C is treated as ordinary input; otherwise, false.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">Unable to get or set the input mode of the console input buffer.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.WindowHeight">
 <summary>
 Gets or sets the height of the console window area.
 </summary>
 <value></value>
 <returns>The height of the console window measured in rows.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is less than or equal to 0.-or-The value of the System.Console.WindowHeight property plus the value of the System.Console.WindowTop property is greater than or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.WindowLeft">
 <summary>
 Gets or sets the leftmost position of the console window area relative to the screen buffer.
 </summary>
 <value></value>
 <returns>The leftmost console window position measured in columns.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">In a set operation, the value to be assigned is less than zero.-or-As a result of the assignment, System.Console.WindowLeft plus System.Console.WindowWidth would exceed System.Console.BufferWidth.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.WindowTop">
 <summary>
 Gets or sets the top position of the console window area relative to the screen buffer.
 </summary>
 <value></value>
 <returns>The uppermost console window position measured in rows.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">In a set operation, the value to be assigned is less than zero.-or-As a result of the assignment, System.Console.WindowTop plus System.Console.WindowHeight would exceed System.Console.BufferHeight.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="P:Microsoft.VisualBasic.Terminal.Terminal.WindowWidth">
 <summary>
 Gets or sets the width of the console window.
 </summary>
 <value></value>
 <returns>The width of the console window measured in columns.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is less than or equal to 0.-or-The value of the System.Console.WindowHeight property plus the value of the System.Console.WindowTop property is greater than or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="E:Microsoft.VisualBasic.Terminal.Terminal.CancelKeyPress">
 <summary>
 Occurs when the System.ConsoleModifiers.Control modifier key (Ctrl) and either the System.ConsoleKey.C console key (C) or the Break key are pressed simultaneously (Ctrl+C or Ctrl+Break).
 </summary>
 <param name="sender"></param>
 <param name="e"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.Shell.AllocConsole">
 <summary>
 You can create a console window In a Windows Forms project.  Project + properties, turn off "Enable application framework" 
 And Set Startup Object To "Sub Main". 
 
 Modify the Application.Run() statement To create the proper startup form, If necessary.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.Shell.ShowConsoleWindows">
 <summary>
 为WinForm应用程序分配一个终端窗口，这个函数一般是在Debug模式之下进行程序调试所使用的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.Shell.Shell(System.String,System.Diagnostics.ProcessWindowStyle,System.Boolean)">
 <summary>
 
 </summary>
 <param name="CommandLine"></param>
 <param name="WindowStyle"></param>
 <param name="WaitForExit">If NOT, then the function returns the associated process id value. Else returns the process exit code.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.STDIO__.I_ConsoleDeviceHandle">
 <summary>
 Represents the standard input, output, and error streams for console applications.(表示一个输入输出流控制台界面接口)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.I_ConsoleDeviceHandle.WriteLine(System.String)">
 <summary>
 Writes the specified string value, followed by the current line terminator, to the standard output stream.
 (将指定的字符串值（后跟当前行终止符）写入输出流。)
 </summary>
 <param name="s"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.I_ConsoleDeviceHandle.WriteLine(System.String,System.String[])">
 <summary>
 Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information.
 (将指定的字符串值（后跟当前行终止符）写入输出流。)
 </summary>
 <param name="s"></param>
 <param name="args"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.I_ConsoleDeviceHandle.ReadLine">
 <summary>
 Reads the next line of characters from the standard input stream.(从输入流读取下一行字符)
 </summary>
 <returns>The next line of characters from the input stream, or null if no more lines are available.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.I_ConsoleDeviceHandle.Read">
 <summary>
 Reads the next character from the standard input stream.(从输入流读取下一个字符)
 </summary>
 <returns>The next character from the input stream, or negative one (-1) if there are currently no more characters to be read.</returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider">
 <summary>
 Provides C like format print
 </summary>
 <remarks>https://github.com/mlnlover11/SharpLua</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.IsPositive(System.Object,System.Boolean)">
 <summary>
 Determines whether the specified value is positive.
 </summary>
 <param name="Value">The value.</param>
 <param name="ZeroIsPositive">if set to true treats 0 as positive.</param>
 <returns>
 true if the specified value is positive; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.ToUnsigned(System.Object)">
 <summary>
 Converts the specified values boxed type to its correpsonding unsigned
 type.
 </summary>
 <param name="Value">The value.</param>
 <returns>A boxed numeric object whos type is unsigned.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.ToInteger(System.Object,System.Boolean)">
 <summary>
 Converts the specified values boxed type to its correpsonding integer
 type.
 </summary>
 <param name="Value">The value.</param>
 <returns>A boxed numeric object whos type is an integer type.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.ReplaceMetaChars(System.String)">
 <summary>
 Replaces the string representations of meta chars with their corresponding
 character values.
 </summary>
 <param name="input">The input.</param>
 <returns>A string with all string meta chars are replaced</returns>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.Formats">
 <summary>
 %[parameter][flags][width][.precision][length]type
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.sprintf(System.String,System.Object[])">
 <summary>
 Format string like C
 </summary>
 <param name="Format"></param>
 <param name="Parameters"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Terminal.STDIO">
 <summary>
 A standard input/output compatibility package that makes VisualBasic console
 program easily running on the Linux server or mac osx operating system.
 (一个用于让VisualBasic应用程序更加容易的运行于Linux服务器或者MAC系统之上的标准输入输出流的系统兼容包)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Terminal.STDIO.Eschs">
 <summary>
 A dictionary list of the escape characters.(转义字符列表)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.printf(System.String,System.Object[])">
 <summary>
 Output the string to the console using a specific formation.(按照指定的格式将字符串输出到终端窗口之上，请注意，这个函数除了将数据流输出到标准终端之外，还会输出到调试终端)
 </summary>
 <param name="s">A string to print on the console window.(输出到终端窗口之上的字符串)</param>
 <param name="args">Formation parameters.(格式化参数)</param>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.cat(System.String[])">
 <summary>
 不换行
 </summary>
 <param name="out"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.scanf(System.String@,System.ConsoleColor)">
 <summary>
 Read the string that user input on the console to the function paramenter.
 (将用户在终端窗口之上输入的数据赋值给一个字符串变量)
 </summary>
 <param name="s"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.ZeroFill(System.String,System.Int32)">
 <summary>
 Fill the number string with specific length of ZERO sequence to generates the fixed width string.
 </summary>
 <param name="sn"></param>
 <param name="len"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.MsgBox(System.String,Microsoft.VisualBasic.MsgBoxStyle)">
 <summary>

 </summary>
 <param name="prompt"></param>
 <param name="style">
 Value just allow:
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.AbortRetryIgnore"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.OkCancel"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.OkOnly"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.RetryCancel"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.YesNo"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.YesNoCancel"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Terminal.STDIO.__testEquals(System.String,System.Char)">
 <summary>

 </summary>
 <param name="input"></param>
 <param name="compare">大写的</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValuExtension`1.InvokeSet(System.String,System.Object)">
 <summary>
 
 </summary>
 <param name="name">Using NameOf</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.SetValue`1">
 <summary>
 Set value linq expression helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.GetSet(System.String)">
 <summary>
 Public Delegate Function IInvokeSetValue(x As T, value As Object) As T
 </summary>
 <param name="name">Using NameOf</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.op_LessThanOrEqual(Microsoft.VisualBasic.Linq.SetValue{`0},System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Linq.SetValue`1.GetSet(System.String)"/>
 </summary>
 <param name="setValue"></param>
 <param name="name">Using NameOf</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.InvokeSetValue(`0,System.String,System.Object)">
 <summary>
 Assigning the value to the specific named property to the target object.
 (将<paramref name="value"/>参数之中的值赋值给目标对象<paramref name="x"/>之中的指定的<paramref name="name"/>属性名称的属性，
 如果发生错误，则原有的对象<paramref name="x"/>不会被修改)
 </summary>
 <param name="x"></param>
 <param name="name">Using NameOf.(可以使用NameOf得到需要进行修改的属性名称)</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.InvokeSet``1(`0@,System.String,``0)">
 <summary>
 Assigning the value to the specific named property to the target object.
 (将<paramref name="value"/>参数之中的值赋值给目标对象<paramref name="obj"/>之中的指定的<paramref name="name"/>属性名称的属性，
 如果发生错误，则原有的对象<paramref name="obj"/>不会被修改)
 </summary>
 <typeparam name="Tvalue"></typeparam>
 <param name="obj"></param>
 <param name="Name">可以使用NameOf得到需要进行修改的属性名称</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.IteratorExtensions.SeqIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Iterates all of the objects in the source sequence with collection index position.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">the source sequence</param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Linq.SeqValue`1.i">
 <summary>
 The position of this object value in the original sequence.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Linq.SeqValue`1.obj">
 <summary>
 The Object data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.IIterator`1">
 <summary>
 Exposes the enumerator, which supports a simple iteration over a collection of
 a specified type.To browse the .NET Framework source code for this type, see
 the Reference Source.
 (使用这个的原因是系统自带的<see cref="T:System.Collections.Generic.IEnumerable`1"/>在Xml序列化之中的支持不太好)
 </summary>
 <typeparam name="T">The type of objects to enumerate.This type parameter is covariant. That is, you
 can use either the type you specified or any type that is more derived. For more
 information about covariance and contravariance, see Covariance and Contravariance
 in Generics.</typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Linq.IIterator`1.GetEnumerator">
 <summary>
 Returns an enumerator that iterates through the collection.
 </summary>
 <returns>An enumerator that can be used to iterate through the collection.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.IIterator`1.IGetEnumerator">
 <summary>
 Returns an enumerator that iterates through a collection.
 </summary>
 <returns>An System.Collections.IEnumerator object that can be used to iterate through
 the collection.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.Extensions">
 <summary>
 Linq Helpers.(为了方便编写Linq代码而构建的一个拓展模块)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.SafeQuery``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 A query proxy function makes your linq not so easily crashed due to the unexpected null reference collection as linq source.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.MaxInd``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the max element its index in the collection
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Removes``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="match">符合这个条件的所有的元素都将会被移除</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.MatrixAsIterator``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Iterates all of the elements in a two dimension collection as the data source for the linq expression or ForEach statement.
 (适用于二维的集合做为linq的数据源，不像<see cref="M:Microsoft.VisualBasic.Extensions.MatrixToList``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>是进行转换，这个是返回迭代器的，推荐使用这个函数)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.RemoveLeft``2(System.Collections.Generic.Dictionary{``0,``1}@,``0)">
 <summary>
 删除制定的键之后返回剩下的数据
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source"></param>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.CopyVector``1(``0,System.Int32)">
 <summary>
 Copy <paramref name="source"/> <paramref name="n"/> times to construct a new vector.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="n"></param>
 <returns>An array consist of source with n elements.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Read``1(``0[],System.Int32@)">
 <summary>
 Read source at element position <paramref name="i"/> and returns its value, 
 and then this function makes position <paramref name="i"/> offset +1
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.Int32)">
 <summary>
 产生指定数目的一个递增序列(所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <param name="n">大于或者等于0的一个数，当小于0的时候会出错</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.Int64)">
 <summary>
 产生指定数目的一个递增序列(所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.UInt32)">
 <summary>
 产生指定数目的一个递增序列(所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``1(System.Int32,System.Func{System.Int32,``0})">
 <summary>
 (所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="len"></param>
 <param name="elementAt"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Boolean)">
 <summary>
 Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 (默认非并行化的，这个函数是安全的，假若参数为空值则会返回一个空的数组)
 </summary>
 <typeparam name="T">The type of the elements of source.</typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="source">An System.Collections.Generic.IEnumerable`1 to create an array from.</param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Boolean)">
 <summary>
 Creates an array from a System.Collections.Generic.IEnumerable`1.(默认非并行化的，这个函数是安全的，假若参数为空值则会返回一个空的数组)
 </summary>
 <typeparam name="T">The type of the elements of source.</typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="source">An System.Collections.Generic.IEnumerable`1 to create an array from.</param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1},System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="source"></param>
 <param name="__ctype">第二个参数是index</param>
 <param name="Parallel"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Debugging.DebuggerLevels">
 <summary>
 默认的参数值是<see cref="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.On"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.On">
 <summary>
 是否输出调试信息有程序代码来控制，这个是默认的参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.Off">
 <summary>
 不会输出任务调试信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.All">
 <summary>
 强制覆盖掉<see cref="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.On"/>的设置，输出所有类型的信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.Warning">
 <summary>
 只会输出警告或者错误类型的信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerLevels.Error">
 <summary>
 只会输出错误类型的信息
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Debugging.DebuggerArgs">
 <summary>
 调试器设置参数模块
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Debugging.DebuggerArgs.ErrLogs">
 <summary>
 错误日志的文件存储位置，默认是在AppData里面
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Debugging.DebuggerArgs.SaveErrorLog(System.String)">
 <summary>
 
 </summary>
 <param name="log">日志文本</param>
</member>
<member name="M:Microsoft.VisualBasic.Debugging.DebuggerArgs.__logShell(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Logging command shell history.
 </summary>
 <param name="args"></param>
</member>
<member name="F:Microsoft.VisualBasic.Debugging.DebuggerArgs.DebuggerHelps">
 <summary>
 Some optional VisualBasic debugger parameter help information.(VisualBasic调试器的一些额外的开关参数的帮助信息)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Debugging.DebuggerArgs.InitDebuggerEnvir(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Initialize the global environment variables in this App process.
 </summary>
 <param name="args">--echo on/off/all/warn/error --err &lt;path.log></param>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Includes">
 <summary>
 File includes search tools
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Includes.Add(System.String)">
 <summary>
 Add includes directory into the search path.
 </summary>
 <param name="DIR"></param>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Includes.GetPath(System.String)">
 <summary>
 Get the absolutely file path from the includes file's relative path.
 </summary>
 <param name="relPath"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.HardLink">
 <summary>
 Provides access to NTFS hard links in .Net.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint">
 <summary>
 Provides access to NTFS junction points in .Net.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_NOT_A_REPARSE_POINT">
 <summary>
 The file or directory is not a reparse point.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_ATTRIBUTE_CONFLICT">
 <summary>
 The reparse point attribute cannot be set because it conflicts with an existing attribute.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_INVALID_REPARSE_DATA">
 <summary>
 The data present in the reparse point buffer is invalid.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_TAG_INVALID">
 <summary>
 The tag present in the reparse point buffer is invalid.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_TAG_MISMATCH">
 <summary>
 There is a mismatch between the tag specified in the request and the tag present in the reparse point.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_SET_REPARSE_POINT">
 <summary>
 Command to set the reparse point data block.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_GET_REPARSE_POINT">
 <summary>
 Command to get the reparse point data block.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_DELETE_REPARSE_POINT">
 <summary>
 Command to delete the reparse point data base.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.IO_REPARSE_TAG_MOUNT_POINT">
 <summary>
 Reparse point tag used to identify mount points and junction points.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.NonInterpretedPathPrefix">
 <summary>
 This prefix indicates to NTFS that the path is to be treated as a non-interpreted
 path in the virtual file system.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.ReparseTag">
 <summary>
 Reparse point tag. Must be a Microsoft reparse point tag.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.ReparseDataLength">
 <summary>
 Size, in bytes, of the data after the Reserved member. This can be calculated by:
 (4 * sizeof(ushort)) + SubstituteNameLength + PrintNameLength +
 (namesAreNullTerminated ? 2 * sizeof(char) : 0);
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.Reserved">
 <summary>
 Reserved; do not use.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.SubstituteNameOffset">
 <summary>
 Offset, in bytes, of the substitute name string in the PathBuffer array.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.SubstituteNameLength">
 <summary>
 Length, in bytes, of the substitute name string. If this string is null-terminated,
 SubstituteNameLength does not include space for the null character.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PrintNameOffset">
 <summary>
 Offset, in bytes, of the print name string in the PathBuffer array.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PrintNameLength">
 <summary>
 Length, in bytes, of the print name string. If this string is null-terminated,
 PrintNameLength does not include space for the null character.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PathBuffer">
 <summary>
 A buffer containing the unicode-encoded path string. The path string contains
 the substitute name string and print name string.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Create(System.String,System.String,System.Boolean)">
 <summary>
 Creates a junction point from the specified directory to the specified target directory.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
 <param name="targetDir">The target directory</param>
 <param name="overwrite">If true overwrites an existing reparse point or empty directory</param>
 <exception cref="T:System.IO.IOException">Thrown when the junction point could not be created or when
 an existing directory was found and <paramref name="overwrite" /> if false</exception>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Delete(System.String)">
 <summary>
 Deletes a junction point at the specified source directory along with the directory itself.
 Does nothing if the junction point does not exist.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Exists(System.String)">
 <summary>
 Determines whether the specified path exists and refers to a junction point.
 </summary>
 <param name="path">The junction point path</param>
 <returns>True if the specified path represents a junction point</returns>
 <exception cref="T:System.IO.IOException">Thrown if the specified path is invalid
 or some other error occurs</exception>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.GetTarget(System.String)">
 <summary>
 Gets the target of the specified junction point.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
 <returns>The target of the junction point</returns>
 <exception cref="T:System.IO.IOException">Thrown when the specified path does not
 exist, is invalid, is not a junction point, or some other error occurs</exception>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink">
 <summary>
 
 </summary>
 <remarks>https://github.com/amd989/Symlinker</remarks>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink.shareModeAll">
 <summary>
 Read, Write, Delete
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink.symLinkTag">
 <summary>
 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Directory">
 <summary>
 A wrapper object for the processing of relative file path. 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.#ctor(System.String)">
 <summary>
 Construct a directory object from the specific Dir path value.
 </summary>
 <param name="DIR">Target directory path</param>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.GetFullPath(System.String)">
 <summary>
 Gets the full path of the target file based on the path relative to this directory object.
 </summary>
 <param name="file">
 The relative path of the target file, and this parameter is also compatible with absolute file path.
 (相对路径)</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.IsAbsolutePath(System.String)">
 <summary>
 Determined that the input file path is a absolute path or not?
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.CreateDirectory(System.String)">
 <summary>
 Creates a directory.
 </summary>
 <param name="junctionPoint">Name and location of the directory.</param>
 <remarks>
 Exceptions:
   T:System.ArgumentException:
     The directory name is malformed. For example, it contains illegal characters
     or is only white space.

   T:System.ArgumentNullException:
     directory is Nothing or an empty string.

   T:System.IO.PathTooLongException:
     The directory name is too long.

   T:System.NotSupportedException:
     The directory name is only a colon (:).

   T:System.IO.IOException:
     The parent directory of the directory to be created is read-only

   T:System.UnauthorizedAccessException:
     The user does not have permission to create the directory.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.NetFile.MapNetFile(System.String)">
 <summary>
 将网络文件映射为本地文件，这个可以同时兼容http或者本地文件路径
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.NetFile.GetMapPath(System.String)">
 <summary>
 网络文件转换为本地文件路径
 </summary>
 <param name="url"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.JavaMath">
 <summary>
 The class {@code Math} contains methods for performing basic
 numeric operations such as the elementary exponential, logarithm,
 square root, and trigonometric functions.
 
 Unlike some of the numeric methods of class
 {@code StrictMath}, all implementations of the equivalent
 functions of class {@code Math} are not defined to return the
 bit-for-bit same results.  This relaxation permits
 better-performing implementations where strict reproducibility is
 not required.
 
 By default many of the {@code Math} methods simply call
 the equivalent method in {@code StrictMath} for their
 implementation.  Code generators are encouraged to use
 platform-specific native libraries or microprocessor instructions,
 where available, to provide higher-performance implementations of
 {@code Math} methods.  Such higher-performance
 implementations still must conform to the specification for
 {@code Math}.
 
 The quality of implementation specifications concern two
 properties, accuracy of the returned result and monotonicity of the
 method.  Accuracy of the floating-point {@code Math} methods is
 measured in terms of _ulps_, units in the last place.  For a
 given floating-point format, an #ulp(double) ulp of a
 specific real number value is the distance between the two
 floating-point values bracketing that numerical value.  When
 discussing the accuracy of a method as a whole rather than at a
 specific argument, the number of ulps cited is for the worst-case
 error at any argument.  If a method always has an error less than
 0.5 ulps, the method always returns the floating-point number
 nearest the exact result; such a method is _correctly
 rounded_.  A correctly rounded method is generally the best a
 floating-point approximation can be; however, it is impractical for
 many floating-point methods to be correctly rounded.  Instead, for
 the {@code Math} [Class], a larger error bound of 1 or 2 ulps is
 allowed for certain methods.  Informally, with a 1 ulp error bound,
 when the exact result is a representable number, the exact result
 should be returned as the computed result; otherwise, either of the
 two floating-point values which bracket the exact result may be
 returned.  For exact results large in magnitude, one of the
 endpoints of the bracket may be infinite.  Besides accuracy at
 individual arguments, maintaining proper relations between the
 method at different arguments is also important.  Therefore, most
 methods with more than 0.5 ulp errors are required to be
 _semi-monotonic_: whenever the mathematical function is
 non-decreasing, so is the floating-point approximation, likewise,
 whenever the mathematical function is non-increasing, so is the
 floating-point approximation.  Not all approximations that have 1
 ulp accuracy will automatically meet the monotonicity requirements.
 
 
 The platform uses signed two's complement integer arithmetic with
 int and long primitive types.  The developer should choose
 the primitive type to ensure that arithmetic operations consistently
 produce correct results, which in some cases means the operations
 will not overflow the range of values of the computation.
 The best practice is to choose the primitive type and algorithm to avoid
 overflow. In cases where the size is {@code int} or {@code long} and
 overflow errors need to be detected, the methods {@code addExact},
 {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
 throw an {@code ArithmeticException} when the results overflow.
 For other arithmetic operations such as divide, absolute value,
 increment, decrement, and negation overflow occurs only with
 a specific minimum or maximum value and should be checked against
 the minimum or maximum as appropriate.
 
 @author  unascribed
 @author  Joseph D. Darcy
 @since   JDK1.0
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.JavaMath.E">
 <summary>
 The {@code double} value that is closer than any other to
 _e_, the base of the natural logarithms.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.JavaMath.PI">
 <summary>
 The {@code double} value that is closer than any other to
 _pi_, the ratio of the circumference of a circle to its
 diameter.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sin(System.Double)">
 <summary>
 Returns the trigonometric sine of an angle.  Special cases:
 + If the argument is NaN or an infinity, then the
 result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the sine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.cos(System.Double)">
 <summary>
 Returns the trigonometric cosine of an angle. Special cases:
 + If the argument is NaN or an infinity, then the
 result is NaN.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the cosine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.tan(System.Double)">
 <summary>
 Returns the trigonometric tangent of an angle.  Special cases:
 + If the argument is NaN or an infinity, then the result
 is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the tangent of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.asin(System.Double)">
 <summary>
 Returns the arc sine of a value; the returned angle is in the
 range -_pi_/2 through _pi_/2.  Special cases:
 + If the argument is NaN or its absolute value is greater
 than 1, then the result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc sine is to be returned. </param>
 <returns>  the arc sine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.acos(System.Double)">
 <summary>
 Returns the arc cosine of a value; the returned angle is in the
 range 0.0 through _pi_.  Special case:
 + If the argument is NaN or its absolute value is greater
 than 1, then the result is NaN.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc cosine is to be returned. </param>
 <returns>  the arc cosine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.atan(System.Double)">
 <summary>
 Returns the arc tangent of a value; the returned angle is in the
 range -_pi_/2 through _pi_/2.  Special cases:
 + If the argument is NaN, then the result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc tangent is to be returned. </param>
 <returns>  the arc tangent of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toRadians(System.Double)">
 <summary>
 Converts an angle measured in degrees to an approximately
 equivalent angle measured in radians.  The conversion from
 degrees to radians is generally inexact.
 </summary>
 <param name="angdeg">   an angle, in degrees </param>
 <returns>  the measurement of the angle {@code angdeg}
          in radians.
 @since   1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toDegrees(System.Double)">
 <summary>
 Converts an angle measured in radians to an approximately
 equivalent angle measured in degrees.  The conversion from
 radians to degrees is generally inexact; users should
 _not_ expect {@code cos(toRadians(90.0))} to exactly
 equal {@code 0.0}.
 </summary>
 <param name="angrad">   an angle, in radians </param>
 <returns>  the measurement of the angle {@code angrad}
          in degrees.
 @since   1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.exp(System.Double)">
 <summary>
 Returns Euler's number _e_ raised to the power of a
 {@code double} value.  Special cases:
 + If the argument is NaN, the result is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is negative infinity, then the result is
 positive zero.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the exponent to raise _e_ to. </param>
 <returns>  the value _e_{@code a},
          where _e_ is the base of the natural logarithms. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log(System.Double)">
 <summary>
 Returns the natural logarithm (base _e_) of a {@code double}
 value.  Special cases:
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is positive zero or negative zero, then the
 result is negative infinity.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   a value </param>
 <returns>  the value ln {@code a}, the natural logarithm of
          {@code a}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log10(System.Double)">
 <summary>
 Returns the base 10 logarithm of a {@code double} value.
 Special cases:
 
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is positive zero or negative zero, then the
 result is negative infinity.
 +  If the argument is equal to 10<sup>_n_</sup> for
 integer _n_, then the result is _n_.
 
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   a value </param>
 <returns>  the base 10 logarithm of  {@code a}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sqrt(System.Double)">
 <summary>
 Returns the correctly rounded positive square root of a
 {@code double} value.
 Special cases:
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is positive
 infinity.
 + If the argument is positive zero or negative zero, then the
 result is the same as the argument.
 Otherwise, the result is the {@code double} value closest to
 the true mathematical square root of the argument value.
 </summary>
 <param name="a">   a value. </param>
 <returns>  the positive square root of {@code a}.
          If the argument is NaN or less than zero, the result is NaN. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.IEEEremainder(System.Double,System.Double)">
 <summary>
 Computes the remainder operation on two arguments as prescribed
 by the IEEE 754 standard.
 The remainder value is mathematically equal to
 ``f1 - f2`` x _n_,
 where _n_ is the mathematical integer closest to the exact
 mathematical value of the quotient {@code f1/f2}, and if two
 mathematical integers are equally close to {@code f1/f2},
 then _n_ is the integer that is even. If the remainder is
 zero, its sign is the same as the sign of the first argument.
 Special cases:
 + If either argument is NaN, or the first argument is infinite,
 or the second argument is positive zero or negative zero, then the
 result is NaN.
 + If the first argument is finite and the second argument is
 infinite, then the result is the same as the first argument.
 </summary>
 <param name="f1">   the dividend. </param>
 <param name="f2">   the divisor. </param>
 <returns>  the remainder when {@code f1} is divided by
          {@code f2}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.ceil(System.Double)">
 <summary>
 Returns the smallest (closest to negative infinity)
 {@code double} value that is greater than or equal to the
 argument and is equal to a mathematical  java.lang.[Integer]. Special cases:
 + If the argument value is already equal to a
 mathematical integer, then the result is the same as the
 argument.  + If the argument is NaN or an infinity or
 positive zero or negative zero, then the result is the same as
 the argument.  + If the argument value is less than zero but
 greater than -1.0, then the result is negative zero. Note
 that the value of {@code Math.ceil(x)} is exactly the
 value of {@code -Math.floor(-x)}.
 
 </summary>
 <param name="a">   a value. </param>
 <returns>  the smallest (closest to negative infinity)
          floating-point value that is greater than or equal to
          the argument and is equal to a mathematical  java.lang.[Integer]. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floor(System.Double)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code double} value that is less than or equal to the
 argument and is equal to a mathematical  java.lang.[Integer]. Special cases:
 + If the argument value is already equal to a
 mathematical integer, then the result is the same as the
 argument.  + If the argument is NaN or an infinity or
 positive zero or negative zero, then the result is the same as
 the argument.
 </summary>
 <param name="a">   a value. </param>
 <returns>  the largest (closest to positive infinity)
          floating-point value that less than or equal to the argument
          and is equal to a mathematical  java.lang.[Integer]. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.atan2(System.Double,System.Double)">
 <summary>
 Returns the angle _theta_ from the conversion of rectangular
 coordinates ({@code x}, {@code y}) to polar
 coordinates (r, _theta_).
 This method computes the phase _theta_ by computing an arc tangent
 of {@code y/x} in the range of -_pi_ to _pi_. Special
 cases:
 + If either argument is NaN, then the result is NaN.
 + If the first argument is positive zero and the second argument
 is positive, or the first argument is positive and finite and the
 second argument is positive infinity, then the result is positive
 zero.
 + If the first argument is negative zero and the second argument
 is positive, or the first argument is negative and finite and the
 second argument is positive infinity, then the result is negative zero.
 + If the first argument is positive zero and the second argument
 is negative, or the first argument is positive and finite and the
 second argument is negative infinity, then the result is the
 {@code double} value closest to _pi_.
 + If the first argument is negative zero and the second argument
 is negative, or the first argument is negative and finite and the
 second argument is negative infinity, then the result is the
 {@code double} value closest to -_pi_.
 + If the first argument is positive and the second argument is
 positive zero or negative zero, or the first argument is positive
 infinity and the second argument is finite, then the result is the
 {@code double} value closest to _pi_/2.
 + If the first argument is negative and the second argument is
 positive zero or negative zero, or the first argument is negative
 infinity and the second argument is finite, then the result is the
 {@code double} value closest to -_pi_/2.
 + If both arguments are positive infinity, then the result is the
 {@code double} value closest to _pi_/4.
 + If the first argument is positive infinity and the second argument
 is negative infinity, then the result is the {@code double}
 value closest to 3*_pi_/4.
 + If the first argument is negative infinity and the second argument
 is positive infinity, then the result is the {@code double} value
 closest to -_pi_/4.
 + If both arguments are negative infinity, then the result is the
 {@code double} value closest to -3*_pi_/4.
 
 The computed result must be within 2 ulps of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="y">   the ordinate coordinate </param>
 <param name="x">   the abscissa coordinate </param>
 <returns>  the _theta_ component of the point
          (_r_, _theta_)
          in polar coordinates that corresponds to the point
          (_x_, _y_) in Cartesian coordinates. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.pow(System.Double,System.Double)">
 <summary>
 Returns the value of the first argument raised to the power of the
 second argument. Special cases:
 
 + If the second argument is positive or negative zero, then the
 result is 1.0.
 + If the second argument is 1.0, then the result is the same as the
 first argument.
 + If the second argument is NaN, then the result is NaN.
 + If the first argument is NaN and the second argument is nonzero,
 then the result is NaN.
 
 + If
 
 + the absolute value of the first argument is greater than 1
 and the second argument is positive infinity, or
 + the absolute value of the first argument is less than 1 and
 the second argument is negative infinity,
 
 then the result is positive infinity.
 
 + If
 
 + the absolute value of the first argument is greater than 1 and
 the second argument is negative infinity, or
 + the absolute value of the
 first argument is less than 1 and the second argument is positive
 infinity,
 
 then the result is positive zero.
 
 + If the absolute value of the first argument equals 1 and the
 second argument is infinite, then the result is NaN.
 
 + If
 
 + the first argument is positive zero and the second argument
 is greater than zero, or
 + the first argument is positive infinity and the second
 argument is less than zero,
 
 then the result is positive zero.
 
 + If
 
 + the first argument is positive zero and the second argument
 is less than zero, or
 + the first argument is positive infinity and the second
 argument is greater than zero,
 
 then the result is positive infinity.
 
 + If
 
 + the first argument is negative zero and the second argument
 is greater than zero but not a finite odd integer, or
 + the first argument is negative infinity and the second
 argument is less than zero but not a finite odd integer,
 
 then the result is positive zero.
 
 + If
 
 + the first argument is negative zero and the second argument
 is a positive finite odd integer, or
 + the first argument is negative infinity and the second
 argument is a negative finite odd integer,
 
 then the result is negative zero.
 
 + If
 
 + the first argument is negative zero and the second argument
 is less than zero but not a finite odd integer, or
 + the first argument is negative infinity and the second
 argument is greater than zero but not a finite odd integer,
 
 then the result is positive infinity.
 
 + If
 
 + the first argument is negative zero and the second argument
 is a negative finite odd integer, or
 + the first argument is negative infinity and the second
 argument is a positive finite odd integer,
 
 then the result is negative infinity.
 
 + If the first argument is finite and less than zero
 
 +  if the second argument is a finite even integer, the
 result is equal to the result of raising the absolute value of
 the first argument to the power of the second argument
 
 + if the second argument is a finite odd integer, the result
 is equal to the negative of the result of raising the absolute
 value of the first argument to the power of the second
 argument
 
 + if the second argument is finite and not an integer, then
 the result is NaN.
 
 
 + If both arguments are integers, then the result is exactly equal
 to the mathematical result of raising the first argument to the power
 of the second argument if that result can in fact be represented
 exactly as a {@code double} value.
 
 (In the foregoing descriptions, a floating-point value is
 considered to be an integer if and only if it is finite and a
 fixed point of the method #ceil ceil or,
 equivalently, a fixed point of the method {@link #floor
 floor}. A value is a fixed point of a one-argument
 method if and only if the result of applying the method to the
 value is equal to the value.)
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the base. </param>
 <param name="b">   the exponent. </param>
 <returns>  the value {@code a}<sup>{@code b}</sup>. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.random">
 <summary>
 Returns a {@code double} value with a positive sign, greater
 than or equal to {@code 0.0} and less than {@code 1.0}.
 Returned values are chosen pseudorandomly with (approximately)
 uniform distribution from that range.
 
 When this method is first called, it creates a single new
 pseudorandom-number generator, exactly as if by the expression
 
 <blockquote>{@code new java.util.Random()}</blockquote>
 
 This new pseudorandom-number generator is used thereafter for
 all calls to this method and is used nowhere else.
 
 This method is properly synchronized to allow correct use by
 more than one thread. However, if many threads need to generate
 pseudorandom numbers at a great rate, it may reduce contention
 for each thread to have its own pseudorandom-number generator.
 </summary>
 <returns>  a pseudorandom {@code double} greater than or equal
 to {@code 0.0} and less than {@code 1.0}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.addExact(System.Int32,System.Int32)">
 <summary>
 Returns the sum of its arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.addExact(System.Int64,System.Int64)">
 <summary>
 Returns the sum of its arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.subtractExact(System.Int32,System.Int32)">
 <summary>
 Returns the difference of the arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value to subtract from the first </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.subtractExact(System.Int64,System.Int64)">
 <summary>
 Returns the difference of the arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value to subtract from the first </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.multiplyExact(System.Int32,System.Int32)">
 <summary>
 Returns the product of the arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.multiplyExact(System.Int64,System.Int64)">
 <summary>
 Returns the product of the arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.incrementExact(System.Int32)">
 <summary>
 Returns the argument incremented by one, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to increment </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.incrementExact(System.Int64)">
 <summary>
 Returns the argument incremented by one, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to increment </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.decrementExact(System.Int32)">
 <summary>
 Returns the argument decremented by one, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to decrement </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.decrementExact(System.Int64)">
 <summary>
 Returns the argument decremented by one, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to decrement </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.negateExact(System.Int32)">
 <summary>
 Returns the negation of the argument, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to negate </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.negateExact(System.Int64)">
 <summary>
 Returns the negation of the argument, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to negate </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toIntExact(System.Int64)">
 <summary>
 Returns the value of the {@code long} argument;
 throwing an exception if the value overflows an {@code int}.
 </summary>
 <param name="value"> the long value </param>
 <returns> the argument as an int </returns>
 <exception cref="T:System.ArithmeticException"> if the {@code argument} overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorDiv(System.Int32,System.Int32)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code int} value that is less than or equal to the algebraic quotient.
 There is one special case, if the dividend is the
  Integer#MIN_VALUE  java.lang.[Integer].MIN_VALUE"/> and the divisor is {@code -1},
 then integer overflow occurs and
 the result is equal to the {@code  java.lang.[Integer].MIN_VALUE}.
 
 Normal integer division operates under the round to zero rounding mode
 (truncation).  This operation instead acts under the round toward
 negative infinity (floor) rounding mode.
 The floor rounding mode gives different results than truncation
 when the exact result is negative.
 
   + If the signs of the arguments are the same, the results of
       {@code floorDiv} and the {@code /} operator are the same.  
       For example, {@code floorDiv(4, 3) == 1} and {@code (4 / 3) == 1}.
   + If the signs of the arguments are different,  the quotient is negative and
       {@code floorDiv} returns the integer less than or equal to the quotient
       and the {@code /} operator returns the integer closest to zero.
       For example, {@code floorDiv(-4, 3) == -2},
       whereas {@code (-4 / 3) == -1}.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the largest (closest to positive infinity)
 {@code int} value that is less than or equal to the algebraic quotient. </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorDiv(System.Int64,System.Int64)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code long} value that is less than or equal to the algebraic quotient.
 There is one special case, if the dividend is the
  Long#MIN_VALUE java.lang.[Long].MIN_VALUE"/> and the divisor is {@code -1},
 then integer overflow occurs and
 the result is equal to the {@code java.lang.[Long].MIN_VALUE}.
 
 Normal integer division operates under the round to zero rounding mode
 (truncation).  This operation instead acts under the round toward
 negative infinity (floor) rounding mode.
 The floor rounding mode gives different results than truncation
 when the exact result is negative.
 
 For examples, see  #floorDiv(int, int)"/>.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the largest (closest to positive infinity)
 {@code long} value that is less than or equal to the algebraic quotient. </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorMod(System.Int32,System.Int32)">
 <summary>
 Returns the floor modulus of the {@code int} arguments.
 
 The floor modulus is {@code x - (floorDiv(x, y) * y)},
 has the same sign as the divisor {@code y}, and
 is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 
 
 The relationship between {@code floorDiv} and {@code floorMod} is such that:
 
   + {@code floorDiv(x, y) * y + floorMod(x, y) == x}
 
 
 The difference in values between {@code floorMod} and
 the {@code %} operator is due to the difference between
 {@code floorDiv} that returns the integer less than or equal to the quotient
 and the {@code /} operator that returns the integer closest to zero.
 
 Examples:
 
   + If the signs of the arguments are the same, the results
       of {@code floorMod} and the {@code %} operator are the same.   
       
       + {@code floorMod(4, 3) == 1};   and {@code (4 % 3) == 1} 
       
   + If the signs of the arguments are different, the results differ from the {@code %} operator. 
      
      + {@code floorMod(+4, -3) == -2};   and {@code (+4 % -3) == +1}  
      + {@code floorMod(-4, +3) == +2};   and {@code (-4 % +3) == -1}  
      + {@code floorMod(-4, -3) == -1};   and {@code (-4 % -3) == -1 }  
      
    
 
 
 If the signs of arguments are unknown and a positive modulus
 is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the floor modulus {@code x - (floorDiv(x, y) * y)} </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorMod(System.Int64,System.Int64)">
 <summary>
 Returns the floor modulus of the {@code long} arguments.
 
 The floor modulus is {@code x - (floorDiv(x, y) * y)},
 has the same sign as the divisor {@code y}, and
 is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 
 
 The relationship between {@code floorDiv} and {@code floorMod} is such that:
 
   + {@code floorDiv(x, y) * y + floorMod(x, y) == x}
 
 
 For examples, see  #floorMod(int, int)"/>.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the floor modulus {@code x - (floorDiv(x, y) * y)} </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Int32)">
 <summary>
 Returns the absolute value of an {@code int} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 
 Note that if the argument is equal to the value of
  Integer#MIN_VALUE"/>, the most negative representable
 {@code int} value, the result is that same value, which is
 negative.
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Int64)">
 <summary>
 Returns the absolute value of a {@code long} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 
 Note that if the argument is equal to the value of
  Long#MIN_VALUE"/>, the most negative representable
 {@code long} value, the result is that same value, which
 is negative.
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Single)">
 <summary>
 Returns the absolute value of a {@code float} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 Special cases:
 + If the argument is positive zero or negative zero, the
 result is positive zero.
 + If the argument is infinite, the result is positive infinity.
 + If the argument is NaN, the result is NaN.
 In other words, the result is the same as the value of the expression:
 {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a))}
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Double)">
 <summary>
 Returns the absolute value of a {@code double} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 Special cases:
 + If the argument is positive zero or negative zero, the result
 is positive zero.
 + If the argument is infinite, the result is positive infinity.
 + If the argument is NaN, the result is NaN.
 In other words, the result is the same as the value of the expression:
 {@code java.lang.[Double].longBitsToDouble((Double.doubleToLongBits(a)&lt;&lt;1)>>>1)}
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.max(System.Int32,System.Int32)">
 <summary>
 Returns the greater of two {@code int} values. That is, the
 result is the argument closer to the value of
  Integer#MAX_VALUE"/>. If the arguments have the same value,
 the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the larger of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.max(System.Int64,System.Int64)">
 <summary>
 Returns the greater of two {@code long} values. That is, the
 result is the argument closer to the value of
  Long#MAX_VALUE"/>. If the arguments have the same value,
 the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the larger of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.min(System.Int32,System.Int32)">
 <summary>
 Returns the smaller of two {@code int} values. That is,
 the result the argument closer to the value of
  Integer#MIN_VALUE"/>.  If the arguments have the same
 value, the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the smaller of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.min(System.Int64,System.Int64)">
 <summary>
 Returns the smaller of two {@code long} values. That is,
 the result is the argument closer to the value of
  Long#MIN_VALUE"/>. If the arguments have the same
 value, the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the smaller of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sinh(System.Double)">
 <summary>
 Returns the hyperbolic sine of a {@code double} value.
 The hyperbolic sine of _x_ is defined to be
 (_e<sup>x</sup> - e<sup>-x</sup>_)/2
 where _e_ is  Math#E Euler's number"/>.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is infinite, then the result is an infinity
 with the same sign as the argument.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 </summary>
 <param name="x"> The number whose hyperbolic sine is to be returned. </param>
 <returns>  The hyperbolic sine of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.cosh(System.Double)">
 <summary>
 Returns the hyperbolic cosine of a {@code double} value.
 The hyperbolic cosine of _x_ is defined to be
 (_e<sup>x</sup> + e<sup>-x</sup>_)/2
 where _e_ is  Math#E Euler's number"/>.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is infinite, then the result is positive
 infinity.
 
 + If the argument is zero, then the result is {@code 1.0}.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 </summary>
 <param name="x"> The number whose hyperbolic cosine is to be returned. </param>
 <returns>  The hyperbolic cosine of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.tanh(System.Double)">
 <summary>
 Returns the hyperbolic tangent of a {@code double} value.
 The hyperbolic tangent of _x_ is defined to be
 (_e<sup>x</sup> - e<sup>-x</sup>_)/(_e<sup>x</sup> + e<sup>-x</sup>_),
 in other words, {@link Math#sinh
 sinh(_x_)}/ Math#cosh cosh(_x_)"/>.  Note
 that the absolute value of the exact tanh is always less than
 1.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 + If the argument is positive infinity, then the result is
 {@code +1.0}.
 
 + If the argument is negative infinity, then the result is
 {@code -1.0}.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 The result of {@code tanh} for any finite input must have
 an absolute value less than or equal to 1.  Note that once the
 exact result of tanh is within 1/2 of an ulp of the limit value
 of 1, correctly signed {@code 1.0} should be returned.
 </summary>
 <param name="x"> The number whose hyperbolic tangent is to be returned. </param>
 <returns>  The hyperbolic tangent of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log1p(System.Double)">
 <summary>
 Returns the natural logarithm of the sum of the argument and 1.
 Note that for small values {@code x}, the result of
 {@code log1p(x)} is much closer to the true result of ln(1
 + {@code x}) than the floating-point evaluation of
 {@code log(1.0+x)}.
 
 Special cases:
 
 
 
 + If the argument is NaN or less than -1, then the result is
 NaN.
 
 + If the argument is positive infinity, then the result is
 positive infinity.
 
 + If the argument is negative one, then the result is
 negative infinity.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="x">   a value </param>
 <returns> the value ln({@code x} + 1), the natural
 log of {@code x} + 1
 @since 1.5 </returns>
 <remarks>http://www.johndcook.com/csharp_log_one_plus_x.html</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.Log1m(System.Double)">
 <summary>
 Computes log(1-x) without losing precision for small values of x.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.LogTricks">
 <summary>
 @author Marc Suchard
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.MathUtils">
 <summary>
 Handy utility functions which have some Mathematical relavance.
 
 @author Matthew Goode
 @author Alexei Drummond
 @author Gerton Lunter
 @version $Id: MathUtils.java,v 1.13 2006/08/31 14:57:24 rambaut Exp $
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.MathUtils.random">
 <summary>
 A random number generator that is initialized with the clock when this
 class is loaded into the JVM. Use this for all random numbers. Note: This
 method or getting random numbers in not thread-safe. Since
 MersenneTwisterFast is currently (as of 9/01) not synchronized using this
 function may cause concurrency issues. Use the static get methods of the
 MersenneTwisterFast class for access to a single instance of the class,
 that has synchronization.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.randomChoicePDF(System.Double[])">
 <param name="pdf">
            array of unnormalized probabilities </param>
 <returns> a sample according to an unnormalized probability distribution </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getNormalized(System.Double[])">
 <param name="array">
            to normalize </param>
 <returns> a new double array where all the values sum to 1. Relative ratios
         are preserved. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getTotal(System.Double[],System.Int32,System.Int32)">
 <param name="array">
            entries to be summed </param>
 <param name="start">
            start position </param>
 <param name="end">
            the index of the element after the last one to be included </param>
 <returns> the total of a the values in a range of an array </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getTotal(System.Double[])">
 <param name="array">
            to sum over </param>
 <returns> the total of the values in an array </returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Java.MathUtils.Seed">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextByte">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextBoolean">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextBytes(System.SByte[])">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextChar">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextGaussian">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextDouble">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
 <returns> a pseudo random double precision floating point number in [01) </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.randomLogDouble">
 <returns> log of random variable in [0,1] </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextExponential(System.Double)">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextInverseGaussian(System.Double,System.Double)">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextFloat">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextLong">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextShort">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextInt">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextInt(System.Int32)">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.uniform(System.Double,System.Double)">
 
 <param name="low"> </param>
 <param name="high"> </param>
 <returns> uniform between low and high </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffle(System.Int32[])">
 <summary>
 Shuffles an array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffle(System.Int32[],System.Int32)">
 <summary>
 Shuffles an array. Shuffles numberOfShuffles times
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffled(System.Int32)">
 <summary>
 Returns an array of shuffled indices of length l.
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.permute(System.Int32[])">
 <summary>
 Permutes an array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.permuted(System.Int32)">
 <summary>
 Returns a uniform random permutation of 0,...,l-1
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.hypot(System.Double,System.Double)">
 <summary>
 Returns sqrt(a^2 + b^2) without under/overflow.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast">
 <summary>
 MersenneTwisterFast:
  
 A simulation quality fast random number generator (MT19937) with the same
 public methods as java.util.Random.
  
  
 About the Mersenne Twister. This is a Java version of the C-program for
 MT19937: Integer version. next(32) generates one pseudorandom unsigned
 integer (32bit) which is uniformly distributed among 0 to 2^32-1 for each
 call. next(int bits) >>>'s by (32-bits) to get a value ranging between 0 and
 2^bits-1 long inclusive; hope that's correct. setSeed(seed) set initial
 values to the working area of 624 words. For setSeed(seed), seed is any
 32-bit integer except for 0.
  
 Reference. M. Matsumoto and T. Nishimura, "Mersenne Twister: A
 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator",
 <i>ACM Transactions on Modeling and Computer Simulation,</i> Vol. 8, No. 1,
 January 1998, pp 3--30.
  
  
 Bug Fixes. This implementation implements the bug fixes made in Java 1.2's
 version of Random, which means it can be used with earlier versions of Java.
 See <a href=
 "http://www.javasoft.com/products/jdk/1.2/docs/api/java/util/Random.html">
 the JDK 1.2 java.util.Random documentation</a> for further documentation on
 the random-number generation contracts made. Additionally, there's an
 undocumented bug in the JDK java.util.Random.nextBytes() method, which this
 code fixes.
  
  
 Important Note. Just like java.util.Random, this generator accepts a long
 seed but doesn't use all of it. java.util.Random uses 48 bits. The Mersenne
 Twister instead uses 32 bits (int size). So it's best if your seed does not
 exceed the int range.
  
  
 <a href="http://www.cs.umd.edu/users/seanl/">Sean Luke's web page</a>
  
  
 - added shuffling method (Alexei Drummond)
  
 - added gamma RV method (Marc Suchard)
  
 This is now package private - it should be accessed using the instance in
 Random
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.serialVersionUID">
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.#ctor">
 <summary>
 Constructor using the time of day as default seed.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.#ctor(System.Int64)">
 <summary>
 Constructor using a given seed. Though you pass this seed in as a long,
 it's best to make sure it's actually an integer.
 </summary>
 <param name="seed">
            generator starting number, often the time of day. </param>
</member>
<member name="P:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.Seed">
 <summary>
 Initalize the pseudo random number generator. The Mersenne Twister only
 uses an integer for its seed; It's best that you don't pass in a long
 that's bigger than an int.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.nextInt(System.Int32)">
 <summary>
 Returns an integer drawn uniformly from 0 to n-1. Suffice it to say, n
 must be > 0, or an IllegalArgumentException is raised.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.permute(System.Int32[])">
 <summary>
 Returns a uniform random permutation of int objects in array
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.shuffle(System.Int32[])">
 <summary>
 Shuffles an array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.shuffle(System.Int32[],System.Int32)">
 <summary>
 Shuffles an array. Shuffles numberOfShuffles times
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.shuffled(System.Int32)">
 <summary>
 Returns an array of shuffled indices of length l.
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.permuted(System.Int32)">
 <summary>
 Returns a uniform random permutation of ints 0,...,l-1
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MersenneTwisterFast.nextGamma(System.Double,System.Double)">
 <summary>
****************************************************************
 * Gamma Distribution - Acceptance Rejection combined with *
 Acceptance Complement * *
 ****************************************************************** 
 * FUNCTION: - gds samples a random number from the standard * gamma
 distribution with parameter a > 0. * Acceptance Rejection gs for a &lt;
 1 , * Acceptance Complement gd for a >= 1 . * REFERENCES: - J.H.
 Ahrens, U. Dieter (1974): Computer methods * for sampling from gamma,
 beta, Poisson and * binomial distributions, Computing 12, 223-246. *
 - J.H. Ahrens, U. Dieter (1982): Generating gamma * variates by a
 modified rejection technique, * Communications of the ACM 25, 47-54.
 * SUBPROGRAMS: - drand(seed) ... (0,1)-Uniform generator with *
 unsigned long integer *seed * - NORMAL(seed) ... Normal generator
 N(0,1). * *
 *****************************************************************
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.C.CString">
 <summary>
 This class provides the ability to simulate various classic C string functions
	which don't have exact equivalents in the .NET Framework.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.ChangeCharacter(System.String,System.Int32,System.Char)">
 <summary>
 This method allows replacing a single character in a string, to help convert
 C++ code where a single character in a character array is replaced.
 </summary>
 <param name="sourcestring"></param>
 <param name="charindex"></param>
 <param name="changechar"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.IsXDigit(System.Char)">
 <summary>
 This method simulates the classic C string function 'isxdigit' (and 'iswxdigit').
 </summary>
 <param name="character"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrChr(System.String,System.Char)">
 <summary>
 This method simulates the classic C string function 'strchr' (and 'wcschr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="chartofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrRChr(System.String,System.Char)">
 <summary>
 This method simulates the classic C string function 'strrchr' (and 'wcsrchr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="chartofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrStr(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strstr' (and 'wcsstr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="stringtofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.__tokensHelper.StrTok(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strtok' (and 'wcstok').
 Note that the .NET string 'Split' method cannot be used to simulate 'strtok' since
 it doesn't allow changing the delimiters between each token retrieval.
 </summary>
 <param name="stringtotokenize"></param>
 <param name="delimiters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrTok(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strtok' (and 'wcstok').
 Note that the .NET string 'Split' method cannot be used to simulate 'strtok' since
 it doesn't allow changing the delimiters between each token retrieval.
 </summary>
 <param name="stringtotokenize"></param>
 <param name="delimiters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.xFormat(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Terminal.STDIO__.CFormatProvider.sprintf(System.String,System.Object[])"/>
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.PathMapper">
 <summary>
 Maps the linux path to the Windows path.(这个模块是将Linux路径映射为Windows路径的)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.PathMapper.platform">
 <summary>
 Gets a <see cref="T:System.PlatformID"/> enumeration value that identifies the operating system
 platform.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PathMapper.GetMapPath(System.String)">
 <summary>
 Map linux path on Windows:
 
 + [~ -> C:\User\&lt;user_name>]
 + [# -> <see cref="P:Microsoft.VisualBasic.App.HOME"/>]
 + [/ -> C:\]
 + [/usr/bin -> C:\Program Files\]
 + [/usr -> C:\User\]
 + [- -> <see cref="P:Microsoft.VisualBasic.App.PreviousDirectory"/>]
 
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PathMapper.HOME">
 <summary>
 Get user home folder
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper">
 <summary>
 mono shortcuts
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper.ScriptMe">
 <summary>
 perl ./<see cref="T:System.Reflection.Assembly"/> @ARGV
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper.BashRun">
 <summary>
 Run from bash shell
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper.BashShell">
 <summary>
 这里比perl脚本掉调用有一个缺点，在运行前还需要使用命令修改为可执行权限
 'sudo chmod 777 cmd.sh'
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper.PerlShell">
 <summary>
 Execute command using perl script
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks">
 <summary>
 Cowsay tricks for showing your message more friendly.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.NormalCow">
 <summary>
 Normal cow
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.DeadCow">
 <summary>
 The cow in dead face
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.RunCowsay(System.String,System.Boolean)">
 <summary>
 Show cowsay with a specific input message on your console screen. you can using /dead to change its face.
 </summary>
 <param name="msg"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.__msgbox(System.String)">
 <summary>
 Creates the message box to display the message for the cow on the console.
 </summary>
 <param name="msg"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileSystemAPI.ls">
 <summary>
 ls -l -ext("*.xml") &lt;= DIR,  The filesystem search proxy
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileSystemAPI.l">
 <summary>
 Long name(DIR+fiename), if not only file name.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileSystemAPI.r">
 <summary>
 递归的搜索
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileSystemAPI.lsDIR">
 <summary>
 Searching the directory, if this parameter is not presents, then returns search file.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.FileSystemAPI.wildcards(System.String[])">
 <summary>
 可以使用这个来限定文件或者文件夹对象的搜索范围
 </summary>
 <param name="__wildcards">可以为文件拓展或者对文件名的通配符的表达式，假若这个是空的，则会默认搜索所有文件*.*</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_Subtraction(Microsoft.VisualBasic.Language.UnixBash.Search,Microsoft.VisualBasic.Language.UnixBash.SearchOpt)">
 <summary>
 Add a search options
 </summary>
 <param name="ls"></param>
 <param name="l"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_LeftShift(Microsoft.VisualBasic.Language.UnixBash.Search,System.Int32)">
 <summary>
 Search the files in the specific directory
 </summary>
 <param name="ls"></param>
 <param name="DIR"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_LessThan(Microsoft.VisualBasic.Language.UnixBash.Search,System.String)">
 <summary>
 Search the files in the specific directory
 </summary>
 <param name="ls"></param>
 <param name="DIR"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_LessThanOrEqual(Microsoft.VisualBasic.Language.UnixBash.Search,System.String)">
 <summary>
 Search the files in the specific directory
 </summary>
 <param name="ls"></param>
 <param name="DIR"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.SearchOpt.Options.Directory">
 <summary>
 List directories, not files listing.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.SearchOpt.Options.Recursive">
 <summary>
 递归搜索所有的文件夹
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.File">
 <summary>
 Asbtract file IO model
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.FileHandle">
 <summary>
 文件系统对象的句柄
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileHandle.IsHTTP">
 <summary>
 Determined that is this filename is a network location.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.FileHandles.OpenHandle(System.String,Microsoft.VisualBasic.TextEncodings.Encodings)">
 <summary>
 Open a file system handle
 </summary>
 <param name="file"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.FileHandles.FileOpened(System.String)">
 <summary>
 Is this file opened
 </summary>
 <param name="filename"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.TextAPI.grep">
 <summary>
 grep (global search regular expression(RE) and print out the line
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.TextAPI.f">
 <summary>
 Text source of the grep operation is a file.
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.a">
 <summary>
 将 binary 文件以 text 文件的方式搜寻数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.c">
 <summary>
 计算找到 '搜寻字符串' 的次数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.i">
 <summary>
 忽略大小写的不同，所以大小写视为相同
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.n">
 <summary>
 顺便输出行号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.v">
 <summary>
 反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.GrepRegx">
 <summary>
 grep -acinv * "pattern" &lt;= "filename or text" |
 grep -acinv * "pattern" &lt;&lt; "filename"
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPI">
 <summary>
 Language syntax extension for the Linq expression in VisualBasic language
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.MakeList``1">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.Exec``1">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.Exec``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 
 </summary>
 <typeparam name="T">Is the type of linq source</typeparam>
 <typeparam name="V">Is the type of value output</typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}}})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <param name="cls"></param>
 <param name="linq">
 An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an array from.
 </param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <param name="cls"></param>
 <param name="linq">
 An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an array from.
 </param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.FirstOrDefaultHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.FirstOrDefaultHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Exec ToArray
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper{`0,`1},System.Func{`0,`1})">
 <summary>
 Exec ToArray
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper{`0,`1},System.Func{`0,System.Int32,`1})">
 <summary>
 Exec ToArray
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.IClassObject">
 <summary>
 The base class object in VisualBasic
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.IClassObject.Extension">
 <summary>
 The extension property.(为了节省内存的需要，这个附加属性尽量不要被自动初始化)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Class`1">
 <summary>
 <see cref="T:System.Type"/>
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.Class`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.Class{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 ToArray
 </summary>
 <param name="cls"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Class`1.op_Like(Microsoft.VisualBasic.Language.Class{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 IsNullOrEmpty
 </summary>
 <param name="cls"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassAPI.Uid``1(``0)">
 <summary>
 Example of the extension property in VisualBasic
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.ClassObject">
 <summary>
 The base class object in VisualBasic
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.ClassObject.Extension">
 <summary>
 The extension property.(为了节省内存的需要，这个附加属性尽量不要被自动初始化)
 </summary>
 <returns></returns>
 <remarks>
 Dummy field for solve the problem of xml serialization >>>simpleContent&lt;&lt;&lt;   
 
 http://stackoverflow.com/questions/2501466/xmltext-attribute-in-base-class-breakes-serialization
 
 So I think you could make it work by adding a dummy property or field that you never 
 use in the ``LookupItem`` class. 
 If you're never assign a value to it, it will remain null and will not be serialized, 
 but it will prevent your class from being treated as simpleContent. I know it's a 
 dirty workaround, but I see no other easy way...
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassObject.ReadProperty``1(System.String)">
 <summary>
 Get dynamics property value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassObject.ToString">
 <summary>
 Default is display the json value of the object class
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassObject.__toString">
 <summary>
 String source for operator <see cref="M:Microsoft.VisualBasic.Language.ClassObject.op_Concatenate(Microsoft.VisualBasic.Language.ClassObject,System.String)"/>
 </summary>
 <returns>Default is using <see cref="M:Microsoft.VisualBasic.Language.ClassObject.ToString"/> method as provider</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassObject.op_Concatenate(Microsoft.VisualBasic.Language.ClassObject,System.String)">
 <summary>
 Contact this class object with other string value
 </summary>
 <param name="x"></param>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.ClassObject.op_Concatenate(System.String,Microsoft.VisualBasic.Language.ClassObject)">
 <summary>
 Contact this class object with other string value
 </summary>
 <param name="s"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Numeric">
 <summary>
 Defines a generalized type-specific comparison method that a value type or class
 implements to order or sort its instances.
 </summary>
 <remarks>

 Summary:

     Compares the current instance with another object of the same type and returns
     an integer that indicates whether the current instance precedes, follows, or
     occurs in the same position in the sort order as the other object.

 Returns:

     A value that indicates the relative order of the objects being compared. The
     return value has these meanings:

     1. Value Meaning Less than zero
        This instance precedes obj in the sort order.

     2. Zero
        This instance occurs in the same position in the sort order as obj.

     3. Greater than zero
        This instance follows obj in the sort order.

 Exceptions:

   T:System.ArgumentException:
     obj is not the same type as this instance.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.MaxIndex``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 The max element its index in the source collection.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.Equals``1(``0,``0)">
 <summary>
 =
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.LessThan``1(``0,``0)">
 <summary>
 &lt;
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.GreaterThan``1(``0,``0)">
 <summary>
 >
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.LessThanOrEquals``1(``0,``0)">
 <summary>
 &lt;=
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.GreaterThanOrEquals``1(``0,``0)">
 <summary>
 =>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.NextInteger(System.Random,System.Int32)">
 <summary>
 <see cref="T:System.Random"/> get next integer in the specific range <paramref name="max"/>
 </summary>
 <param name="rnd"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Int">
 <summary>
 Alias of <see cref="T:System.Int32"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Int.CompareTo(System.Object)">
 <summary>
 Compare <see cref="T:Microsoft.VisualBasic.Language.Int"/> or <see cref="T:System.Int32"/>
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Int.op_LessThan(System.Int32,Microsoft.VisualBasic.Language.Int)">
 <summary>
 n &lt; value &lt;= n2
 假若n 大于value，则返回最大值，上面的表达式肯定不成立
 </summary>
 <param name="n"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Float.op_LessThan(System.Double,Microsoft.VisualBasic.Language.Float)">
 <summary>
 n &lt; value &lt;= n2
 假若n 大于value，则返回最大值，上面的表达式肯定不成立
 </summary>
 <param name="n"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.IParallelTask.WaitForExit">
 <summary>
 这个函数会检查<see cref="P:Microsoft.VisualBasic.Parallel.Tasks.IParallelTask.TaskComplete"/>属性来判断任务是否执行完毕
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.IBackgroundTask`1">
 <summary>
 背景线程的任务抽象
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.__backgroundTask`1.Value">
 <summary>
 获取得到任务线程执行的输出结果
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.__backgroundTask`1.Abort">
 <summary>
 取消当前的任务的执行，在线程内部产生的异常可以在<see cref="P:Microsoft.VisualBasic.Parallel.Tasks.__backgroundTask`1.ExecuteException"/>获取得到
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.CallbackTask">
 <summary>
 When the task job complete, then the program will notify user code through callback function.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1">
 <summary>
 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.Join(System.Func{`0})">
 <summary>
 函数会被插入一个队列之中，之后线程会被阻塞在这里直到函数执行完毕，这个主要是用来控制服务器上面的任务并发的
 </summary>
 <param name="handle"></param>
 <returns>假若本对象已经开始Dispose了，则为完成的任务都会返回Nothing</returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.Enqueue(System.Func{`0},System.Action{`0})">
 <summary>
 这个函数只会讲任务添加到队列之中，而不会阻塞线程
 </summary>
 <param name="handle"></param>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1">
 <summary>
 Represents the status of an asynchronous operation.(背景线程加载数据)
 </summary>
 <typeparam name="TOut"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.IsCompleted">
 <summary>
 Gets a value that indicates whether the asynchronous operation has completed.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.Run">
 <summary>
 Start the background task thread.(启动后台背景线程)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.GetValue">
 <summary>
 没有完成会一直阻塞线程在这里
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread">
 <summary>
 Running a specific <see cref="T:System.Action"/> in the background periodically.
 (比较适合用于在服务器上面执行周期性的计划任务)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Periods">
 <summary>
 ms
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.ErrHandle">
 <summary>
 If this exception handler is null, then when the unhandled exception occurring,
 this thread object will throw the exception and then stop working.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Running">
 <summary>
 指示当前的这个任务处理对象是否处于运行状态
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.#ctor(System.Int32,System.Action)">
 <summary>
 Running a specific action in the background periodically. The time unit of the parameter <paramref name="Periods"/> is ms or Ticks.
 </summary>
 <param name="Periods">ms for update thread sleeps</param>
 <param name="updates"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Start">
 <summary>
 运行这条线程，假若更新线程已经在运行了，则会自动忽略这次调用
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Stop">
 <summary>
 停止更新线程的运行
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.Task`2">
 <summary>
 更加底层的线程模式，和LINQ相比不会受到CPU核心数目的限制
 </summary>
 <typeparam name="T">后台任务的执行参数</typeparam>
 <typeparam name="TOut">后台任务的执行结果</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.Task`2.Value">
 <summary>
 假若任务已经完成，则会返回计算值，假若没有完成，则只会返回空值，假若想要在任何情况之下都会得到后台任务所执行的计算结果，请使用<see cref="M:Microsoft.VisualBasic.Parallel.Tasks.Task`2.GetValue"/>方法
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.Task`2.GetValue">
 <summary>
 假若后台任务还没有完成，则函数会一直阻塞在这里直到任务执行完毕，假若任务早已完成，则函数会立即返回数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.Task">
 <summary>
 这个是带有<see cref="E:Microsoft.VisualBasic.Parallel.Tasks.Task.TaskJobComplete"/>事件的任务对象
 </summary>
</member>
<member name="E:Microsoft.VisualBasic.Parallel.Tasks.Task.TaskJobComplete">
 <summary>
 当所请求的任务执行完毕之后触发
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.BatchTasks.BatchTask``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Func{System.String},System.Int32,System.Int32)">
 <summary>
 当所需要进行计算的数据量比较大的时候，建议分块使用本函数生成多个进程进行批量计算以获得较好的计算效率
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="getCLI"></param>
 <param name="getExe"></param>
 <param name="numThreads">-1表示使用系统自动配置的参数，一次性提交所有的计算任务可能会是计算效率变得很低，所以需要使用这个参数来控制计算的线程数量</param>
 <param name="TimeInterval">默认的任务提交时间间隔是一秒钟提交一个新的计算任务</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.BatchTasks.BatchTask``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <typeparam name="TIn"></typeparam>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="getTask"></param>
 <param name="numThreads">可以在这里手动的控制任务的并发数，这个数值小于或者等于零则表示自动配置线程的数量，如果想要单线程，请将这个参数设置为1</param>
 <param name="TimeInterval"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.BatchTasks.BatchTask``1(System.Func{``0}[],System.Int32,System.Int32)">
 <summary>
 由于LINQ是分片段来执行的，当某个片段有一个线程被卡住之后整个进程都会被卡住，所以执行大型的计算任务的时候效率不太好，
 使用这个并行化函数可以避免这个问题，同时也可以自己手动控制线程的并发数
 </summary>
 <typeparam name="T"></typeparam>
 <param name="actions"></param>
 <param name="numThreads">可以在这里手动的控制任务的并发数，这个数值小于或者等于零则表示自动配置线程的数量</param>
 <param name="TimeInterval"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ThreadQueue">
 <summary>
 任务线程队列
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.MyThread">
 <summary>
 Writer Thread ☺
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.ThreadQueue.MultiThreadSupport">
 <summary>
 If TRUE, the Writing process will be separated from the main thread.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.Queue">
 <summary>
 Just my queue
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.QSolverRunning">
 <summary>
 Is thread running?
 hum
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.dummy">
 <summary>
 lock
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.AddToQueue(System.Action)">
 <summary>
 Add an Action to the queue.
 </summary>
 <param name="A">()=>{ .. }</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.WaitQueue">
 <summary>
 Wait for all thread queue job done.(Needed if you are using multiThreaded queue)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.exeQueue">
 <summary>
 Execute the queue list
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions">
 <summary>
 对大量的短时间的任务进行分区的操作是在这里完成的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.PartTokens(System.Int32,System.Int32)">
 <summary>
 根据任务总量计算出所需要的线程的数量
 </summary>
 <param name="source"></param>
 <param name="num_threads"></param>
 <returns></returns>
 <remarks>假设所有的任务都被平均的分配到每一个线程之上</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Performance the partitioning operation on the input sequence.
 (请注意，这个函数适用于数量非常多的序列。对所输入的序列进行分区操作，<paramref name="parTokens"/>函数参数是每一个分区里面的元素的数量)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="parTokens"></param>
 <returns></returns>
 <remarks>对于数量较少的序列，可以使用<see cref="M:Microsoft.VisualBasic.Extensions.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>进行分区操作，
 该函数使用数组的<see cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>方法进行分区复制，效率较高
 
 由于本函数需要处理大量的数据，使用Array的方法会内存占用较厉害，所以在这里更改为List操作以降低内存的占用
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.Partitioning``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1})">
 <summary>
 进行分区之后返回一个长时间的任务组合
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.Partitioning``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1},System.Func{``0,System.Boolean})">
 <summary>
 进行分区之后返回一个长时间的任务组合
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.__taskHelper`2">
 <summary>
 因为在上一层调用之中使用了并行化，所以在这里不能够使用并行化拓展了
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="out"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule">
 <summary>
 Parallel Linq query library for VisualBasic.
 (用于高效率执行批量查询操作和用于检测操作超时的工具对象，请注意，为了提高查询的工作效率，请尽量避免在查询操作之中生成新的临时对象
 并行版本的LINQ查询和原始的线程操作相比具有一些性能上面的局限性)
 </summary>
 <remarks>
 在使用Parallel LINQ的时候，请务必要注意不能够使用Let语句操作共享变量，因为排除死锁的开销比较大
 
 在设计并行任务的时候应该遵循的一些原则:
 1. 假若每一个任务之间都是相互独立的话，则才可以进行并行化调用
 2. 在当前程序域之中只能够通过线程的方式进行并行化，对于时间较短的任务而言，非并行化会比并行化更加有效率
 3. 但是对于这些短时间的任务，仍然可以将序列进行分区合并为一个大型的长时间任务来产生并行化
 4. 对于长时间的任务，可以直接使用并行化Linq拓展执行并行化
 
 这个模块主要是针对大量的短时间的任务序列的并行化的，用户可以在这里配置线程的数量自由的控制并行化的程度
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.CPU_NUMBER">
 <summary>
 Get the number of processors on the current machine.(获取当前的系统主机的CPU核心数)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.AutoConfig(System.Int32)">
 <summary>
 假如小于0，则认为是自动配置，0被认为是单线程，反之直接返回
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.Recommended_NUM_THREADS">
 <summary>
 The possible recommended threads of the linq based on you machine processors number, i'm not sure...
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Double,System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="timeout">单个数据分区的计算的超时的时间，单位是秒</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="where">Processing where test on the inputs</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Boolean},System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="outWhere">Processing where test on the output</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.GroupListNode`2.InitReads">
 <summary>
 由于<see cref="P:Microsoft.VisualBasic.Parallel.GroupListNode`2.Group"/>在分组之后的后续的操作的过程之中元素会发生改变，
 所以在这个属性之中存储了在初始化<see cref="P:Microsoft.VisualBasic.Parallel.GroupListNode`2.Group"/>列表的时候的原始的列表之中的元素的个数以满足一些其他的算法操作
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.GroupResult`2">
 <summary>
 
 </summary>
 <typeparam name="T">Group的元素的类型</typeparam>
 <typeparam name="Itag">Group的Key的类型</typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.GroupAPI.ParallelGroup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 貌似使用LINQ进行Group操作的时候是没有并行化的，灰非常慢，则可以使用这个拓展函数来获取较好的性能
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="T_TAG"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ServicesFolk">
 <summary>
 主服务和子服务之间的相互作用的特点是子服务不会知道主服务节点的数据接口，所有的交互都是通过子服务上面的一个模块来监听主服务来实现的
 当主服务有数据需要向子服务更新的时候，会主动发送数据请求至子服务节点
 </summary>
 <remarks>当前的用户规模还比较小这里仅仅是实现了本地的调用，后面考虑到业务吞吐量的问题，会将服务的调用分开到两台物理主机之上</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ServicesFolk.Folk(System.String,System.String@,System.Diagnostics.Process@)">
 <summary>
 函数返回子进程的交互数据通信的端口号
 </summary>
 <param name="assm"></param>
 <param name="CLI">命令行参数字符串，可以在这里加入一些其他的自定义数据</param>
 <returns>函数返回子服务的交互端口</returns>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ServicesFolk.__getChildPortal.addArgs">
 <summary>
 所返回来的额外的参数信息
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ServicesFolk.ReturnPortal(Microsoft.VisualBasic.CommandLine.CommandLine,System.Int32,System.String)">
 <summary>
 子服务向服务主节点返回端口号数据，这个方法需要要在子服务上面的服务程序启动之后再调用
 </summary>
 <param name="CLI"></param>
 <param name="Port"></param>
 <param name="addArgs">额外返回的参数信息</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ParallelLoading">
 <summary>

 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.ParallelLoading.LoadEntry.MethodEntryPoint">
 <summary>
 必须满足接口类型： Function(path As String) As T
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.Load``1(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 当目标数据集非常的大的时候，在单个应用程序里面进行加载已经回非常缓慢了，
 则这个时候可以使用这个函数将数据的加载任务分配到多个子进程之中以提高加载的时候的CPU的利用效率
 </summary>
 <typeparam name="T"></typeparam>
 <param name="sourceURL"></param>
 <returns></returns>
 <remarks>函数会自动从<typeparamref name="T"/></remarks>泛型类型之中解析出加载的函数
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.Load``1(System.String,System.String)">
 <summary>
 通过与并行进程进行内存共享来传输加载完毕的数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="url"></param>
 <param name="Process"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.SendMessageAPI(System.Int32)">
 <summary>
 动态编译的加载进程的调用API来向主进程返回消息
 </summary>
 <param name="Port"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.GetReferences(System.Type)">
 <summary>
 递归的获取该类型所处的模块的所有的依赖关系，返回来的是全路径
 </summary>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.GetReferences(System.Reflection.Assembly,System.Int32,Microsoft.VisualBasic.List{System.String}@)">
 <summary>
 有一些会出现循环引用的情况？？？？？
 </summary>
 <param name="assembly"></param>
 <param name="i"></param>
 <param name="refList"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.GetReferences(System.Reflection.Assembly,System.Boolean,System.Boolean)">
 <summary>

 </summary>
 <param name="assembly"></param>
 <param name="removeSystem">是否移除系统引用</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.IsSystemAssembly(System.String,System.Boolean)">
 <summary>
 放在C:\WINDOWS\Microsoft.Net\这个文件夹下面的所有的引用都是本地编译的，哈希值已经不对了
 </summary>
 <param name="url"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.GetReferences(System.String,System.Int32,Microsoft.VisualBasic.List{System.String}@)">
 <summary>

 </summary>
 <param name="url">+特殊符号存在于这个字符串之中的话，函数会出错</param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelLoading.DynamicsVBCTask(Microsoft.VisualBasic.Parallel.ParallelLoading.LoadEntry)">
 <summary>
 动态编译
 </summary>
 <param name="LoadEntry"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelExtension.RunTask(System.Threading.ThreadStart)">
 <summary>
 Start a new thread and then returns the background thread task handle.
 </summary>
 <param name="start"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut``2(System.Func{``0,``1},``0,``1@,System.Double)">
 <summary>
 The returns value of TRUE represent of the target operation has been time out.(返回真，表示操作超时)
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="handle"></param>
 <param name="Out"></param>
 <param name="TimeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut``1(System.Func{``0},``0@,System.Double)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="handle"></param>
 <param name="Out"></param>
 <param name="TimeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut(System.Action,System.Double)">
 <summary>
 
 </summary>
 <param name="handle"></param>
 <param name="TimeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.InvokesHelper.Invoke(System.Action[],System.Int32)">
 <summary>
 
 </summary>
 <param name="tasks"></param>
 <param name="numOfThreads">同时执行的句柄的数目</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Actives.Active(System.Type)">
 <summary>
 Display the json of the target type its instance object.
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Actives.__active(System.Type)">
 <summary>
 Creates the example instance object for the example
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Where.BuildAll``1(Microsoft.VisualBasic.Scripting.Logics,System.Func{``0,System.Boolean}[])">
 <summary>
 Not support <see cref="F:Microsoft.VisualBasic.Scripting.Logics.Not"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="logic"></param>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Where.__or``1(``0,System.Func{``0,System.Boolean}[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.Logics.Or"/>, 所有的表达式都会被计算
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Where.__and``1(``0,System.Func{``0,System.Boolean}[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.Logics.And"/>, 所有的表达式都会被计算
 </summary>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.MetaAPI.TypeInfo">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.MetaAPI.GetEntry(System.Type)">
 <summary>
 获取定义在类型定义上面的命名空间的标记信息
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo">
 <summary>
 The type reference information.(类型信息)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.assm">
 <summary>
 The assembly file which contains this type definition.(模块文件)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.FullIdentity">
 <summary>
 <see cref="P:System.Type.FullName"/>.(类型源)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.SystemKnownType">
 <summary>
 Is this type object is a known system type?(是否是已知的类型？)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.#ctor(System.Type)">
 <summary>
 Creates type reference from the definition.
 </summary>
 <param name="info"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.LoadAssembly(System.String)">
 <summary>
 Loads the assembly file which contains this type. If the <param name="DIR"></param> is not a valid directory location, 
 then using the location <see cref="P:Microsoft.VisualBasic.App.HOME"/> as default.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.GetType(System.Boolean)">
 <summary>
 Get mapping type information.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.op_Equality(Microsoft.VisualBasic.Scripting.MetaData.TypeInfo,System.Type)">
 <summary>
 检查a是否是指向b的类型引用的
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.Cite">
 <summary>
 EndNote tags
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.Authors">
 <summary>
 author(eMail);author(eMail)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.ISSN">
 <summary>
 ISSN_1; ISSN_2; ISSN_3
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.Abstract">
 <summary>
 文章的摘要，可以使用&lt;p>或者&lt;br/>来进行分段
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Cite.#ctor(System.String)">
 <summary>
 %x 是文章的摘要，可以使用&lt;p>或者&lt;br/>来进行分段
 </summary>
 <param name="EndNoteImports"></param>
 <remarks>
 %A Griffiths-Jones, Sam
 %A Bateman, Alex
 %A Marshall, Mhairi
 %A Khanna, Ajay
 %A Eddy, Sean R.
 %T Rfam: an RNA family database
 %0 Journal Article
 %D 2003 
 %8 January 1, 2003 
 %J Nucleic Acids Research 
 %P 439-441 
 %R 10.1093/nar/gkg006 
 %V 31 
 %N 1 
 %U http://nar.oxfordjournals.org/content/31/1/439.abstract 
 %X Rfam Is a collection of multiple sequence alignments And covariance models representing non-coding RNA families. Rfam Is available on the web in the UK at http://www.sanger.ac.uk/Software/Rfam/ And in the US at http://rfam.wustl.edu/. These websites allow the user to search a query sequence against a library of covariance models, And view multiple sequence alignments And family annotation. The database can also be downloaded in flatfile form And searched locally using the INFERNAL package (http://infernal.wustl.edu/). The first release of Rfam (1.0) contains 25 families, which annotate over 50 000 non-coding RNA genes in the taxonomic divisions of the EMBL nucleotide database. 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Cite.__formatAbstractPreview(System.String)">
 <summary>
 摘要可能会有空值的
 </summary>
 <param name="absLen"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.Parameter">
 <summary>
 You Cann assign the parameter value using the parameter's alias name in the scripting using this attribute.
 (你可以使用本属性将函数的参数名进行重命名，这样子你就可以使用本属性得到一个书写更加漂亮的编程脚本文件了)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.ParameterInfo">
 <summary>
 请使用这个方法<see cref="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.GetParameterNameAlias(System.Reflection.ParameterInfo,Microsoft.VisualBasic.Scripting.MetaData.Parameter)"></see>来获取参数信息
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.Alias">
 <summary>
 The alias name of this function parameter in the scripting.(脚本函数的参数的别名)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.Description">
 <summary>
 The description information in the scripting help system.(在帮助信息里面进行显示的本参数的简要的描述信息)  
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.#ctor(System.String,System.String)">
 <summary>
 You can using this attribute to customize your API interface.
 </summary>
 <param name="Alias">The alias name of this function parameter in the scripting.(当前脚本函数的这个参数的别名)</param>
 <param name="MyDescription">The description information in the scripting help system.(这个信息会显示在脚本环境的帮助系统之中)</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.GetAliasNameView(System.Reflection.ParameterInfo)">
 <summary>
 当没有定义属性的时候，会返回参数名
 </summary>
 <param name="pInfo"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.Url">
 <summary>
 This plugins project's home page url.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.Publisher">
 <summary>
 Your name or E-Mail
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.Cites">
 <summary>
 这个脚本模块包的文献引用列表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.#ctor(Microsoft.VisualBasic.CommandLine.Reflection.Namespace)">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
 <param name="ns"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.#ctor(Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace)">
 <summary>
 拷贝自身
 </summary>
 <param name="base"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.#ctor(System.String)">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
 <param name="[Namespace]"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageNamespace.#ctor">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.SoftwareTools">
 <summary>
 API for facilities of the software development.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.ResearchTools">
 <summary>
 Analysis Tools API that applied on your scientific research or industry production on computer science.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.UtilityTools">
 <summary>
 Something small utilities for facility the scripting, makes your programming more easily.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.CLI_MAN">
 <summary>
 CLI program help manual.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.OverloadsSignatureHandle">
 <summary>
 用于解决函数重载的函数数字签名的属性
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.OverloadsSignatureHandle.#ctor(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="TypeIdBrief">Brief name for the target signature type <paramref name="FullName"></paramref></param>
 <param name="FullName">Target signature type for function overloads.</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ExternalCall">
 <summary>
 Shell object for the external script running.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ExternalCall.__host">
 <summary>
 脚本宿主的可执行文件的路径
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="host">The program its file name to run the script</param>
 <param name="ext">File extension name of this type of script</param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.Run(System.String,System.Collections.Specialized.NameValueCollection)">
 <summary>
 
 </summary>
 <param name="script">The script content</param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.Shell(System.String,System.Collections.Specialized.NameValueCollection)">
 <summary>
 
 </summary>
 <param name="path">The script file path</param>
 <param name="args"></param>
 <returns></returns>
 <remarks>Perl脚本测试通过！</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShellValue">
 <summary>
 Script shell result.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.STD_OUT">
 <summary>
 Standard output on the console
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.STD_ERR">
 <summary>
 Standard error
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.state">
 <summary>
 Process exit code
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShellValue.GetObject``1(System.Func{System.String,``0})">
 <summary>
 Parsing object from the standard output
 </summary>
 <typeparam name="T"></typeparam>
 <param name="parser">Object parser</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserAPI.TokenParser``1(Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser{``0},System.String,Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens{``0})">
 <summary>
 
 </summary>
 <typeparam name="Tokens"></typeparam>
 <param name="parser"></param>
 <param name="expr">表达式字符串</param>
 <param name="stackT"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserAPI.TryCast``1(Microsoft.VisualBasic.Scripting.TokenIcer.Token{``0})">
 <summary>
 Try cast the token value to a .NET object based on the token type name.
 </summary>
 <typeparam name="Tokens"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1">
 <summary>
 进行栈树解析所必须要的一些基本元素
 </summary>
 <typeparam name="Tokens"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.Pretend">
 <summary>
 Pretend the root tokens as a true node
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.ParamDeli">
 <summary>
 参数的分隔符，一般是逗号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.LPair">
 <summary>
 向下一层堆栈符号，一般是左括号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.RPair">
 <summary>
 向上一层出栈符号，一般是右括号
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.Equals(`0,`0)">
 <summary>
 Tokens equals?
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens`1.#ctor(System.Func{`0,`0,System.Boolean})">
 <summary>
 Tokens equals? 
 </summary>
 <param name="equals"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.Func`1.ToArray(Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens{`0})">
 <summary>
 将表达式的栈空间展开
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.PeekToken`1">
 <summary>
 A PeekToken object class
 </summary>
 <remarks>
 A PeekToken is a special pointer object that can be used to Peek() several
 tokens ahead in the GetToken() queue.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.Token`1">
 <summary>
 a Token object class
 </summary>
 <typeparam name="Tokens">应该是枚举类型</typeparam>
 <remarks>
 A Token object holds the token and token value.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.Token`1.TokenName">
 <summary>
 Token type
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.Token`1.TokenValue">
 <summary>
 The text that makes up the token.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.Token`1.UNDEFINED">
 <summary>
 务必要保持0为未定义
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.Token`1.IsNumeric">
 <summary>
 Returns a Boolean value indicating whether an expression can be evaluated as
 a number.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.Prefix">
 <summary>
 预定义的一些脚本的解析程序
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.Prefix.MathTokens">
 <summary>
 Tokens is an enumeration of all possible token values.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.Prefix.MathParserHash">
 <summary>
 These lines add each grammar rule to the dictionary
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.StackParser">
 <summary>
 Stack tree parser
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.StackParser.Parsing``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Scripting.TokenIcer.Token{``0}},Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens{``0})">
 <summary>
 返回顶层的根节点
 </summary>
 <param name="source"></param>
 <param name="stackT">Pretend the root tokens as a true node</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.StackParser.__parsing``1(System.Collections.Generic.Queue{Microsoft.VisualBasic.Scripting.TokenIcer.Token{``0}},Microsoft.VisualBasic.Scripting.TokenIcer.StackTokens{``0})">
 <summary>
 主要是解析当前的栈层之中的使用，逗号分隔的参数列表
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1">
 <summary>
 TokenParser
 </summary>
 <remarks>
 TokenParser is the main parser engine for converting input into lexical tokens.
 
 Auto Generated from
 http://www.codeproject.com/Articles/220042/Easily-Create-Your-Own-Parser
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.InputString">
 <summary>
 InputString Property
 </summary>
 <value>
 The string value that holds the input string.
 </value>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.String}},`0)">
 <summary>
 Default Constructor
 </summary>
 <param name="tokens">Values is the regex expression</param>
 <remarks>
 The constructor initalizes memory and adds all of the tokens to the token dictionary.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.#ctor(System.Collections.Generic.Dictionary{`0,System.String},`0)">
 <summary>
 Default Constructor
 </summary>
 <param name="tokens">Values is the regex expression</param>
 <remarks>
 The constructor initalizes memory and adds all of the tokens to the token dictionary.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.PrepareRegex">
 <summary>
 PrepareRegex prepares the regex for parsing by pre-matching the Regex tokens.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.ResetParser">
 <summary>
 ResetParser resets the parser to its inital state. Reloading InputString is required.
 </summary>
 <seealso cref="P:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.InputString" />
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.GetToken">
 <summary>
 GetToken gets the next token in queue
 </summary>
 <remarks>
 GetToken attempts to the match the next character(s) using the
 Regex rules defined in the dictionary. If a match can not be
 located, then an Undefined token will be created with an empty
 string value. In addition, the token pointer will be incremented
 by one so that this token doesn't attempt to get identified again by
 GetToken()
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.Peek">
 <summary>
 Returns the next token that GetToken() will return.
 </summary>
 <seealso cref="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.Peek(Microsoft.VisualBasic.Scripting.TokenIcer.PeekToken{`0})" />
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.Peek(Microsoft.VisualBasic.Scripting.TokenIcer.PeekToken{`0})">
 <summary>
 Returns the next token after the Token passed here
 </summary>
 <param name="peekToken">The PeekToken token returned from a previous Peek() call</param>
 <seealso cref="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenParser`1.Peek" />
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Casting">
 <summary>
 Methods for convert the <see cref="T:System.String"/> to some .NET data types.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Casting.As``1(System.Object)">
 <summary>
 DirectCast(obj, T)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Casting.val(System.String)">
 <summary>
 Will processing value NaN automatically and strip for the comma.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Casting.CastInteger(System.String)">
 <summary>
 出错会返回默认是0
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Casting.CastCommandLine(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.Collections.Generic.IEnumerable{System.String},System.Boolean)"/>
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Casting.CastImage(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.LoadImage(System.Byte[])"/>
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.InputHandler">
 <summary>
 转换从终端或者脚本文件之中输入的字符串的类型的转换
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.InputHandler.LoadObject">
 <summary>
 在脚本编程之中将用户输入的字符串数据转换为目标类型的方法接口
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.CasterString">
 <summary>
 Object为字符串类型，这个字典可以讲字符串转为目标类型
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.String,System.Type)">
 <summary>
 Converts a string expression which was input from the console or script file to the specified type.
 (请注意，函数只是转换最基本的数据类型，转换错误会返回空值)
 </summary>
 <param name="Expression">The string expression to convert.</param>
 <param name="TargetType">The type to which to convert the object.</param>
 <returns>An object whose type at run time is the requested target type.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic``1(System.String)">
 <summary>
 Converts a string expression which was input from the console or script file to the specified type.
 (请注意，函数只是转换最基本的数据类型，转换错误会返回空值)
 </summary>
 <param name="Expression">The string expression to convert.</param>
 <typeparam name="T">The type to which to convert the object.</typeparam>
 <returns>An object whose type at run time is the requested target type.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.IsPrimitive(System.Type)">
 <summary>
 Does this type can be cast from the <see cref="T:System.String"/> type?(目标类型能否由字符串转换过来??)
 </summary>
 <param name="targetType"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CapabilityPromise(System.String,System.Type,System.Func{System.String,System.Object})">
 <summary>
 Dynamics updates the capability of function <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.String,System.Type)"/>, 
 <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic``1(System.String)"/> and 
 <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.IsPrimitive(System.Type)"/>
 </summary>
 <param name="briefName"></param>
 <param name="stringConvertType"></param>
 <param name="cast"></param>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.Types">
 <summary>
 Enumerate all of the types that can be handled in this module. All of the key string is in lower case.(键值都是小写的)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.GetType(System.String,System.Boolean)">
 <summary>
 类型获取失败会返回空值，大小写不敏感
 </summary>
 <param name="name">类型的名称简写</param>
 <param name="ObjectGeneric">是否出错的时候返回Object类型，默认返回Nothing</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.String">
 <summary>
 <see cref="T:System.Type"/> information for <see cref="T:System.String"/> type from GetType operator
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.Convertible(System.Type,System.Type)">
 <summary>
 Does the <paramref name="inputtype"/> type can be cast to type <paramref name="DefType"/>.(主要为了方便减少脚本编程模块的代码)
 </summary>
 <param name="inputType"></param>
 <param name="DefType"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object)">
 <summary>
 <seealso cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.__toStringInternal(System.Object)"/>, 出现错误的时候总是会返回空字符串的
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CastArray``1(System.Object)">
 <summary>
 The parameter <paramref name="obj"/> should implements a <see cref="T:System.Collections.IEnumerable"/> interface on the type. and then DirectCast object to target type.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.DirectCast(System.Object[],System.Type)">
 <summary>
 
 </summary>
 <param name="array"></param>
 <param name="type">数组里面的元素的类型</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter">
 <summary>
 Provides JSON formatting functionality.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter.Format(System.String)">
 <summary>
 Returns a 'pretty printed' version of the specified JSON string, formatted for human
 consumption.
 </summary>
 <param name="json">A valid JSON string.</param>
 <returns>A 'pretty printed' version of the specified JSON string.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter.Minify(System.String)">
 <summary>
 Returns a 'minified' version of the specified JSON string, stripped of all 
 non-essential characters.
 </summary>
 <param name="json">A valid JSON string.</param>
 <returns>A 'minified' version of the specified JSON string.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.JsonContract">
 <summary>
 Only works on the Public visible type.
 (使用.NET系统环境之中自带的框架进行JSON序列化和反序列化)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetJson(System.Object,System.Type,System.Boolean)">
 <summary>
 使用<see cref="T:System.Web.Script.Serialization.ScriptIgnoreAttribute"/>来屏蔽掉不想序列化的属性
 </summary>
 <param name="obj"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetJson``1(``0,System.Boolean)">
 <summary>
 Gets the json text value of the target object, the attribute <see cref="T:System.Web.Script.Serialization.ScriptIgnoreAttribute"/> 
 can be used for block the property which is will not serialize to the text.
 (使用<see cref="T:System.Web.Script.Serialization.ScriptIgnoreAttribute"/>来屏蔽掉不想序列化的属性)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="json">null -> Nothing</param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject``1(System.String)">
 <summary>
 JSON反序列化
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructFormatter.Serialize``1(``0,System.String)">
 <summary>
 Save a structure type object into a binary file.(使用二进制序列化保存一个对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructFormatter.Load``1(System.String)">
 <summary>
 Load a strucutre object from the file system by using binary serializer deserialize.
 (使用反二进制序列化从指定的文件之中加载一个对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer">
 <summary>
 Some times these method is not works well, not sure why?
 </summary>
 <remarks>
 http://blog.csdn.net/zztoll/article/details/8695992
 
 Marshal类的两个方法StructureToPtr和PtrToStructure实现序列化
 
 我们主要是使用Marshal类里的两个方法：
 
 第一个是StructureToPtr，将数据从托管对象封送到非托管内存块。
 第二个是PtrToStructure，将数据从非托管内存块封送到新分配的指定类型的托管对象。
 
 只要有了这两个相互转换的方法，我们就可以实现序列化了。
 
 首先我们先来看下序列化
 
 序列化：
 
 有一个前提条件，那就是我们必须要知道需要序列化对象的大小。
 
 第一步：我们先求出对象的大小，然后在非托管内存中给它分配相应的内存大小。
 第二步：接着我们就把这个对象封送到刚分配出来的内存中，之后我们会得到一个分配出来的内存块首地址指针。
 第三步：最后我们可以通过这个首地址指针，从指针所指的位置处开始，拷贝数据到指定的byte[]数组中，
 拷贝的长度就是我们为这个对象分配出来的内存大小，得到byte[]数据后，下面的事情我就不用多说了，
 你可以保存到数据库或者文件中。
 
 反序列化：
 
 序列化的时候我们先将一个对象封送到了非托管内存块中，然后再把内存块中的数据读到byte[]数组中，
 
 现在我们反序列化
 
 第一步：我们先求出对象的大小，然后在非托管内存中给它分配相应的内存大小。
 第二步：然后把这个byte[]数据拷贝到非托管内存块中。
 第三步：最后再从内存块中封送指定大小的数据到对象中。
 
 有一个地方需要注意，那就是因为引用类型的对象我们是无法求的它的实际大小的，所以这里的对象我们只能使用非托管对象，比如struct结构体。
 所以，当我们只是用来存储数据，不涉及任何操作的对象，我们可以把它作为一个结构体来处理，这样我们在序列化的时候可以节省空间开销。
 因为你如果你要是用平常的序列化方法去序列化一个类对象，他所需要的空间开销是要大于你去序列化一个具有相同结构的struct对象。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer.StructureToByte``1(``0)">
 <summary>
 由结构体转换为byte数组(字符串类型以及Class类型都将会被序列化为内存指针，所以这个函数只适合于值类型的)
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer.ByteToStructure``1(System.Byte[])">
 <summary>
 由byte数组转换为结构体(字符串类型以及Class类型都将会被序列化为内存指针，所以这个函数只适合于值类型的)
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.BufferAPI">
 <summary>
 适用于对变长的流的操作
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.MappingsIgnored">
 <summary>
 这个属性或者方法不会被用于映射
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.UseCustomMapping">
 <summary>
 不会使用系统自带的映射方法进行映射
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.Source">
 <summary>
 映射的文本文件源
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.Mapping">
 <summary>
 映射操作的目标数据模型
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.SourceToMappingCasting">
 <summary>
 从源映射到数据模型的类型转换
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.MappingToSourceCasting">
 <summary>
 从数据模型映射到源的类型转换
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.DynamicsConfiguration.LoadDocument``1(System.String)">
 <summary>
 加载完数据之后返回其自身
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.__StringTypeCaster">
 <summary>
 数据类型转换方法的句柄对象
 </summary>
 <param name="data">源之中的数据，由于源是一个TEXT格式的数据文件，故而这里的数据类型为字符串，通过本句柄对象可以将字符串数据映射为其他的复杂数据类型</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.ConfigurationMappings">
 <summary>
 最基本的思想是将属性值按照同名属性名称在A和B两个对象类型之间进行映射，即A与B两个对象之间必须要具备相同的属性名称，才可以产生映射，请注意在本对象之中仅能够映射最基本的值类型的数据类型
 对于一些自定义的映射操作，请在目标数据模型之中定义自定义的映射函数，要求为函数只有一个参数，参数类型和返回值类型分别为映射的两个节点的数据类型，程序会使用反射自动查找
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.LoadMapping``2(``1)">
 <summary>
 从源江基本的值类型映射到数据模型，以将配置数据读取出来并进行加载
 </summary>
 <typeparam name="T_Entity">数据模型</typeparam>
 <typeparam name="T_Mapping">源</typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.WriteMapping``2(``0)">
 <summary>
 从数据模型将值类型数据映射回源，以将配置数据写入文件
 </summary>
 <typeparam name="T_Entity">数据模型</typeparam>
 <typeparam name="T_Mapping">源</typeparam>
 <param name="Model"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.GetNodeMapping``2(System.Object)">
 <summary>
 获取从源映射至数据模型的映射过程
 </summary>
 <typeparam name="T_Entity">数据模型</typeparam>
 <typeparam name="T_Mapping">源</typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ShadowsCopy.ShadowsCopy``1(``0)">
 <summary>
 将目标对象之中的属性按值复制
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks>对外函数接口，为了防止无限递归的出现</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ShadowsCopy.ShadowsCopy(System.Object)">
 <summary>
 将目标对象之中的属性按值复制
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks>对外函数接口，为了防止无限递归的出现</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ShadowsCopy.__shadowsCopy(System.Type,System.Object)">
 <summary>
 递归使用的，基本数据类型直接复制，引用类型则首先创建一个新的对象，在对该对象进行递归复制，假若目标对象没有可用的无参数的构造函数，则直接赋值
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ShadowsCopy.ShadowCopy``1(``0,``0@)">
 <summary>
 请使用这个函数来对CSV序列化的对象进行浅拷贝。将<paramref name="source"/>之中的第一层的属性值拷贝到<paramref name="target"/>对应的属性值之中，然后返回<paramref name="target"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="Target"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ShadowsCopy.ShadowCopy``2(``0)">
 <summary>
 将第一层的属性值从基本类复制给继承类
 </summary>
 <typeparam name="Tbase"></typeparam>
 <typeparam name="TInherits"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.ShadowsCopyOpr`1">
 <summary>
 批量拷贝需要使用这个模块来执行
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.ShadowsCopyOpr`2">
 <summary>
 批量拷贝需要使用这个模块来执行
 </summary>
 <typeparam name="Tbase"></typeparam>
 <typeparam name="TInherits"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Text.ParserValue`1">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>这个对象的用途和<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1"/>对象的用途是一致的，只不过差异在于所想要表达的寓意上面</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.ToString">
 <summary>
 &lt;?xml version="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.version"/>}" encoding="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.encoding"/>}" standalone="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.standalone"/>}"?>
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Xmlns">
 <summary>
 Xml namespace
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.Set(System.String,System.String)">
 <summary>
 Set the value of a new xml namespace.(<paramref name="ns"/>命名空间参数不需要添加 xmlns: 前缀)
 </summary>
 <param name="ns"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.RootParser(System.String)">
 <summary>
 The parser for the xml root node.
 </summary>
 <param name="root"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.WriteNamespace(System.Text.StringBuilder)">
 <summary>
 
 </summary>
 <param name="xml"></param>
 <remarks>当前的这个对象是新值，需要替换掉文档里面的旧值</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.XmlDoc">
 <summary>
 请使用<see cref="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.ToString"/>方法获取修改之后的Xml文档
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.XmlDoc.xmlns">
 <summary>
 Xml namespace definitions
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.#ctor(System.String)">
 <summary>
 Create a xml tools from xml document text.
 </summary>
 <param name="xml"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.ToString">
 <summary>
 使用这个函数可以得到修改之后的Xml文档
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.SaveTo(System.String,System.Text.Encoding)">
 <summary>
 Me.ToString.SaveTo(Path, encoding)
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.FormattedParser">
 <summary>
 Parser API for the well formatted documents.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.FormattedParser.FlagSplit(System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
 <summary>
 String collection tokens by a certain delimiter string element.
 </summary>
 <param name="source"></param>
 <param name="isFlag">
 
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.FormattedParser.CrossFields(System.String)">
 <summary>
 Example as: ------- ------ -----    ------- ------ -----   ---- --  --------   ----------- 
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.FormattedParser.FieldParser(System.String,System.Int32[])">
 <summary>
 Parsing a line of string into several fields fragments based on the fields length.
 </summary>
 <param name="s">The input text line.</param>
 <param name="pos">The text length of each field property value.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.FormattedParser.DoContinute">
 <summary>
 Condition for continue move the parser pointer.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.FormattedParser.ReadHead(System.String[],System.Int32@,Microsoft.VisualBasic.Text.FormattedParser.DoContinute)">
 <summary>
 Parsing the document head section from the document.
 </summary>
 <param name="buf"></param>
 <param name="offset">
 This function will returns the new offset value from this reference parameter.
 (从这里向调用者返回偏移量)
 </param>
 <param name="__isHead">Condition for continue move the parser pointer to the next line.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.StatementMatches">
 <summary>
 其他的匹配方法是基于字符的，这个是基于单词的比对
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.StatementMatches.Match(System.String,System.String,System.Boolean)">
 <summary>
 基于字符的比较
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.StatementMatches.MatchFuzzy(System.String,System.String,System.Boolean,System.Double)">
 <summary>
 基于单词的比较
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <param name="strict"></param>
 <param name="cut"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.StatementMatches.__tokenEquals">
 <summary>
 字符串模糊等价
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.BipartiteMatcher">
 <summary>
 Summary description for StringMatcher.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.Similarity">
 <summary>
 Summary description for StringMatcher.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.ISimilarity">
 <summary>
 Summary description for IEditDistance.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.Leven">
 <summary>
 Summary description for Leven.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.FuzzyMatchString.__fuzzyCharEquals(System.Char,System.Char)">
 <summary>
 忽略大小写
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.FuzzyMatchString.Equals(System.String,System.String,System.Boolean,System.Double)">
 <summary>
 两个参数字符串是否模糊等价？
 </summary>
 <param name="string1"></param>
 <param name="string2"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.FuzzyMatchString.StringSelection(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Double)">
 <summary>
 从一个不直接相等的字符串列表之中模糊的查找出匹配度最高的目标字符串
 </summary>
 <param name="query"></param>
 <param name="List"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.Tokeniser">
 <summary>
 Summary description for Tokeniser.
 Partition string off into subwords
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.UnbufferedStringReader">
 <summary>
 Represents a reader that can read a sequential series of characters.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Close">
 <summary>
 Closes the System.IO.TextReader and releases any system resources associated
 with the TextReader.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Peek">
 <summary>
 Reads the next character without changing the state of the reader or the character
 source. Returns the next available character without actually reading it from
 the reader.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Read">
 <summary>
 Reads the next character from the text reader and advances the character position
 by one character.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Read(System.Char[],System.Int32,System.Int32)">
 <summary>
 Reads a specified maximum number of characters from the current reader and writes
 the data to a buffer, beginning at the specified index.
 </summary>
 <param name="buffer"></param>
 <param name="index"></param>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.ReadLine">
 <summary>
 Reads a line of characters from the text reader and returns the data as a string.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.ReadToEnd">
 <summary>
 Reads all characters from the current position to the end of the text reader
 and returns them as one string.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.UnbufferedStringReader.Position">
 <summary>
 The current read position.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Splitter">
 <summary>
 Split strings with support to multi-character, multi-lines Delimiter
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Splitter.m_Expression">
 <summary>
 Holds the string to split
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Splitter.m_Delimiter">
 <summary>
 Delimiter to split the expression with
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Splitter.#ctor">
 <summary>
 Constrctor for The Splitter
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextSegment">
 <summary>
 文本之中的一个片段
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextSegment.Segment">
 <summary>
 当前的这个文本片段的字符串值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextSegment.Array">
 <summary>
 ASCII值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextSegment.Index">
 <summary>
 在原始文本之中的左端起始位置
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextIndexing.PreCache">
 <summary>
 为了用于加速批量匹配计算的效率而生成的一个缓存对象
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextIndexing.#ctor(System.String,System.Int32,System.Int32)">
 <summary>
 Creates a text index instance object for the statement fuzzy match in the whole text document.
 </summary>
 <param name="text"></param>
 <param name="min"></param>
 <param name="max"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextIndexing.Found(System.String,System.Double,System.Int32)">
 <summary>
 
 </summary>
 <param name="keyword"></param>
 <param name="cutoff"></param>
 <param name="NumPartitions">负数表示不进行分区</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextIndexing.Found(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="keyword"></param>
 <param name="cutoff">表示出现连续的m匹配的片段的长度,-1表示所搜索的关键词片段的长度一半</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextIndexing.IsMatch(System.String,System.Int32)">
 <summary>
 函数返回最长的匹配的个数，-1表示没有匹配
 </summary>
 <param name="m"></param>
 <param name="cutoff"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.GB2312">
 <summary>
 汉字拼音转换类
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.GB2312.otherChinese">
 <summary>
 二级汉字数组
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.GB2312.otherPinYin">
 <summary>
 二级汉字对应拼音数组
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.GetFirst(System.Char)">
 <summary>
 取拼音第一个字段
 </summary>        
 <param name="ch"></param>        
 <returns></returns>        
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.GetFirst(System.String)">
 <summary>
 取拼音第一个字段
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.Get(System.Char)">
 <summary>
 获取单字拼音
 </summary>
 <param name="ch"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.Get(System.String)">
 <summary>
 把汉字转换成拼音(全拼)
 </summary>
 <param name="str">汉字字符串</param>
 <returns>转换后的拼音(全拼)字符串</returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextGrepMethodToken">
 <summary>
 
 </summary>
 <param name="source">文本源</param>
 <param name="paras">脚本命令的参数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextGrepScriptEngine">
 <summary>
 A script object for grep the gene id in the blast output query and subject title.(用于解析基因名称的脚本类，这个对象是在项目的初始阶段，为了方便命令行操作而设置的)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Text.TextGrepScriptEngine._Operations">
 <summary>
 Source,Script,ReturnValue
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextGrepScriptEngine.Compile(System.String)">
 <summary>
 对用户所输入的脚本进行编译，对于内部的空格，请使用单引号'进行分割
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextGrepScriptEngine.Method">
 <summary>
 字符串剪裁操作的函数指针
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextGrepScriptEngine.Grep(System.String)">
 <summary>
 修整目标字符串，按照脚本之中的方法取出所需要的字符串信息
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextGrepScriptEngine.Tokens(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="Source"></param>
 <param name="Script"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextGrepScriptEngine.MidString(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="source"></param>
 <param name="ScriptTokens">向量之中的第一个元素为命令的名字，第二个元素为Mid函数的Start参数，第三个元素为Mid函数的Length参数，可以被忽略掉</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextFileEncodingDetector">
 <summary>
 Encoding fileEncoding = TextFileEncodingDetector.DetectTextFileEncoding("you file path",Encoding.Default);
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextFileEncodingDetector.DetectTextFileEncoding(System.String,System.Text.Encoding)">
 <summary>
 completely arbitrary - inappropriate for high numbers of files / high speed requirements
 </summary>
 <param name="InputFilename"></param>
 <param name="DefaultEncoding"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.hBitmap">
 <summary>
 线程不安全的图片数据对象
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hBitmap.GetImage">
 <summary>
 Gets a copy of the original raw image value that which constructed this bitmap object class
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hBitmap.GetIndex(System.Int32,System.Int32)">
 <summary>
 返回第一个元素的位置
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns>B, G, R</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hBitmap.GetPixel(System.Int32,System.Int32)">
 <summary>
 Gets the color of the specified pixel in this System.Drawing.Bitmap.
 </summary>
 <param name="x">The x-coordinate of the pixel to retrieve.</param>
 <param name="y">The y-coordinate of the pixel to retrieve.</param>
 <returns>A System.Drawing.Color structure that represents the color of the specified pixel.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hBitmap.SetPixel(System.Int32,System.Int32,System.Drawing.Color)">
 <summary>
 Sets the color of the specified pixel in this System.Drawing.Bitmap.(这个函数线程不安全)
 </summary>
 <param name="x">The x-coordinate of the pixel to set.</param>
 <param name="y">The y-coordinate of the pixel to set.</param>
 <param name="color">
 A System.Drawing.Color structure that represents the color to assign to the specified
 pixel.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hBitmap.FromImage(System.Drawing.Image)">
 <summary>
 这个函数会自动复制原始图片数据里面的东西的
 </summary>
 <param name="res"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.hcBitmap.Binarization(System.Drawing.Bitmap@,Microsoft.VisualBasic.Imaging.hcBitmap.BinarizationStyles)">
 <summary>
 
 </summary>
 <param name="curBitmap"></param>
 <remarks>
 http://www.codeproject.com/Articles/1094534/Image-Binarization-Using-Program-Languages
 
 The .net Bitmap object keeps a reference to HBITMAP handle, Not to the underlying bitmap itself.
 So, single pixel access call to <see cref="M:System.Drawing.Bitmap.SetPixel(System.Int32,System.Int32,System.Drawing.Color)"/>/<see cref="M:System.Drawing.Bitmap.GetPixel(System.Int32,System.Int32)"/> Or 
 even retrieve Width/Height properties does something Like: 
 lock handle In place-Get/Set value/unlock handle. It Is the most inefficient way To manipulate bitmaps In .NET. 
 The author should read about <see cref="M:System.Drawing.Bitmap.LockBits(System.Drawing.Rectangle,System.Drawing.Imaging.ImageLockMode,System.Drawing.Imaging.PixelFormat)"/> first.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.IGraphics">
 <summary>
 Encapsulates a GDI+/SVG etc drawing surface. This class must be inherited.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorExtensions.__allDotNETPrefixColors">
 <summary>
 Key都是小写的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.ColorExtensions.AllDotNetPrefixColors">
 <summary>
 Gets all of the known name color from the Color object its shared property.
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorExtensions.RGB_EXPRESSION">
 <summary>
 解析颜色表达式里面的RGB的正则表达式
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorExtensions.ToColor(System.String)">
 <summary>
 
 </summary>
 <param name="str">颜色表达式或者名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorExtensions.IsNullOrEmpty(System.Drawing.Color)">
 <summary>
 Determine that the target color value is a empty variable.(判断目标颜色值是否为空值)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.FontFace">
 <summary>
 Font names collection
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.FontFace.MicrosoftYaHei">
 <summary>
 微软雅黑字体的名称
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ColorCube">
 <summary>
 Describes the RGB color space as a 3D cube with the origin at Black.
 </summary>
 <remarks>
 http://social.technet.microsoft.com/wiki/contents/articles/20990.generate-color-sequences-using-rgb-color-cube-in-vb-net.aspx
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.Compare(System.Drawing.Color,System.Drawing.Color)">
 <summary>
 Compares two colors according to their distance from the origin of the cube (black).
 </summary>
 <param name="source"></param>
 <param name="target"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetBrightness(System.Drawing.Color)">
 <summary>
 Returns an integer between 0 and 255 indicating the perceived brightness of the color.
 </summary>
 <param name="target">A System.Drawing.Color instance.</param>
 <returns>An integer indicating the brightness with 0 being dark and 255 being bright.</returns>
 <remarks>
 Formula found using web search at:
 http://www.nbdtech.com/Blog/archive/2008/04/27/Calculating-the-Perceived-Brightness-of-a-Color.aspx This link is external to TechNet Wiki. It will open in a new window.
 with reference to : http://alienryderflex.com/hsp.html This link is external to TechNet Wiki. It will open in a new window.
 Effectively the same as measuring a color's distance from black, but constrained to a 0-255 range.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorFrom(System.Int32,System.Int32,System.Int32)">
 <summary>
 Gets a color from within the cube starting at the origin and moving a given distance in the specified direction.
 </summary>
 <param name="azimuth">The side-to-side angle in degrees; 0 points toward red and 90 points toward blue.</param>
 <param name="elevation">The top-to-bottom angle in degrees; 0 is no green and 90 points toward full green.</param>
 <param name="distance">The distance to travel within the cube; 500 is max.</param>
 <returns>The color within the cube at the given distance in the specified direction.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorFrom(System.Drawing.Color,System.Double,System.Double,System.Double,System.Boolean)">
 <summary>
 Gets a color from within the cube starting at the specified location and moving a given distance in the specified direction.
 </summary>
 <param name="source">The source location within the cube from which to start moving.</param>
 <param name="azimuth">The side-to-side angle in degrees; 0 points toward red and 90 points toward blue.</param>
 <param name="elevation">The top-to-bottom angle in degrees; 0 is no green and 90 points toward full green.</param>
 <param name="distance">The distance to travel within the cube; the approximate distance from black to white is 500.</param>
 <returns>The color within the cube at the given distance in the specified direction.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorsAround(System.Drawing.Color,System.Int32,System.Int32)">
 <summary>
 Creates an array of colors from a selection within a sphere around the specified color.
 </summary>
 <param name="target">The color to select around.</param>
 <param name="distance">The radius of the selection sphere.</param>
 <param name="increment">The increment within the sphere at which a selection is taken; larger numbers result in smaller selection sets.</param>
 <returns>An array of colors located around the specified color within the cube.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorSequence(System.Drawing.Color,System.Drawing.Color,System.Int32)">
 <summary>
 Creates an array of colors in a gradient sequence between two specified colors.
 </summary>
 <param name="source">The starting color in the sequence.</param>
 <param name="target">The end color in the sequence.</param>
 <param name="increment">The increment between colors.</param>
 <returns>A gradient array of colors.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorSpectrum(System.Int32)">
 <summary>
 Creates a rainbow array of colors by selecting from the edges of the cube in ROYGBIV order at the specified increment.
 </summary>
 <param name="increment">The increment along the edges at which a selection is taken; larger numbers result in smaller selection sets.</param>
 <returns>An array of colors in ROYGBIV order at the given increment.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetDistance(System.Drawing.Color,System.Drawing.Color)">
 <summary>
 Gets the distance between two colors within the cube.
 </summary>
 <param name="source">The source color in the cube.</param>
 <param name="target">The target color in the cube.</param>
 <returns>The distance between the source and target colors.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetHSL(System.Drawing.Color)">
 <summary>
 Converts a RGB color into its Hue, Saturation, and Luminance (HSL) values.
 </summary>
 <param name="rgb">The color to convert.</param>
 <returns>The HSL representation of the color.</returns>
 <remarks>
 Source algorithm found using web search at:
 http://geekymonkey.com/Programming/CSharp/RGB2HSL_HSL2RGB.htm This link is external to TechNet Wiki. It will open in a new window.
 (Adapted to VB)
 </remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.HSLColor">
 <summary>
 Describes a RGB color in Hue, Saturation, and Luminance values.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.H">
 <summary>
 The color hue.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.S">
 <summary>
 The color saturation.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.L">
 <summary>
 The color luminance.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ColorMapsExtensions">
 <summary>
 Create Custom Color Maps
 </summary>
 <remarks>http://www.codeproject.com/Articles/18150/Create-Custom-Color-Maps-in-C</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMapsExtensions.ColorSequence(Microsoft.VisualBasic.Imaging.ColorMapsExtensions.MapsFunc,Microsoft.VisualBasic.Imaging.ColorMap,System.Int32)">
 <summary>
 
 </summary>
 <param name="Maps"></param>
 <param name="map"><see cref="P:Microsoft.VisualBasic.Imaging.ColorMap.MaxDepth"/></param>
 <param name="min">value should smaller than <see cref="P:Microsoft.VisualBasic.Imaging.ColorMap.MaxDepth"/> in parameter <paramref name="map"/></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Imaging.ColorMap.Alpha">
 <summary>
 Alpha value in the RBG color function.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMap.Jet">
 <summary>
 *
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle">
 <summary>
 GDI+ device handle for encapsulates a GDI+ drawing surface.(GDI+绘图设备句柄)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Graphics">
 <summary>
 GDI+ device handle.(GDI+绘图设备句柄)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.ImageResource">
 <summary>
 GDI+ device handle memory.(GDI+设备之中的图像数据)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Size">
 <summary>
 Gets the width and height, in pixels, of this image.(图像的大小)
 </summary>
 <returns>A System.Drawing.Size structure that represents the width and height, in pixels,
 of this image.</returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Center">
 <summary>
 在图象上面的中心的位置点
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Save(System.String,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 将GDI+设备之中的图像数据保存到指定的文件路径之中，默认的图像文件的格式为PNG格式
 </summary>
 <param name="Path"></param>
 <param name="Format">默认为png格式</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Save(System.String,System.Drawing.Imaging.ImageFormat)">
 <summary>
 将GDI+设备之中的图像数据保存到指定的文件路径之中，默认的图像文件的格式为PNG格式
 </summary>
 <param name="Path"></param>
 <param name="Format">默认为png格式</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.CreateDevice(System.Drawing.Size,System.Drawing.Color)">
 <summary>
 
 </summary>
 <param name="r"></param>
 <param name="filled">所填充的颜色</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.Dispose">
 <summary>
 Releases all resources used by this System.Drawing.Graphics.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.CompositingMode">
 <summary>
 Gets a value that specifies how composited images are drawn to this System.Drawing.Graphics.
 </summary>
 <returns>
 This property specifies a member of the System.Drawing.Drawing2D.CompositingMode enumeration. 
 The default is System.Drawing.Drawing2D.CompositingMode.SourceOver.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.CompositingQuality">
 <summary>
 Gets or sets the rendering quality of composited images drawn to this System.Drawing.Graphics.
 </summary>
 <returns>
 This property specifies a member of the System.Drawing.Drawing2D.CompositingQuality enumeration. 
 The default is System.Drawing.Drawing2D.CompositingQuality.Default.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.DpiX">
 <summary>
 Gets the horizontal resolution of this System.Drawing.Graphics.
 </summary>
 <returns>
 The value, in dots per inch, for the horizontal resolution supported by this System.Drawing.Graphics.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.InterpolationMode">
 <summary>
 Gets or sets the interpolation mode associated with this System.Drawing.Graphics.
 </summary>
 <returns>One of the System.Drawing.Drawing2D.InterpolationMode values.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.DrawBézier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)">
 <summary>
 Draws a Bézier spline defined by four System.Drawing.Point structures.
 </summary>
 <param name="pen">System.Drawing.Pen structure that determines the color, width, and style of the
 curve.</param>
 <param name="pt1">System.Drawing.Point structure that represents the starting point of the curve.</param>
 <param name="pt2">System.Drawing.Point structure that represents the first control point for the
 curve.</param>
 <param name="pt3">System.Drawing.Point structure that represents the second control point for the
 curve.</param>
 <param name="pt4">System.Drawing.Point structure that represents the ending point of the curve.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)">
 <summary>
 Draws a line connecting two System.Drawing.Point structures.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the line.</param>
 <param name="pt1">System.Drawing.Point structure that represents the first point to connect.</param>
 <param name="pt2">System.Drawing.Point structure that represents the second point to connect.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)">
 <summary>
 Draws the specified text string in the specified rectangle with the specified
 System.Drawing.Brush and System.Drawing.Font objects.
 </summary>
 <param name="s">String to draw.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="brush">System.Drawing.Brush that determines the color and texture of the drawn text.</param>
 <param name="layoutRectangle">System.Drawing.RectangleF structure that specifies the location of the drawn
 text.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)">
 <summary>
 Draws the specified text string at the specified location with the specified
 System.Drawing.Brush and System.Drawing.Font objects.
 </summary>
 <param name="s">String to draw.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="brush">System.Drawing.Brush that determines the color and texture of the drawn text.</param>
 <param name="point">System.Drawing.PointF structure that specifies the upper-left corner of the drawn
 text.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle.MeasureString(System.String,System.Drawing.Font)">
 <summary>
 Measures the specified string when drawn with the specified System.Drawing.Font.
 </summary>
 <param name="text">String to measure.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <returns>This method returns a System.Drawing.SizeF structure that represents the size,
 in the units specified by the System.Drawing.Graphics.PageUnit property, of the
 string specified by the text parameter as drawn with the font parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDITransform.RotateImage(System.Drawing.Image,System.Single)">
 <summary>
 Creates a new Image containing the same image only rotated
 </summary>
 <param name="image">The <see cref="T:System.Drawing.Image"/> to rotate</param>
 <param name="angle">The amount to rotate the image, clockwise, in degrees</param>
 <returns>A new <see cref="T:System.Drawing.Bitmap"/> that is just large enough
 to contain the rotated image without cutting any corners off.</returns>
 <exception cref="T:System.ArgumentNullException">Thrown if <see cref="T:System.Drawing.Image"/> is null.</exception>
 <remarks>
 
 Explaination of the calculations

 The trig involved in calculating the new width and height
 is fairly simple; the hard part was remembering that when 
 PI/2 &lt;= theta &lt;= PI and 3PI/2 &lt;= theta &lt; 2PI the width and 
 height are switched.
  
 When you rotate a rectangle, r, the bounding box surrounding r
 contains for right-triangles of empty space.  Each of the 
 triangles hypotenuse's are a known length, either the width or
 the height of r.  Because we know the length of the hypotenuse
 and we have a known angle of rotation, we can use the trig
 function identities to find the length of the other two sides.
  
 sine = opposite/hypotenuse
 cosine = adjacent/hypotenuse
  
 solving for the unknown we get
  
 opposite = sine * hypotenuse
 adjacent = cosine * hypotenuse
  
 Another interesting point about these triangles is that there
 are only two different triangles. The proof for which is easy
 to see, but its been too long since I've written a proof that
 I can't explain it well enough to want to publish it.  
  
 Just trust me when I say the triangles formed by the lengths 
 width are always the same (for a given theta) and the same 
 goes for the height of r.
  
 Rather than associate the opposite/adjacent sides with the
 width and height of the original bitmap, I'll associate them
 based on their position.
  
 adjacent/oppositeTop will refer to the triangles making up the 
 upper right and lower left corners
  
 adjacent/oppositeBottom will refer to the triangles making up 
 the upper left and lower right corners
  
 The names are based on the right side corners, because thats 
 where I did my work on paper (the right side).
  
 Now if you draw this out, you will see that the width of the 
 bounding box is calculated by adding together adjacentTop and 
 oppositeBottom while the height is calculate by adding 
 together adjacentBottom and oppositeTop.
 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.TiffWriter.SaveToExistingFile(System.String,System.Drawing.Image[],System.String)">
 <summary>
 This function can save newly scanned images on existing single page or multipage file
 </summary>
 <param name="fileName"></param>
 <param name="bmp"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ImageFormats">
 <summary>
 Specifies the file format of the image.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Bmp">
 <summary>
 Gets the bitmap (BMP) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Emf">
 <summary>
 Gets the enhanced metafile (EMF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Exif">
 <summary>
 Gets the Exchangeable Image File (Exif) format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Gif">
 <summary>
 Gets the Graphics Interchange Format (GIF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Icon">
 <summary>
 Gets the Windows icon image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Jpeg">
 <summary>
 Gets the Joint Photographic Experts Group (JPEG) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.MemoryBmp">
 <summary>
 Gets the format of a bitmap in memory.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Png">
 <summary>
 Gets the W3C Portable Network Graphics (PNG) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Tiff">
 <summary>
 Gets the Tagged Image File Format (TIFF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Wmf">
 <summary>
 Gets the Windows metafile (WMF) image format.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ImageFormatExtensions">
 <summary>
 Specifies the file format of the image. Not inheritable.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageFormatExtensions.SaveAs(System.Drawing.Image,System.String,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Saves this <see cref="T:System.Drawing.Image"/> to the specified file in the specified format.
 </summary>
 <param name="res">The image resource data that will be saved to the disk</param>
 <param name="path">path string</param>
 <param name="format">Image formats enumeration.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.GrayBitmap">
 <summary>
 Download by http://www.codefans.net
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GrayBitmap.DrawGrayBitmap(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Chang the bitmap to gray bitmap in hdc.
 </summary>
 <param name="hdc"></param>
 <param name="nx"></param>
 <param name="ny"></param>
 <param name="nWidth"></param>
 <param name="nHeight"></param>
 <param name="nMaskColor"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.GDIPlusExtensions">
 <summary>
 GDI+
 </summary>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.LoadImage(System.String)">
 <summary>
 Load image from a file and then close the file handle.
 (使用<see cref="M:System.Drawing.Image.FromFile(System.String)"/>函数在加载完成图像到Dispose这段之间内都不会释放文件句柄，
 则使用这个函数则没有这个问题，在图片加载之后会立即释放掉文件句柄)
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.GetRawStream(System.Drawing.Image)">
 <summary>
 将图片对象转换为原始的字节流
 </summary>
 <param name="image"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.MeasureString(System.String,System.Drawing.Font,System.Single,System.Single)">
 <summary>
 Measures the specified string when drawn with the specified System.Drawing.Font.
 </summary>
 <param name="s">String to measure.</param>
 <param name="Font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="XScaleSize"></param>
 <param name="YScaleSize"></param>
 <returns>This method returns a System.Drawing.SizeF structure that represents the size,
 in the units specified by the System.Drawing.Graphics.PageUnit property, of the
 string specified by the text parameter as drawn with the font parameter.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.ImageAddFrame(Microsoft.VisualBasic.Imaging.GDIPlusDeviceHandle,System.Drawing.Pen,System.Int32)">
 <summary>
 Adding a frame box to the target image source.(为图像添加边框)
 </summary>
 <param name="Handle"></param>
 <param name="pen">Default pen width is 1px and with color <see cref="P:System.Drawing.Color.Black"/>.(默认的绘图笔为黑色的1个像素的边框)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.CreateGDIDevice(System.Drawing.SizeF,System.Drawing.Color)">
 <summary>
 创建一个GDI+的绘图设备
 </summary>
 <param name="r"></param>
 <param name="filled">默认的背景填充颜色为白色</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.GDIPlusDeviceHandleFromImageFile(System.String)">
 <summary>
 从指定的文件之中加载GDI+设备的句柄
 </summary>
 <param name="path"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.GdiFromImage(System.Drawing.Image,System.String)">
 <summary>
 无需处理图像数据，这个函数已经自动克隆了该对象，不会影响到原来的对象
 </summary>
 <param name="res"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.CreateGDIDevice(System.Drawing.Size,System.Drawing.Color,System.String)">
 <summary>
 创建一个GDI+的绘图设备
 </summary>
 <param name="r"></param>
 <param name="filled">默认的背景填充颜色为白色</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.ImageCrop(System.Drawing.Image,System.Drawing.Point,System.Drawing.Size)">
 <summary>
 图片剪裁小方块区域
 </summary>
 <param name="pos">左上角的坐标位置</param>
 <param name="size">剪裁的区域的大小</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.TrimRoundAvatar(System.Drawing.Image,System.Int32)">
 <summary>
 图片剪裁为圆形的头像
 </summary>
 <param name="resAvatar">要求为正方形或者近似正方形</param>
 <param name="OutSize"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.Vignette(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Color)">
 <summary>
 羽化
 </summary>
 <param name="Image"></param>
 <param name="y1"></param>
 <param name="y2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIPlusExtensions.CorpBlank(System.Drawing.Image,System.Int32,System.Drawing.Color)">
 <summary>
 确定边界，然后进行剪裁
 </summary>
 <param name="res"></param>
 <param name="margin"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathMatch.__pairs(System.String[],System.String[],System.Func{System.String,System.String})">
 <summary>
 <paramref name="paths1"/>的元素要比<paramref name="path2"/>多
 </summary>
 <param name="paths1"></param>
 <param name="path2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.NumberGroups">
 <summary>
 Simple number vector grouping
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.LICENSE">
 <summary>
 Information about this VisualBasic App framework code module.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.LICENSE.GPL3">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="M:Microsoft.VisualBasic.LICENSE.GithubRepository">
 <summary>
 https://github.com/xieguigang/VisualBasic_AppFramework
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.WebResult">
 <summary>
 The data structure for represents the search result of the Web search egine.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Title">
 <summary>
 Specifies the Title element of the result string. 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.BriefText">
 <summary>
 In short description of the link produced. 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.URL">
 <summary>
 Url that points to the Current result.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Update">
 <summary>
 Update time.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Site">
 <summary>
 Returns the root domain name.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.HTTP_RFC">
 <summary>
 The following is a list of Hypertext Transfer Protocol (HTTP) response status codes. This includes codes from IETF internet standards 
 as well as other IETF RFCs, other specifications and some additional commonly used codes. The first digit of the status code specifies 
 one of five classes of response; the bare minimum for an HTTP client is that it recognises these five classes. The phrases used are the 
 standard examples, but any human-readable alternative can be provided. Unless otherwise stated, the status code is part of the HTTP/1.1 
 standard (RFC 7231).

 The Internet Assigned Numbers Authority (IANA) maintains the official registry Of HTTP status codes.

 Microsoft IIS sometimes uses additional Decimal Sub-codes To provide more specific information, but these are Not listed here.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONTINUTE">
 <summary>
 100 Continue |
 This means that the server has received the request headers, And that the client should proceed To send the request body 
 (In the Case Of a request For which a body needs To be sent; For example, a POST request). If the request body Is large, 
 sending it To a server When a request has already been rejected based upon inappropriate headers Is inefficient. 
 To have a server check If the request could be accepted based On the request's headers alone, a client must send Expect: 
 100-continue as a header in its initial request and check if a 100 Continue status code is received in response before 
 continuing (or receive 417 Expectation Failed and not continue).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SWITCHING_PROTOCOLS">
 <summary>
 101 Switching Protocols |
 This means the requester has asked the server To switch protocols And the server Is acknowledging that it will Do so.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PROCESSING">
 <summary>
 102 Processing (WebDAV; RFC 2518) |
 As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. 
 This code indicates that the server has received And Is processing the request, but no response Is available yet.[3] 
 This prevents the client from timing out And assuming the request was lost.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK">
 <summary>
 200 OK |
 Standard response For successful HTTP requests. The actual response will depend On the request method used. In a Get request, 
 the response will contain an entity corresponding To the requested resource. In a POST request, the response will contain an 
 entity describing Or containing the result Of the action.
 (由于可能会修改附带一些其他的元素据信息，所以只读属性不会使用简写的形式的，而是需要重新生成新的对象实例以防止数据污染)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CREATED">
 <summary>
 201 Created |
 The request has been fulfilled And resulted In a New resource being created.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_ACCEPTED">
 <summary>
 202 Accepted |
 The request has been accepted For processing, but the processing has Not been completed. The request might Or might Not eventually be acted upon, 
 As it might be disallowed When processing actually takes place.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NON_AUTH_INFO">
 <summary>
 203 Non-Authoritative Information (since HTTP/1.1) |
 The server successfully processed the request, but Is returning information that may be from another source.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_CONTENT">
 <summary>
 204 No Content |
 The server successfully processed the request, but Is Not returning any content.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RESET_CONTENT">
 <summary>
 205 Reset Content |
 The server successfully processed the request, but Is Not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PARTIAL_CONTENT">
 <summary>
 206 Partial Content (RFC 7233) |
 The server Is delivering only part Of the resource (Byte serving) due To a range header sent by the client. 
 The range header Is used by HTTP clients To enable resuming Of interrupted downloads, Or split a download into multiple simultaneous streams.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MULTI_STATUS">
 <summary>
 207 Multi-Status (WebDAV; RFC 4918) |
 The message body that follows Is an XML message And can contain a number Of separate response codes, depending On how many Sub-requests were made.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_ALREADY_REPORTED">
 <summary>
 208 Already Reported (WebDAV; RFC 5842) |
 The members Of a DAV binding have already been enumerated In a previous reply To this request, And are Not being included again.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_IM_USED">
 <summary>
 226 IM Used (RFC 3229) |
 The server has fulfilled a request For the resource, And the response Is a representation Of the result Of one Or more instance-manipulations applied To the current instance.[5]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MULTI_CHOICES">
 <summary>
 300 Multiple Choices |
 Indicates multiple options For the resource that the client may follow. It, For instance, could be used To present different 
 format options For video, list files With different extensions, Or word sense disambiguation.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MOVED_PERMANENTLY">
 <summary>
 301 Moved Permanently |
 This And all future requests should be directed to the given URI.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FOUND">
 <summary>
 302 Found |
 This Is an example of industry practice contradicting the standard. The HTTP/1.0 specification (RFC 1945) required the client 
 to perform a temporary redirect (the original describing phrase was "Moved Temporarily"),[6] but popular browsers implemented 
 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 And 307 to distinguish between the 
 two behaviours.[7] However, some Web applications And frameworks use the 302 status code as if it were the 303.[8]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SEE_OTHER">
 <summary>
 303 See Other (since HTTP/1.1) |
 The response To the request can be found under another URI Using a Get method. When received In response To a POST (Or PUT/DELETE), 
 it should be assumed that the server has received the data And the redirect should be issued With a separate Get message.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_MODIFIED">
 <summary>
 304 Not Modified (RFC 7232) |
 Indicates that the resource has Not been modified since the version specified by the request headers If-Modified-Since Or If-None-Match. 
 This means that there Is no need To retransmit the resource, since the client still has a previously-downloaded copy.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_USE_PROXY">
 <summary>
 305 Use Proxy (since HTTP/1.1) |
 The requested resource Is only available through a proxy, whose address Is provided In the response. Many HTTP clients 
 (such As Mozilla[9] And Internet Explorer) Do Not correctly handle responses With this status code, primarily For security reasons.[10]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SWITCH_PROXY">
 <summary>
 306 Switch Proxy |
 No longer used. Originally meant "Subsequent requests should use the specified proxy."[11]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TEMP_REDIRECT">
 <summary>
 307 Temporary Redirect (since HTTP/1.1) |
 In this case, the request should be repeated with another URI; however, future requests should still use the original URI. 
 In contrast to how 302 was historically implemented, the request method Is Not allowed to be changed when reissuing the original request. 
 For instance, a POST request should be repeated using another POST request.[12]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PERMANENT_REDIRECT">
 <summary>
 308 Permanent Redirect (RFC 7538) |
 The request, and all future requests should be repeated Using another URI. 307 And 308 (As proposed) parallel the behaviours 
 Of 302 And 301, but Do Not allow the HTTP method To change. So, For example, submitting a form To a permanently redirected resource may Continue smoothly.[13]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RESUME_INCOMPLETE">
 <summary>
 308 Resume Incomplete (Google) |
 This code Is used In the Resumable HTTP Requests Proposal To Resume aborted PUT Or POST requests.[14]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BAD_REQUEST">
 <summary>
 400 Bad Request |
 The server cannot Or will Not process the request due To something that Is perceived To be a client Error (e.g., malformed request syntax, 
 invalid request message framing, Or deceptive request routing).[15]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNAUTHORIZED">
 <summary>
 401 Unauthorized (RFC 7235) |
 Similar to 403 Forbidden, but specifically for use when authentication Is required And has failed Or has Not yet been provided. 
 The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. 
 See Basic access authentication And Digest access authentication.(证书未认证)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PAYMENT_REQUIRED">
 <summary>
 402 Payment Required |
 Reserved for future use. The original intention was that this code might be used as part of some form of digital cash Or micropayment scheme, 
 but that has Not happened, And this code Is Not usually used. YouTube uses this status if a particular IP address has made excessive requests, 
 And requires the person to enter a CAPTCHA.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FORBIDDEN">
 <summary>
 403 Forbidden |
 The request was a valid request, but the server Is refusing To respond To it. Unlike a 401 Unauthorized response, authenticating will make no difference.
 (被封号了)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_FOUND">
 <summary>
 404 Not Found |
 The requested resource could Not be found but may be available again In the future. Subsequent requests by the client are permissible.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_METHOD_NOT_ALLOWED">
 <summary>
 405 Method Not Allowed |
 A request was made Of a resource Using a request method Not supported by that resource; For example, 
 Using Get On a form which requires data To be presented via POST, Or Using PUT On a read-only resource.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_ACCEPTABLE">
 <summary>
 406 Not Acceptable |
 The requested resource Is only capable Of generating content Not acceptable according To the Accept headers sent In the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PROXY_AUTH_REQUIRED">
 <summary>
 407 Proxy Authentication Required (RFC 7235) |
 The client must first authenticate itself With the proxy.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_TIMEOUT">
 <summary>
 408 Request Timeout |
 The server timed out waiting For the request. According To HTTP specifications: 
 "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
 (请求超时)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONFLICT">
 <summary>
 409 Conflict |
 Indicates that the request could Not be processed because Of conflict In the request, such As an edit conflict In the Case Of multiple updates.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_GONE">
 <summary>
 410 Gone |
 Indicates that the resource requested Is no longer available And will Not be available again. 
 This should be used When a resource has been intentionally removed And the resource should be purged. 
 Upon receiving a 410 status code, the client should Not request the resource again In the future. 
 Clients such As search engines should remove the resource from their indices.[16] Most use cases 
 Do Not require clients And search engines To purge the resource, And a "404 Not Found" may be used instead.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LENGTH_REQUIRED">
 <summary>
 411 Length Required |
 The request did Not specify the length Of its content, which Is required by the requested resource.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PRECONDITION_FAILED">
 <summary>
 412 Precondition Failed (RFC 7232) |
 The server does Not meet one Of the preconditions that the requester put On the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PAYLOAD_TOO_LARGE">
 <summary>
 413 Payload Too Large (RFC 7231) |
 The request Is larger than the server Is willing Or able To process. Called "Request Entity Too Large " previously.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_URI_TOO_LONG">
 <summary>
 414 Request-URI Too Long |
 The URI provided was too Long For the server To process. Often the result Of too much data being encoded As a query-String Of a Get request, In which Case it should be converted To a POST request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNSUPPORTED_MEDIA_TYPE">
 <summary>
 415 Unsupported Media Type |
 The request entity has a media type which the server Or resource does Not support. For example, the client uploads an image As image/svg+xml, but the server requires that images use a different format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RANGE_NOT_SATISFIABLE">
 <summary>
 416 Requested Range Not Satisfiable (RFC 7233) |
 The client has asked For a portion Of the file (Byte serving), but the server cannot supply that portion. For example, If the client asked For a part Of the file that lies beyond the End Of the file.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_EXPECTATION_FAILED">
 <summary>
 417 Expectation Failed |
 The server cannot meet the requirements Of the Expect request-header field.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_IM_TEAPOT">
 <summary>
 418 I'm a teapot (RFC 2324) |
 This code was defined In 1998 As one Of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, 
 and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by tea pots requested to brew coffee.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_AUTH_TIMEOUT">
 <summary>
 419 Authentication Timeout (Not in RFC 2616) |
 Not a part of the HTTP standard, 419 Authentication Timeout denotes that previously valid authentication has expired. 
 It Is used as an alternative to 401 Unauthorized in order to differentiate from otherwise authenticated clients being denied access to specific server resources.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_METHOD_FAILURE">
 <summary>
 420 Method Failure (Spring Framework) |
 Not part of the HTTP standard, but defined by Spring in the HttpStatus class to be used when a method failed. This status code Is deprecated by Spring.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_ENHANCE_YOUR_CALM">
 <summary>
 420 Enhance Your Calm (Twitter) |
 Not part of the HTTP standard, but returned by version 1 of the Twitter Search And Trends API when the client Is being rate limited.[17] 
 Other services may wish to implement the 429 Too Many Requests response code instead.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MISDIRECTED_REQUEST">
 <summary>
 421 Misdirected Request (HTTP/2) |
 The request was directed at a server that Is Not able To produce a response (For example because a connection reuse).[18]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNPROCESSABLE_ENTITY">
 <summary>
 422 Unprocessable Entity (WebDAV; RFC 4918) |
 The request was well-formed but was unable To be followed due To semantic errors.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOCKED">
 <summary>
 423 Locked (WebDAV; RFC 4918) |
 The resource that Is being accessed Is locked.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FAILED_DEPENDENCY">
 <summary>
 424 Failed Dependency (WebDAV; RFC 4918) |
 The request failed due To failure Of a previous request (e.g., a PROPPATCH).[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UPGRADE_REQUIRED">
 <summary>
 426 Upgrade Required |
 The client should switch To a different protocol such As TLS/1.0, given In the Upgrade header field.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PRECONDITION_REQUIRED">
 <summary>
 428 Precondition Required (RFC 6585) |
 The origin server requires the request To be conditional. Intended To prevent "the 'lost update' problem, 
 where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party 
 has modified the state on the server, leading to a conflict."[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TOO_MANY_REQUEST">
 <summary>
 429 Too Many Requests (RFC 6585) |
 The user has sent too many requests In a given amount Of time. Intended For use With rate limiting schemes.[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_HEADER_FIELDS_TOO_LARGE">
 <summary>
 431 Request Header Fields Too Large (RFC 6585) |
 The server Is unwilling To process the request because either an individual header field, Or all the header fields collectively, are too large.[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOGIN_TIMEOUT">
 <summary>
 440 Login Timeout (Microsoft) |
 A Microsoft extension. Indicates that your session has expired.[20]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_RESPONSE">
 <summary>
 444 No Response (Nginx) |
 Used in Nginx logs to indicate that the server has returned no information to the client And closed the connection (useful as a deterrent for malware).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RETRY_WITH">
 <summary>
 449 Retry With (Microsoft) |
 A Microsoft extension. The request should be retried after performing the appropriate action.[21]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BLOCKED">
 <summary>
 450 Blocked by Windows Parental Controls (Microsoft) |
 A Microsoft extension. This Error Is given When Windows Parental Controls are turned On And are blocking access To the given webpage.[22]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LEGAL_UNAVAILABLE">
 <summary>
 451 Unavailable For Legal Reasons (Internet draft) |
 Defined in the internet draft "A New HTTP Status Code for Legally-restricted Resources".[23] 
 Intended to be used when resource access Is denied for legal reasons, e.g. censorship Or government-mandated blocked access. 
 A reference to the 1953 dystopian novel Fahrenheit 451, where books are outlawed.[24]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REDIRECT">
 <summary>
 451 Redirect (Microsoft) |
 Used in Exchange ActiveSync if there either Is a more efficient server to use Or the server cannot access the users' mailbox.[25]
 The client Is supposed To re-run the HTTP Autodiscovery protocol To find a better suited server.[26]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_HEADER_TOO_LARGE">
 <summary>
 494 Request Header Too Large (Nginx) |
 Nginx internal code similar To 431 but it was introduced earlier In version 0.9.4 (On January 21, 2011).[27][original research?]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CERT_ERROR">
 <summary>
 495 Cert Error (Nginx) |
 Nginx internal code used When SSL client certificate Error occurred To distinguish it from 4XX In a log And an Error page redirection.
 (在SSL层解密的时候错误，则为证书错误)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_CERT">
 <summary>
 496 No Cert (Nginx) |
 Nginx internal code used When client didn't provide certificate to distinguish it from 4XX in a log and an error page redirection.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_HTTP_TO_HTTPS">
 <summary>
 497 HTTP to HTTPS (Nginx) |
 Nginx internal code used For the plain HTTP requests that are sent To HTTPS port To distinguish it from 4XX In a log And an Error page redirection.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TOKEN_INVALID">
 <summary>
 498 Token expired/invalid (Esri) |
 Returned by ArcGIS For Server. A code Of 498 indicates an expired Or otherwise invalid token.[28]
 (错误的参数信息)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CLOSED_REQUEST">
 <summary>
 499 Client Closed Request (Nginx) |
 Used in Nginx logs to indicate when the connection has been closed by client while the server Is still processing its request, making server unable to send a status code back.[29]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TOKEN_REQUIRED">
 <summary>
 499 Token required (Esri) |
 Returned by ArcGIS For Server. A code Of 499 indicates that a token Is required (If no token was submitted).[28]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_INTERNAL_SERVER_ERROR">
 <summary>
 500 Internal Server Error |
 A generic Error message, given When an unexpected condition was encountered And no more specific message Is suitable.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_IMPLEMENTED">
 <summary>
 501 Not Implemented |
 The server either does Not recognize the request method, Or it lacks the ability To fulfill the request. Usually this implies future availability (e.g., a New feature Of a web-service API).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BAD_GATEWAY">
 <summary>
 502 Bad Gateway |
 The server was acting As a gateway Or proxy And received an invalid response from the upstream server.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SERVICE_UNAVAILABLE">
 <summary>
 503 Service Unavailable |
 The server Is currently unavailable (because it Is overloaded Or down For maintenance). Generally, this Is a temporary state.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_GATEWAY_TIMEOUT">
 <summary>
 504 Gateway Timeout |
 The server was acting As a gateway Or proxy And did Not receive a timely response from the upstream server.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_VERSION_NOT_SUPPORTED">
 <summary>
 505 HTTP Version Not Supported |
 The server does Not support the HTTP protocol version used In the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NEGOTIATES">
 <summary>
 506 Variant Also Negotiates (RFC 2295) |
 Transparent content negotiation For the request results In a circular reference.[30]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_INSUFFICIENT_STORAGE">
 <summary>
 507 Insufficient Storage (WebDAV; RFC 4918) |
 The server Is unable To store the representation needed To complete the request.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOOP_DETECTED">
 <summary>
 508 Loop Detected (WebDAV; RFC 5842) |
 The server detected an infinite Loop While processing the request (sent In lieu Of 208 Already Reported).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BANDWIDTH_LIMITED_EXCEEDED">
 <summary>
 509 Bandwidth Limit Exceeded (Apache bw/limited extension)[31] |
 This status code Is Not specified In any RFCs. Its use Is unknown.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_EXTENDED">
 <summary>
 510 Not Extended (RFC 2774) |
 Further extensions To the request are required For the server To fulfil it.[32]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NETWORK_AUTH_REQUIRED">
 <summary>
 511 Network Authentication Required (RFC 6585) |
 The client needs To authenticate To gain network access. Intended For use by intercepting proxies used To control access To the network 
 (e.g., "captive portals" used To require agreement To Terms Of Service before granting full Internet access via a Wi-Fi hotspot).[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNKNOWN_ERROR">
 <summary>
 520 Unknown Error |
 This status code Is Not specified In any RFC And Is returned by certain services, For instance Microsoft Azure And CloudFlare servers: 
 "The 520 error is essentially a “catch-all” response for when the origin server returns something unexpected or something that is not 
 tolerated/interpreted (protocol violation or empty response)."[33]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONNECTION_TIMEOUT">
 <summary>
 522 Origin Connection Time-out |
 This status code Is Not specified In any RFCs, but Is used by CloudFlare's reverse proxies to signal that a server connection timed out.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_READ_TIMEOUT_ERROR">
 <summary>
 598 Network read timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network read timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONNECT_TIMEOUT_ERROR">
 <summary>
 599 Network connect timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network connect timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.NetResponse">
 <summary>
 The following is a list of Hypertext Transfer Protocol (HTTP) response status codes. This includes codes from IETF internet standards 
 as well as other IETF RFCs, other specifications and some additional commonly used codes. The first digit of the status code specifies 
 one of five classes of response; the bare minimum for an HTTP client is that it recognises these five classes. The phrases used are the 
 standard examples, but any human-readable alternative can be provided. Unless otherwise stated, the status code is part of the HTTP/1.1 
 standard (RFC 7231).

 The Internet Assigned Numbers Authority (IANA) maintains the official registry Of HTTP status codes.

 Microsoft IIS sometimes uses additional Decimal Sub-codes To provide more specific information, but these are Not listed here.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CONTINUTE">
 <summary>
 100 Continue |
 This means that the server has received the request headers, And that the client should proceed To send the request body 
 (In the Case Of a request For which a body needs To be sent; For example, a POST request). If the request body Is large, 
 sending it To a server When a request has already been rejected based upon inappropriate headers Is inefficient. 
 To have a server check If the request could be accepted based On the request's headers alone, a client must send Expect: 
 100-continue as a header in its initial request and check if a 100 Continue status code is received in response before 
 continuing (or receive 417 Expectation Failed and not continue).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_SWITCHING_PROTOCOLS">
 <summary>
 101 Switching Protocols |
 This means the requester has asked the server To switch protocols And the server Is acknowledging that it will Do so.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PROCESSING">
 <summary>
 102 Processing (WebDAV; RFC 2518) |
 As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. 
 This code indicates that the server has received And Is processing the request, but no response Is available yet.[3] 
 This prevents the client from timing out And assuming the request was lost.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_OK">
 <summary>
 200 OK |
 Standard response For successful HTTP requests. The actual response will depend On the request method used. In a Get request, 
 the response will contain an entity corresponding To the requested resource. In a POST request, the response will contain an 
 entity describing Or containing the result Of the action.
 (由于可能会修改附带一些其他的元素据信息，所以只读属性不会使用简写的形式的，而是需要重新生成新的对象实例以防止数据污染)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CREATED">
 <summary>
 201 Created |
 The request has been fulfilled And resulted In a New resource being created.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_ACCEPTED">
 <summary>
 202 Accepted |
 The request has been accepted For processing, but the processing has Not been completed. The request might Or might Not eventually be acted upon, 
 As it might be disallowed When processing actually takes place.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NON_AUTH_INFO">
 <summary>
 203 Non-Authoritative Information (since HTTP/1.1) |
 The server successfully processed the request, but Is returning information that may be from another source.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NO_CONTENT">
 <summary>
 204 No Content |
 The server successfully processed the request, but Is Not returning any content.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_RESET_CONTENT">
 <summary>
 205 Reset Content |
 The server successfully processed the request, but Is Not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PARTIAL_CONTENT">
 <summary>
 206 Partial Content (RFC 7233) |
 The server Is delivering only part Of the resource (Byte serving) due To a range header sent by the client. 
 The range header Is used by HTTP clients To enable resuming Of interrupted downloads, Or split a download into multiple simultaneous streams.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_MULTI_STATUS">
 <summary>
 207 Multi-Status (WebDAV; RFC 4918) |
 The message body that follows Is an XML message And can contain a number Of separate response codes, depending On how many Sub-requests were made.[4]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_ALREADY_REPORTED">
 <summary>
 208 Already Reported (WebDAV; RFC 5842) |
 The members Of a DAV binding have already been enumerated In a previous reply To this request, And are Not being included again.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_IM_USED">
 <summary>
 226 IM Used (RFC 3229) |
 The server has fulfilled a request For the resource, And the response Is a representation Of the result Of one Or more instance-manipulations applied To the current instance.[5]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_MULTI_CHOICES">
 <summary>
 300 Multiple Choices |
 Indicates multiple options For the resource that the client may follow. It, For instance, could be used To present different 
 format options For video, list files With different extensions, Or word sense disambiguation.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_MOVED_PERMANENTLY">
 <summary>
 301 Moved Permanently |
 This And all future requests should be directed to the given URI.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_FOUND">
 <summary>
 302 Found |
 This Is an example of industry practice contradicting the standard. The HTTP/1.0 specification (RFC 1945) required the client 
 to perform a temporary redirect (the original describing phrase was "Moved Temporarily"),[6] but popular browsers implemented 
 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 And 307 to distinguish between the 
 two behaviours.[7] However, some Web applications And frameworks use the 302 status code as if it were the 303.[8]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_SEE_OTHER">
 <summary>
 303 See Other (since HTTP/1.1) |
 The response To the request can be found under another URI Using a Get method. When received In response To a POST (Or PUT/DELETE), 
 it should be assumed that the server has received the data And the redirect should be issued With a separate Get message.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NOT_MODIFIED">
 <summary>
 304 Not Modified (RFC 7232) |
 Indicates that the resource has Not been modified since the version specified by the request headers If-Modified-Since Or If-None-Match. 
 This means that there Is no need To retransmit the resource, since the client still has a previously-downloaded copy.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_USE_PROXY">
 <summary>
 305 Use Proxy (since HTTP/1.1) |
 The requested resource Is only available through a proxy, whose address Is provided In the response. Many HTTP clients 
 (such As Mozilla[9] And Internet Explorer) Do Not correctly handle responses With this status code, primarily For security reasons.[10]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_SWITCH_PROXY">
 <summary>
 306 Switch Proxy |
 No longer used. Originally meant "Subsequent requests should use the specified proxy."[11]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_TEMP_REDIRECT">
 <summary>
 307 Temporary Redirect (since HTTP/1.1) |
 In this case, the request should be repeated with another URI; however, future requests should still use the original URI. 
 In contrast to how 302 was historically implemented, the request method Is Not allowed to be changed when reissuing the original request. 
 For instance, a POST request should be repeated using another POST request.[12]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PERMANENT_REDIRECT">
 <summary>
 308 Permanent Redirect (RFC 7538) |
 The request, and all future requests should be repeated Using another URI. 307 And 308 (As proposed) parallel the behaviours 
 Of 302 And 301, but Do Not allow the HTTP method To change. So, For example, submitting a form To a permanently redirected resource may Continue smoothly.[13]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_RESUME_INCOMPLETE">
 <summary>
 308 Resume Incomplete (Google) |
 This code Is used In the Resumable HTTP Requests Proposal To Resume aborted PUT Or POST requests.[14]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_BAD_REQUEST">
 <summary>
 400 Bad Request |
 The server cannot Or will Not process the request due To something that Is perceived To be a client Error (e.g., malformed request syntax, 
 invalid request message framing, Or deceptive request routing).[15]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_UNAUTHORIZED">
 <summary>
 401 Unauthorized (RFC 7235) |
 Similar to 403 Forbidden, but specifically for use when authentication Is required And has failed Or has Not yet been provided. 
 The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. 
 See Basic access authentication And Digest access authentication.(证书未认证)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PAYMENT_REQUIRED">
 <summary>
 402 Payment Required |
 Reserved for future use. The original intention was that this code might be used as part of some form of digital cash Or micropayment scheme, 
 but that has Not happened, And this code Is Not usually used. YouTube uses this status if a particular IP address has made excessive requests, 
 And requires the person to enter a CAPTCHA.[citation needed]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_FORBIDDEN">
 <summary>
 403 Forbidden |
 The request was a valid request, but the server Is refusing To respond To it. Unlike a 401 Unauthorized response, authenticating will make no difference.
 (被封号了)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NOT_FOUND">
 <summary>
 404 Not Found |
 The requested resource could Not be found but may be available again In the future. Subsequent requests by the client are permissible.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_METHOD_NOT_ALLOWED">
 <summary>
 405 Method Not Allowed |
 A request was made Of a resource Using a request method Not supported by that resource; For example, 
 Using Get On a form which requires data To be presented via POST, Or Using PUT On a read-only resource.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NOT_ACCEPTABLE">
 <summary>
 406 Not Acceptable |
 The requested resource Is only capable Of generating content Not acceptable according To the Accept headers sent In the request.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PROXY_AUTH_REQUIRED">
 <summary>
 407 Proxy Authentication Required (RFC 7235) |
 The client must first authenticate itself With the proxy.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REQUEST_TIMEOUT">
 <summary>
 408 Request Timeout |
 The server timed out waiting For the request. According To HTTP specifications: 
 "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
 (请求超时)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CONFLICT">
 <summary>
 409 Conflict |
 Indicates that the request could Not be processed because Of conflict In the request, such As an edit conflict In the Case Of multiple updates.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_GONE">
 <summary>
 410 Gone |
 Indicates that the resource requested Is no longer available And will Not be available again. 
 This should be used When a resource has been intentionally removed And the resource should be purged. 
 Upon receiving a 410 status code, the client should Not request the resource again In the future. 
 Clients such As search engines should remove the resource from their indices.[16] Most use cases 
 Do Not require clients And search engines To purge the resource, And a "404 Not Found" may be used instead.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_LENGTH_REQUIRED">
 <summary>
 411 Length Required |
 The request did Not specify the length Of its content, which Is required by the requested resource.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PRECONDITION_FAILED">
 <summary>
 412 Precondition Failed (RFC 7232) |
 The server does Not meet one Of the preconditions that the requester put On the request.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PAYLOAD_TOO_LARGE">
 <summary>
 413 Payload Too Large (RFC 7231) |
 The request Is larger than the server Is willing Or able To process. Called "Request Entity Too Large " previously.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_URI_TOO_LONG">
 <summary>
 414 Request-URI Too Long |
 The URI provided was too Long For the server To process. Often the result Of too much data being encoded As a query-String Of a Get request, In which Case it should be converted To a POST request.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_UNSUPPORTED_MEDIA_TYPE">
 <summary>
 415 Unsupported Media Type |
 The request entity has a media type which the server Or resource does Not support. For example, the client uploads an image As image/svg+xml, but the server requires that images use a different format.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_RANGE_NOT_SATISFIABLE">
 <summary>
 416 Requested Range Not Satisfiable (RFC 7233) |
 The client has asked For a portion Of the file (Byte serving), but the server cannot supply that portion. For example, If the client asked For a part Of the file that lies beyond the End Of the file.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_EXPECTATION_FAILED">
 <summary>
 417 Expectation Failed |
 The server cannot meet the requirements Of the Expect request-header field.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_IM_TEAPOT">
 <summary>
 418 I'm a teapot (RFC 2324) |
 This code was defined In 1998 As one Of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, 
 and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by tea pots requested to brew coffee.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_AUTH_TIMEOUT">
 <summary>
 419 Authentication Timeout (Not in RFC 2616) |
 Not a part of the HTTP standard, 419 Authentication Timeout denotes that previously valid authentication has expired. 
 It Is used as an alternative to 401 Unauthorized in order to differentiate from otherwise authenticated clients being denied access to specific server resources.[citation needed]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_METHOD_FAILURE">
 <summary>
 420 Method Failure (Spring Framework) |
 Not part of the HTTP standard, but defined by Spring in the HttpStatus class to be used when a method failed. This status code Is deprecated by Spring.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_ENHANCE_YOUR_CALM">
 <summary>
 420 Enhance Your Calm (Twitter) |
 Not part of the HTTP standard, but returned by version 1 of the Twitter Search And Trends API when the client Is being rate limited.[17] 
 Other services may wish to implement the 429 Too Many Requests response code instead.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_MISDIRECTED_REQUEST">
 <summary>
 421 Misdirected Request (HTTP/2) |
 The request was directed at a server that Is Not able To produce a response (For example because a connection reuse).[18]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_UNPROCESSABLE_ENTITY">
 <summary>
 422 Unprocessable Entity (WebDAV; RFC 4918) |
 The request was well-formed but was unable To be followed due To semantic errors.[4]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_LOCKED">
 <summary>
 423 Locked (WebDAV; RFC 4918) |
 The resource that Is being accessed Is locked.[4]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_FAILED_DEPENDENCY">
 <summary>
 424 Failed Dependency (WebDAV; RFC 4918) |
 The request failed due To failure Of a previous request (e.g., a PROPPATCH).[4]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_UPGRADE_REQUIRED">
 <summary>
 426 Upgrade Required |
 The client should switch To a different protocol such As TLS/1.0, given In the Upgrade header field.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_PRECONDITION_REQUIRED">
 <summary>
 428 Precondition Required (RFC 6585) |
 The origin server requires the request To be conditional. Intended To prevent "the 'lost update' problem, 
 where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party 
 has modified the state on the server, leading to a conflict."[19]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_TOO_MANY_REQUEST">
 <summary>
 429 Too Many Requests (RFC 6585) |
 The user has sent too many requests In a given amount Of time. Intended For use With rate limiting schemes.[19]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REQUEST_HEADER_FIELDS_TOO_LARGE">
 <summary>
 431 Request Header Fields Too Large (RFC 6585) |
 The server Is unwilling To process the request because either an individual header field, Or all the header fields collectively, are too large.[19]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_LOGIN_TIMEOUT">
 <summary>
 440 Login Timeout (Microsoft) |
 A Microsoft extension. Indicates that your session has expired.[20]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NO_RESPONSE">
 <summary>
 444 No Response (Nginx) |
 Used in Nginx logs to indicate that the server has returned no information to the client And closed the connection (useful as a deterrent for malware).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_RETRY_WITH">
 <summary>
 449 Retry With (Microsoft) |
 A Microsoft extension. The request should be retried after performing the appropriate action.[21]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_BLOCKED">
 <summary>
 450 Blocked by Windows Parental Controls (Microsoft) |
 A Microsoft extension. This Error Is given When Windows Parental Controls are turned On And are blocking access To the given webpage.[22]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_LEGAL_UNAVAILABLE">
 <summary>
 451 Unavailable For Legal Reasons (Internet draft) |
 Defined in the internet draft "A New HTTP Status Code for Legally-restricted Resources".[23] 
 Intended to be used when resource access Is denied for legal reasons, e.g. censorship Or government-mandated blocked access. 
 A reference to the 1953 dystopian novel Fahrenheit 451, where books are outlawed.[24]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REDIRECT">
 <summary>
 451 Redirect (Microsoft) |
 Used in Exchange ActiveSync if there either Is a more efficient server to use Or the server cannot access the users' mailbox.[25]
 The client Is supposed To re-run the HTTP Autodiscovery protocol To find a better suited server.[26]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REQUEST_HEADER_TOO_LARGE">
 <summary>
 494 Request Header Too Large (Nginx) |
 Nginx internal code similar To 431 but it was introduced earlier In version 0.9.4 (On January 21, 2011).[27][original research?]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CERT_ERROR">
 <summary>
 495 Cert Error (Nginx) |
 Nginx internal code used When SSL client certificate Error occurred To distinguish it from 4XX In a log And an Error page redirection.
 (在SSL层解密的时候错误，则为证书错误)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NO_CERT">
 <summary>
 496 No Cert (Nginx) |
 Nginx internal code used When client didn't provide certificate to distinguish it from 4XX in a log and an error page redirection.
 (客户端在向ssl服务器发送ssl请求的时候没有应用密匙加密，直接发送明文给服务器了，则服务器直接拒绝请求)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_HTTP_TO_HTTPS">
 <summary>
 497 HTTP to HTTPS (Nginx) |
 Nginx internal code used For the plain HTTP requests that are sent To HTTPS port To distinguish it from 4XX In a log And an Error page redirection.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_TOKEN_INVALID">
 <summary>
 498 Token expired/invalid (Esri) |
 Returned by ArcGIS For Server. A code Of 498 indicates an expired Or otherwise invalid token.[28]
 (错误的参数信息)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CLOSED_REQUEST">
 <summary>
 499 Client Closed Request (Nginx) |
 Used in Nginx logs to indicate when the connection has been closed by client while the server Is still processing its request, making server unable to send a status code back.[29]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_TOKEN_REQUIRED">
 <summary>
 499 Token required (Esri) |
 Returned by ArcGIS For Server. A code Of 499 indicates that a token Is required (If no token was submitted).[28]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_INTERNAL_SERVER_ERROR">
 <summary>
 500 Internal Server Error |
 A generic Error message, given When an unexpected condition was encountered And no more specific message Is suitable.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NOT_IMPLEMENTED">
 <summary>
 501 Not Implemented |
 The server either does Not recognize the request method, Or it lacks the ability To fulfill the request. Usually this implies future availability (e.g., a New feature Of a web-service API).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_BAD_GATEWAY">
 <summary>
 502 Bad Gateway |
 The server was acting As a gateway Or proxy And received an invalid response from the upstream server.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_SERVICE_UNAVAILABLE">
 <summary>
 503 Service Unavailable |
 The server Is currently unavailable (because it Is overloaded Or down For maintenance). Generally, this Is a temporary state.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_GATEWAY_TIMEOUT">
 <summary>
 504 Gateway Timeout |
 The server was acting As a gateway Or proxy And did Not receive a timely response from the upstream server.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_VERSION_NOT_SUPPORTED">
 <summary>
 505 HTTP Version Not Supported |
 The server does Not support the HTTP protocol version used In the request.
 (服务器所不支持的协议类型)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NEGOTIATES">
 <summary>
 506 Variant Also Negotiates (RFC 2295) |
 Transparent content negotiation For the request results In a circular reference.[30]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_INSUFFICIENT_STORAGE">
 <summary>
 507 Insufficient Storage (WebDAV; RFC 4918) |
 The server Is unable To store the representation needed To complete the request.[4]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_LOOP_DETECTED">
 <summary>
 508 Loop Detected (WebDAV; RFC 5842) |
 The server detected an infinite Loop While processing the request (sent In lieu Of 208 Already Reported).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_BANDWIDTH_LIMITED_EXCEEDED">
 <summary>
 509 Bandwidth Limit Exceeded (Apache bw/limited extension)[31] |
 This status code Is Not specified In any RFCs. Its use Is unknown.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NOT_EXTENDED">
 <summary>
 510 Not Extended (RFC 2774) |
 Further extensions To the request are required For the server To fulfil it.[32]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_NETWORK_AUTH_REQUIRED">
 <summary>
 511 Network Authentication Required (RFC 6585) |
 The client needs To authenticate To gain network access. Intended For use by intercepting proxies used To control access To the network 
 (e.g., "captive portals" used To require agreement To Terms Of Service before granting full Internet access via a Wi-Fi hotspot).[19]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_UNKNOWN_ERROR">
 <summary>
 520 Unknown Error |
 This status code Is Not specified In any RFC And Is returned by certain services, For instance Microsoft Azure And CloudFlare servers: 
 "The 520 error is essentially a “catch-all” response for when the origin server returns something unexpected or something that is not 
 tolerated/interpreted (protocol violation or empty response)."[33]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CONNECTION_TIMEOUT">
 <summary>
 522 Origin Connection Time-out |
 This status code Is Not specified In any RFCs, but Is used by CloudFlare's reverse proxies to signal that a server connection timed out.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_READ_TIMEOUT_ERROR">
 <summary>
 598 Network read timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network read timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_CONNECT_TIMEOUT_ERROR">
 <summary>
 599 Network connect timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network connect timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.NetResponse.IsHTTP_RFC(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 服务器所返回来的数据是否为HTTP错误代码
 </summary>
 <param name="response"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.Streams.Array.ArrayAbstract`1.value(System.Int32)">
 <summary>
 由于这个模块是专门应用于服务器端的数据交换的模块，所以稳定性优先，
 这里面的函数都是安全的数组访问方法
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Streams.Array.VarArray`1">
 <summary>
 The bytes length of the element in thee source sequence is not fixed.
 (序列里面的元素的长度是不固定的)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Streams.Array.VarArray`1.Serialize">
 <summary>
 Long + T + Long + T
 其中Long是一个8字节长度的数组，用来指示T的长度
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Streams.Array.ValueArray`1">
 <summary>
 对于<see cref="T:System.Int64"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Double"/>, <see cref="T:System.DateTime"/>
 这些类型的数据来说，进行网络传输的时候使用json会被转换为字符串，数据量比较大，而转换为字节再进行传输，数据流量的消耗会比较小
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>这个是定长的数组序列</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Streams.String">
 <summary>
 字符串序列流
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME">
 <summary>
 MIME stands for "Multipurpose Internet Mail Extensions. It's a way of identifying files on the Internet according to their nature and format. 
 For example, using the "Content-type" header value defined in a HTTP response, the browser can open the file with the proper extension/plugin.
 (http://www.freeformatter.com/mime-types-list.html)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.ExtDict">
 <summary>
 枚举出所有已知的文件拓展名列表
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.ContentTypes">
 <summary>
 根据类型来枚举
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.Unknown">
 <summary>
 .*（ 二进制流，不知道下载文件类型）
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType">
 <summary>
 MIME types / Internet Media Types
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.Name">
 <summary>
 Type name or brief info
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.MIMEType">
 <summary>
 MIME Type / Internet Media Type
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.FileExt">
 <summary>
 File Extension
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.Details">
 <summary>
 More Details
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ISerializable">
 <summary>
 支持序列化的对象，则这个对象可以被应用于<see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/>数据载体的网络传输操作过程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.ISerializable.Serialize">
 <summary>
 Transform this .NET object into a raw stream object for the network data transfer. 
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.RawStream">
 <summary>
 原始串流的基本模型，这个流对象应该具备有两个基本的方法：
 1. 从原始的字节流之中反序列化构造出自身的构造函数
 2. 将自身序列化为字节流的<see cref="M:Microsoft.VisualBasic.Net.Protocols.ISerializable.Serialize"/>序列化方法
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RawStream.#ctor(System.Byte[])">
 <summary>
 You should overrides this constructor to generate a stream object.(必须要有一个这个构造函数来执行反序列化)
 </summary>
 <param name="rawStream"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RawStream.Serialize">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Net.Protocols.ISerializable.Serialize"/>序列化方法
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RawStream.GetRawStream``1(System.Byte[])">
 <summary>
 按照类型的定义进行反序列化操作
 </summary>
 <typeparam name="TRawStream"></typeparam>
 <param name="rawStream"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RawStream.INT32">
 <summary>
 Single/Integer
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RawStream.DblFloat">
 <summary>
 System.Double
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RawStream.op_LessThanOrEqual(System.String,Microsoft.VisualBasic.Net.Protocols.RawStream)">
 <summary>
 
 </summary>
 <param name="addr">IPEndPoint string value likes 127.0.0.1:8080</param>
 <param name="raw"></param>
 <returns></returns>
 <![CDATA[

 Dim rep As RequestStream =
    "127.0.0.1:80" <= New RequestStream With {
           ...
     }
 ]]>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.IVerifySession">
 <summary>
 这个组件用来为用户输入一些验证信息
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Reflection.AppMgr">
 <summary>
 能够处理多种协议数据
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.AppMgr.RegisterApp``1(``0,System.Boolean)">
 <summary>
 有点多此一举？？
 </summary>
 <typeparam name="T"></typeparam>
 <param name="App"></param>
 <param name="[overrides]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.__protocolInvoker.InvokeProtocol3(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 
 </summary>
 <param name="CA"><see cref="P:Microsoft.VisualBasic.Net.SSL.Certificate.uid"/></param>
 <param name="request"></param>
 <param name="remoteDevice"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol">
 <summary>
 This attribute indicates the entry point of the protocol processor definition location and the details of the protocol processor. 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.EntryPoint">
 <summary>
 Entry point for the data protocols, this property usually correspondent to the request stream's 
 property: <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocol"/> and <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ProtocolCategory"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.DeclaringType">
 <summary>
 这个属性对于方法而言为空，但是对于类型入口点而言则不为空
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.#ctor(System.Int64)">
 <summary>
 Generates the protocol method entrypoint.(应用于服务器上面的协议处理方法)
 </summary>
 <param name="EntryPoint"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.#ctor(System.Type)">
 <summary>
 Generates the <see cref="T:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler"/> on the server side, this is using for initialize a protocol API entry point.(客户端上面的类型)
 </summary>
 <param name="Type">客户端上面的类型</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.GetProtocolCategory(System.Type)">
 <summary>
 This method is usually using for generates a <see cref="T:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler"/> object.
 Correspondent to the protocol class property <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ProtocolCategory"/>
 </summary>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol.GetEntryPoint(System.Reflection.MethodInfo)">
 <summary>
 This method is usually using for generates a details protocol processor, example is calling the method interface: <see cref="T:Microsoft.VisualBasic.Net.Abstract.DataRequestHandler"/>
 Correspondent to the protocol entry property <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocol"/>
 </summary>
 <param name="Method"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler">
 <summary>
 这个模块只处理<see cref="T:Microsoft.VisualBasic.Net.Abstract.DataRequestHandler"/>类型的接口
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler.DeclaringType">
 <summary>
 这个类型建议一般为某种枚举类型
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler.#ctor(System.Object)">
 <summary>
 请注意，假若没有在目标的类型定义之中查找出入口点的定义，则这个构造函数会报错，
 假若需要安全的创建对象，可以使用<see cref="M:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler.SafelyCreateObject``1(``0)"/>函数
 </summary>
 <param name="obj">Protocol的实例</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler.SafelyCreateObject``1(``0)">
 <summary>
 失败会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="App"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.Reflection.ProtocolHandler.HandleRequest(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 Handle the data request from the client for socket events: <see cref="P:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Responsehandler"/> or <see cref="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Responsehandler"/>
 </summary>
 <param name="CA"></param>
 <param name="request">The request stream object which contains the commands from the client</param>
 <param name="remoteDevcie">The IPAddress of the target incoming client data request.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.RequestStream">
 <summary>
 Socket user client => Socket server data request &amp;
 Socket server => Socket user client data response package.
 (Socket客户端 => Socket服务器所发送的数据请求以及从
 Socket服务器 => Socket客户端所返回数据的数据响应包)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ProtocolCategory">
 <summary>
 This property indicates the protocol processor module for the server object.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocol">
 <summary>
 This property indicates which the specifics protocol processor will be used for the incoming client request.
 (协议的头部)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.BufferLength">
 <summary>
 Buffer length of the protocol request raw stream data <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ChunkBuffer"/>.(协议数据的长度)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ChunkBuffer">
 <summary>
 The raw stream data of the details data request or the server response data.(协议的具体数据请求)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.uid">
 <summary>
 使用用户的账号信息唯一标识出来的对象，在服务器端用来查找用户证书的
 由于在服务器上面这个哈希值是和解密的密匙唯一对应的，所以服务器上面大多数情况下是直接通过这个哈希值来决定授权的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.FullRead">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ChunkBuffer"/>部分的数据是否完整？
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.#ctor(System.Int64,System.Int64,System.String)">
 <summary>
 The default text encoding is <see cref="P:System.Text.Encoding.UTF8"/>
 </summary>
 <param name="ProtocolCategory"></param>
 <param name="Protocol"></param>
 <param name="s_Data">Protocol request argument parameters</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.#ctor(System.String)">
 <summary>
 其余的协议参数都是值 <see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.#ctor(System.Byte[])">
 <summary>
 Deserialize (当还有剩余数据的时候会将数据进行剪裁)
 </summary>
 <param name="rawStream"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.GetUTF8String">
 <summary>
 默认是使用UTF8编码来编码字符串的
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.LoadObject``1(Microsoft.VisualBasic.Net.Protocols.LoadObject{``0})">
 <summary>
 将数据首先生成字符串，然后根据函数指针<paramref name="handler"/>句柄的描述从字符串之中反序列化加载对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="handler"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.LoadObject``1">
 <summary>
 json
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.GetRawStream``1">
 <summary>
 从原始数据流<see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ChunkBuffer"/>之中进行反序列化得到一个嵌套的数据串流对象
 </summary>
 <typeparam name="TStream"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.CreateProtocol``1(System.Int64,System.Int64,``0)">
 <summary>
 这个函数是使用json序列化参数信息的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="cat"></param>
 <param name="protocol"></param>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.CreatePackage``1(``0)">
 <summary>
 服务器端返回数据所使用的，默认使用json序列化，所有的标签为<see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.CreatePackage(System.Byte[])">
 <summary>
 服务器端返回数据所使用的，所有的标签为<see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <param name="pack"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.Serialize">
 <summary>
 执行序列化进行网络之间的数据传输
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RequestStream.SYS_PROTOCOL">
 <summary>
 系统里面最基本的基本数据协议
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocols">
 <summary>
 最基本的Socket数据串流协议
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocols.SSL">
 <summary>
 私有密匙加密
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocols.SSL_PublicToken">
 <summary>
 公共密匙加密
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.RequestStream.Protocols.InvalidCertificates">
 <summary>
 无效的数字证书
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.IsSSLProtocol">
 <summary>
 这个请求数据是一个SSL加密数据（使用用户的私有密匙）
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.IsSSL_PublicToken">
 <summary>
 使用公共密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.IsPlantText">
 <summary>
 这个数据仅仅是一个文本，没有包含有任何协议头数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.IsSSLHandshaking">
 <summary>
 这个请求数据是否为握手协议
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.RequestStream.op_Equality(Microsoft.VisualBasic.Net.Protocols.RequestStream,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 简单的字符串等价
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Mailto.MailConfigure.Password">
 <summary>
 存储至文件之前请先加密
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Mailto.MailContents.Attatchments">
 <summary>
 The path list of the attachments file.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Mailto.MailContents.Logo">
 <summary>
 The file path of the logo image.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.Mailto.EMailClient">
 <summary>
 A client of gmail.com
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Mailto.EMailClient.SendMessagesTo(System.String,System.String,System.String)">
 <summary>

 </summary>
 <param name="emailTitle">标题</param>
 <param name="emailNote">内容</param>
 <param name="emailUser">收件人地址</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Mailto.EMailClient.GmailClient(System.String,System.String)">
 <summary>
 Gmail
 </summary>
 <param name="account"></param>
 <param name="pass"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.Abstract.IProtocolHandler">
 <summary>
 Object for handles the request <see cref="T:Microsoft.VisualBasic.Net.Protocols.Reflection.Protocol"/>.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Abstract.DataRequestHandler">
 <summary>
 
 </summary>
 <param name="CA"><see cref="P:Microsoft.VisualBasic.Net.SSL.Certificate.uid"/></param>
 <param name="request"></param>
 <param name="RemoteAddress"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Abstract.ExceptionHandler">
 <summary>
 处理错误的工作逻辑的抽象接口
 </summary>
 <param name="ex">Socket的内部错误信息</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.Abstract.IServicesSocket">
 <summary>
 Socket listening object which is running at the server side asynchronous able multiple threading.
 (运行于服务器端上面的Socket监听对象，多线程模型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.LocalPort">
 <summary>
 The server services listening on this local port.(当前的这个服务器对象实例所监听的本地端口号)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.Run">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.Run(System.Net.IPEndPoint)">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Abstract.IDataRequestHandler.Responsehandler">
 <summary>
 This function pointer using for the data request handling of the data request from the client socket.
 (这个函数指针用于处理来自于客户端的请求)
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.SSL.Certificate">
 <summary>
 应用程序的完整性验证和用户身份的验证
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.Certificate.PrivateKey">
 <summary>
 私有密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.Certificate.uid">
 <summary>
 <see cref="T:System.Guid"/>计算出来的哈希值只能为负数，现在约定，当这个属性为0的时候就认为这个证书是公共密匙，
 这个一般是使用用户的账号所计算出来的哈希值
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.SSL.Certificate._uid">
 <summary>
 初始化继承类所需要的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.Certificate.hash">
 <summary>
 与<see cref="P:Microsoft.VisualBasic.Net.SSL.Certificate.uid"/>属性所不同的是，这个属性是<see cref="P:Microsoft.VisualBasic.Net.SSL.Certificate.PrivateKey"/>的哈希值，
 通常这个哈希值在请求resultful WebAPI的时候用来作为用户的唯一标识
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.#ctor(System.String,System.String)">
 <summary>
 请注意这个构造方法会计算一遍密码的哈希值，假若需要直接进行初始化，请使用<see cref="M:Microsoft.VisualBasic.Net.SSL.Certificate.Install(System.String,System.Boolean)"/>方法
 </summary>
 <param name="hash">用户的私有密匙</param>
 <param name="uid">大小写无关的</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.#ctor(System.String,System.Int64)">
 <summary>
 
 </summary>
 <param name="hash">原始的密码，会在这个构造函数之中计算为哈希值产生新的密码。</param>
 <param name="uid">客户端所发送过来的使用哈希值计算出来的唯一标识符</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.#ctor(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 从服务器上面所返回来的握手数据
 </summary>
 <param name="handshakeData"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.#ctor(System.String)">
 <summary>
 这个构造函数不再计算哈希值而是直接初始化
 </summary>
 <param name="hash">必须是md5哈希值</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.Install(System.String,System.Int64)">
 <summary>
 不计算密匙<paramref name="privateKey"/>哈希值而是直接安装
 </summary>
 <param name="privateKey"></param>
 <param name="uid"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.Encrypt(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 函数会根据uid的值来设定协议为私有密匙还是公共密匙
 </summary>
 <param name="request"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.PublicEncrypt(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 强制将协议设定为公共密匙加密
 </summary>
 <param name="request"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.Decrypt(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Net.SSL.Certificate.Decrypt(System.Byte[])"/> <see cref="P:Microsoft.VisualBasic.Net.Protocols.RequestStream.ChunkBuffer"/>
 </summary>
 <param name="request"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.Certificate.AppDomain">
 <summary>
 检查应用程序的完整性
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.Certificate.Install(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="App">可执行程序的文件路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLProtocols.Handshaking(Microsoft.VisualBasic.Net.SSL.Certificate,System.Net.IPEndPoint)">
 <summary>
 客户端与服务器之间初始化加密连接
 </summary>
 <param name="CA">客户端的证书，这个是服务器来进行客户端程序的完整性验证的</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices">
 <summary>
 抽象SSL服务器
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.InstallCertificates">
 <summary>
 告诉SSL层如何安装数字证书
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.RaiseHandshakingEvent">
 <summary>
 有新的客户端请求进行连接
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.RefuseHandshake">
 <summary>
 对于某些应用出于安全性的考虑，会将这里设置为False，则服务器就会全部拒绝后面的所有的握手请求，只接受来自于从外部导入的用户证书的数据请求
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.CA">
 <summary>
 公共密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.PrivateKeys">
 <summary>
 客户端的私有密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.ResponseHandler">
 <summary>
 处理私有密匙的数据请求
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices.Install(Microsoft.VisualBasic.Net.SSL.Certificate,System.Boolean,System.String)">
 <summary>
 
 </summary>
 <param name="CA"></param>
 <param name="[overrides]">当证书的哈希值有冲突的时候，新安装的证书<paramref name="ca"/>可不可以将旧的证书覆盖掉</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLProtocols.SSLServicesResponseHandler(Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices,System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint,Microsoft.VisualBasic.Net.SSL.SSLProtocols.InstallCertificates)">
 <summary>
 
 </summary>
 <param name="ssl"></param>
 <param name="CA">解密使用的证书凭据，这个用来鉴别客户端身份是否被伪造</param>
 <param name="request"></param>
 <param name="remoteDev"></param>
 <param name="InstallCertificates"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLProtocols.__sslHandshake(System.Int64,Microsoft.VisualBasic.Net.SSL.SSLProtocols.ISSLServices,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint,Microsoft.VisualBasic.Net.SSL.SSLProtocols.InstallCertificates)">
 <summary>
 客户端与服务器之间进行连接的初始化，服务器会在这里为客户端动态的生成一个密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.CA">
 <summary>
 这个数字证书是当前版本下的服务器的客户端的数字签名，服务器会使用这个证书来验证客户端的文件是否被恶意破解，相当于公有密匙
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.PrivateKeys">
 <summary>
 A table stores the certificates of the current connected clients on this server.
 (连接上来的客户端的私有证书列表)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.#ctor(System.Int32,Microsoft.VisualBasic.Net.SSL.Certificate,System.Object,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 
 </summary>
 <param name="LocalPort"></param>
 <param name="CA">服务器在部署的时候向对应版本您的客户端的数字签名</param>
 <param name="exHandler">Public Delegate Sub <see cref="T:Microsoft.VisualBasic.Net.Abstract.ExceptionHandler"/>(ex As <see cref="T:System.Exception"/>)</param>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.LocalPort">
 <summary>
 底层工作socket所监听的端口号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Responsehandler">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Net.Abstract.DataRequestHandler"/>: 
 Public Delegate Function <see cref="T:Microsoft.VisualBasic.Net.Abstract.DataRequestHandler"/>(CA As <see cref="T:System.Int64"/>, request As <see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/>, 
 RemoteAddress As <see cref="T:System.Net.IPEndPoint"/>) As <see cref="T:System.Net.IPEndPoint"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.ISSLServices_InstallCertificates">
 <summary>
 生成证书的方法
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.RaiseHandshakingEvent">
 <summary>
 客户端和服务器握手之后触发这个动作
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.RefuseHandshake">
 <summary>
 Does this ssl server accepts the handshaking from the user client or just allow the client connect to this server from manual imports their certificates by using method <see cref="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Install(Microsoft.VisualBasic.Net.SSL.Certificate,System.Boolean,System.String)"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.WaitForStart">
 <summary>
 等待底层socket成功进入监听模式
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Run(System.Net.IPEndPoint)">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Run">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.Install(Microsoft.VisualBasic.Net.SSL.Certificate,System.Boolean,System.String)">
 <summary>
 If the property of <see cref="P:Microsoft.VisualBasic.Net.SSL.SSLSynchronizationServicesSocket.RefuseHandshake"/> is set to TRUE, then no more new client can be connect to this server object.
 The only way to add new client on this server is using this function to imports the client's certificates direct manually.
 (假若ssl层关闭了握手协议，则不可能会再有新的客户端可以连接到这个服务器上面了，则这个时候就可以使用这个方法来手工的为新的客户端导入数字证书，从而可以只接受指定的客户端的连接操作
 假若是证书同步操作的话，则可以将app授权证书通过这个方法导入到服务器模块接收主节点的证书同步操作)
 </summary>
 <param name="CA"></param>
 <param name="[overrides]"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Application.Protocols.SendMessagePost.FROM">
 <summary>
 发送这条消息的客户端的在服务器上面的句柄，也可以看作为用户编号，尽管这个编号是经过一些映射操作最终得到的
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLClient.#ctor(System.Net.IPEndPoint,System.Int64,Microsoft.VisualBasic.Net.Persistent.PushMessage,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 
 </summary>
 <param name="services"></param>
 <param name="ID"></param>
 <param name="DataRequestHandle">Public Delegate Function PushMessage(USER_ID As <see cref="T:System.Int64"/>, Message As <see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/>) As <see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/></param>
 <param name="ExceptionHandler"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLClient.Logon(Microsoft.VisualBasic.Net.SSL.Certificate)">
 <summary>
 使用已经拥有的用户证书登录服务器，这一步省略了握手步骤
 </summary>
 <param name="UserToken"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLClient.SendMessage(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 消息在这个函数之中自动被加密处理
 </summary>
 <param name="USER_ID"></param>
 <param name="request"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices">
 <summary>
 消息都是经过加密操作了的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices.CA">
 <summary>
 共有密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices.PrivateKeys">
 <summary>
 连接到当前的这个服务器上面的客户端的私有密匙列表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices.#ctor(System.Int32,System.Object,Microsoft.VisualBasic.Net.Persistent.OffLineMessageSendHandler,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 
 </summary>
 <param name="LocalPort"></param>
 <param name="OffLineMessageSendHandler">
 Public Delegate Sub <see cref="T:Microsoft.VisualBasic.Net.Persistent.OffLineMessageSendHandler"/>(FromUSER_ID As <see cref="T:System.Int64"/>, USER_ID As <see cref="T:System.Int64"/>, Message As <see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/>)
 </param>
 <param name="exHandler"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices.Install(Microsoft.VisualBasic.Net.SSL.Certificate)">
 <summary>
 安装新的公有密匙
 </summary>
 <param name="CA"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.SSLPushServices.Install(Microsoft.VisualBasic.Net.SSL.Certificate,System.Boolean,System.String)">
 <summary>
 安装新的用户私有密匙
 </summary>
 <param name="CA"></param>
 <param name="[overrides]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Application.USER">
 <summary>
 服务器也相当于一个USER，只不过服务器的UID为0，即最高级的用户
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.USER.#ctor(System.String,System.Int32,System.Int64,Microsoft.VisualBasic.Net.Persistent.PushMessage,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 
 </summary>
 <param name="HostName"></param>
 <param name="RemotePort"></param>
 <param name="ID"></param>
 <param name="DataRequestHandle">使用这个函数来获取外部发送过来的用户消息</param>
 <param name="ExceptionHandler"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.USER.BeginConnect(System.Windows.Forms.MethodInvoker,Microsoft.VisualBasic.Net.SSL.Certificate)">
 <summary>
 请注意，线程会在这里阻塞
 </summary>
 <param name="ForceCloseConnection">远程主机强制关闭连接之后触发这个动作</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.USER.BeginConnect(Microsoft.VisualBasic.Net.SSL.Certificate,System.Windows.Forms.MethodInvoker)">
 <summary>
 不会发生阻塞
 </summary>
 <param name="ForceCloseConnection">远程主机强制关闭连接之后触发这个动作</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.USER.__sendMessageToMe(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 
 </summary>
 <param name="CA"></param>
 <param name="request"></param>
 <param name="remote">由于数据都是通过中心服务器转发的，所以这个已经没有存在的意义了，但是为了和短连接的socket的数据处理接口保持兼容，所以还保留这个参数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.USER.SendMessage(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 True标识发送成功，False标识用户离线
 </summary>
 <param name="USER_ID"></param>
 <param name="Message">在发送之前请对消息进行加密处理</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer">
 <summary>
 长连接模式的消息推送服务器
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer._workSocket">
 <summary>
 客户端对这个服务器的端口号是自动配置的，只需要向客户端返回<see cref="F:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket._LocalPort"/>端口就可以了
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer._sslLayer">
 <summary>
 使用证书来加密发出去的消息
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.LocalPort">
 <summary>
 从这个端口号进行登录（协同长连接的socket正常工作的socket的端口号，可以看作为UserAPI）
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.__requestHandlerInterface(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 只要是为ssl服务设置的
 </summary>
 <param name="remote"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.#ctor(System.Int32,Microsoft.VisualBasic.Net.Persistent.OffLineMessageSendHandler,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 
 </summary>
 <param name="LocalPort"></param>
 <param name="OffLineMessageSendHandler">Public Delegate Sub <see cref="T:Microsoft.VisualBasic.Net.Persistent.OffLineMessageSendHandler"/>(FromUSER_ID As <see cref="T:System.Int64"/>, USER_ID As <see cref="T:System.Int64"/>, Message As <see cref="T:Microsoft.VisualBasic.Net.Protocols.RequestStream"/>)</param>
 <param name="exHandler"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.DisconnectUser(System.Int64,System.Boolean)">
 <summary>
 Disconnect user persistent connection who have the specific <paramref name="user_id"/> from this server.
 (断开服务器与用户客户端的长连接)
 </summary>
 <param name="USER_ID">This user will be deleted from the server registry.</param>
 <param name="removeCA">是否在删除socket句柄的时候还会删除相对应的ssl证书</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.SendMessage(System.Int64,System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 
 </summary>
 <param name="From"></param>
 <param name="USER_ID"></param>
 <param name="Message"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.__sendMessage(System.Int64,System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 发送出去的数据需要进行加密，假若是ssl模式的话
 </summary>
 <param name="From"></param>
 <param name="USER_ID"></param>
 <param name="Message"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.UidMappings">
 <summary>
 将外部编号映射为内部的客户端句柄
 假若找不到，请返回-1
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.__sendMessage(Microsoft.VisualBasic.Net.Persistent.Socket.WorkSocket,System.Int64,System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 
 </summary>
 <param name="socket"></param>
 <param name="From">这个是这一条消息的源头，可能需要进行映射</param>
 <param name="USER_ID"></param>
 <param name="Message"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.__usrInvokeSend(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 用户客户端请求发送消息至指定编号的用户的终端之上
 </summary>
 <param name="CA"></param>
 <param name="request"></param>
 <param name="remote"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.RemoveFreeConnections">
 <summary>
 哈希值不存在于现有的登录用户列表之中就是空闲连接
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Application.MessagePushServer.AcceptClient(Microsoft.VisualBasic.Net.Persistent.Socket.WorkSocket)">
 <summary>
 建立一个新的连接
 </summary>
 <param name="Client"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.OffLineMessageSendHandler">
 <summary>
 离线数据请求
 </summary>
 <param name="FromUSER_ID"></param>
 <param name="USER_ID"></param>
 <param name="Message"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Socket.WorkSocket">
 <summary>
 长连接之中只是进行消息的发送处理，并不保证数据能够被接收到
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.WorkSocket.ReadCallback(System.IAsyncResult)">
 <summary>
 DO_NOTHING
 </summary>
 <param name="ar"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient">
 <summary>
 请注意，这个对象是应用于客户端与服务器保持长连接所使用，并不会主动发送消息给服务器，而是被动的接受服务器的数据请求
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.port">
 <summary>
 The port number for the remote device.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.remoteEP">
 <summary>
 Remote End Point
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.#ctor(Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>

 </summary>
 <param name="Client">Copy the TCP client connection profile data from this object.(从本客户端对象之中复制出连接配置参数以进行初始化操作)</param>
 <param name="ExceptionHandler"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.#ctor(System.String,System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>

 </summary>
 <param name="RemotePort"></param>
 <param name="ExceptionHandler">Public Delegate Sub ExceptionHandler(ex As Exception)</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.OnServerHashCode">
 <summary>
 本客户端socket在服务器上面的哈希句柄值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.RemoteServerShutdown">
 <summary>
 远程主机强制关闭连接之后触发这个动作
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.BeginConnect">
 <summary>
 函数会想服务器上面的socket对象一样在这里发生阻塞
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.ConnectCallback(System.IAsyncResult)">
 <summary>
 Retrieve the socket from the state object.
 </summary>
 <param name="ar"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.Receive(Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.StateObject)">
 <summary>
 An exception of type '<see cref="T:System.Net.Sockets.SocketException"/>' occurred in System.dll but was not handled in user code
 Additional information: A request to send or receive data was disallowed because the socket is not connected and
 (when sending on a datagram socket using a sendto call) no address was supplied
 </summary>
 <param name="client"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.__send(System.Net.Sockets.Socket,System.String)">
 <summary>
 ????
 An exception of type 'System.Net.Sockets.SocketException' occurred in System.dll but was not handled in user code
 Additional information: A request to send or receive data was disallowed because the socket is not connected and
 (when sending on a datagram socket using a sendto call) no address was supplied
 </summary>
 <param name="client"></param>
 <param name="data"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.readDataBuffer(Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.StateObject,System.IAsyncResult)">
 <summary>
 Read data from the remote device.
 </summary>
 <param name="state"></param>
 <param name="ar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.PersistentClient.ReceiveCallback(System.IAsyncResult)">
 <summary>
 Retrieve the state object and the client socket from the asynchronous state object.
 </summary>
 <param name="ar"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket">
 <summary>
 
 </summary>
 <remarks>
 一、TCP长连接
 
 正常情况下，一条TCP连接建立后，只要双不提出关闭请求并且不出现异常情况，这条连接是一直存在的，
 操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。
 所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。
 在编程中， 往往需要建立一条TCP连接， 并且长时间处于连接状态。
 所谓的TCP长连接并没有确切的时间限制， 而是说这条连接需要的时间比较长。
 
 二、TCP连接的正常中断
 
 TCP连接在事务处理完毕之后， 由一方提出关闭连接请求， 双方通过四次握手（建立连接是三次握手， 
 当然可以通过优化TCP / IP协议栈来减少握手的次数来提高性能， 但这样会形成不规范或者不优雅的通信）来正常关闭连接
 
 三、TCP连接的异常中断
 
 导致TCP连接异常中断的因素有： 物理连接被中断、操作系统down机、程序崩溃等等。
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket._LocalPort">
 <summary>
 Socket对象监听的端口号
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.LocalPort">
 <summary>
 The server services listening on this local port.(当前的这个服务器对象实例所监听的本地端口号)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.#ctor(System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 消息处理的方法接口： Public Delegate Function DataResponseHandler(str As String, RemotePort As Integer) As String
 </summary>
 <param name="LocalPort">监听的本地端口号，假若需要进行端口映射的话，则可以在<see cref="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.Run"></see>方法之中设置映射的端口号</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.Run">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.Run(System.Net.IPEndPoint)">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.__initSocket(System.Net.IPEndPoint)">
 <summary>
 Bind the socket to the local endpoint and listen for incoming connections.
 </summary>
 <param name="localEndPoint"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.AcceptCallback(System.IAsyncResult)">
 <summary>
 Get the socket that handles the client request.
 </summary>
 <param name="ar"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.__initSocketThread(System.Net.Sockets.Socket)">
 <summary>
 Create the state object for the async receive.
 </summary>
 <param name="handler"></param>
</member>
<member name="F:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.disposedValue">
 <summary>
 退出监听线程所需要的
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Persistent.Socket.ServicesSocket.Dispose">
 <summary>
 Stop the server socket listening threads.(终止服务器Socket监听线程)
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.wGetTools">
 <summary>
 提供一些比较详细的数据信息和事件处理
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.wGetTools.CurrentSize">
 <summary>
 Size that has been downloaded
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.wGetTools.TotalSize">
 <summary>
 Total size of the file that has to be downloaded
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.wGetTools.DownloadSpeed">
 <summary>
 KB/sec
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.wGetTools.Downloading">
 <summary>
 Client status
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.StateObject">
 <summary>
 State object for reading client data asynchronously
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.StateObject.workSocket">
 <summary>
 Client  socket.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.StateObject.BufferSize">
 <summary>
 Size of receive buffer.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.StateObject.readBuffer">
 <summary>
 Receive buffer.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.StateObject.ChunkBuffer">
 <summary>
 Received data.
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.IPEndPoint">
 <summary>
 The object of <see cref="T:System.Net.IPEndPoint"/> can not be Xml serialization.
 (系统自带的<see cref="T:System.Net.IPEndPoint"></see>不能够进行Xml序列化)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor">
 <summary>
 This parameterless constructor is required for the xml serialization.(XML序列化所需要的)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor(System.String,System.Int32)">
 <summary>

 </summary>
 <param name="IPAddress">IPAddress string using for create object using method <see cref="M:System.Net.IPAddress.Parse(System.String)"/></param>
 <param name="Port"><see cref="P:System.Net.IPEndPoint.Port"/></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor(System.String)">
 <summary>

 </summary>
 <param name="str">IPAddress:Port</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.ToString">
 <summary>
 http://IPAddress:&lt;Port>/
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.GetIPEndPoint">
 <summary>
 Convert this networking end point DDM into the <see cref="T:System.Net.IPEndPoint"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.IPEndPoint.IsValid">
 <summary>
 格式是否正确
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.LANTools">
 <summary>
 http://www.codeproject.com/Tips/358946/Retrieving-IP-and-MAC-addresses-for-a-LAN
 </summary>
 <code>
 ' Get my PC IP address
 Call Console.WriteLine("My IP : {0}", GetIPAddress())
 
 ' Get My PC MAC address
 Call Console.WriteLine("My MAC: {0}", GetMacAddress())
 
 ' Get all devices on network
 Dim all As Dictionary(Of IPAddress, PhysicalAddress) = GetAllDevicesOnLAN()
 For Each kvp As KeyValuePair(Of IPAddress, PhysicalAddress) In all
     Console.WriteLine("IP : {0}" &amp; vbLf &amp; " MAC {1}", kvp.Key, kvp.Value)
 Next
 </code>
</member>
<member name="T:Microsoft.VisualBasic.Net.LANTools.MIB_IPNETROW">
 <summary>
 MIB_IPNETROW structure returned by GetIpNetTable
 DO NOT MODIFY THIS STRUCTURE.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetIpNetTable(System.IntPtr,System.Int32@,System.Boolean)">
 <summary>
 GetIpNetTable external method
 </summary>
 <param name="pIpNetTable"></param>
 <param name="pdwSize"></param>
 <param name="bOrder"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.LANTools.ERROR_INSUFFICIENT_BUFFER">
 <summary>
 Error codes GetIpNetTable returns that we recognise
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetAllDevicesOnLAN">
 <summary>
 Get the IP and MAC addresses of all known devices on the LAN
 </summary>
 <remarks>
 1) This table is not updated often - it can take some human-scale time 
    to notice that a device has dropped off the network, or a new device
    has connected.
 2) This discards non-local devices if they are found - these are multicast
    and can be discarded by IP address range.
 </remarks>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetIPAddress">
 <summary>
 Gets the IP address of the current PC
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetMacAddress">
 <summary>
 Gets the MAC address of the current PC.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.IsMulticast(System.Net.IPAddress)">
 <summary>
 Returns true if the specified IP address is a multicast address
 </summary>
 <param name="ip"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.DomainName.TLD">
 <summary>
 顶级域名
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.DomainParser">
 <summary>
 http://sub.domain.com/somefolder/index.html -> domain.com
 somedomain.info -> somedomain.info
 http://anotherdomain.org/home -> anotherdomain.org
 www.subdomain.anothersubdomain.maindomain.com/something/ -> maindomain.com
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.DomainParser.TryParse(System.String)">
 <summary>
 解析错误会返回空字符串
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.PingUtility">
 <summary>
 http://www.codeproject.com/Articles/18635/Ping-exe-replica-in-C
 
 Ping.exe replica in C# 2.0

 Stefan Prodan, 3 May 2007 CPOL
 Usage example of the System.Net.NetworkInformation.Ping.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.PingUtility.Ping(System.Net.IPAddress,System.UInt32)">
 <summary>
 返回与目标远程机器之间的平均通信时间长度
 </summary>
 <param name="IP"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket">
 <summary>
 Socket listening object which is running at the server side asynchronous able multiple threading.
 (运行于服务器端上面的Socket监听对象，多线程模型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.LocalPort">
 <summary>
 The server services listening on this local port.(当前的这个服务器对象实例所监听的本地端口号)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Responsehandler">
 <summary>
 This function pointer using for the data request handling of the data request from the client socket.   
 [Public Delegate Function DataResponseHandler(str As <see cref="T:System.String"/>, RemoteAddress As <see cref="T:System.Net.IPEndPoint"/>) As <see cref="T:System.String"/>]
 (这个函数指针用于处理来自于客户端的请求)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.#ctor(System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 消息处理的方法接口： Public Delegate Function DataResponseHandler(str As String, RemotePort As Integer) As String
 </summary>
 <param name="LocalPort">监听的本地端口号，假若需要进行端口映射的话，则可以在<see cref="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Run"></see>方法之中设置映射的端口号</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.#ctor(Microsoft.VisualBasic.Net.Abstract.DataRequestHandler,System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 短连接socket服务端
 </summary>
 <param name="DataArrivalEventHandler"></param>
 <param name="LocalPort"></param>
 <param name="exHandler"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.BeginListen(Microsoft.VisualBasic.Net.Abstract.DataRequestHandler,System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 函数返回Socket的注销方法
 </summary>
 <param name="DataArrivalEventHandler">Public Delegate Function DataResponseHandler(str As String, RemotePort As Integer) As String</param>
 <param name="LocalPort"></param>
 <param name="exHandler"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Run">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Run(System.Net.IPEndPoint)">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.HandleRequest(System.Net.Sockets.Socket,Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 All the data has been read from the client. Display it on the console.
 Echo the data back to the client.
 </summary>
 <param name="handler"></param>
 <param name="requestData"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Send(System.Net.Sockets.Socket,System.String)">
 <summary>
 Server reply the processing result of the request from the client.
 </summary>
 <param name="handler"></param>
 <param name="data"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.IsServerInternalException(System.String)">
 <summary>
 SERVER_INTERNAL_EXCEPTION，Server encounter an internal exception during processing
 the data request from the remote device.
 (判断是否服务器在处理客户端的请求的时候，发生了内部错误)
 </summary>
 <param name="replyData"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.disposedValue">
 <summary>
 退出监听线程所需要的
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket.Dispose">
 <summary>
 Stop the server socket listening threads.(终止服务器Socket监听线程)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.Ping(System.Net.IPEndPoint,System.Int32)">
 <summary>
 -1标识Ping不通
 </summary>
 <param name="operationTimeOut">ms</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.Ping(Microsoft.VisualBasic.Net.AsynInvoke,System.Int32)">
 <summary>
 -1 ping failure
 </summary>
 <param name="invoke"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.ConnectSocket(System.String,System.Int32)">
 <summary>
 假若不能成功的建立起连接的话，则会抛出错误
 </summary>
 <param name="server"></param>
 <param name="port"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.GetFirstAvailablePort(System.Int32)">
 <summary>
 Get the first available TCP port on this local machine.
 (获取第一个可用的端口号，请注意，在高并发状态下可能会出现端口被占用的情况，
 所以这时候建议将<paramref name="BEGIN_PORT"/>设置为-1，则本函数将会尝试使用随机数来分配可用端口，从而避免一些系统崩溃的情况产生)
 </summary>
 <param name="BEGIN_PORT">Check the local port available from this port value.(从这个端口开始检测)</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.PortIsUsed">
 <summary>
 获取操作系统已用的端口号
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.TCPExtensions.PortIsAvailable(System.Int32)">
 <summary>
 检查指定端口是否已用
 </summary>
 <param name="port"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.AsynInvoke">
 <summary>
 The server socket should returns some data string to this client or this client will stuck at the <see cref="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(Microsoft.VisualBasic.Net.Protocols.RequestStream)"></see> function.
 (服务器端<see cref="T:Microsoft.VisualBasic.Net.TcpSynchronizationServicesSocket"></see>必须要返回数据，否则本客户端会在<see cref="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(Microsoft.VisualBasic.Net.Protocols.RequestStream)"></see>函数位置一直处于等待的状态)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.AsynInvoke.port">
 <summary>
 The port number for the remote device.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.AsynInvoke.response">
 <summary>
 The response from the remote device.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.AsynInvoke.connectDone">
 <summary>
 ' ManualResetEvent instances signal completion.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.AsynInvoke.remoteEP">
 <summary>
 Remote End Point
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.AsynInvoke.LocalIPAddress">
 <summary>
 Gets the IP address of this local machine.
 (获取本机对象的IP地址，请注意这个属性获取得到的仅仅是本机在局域网内的ip地址，假若需要获取得到公网IP地址，还需要外部服务器的帮助才行)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.#ctor(Microsoft.VisualBasic.Net.AsynInvoke,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>

 </summary>
 <param name="Client">Copy the TCP client connection profile data from this object.(从本客户端对象之中复制出连接配置参数以进行初始化操作)</param>
 <param name="ExceptionHandler"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.#ctor(System.String,System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>

 </summary>
 <param name="remotePort"></param>
 <param name="ExceptionHandler">Public Delegate Sub ExceptionHandler(ex As Exception)</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.LocalConnection(System.Int32,Microsoft.VisualBasic.Net.Abstract.ExceptionHandler)">
 <summary>
 初始化一个在本机进行进程间通信的Socket对象
 </summary>
 <param name="LocalPort"></param>
 <param name="ExceptionHandler"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.OperationTimeOut(System.String)">
 <summary>
 判断服务器所返回来的数据是否为操作超时
 </summary>
 <param name="str"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(System.String,System.Int32,System.Action)">
 <summary>
 Returns the server reply.(假若操作超时的话，则会返回<see cref="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REQUEST_TIMEOUT"></see>)
 </summary>
 <param name="Message"></param>
 <param name="OperationTimeOut">操作超时的时间长度，默认为30秒</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Int32,System.Action)">
 <summary>
 Returns the server reply.(假若操作超时的话，则会返回<see cref="P:Microsoft.VisualBasic.Net.Http.NetResponse.RFC_REQUEST_TIMEOUT"></see>，
 请注意，假若目标服务器启用了ssl加密服务的话，假若这个请求是明文数据，则服务器会直接拒绝请求返回<see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_CERT"/> 496错误代码，
 所以调用前请确保参数<paramref name="Message"/>已经使用证书加密)
 </summary>
 <param name="Message"></param>
 <param name="OperationTimeOut">操作超时的时间长度，默认为30秒</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(System.String)">
 <summary>
 This function returns the server reply for this request <paramref name="Message"></paramref>.
 </summary>
 <param name="Message">The client request to the server.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(Microsoft.VisualBasic.Net.Protocols.RequestStream)">
 <summary>
 Send a request message to the remote server.
 </summary>
 <param name="Message"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(Microsoft.VisualBasic.Net.Protocols.RequestStream,Microsoft.VisualBasic.Net.SSL.Certificate,System.Boolean)">
 <summary>
 发送一段使用证书对象<paramref name="CA"/>进行数据加密操作的消息请求<paramref name="Message"/>
 </summary>
 <param name="Message"></param>
 <param name="CA"></param>
 <param name="isPublicToken"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.SendMessage(System.Byte[])">
 <summary>
 最底层的消息发送函数
 </summary>
 <param name="Message"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.Receive(System.Net.Sockets.Socket)">
 <summary>
 An exception of type '<see cref="T:System.Net.Sockets.SocketException"/>' occurred in System.dll but was not handled in user code
 Additional information: A request to send or receive data was disallowed because the socket is not connected and
 (when sending on a datagram socket using a sendto call) no address was supplied
 </summary>
 <param name="client"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.AsynInvoke.__send(System.Net.Sockets.Socket,System.Byte[])">
 <summary>
 ????
 An exception of type 'System.Net.Sockets.SocketException' occurred in System.dll but was not handled in user code
 Additional information: A request to send or receive data was disallowed because the socket is not connected and
 (when sending on a datagram socket using a sendto call) no address was supplied
 </summary>
 <param name="client"></param>
 <param name="byteData"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.LicenseMgr">
 <summary>
 Source code license manager
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.LicenseMgr.Template">
 <summary>
 The license template example.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.LicenseMgr.Ignores">
 <summary>
 {".+\.Designer\.vb", "AssemblyInfo\.vb"}
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.LicenseMgr.Insert(System.String,Microsoft.VisualBasic.SoftwareToolkits.LicenseInfo)">
 <summary>
 
 </summary>
 <param name="src">*.vb path</param>
 <param name="info">License meta data</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.LicenseMgr.Inserts(Microsoft.VisualBasic.SoftwareToolkits.LicenseInfo)">
 <summary>
 
 </summary>
 <param name="info">The root directory</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.Project">
 <summary>
 Describes a Project, a collection of related types and namespaces.  In this case, one Project = one DLL.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectMember">
 <summary>
 Base class for a method or property.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectMember.Declare">
 <summary>
 申明的原型
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectNamespace">
 <summary>
 A namespace within a project -- typically a collection of related types.  Equates to a .net Namespace.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectSpace">
 <summary>
 A collection of one or more projects put together, and their attendant namespaces.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectSpace.ExportMarkdownFiles(System.String,System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="folderPath"></param>
 <param name="pageTemplate">a markdown page template. This token: [content] will be replaced with generated content.</param>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectType">
 <summary>
 A type within a project namespace.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Assembly.ProjectType.ExportMarkdownFile(System.String,System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="folderPath"></param>
 <param name="pageTemplate"></param>
 <param name="hexoPublish"></param>
 <remarks>这里还应该包括完整的函数的参数注释的输出</remarks>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.memberTypes.Type">
 <summary>
 T
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.memberTypes.Filed">
 <summary>
 F
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.memberTypes.Method">
 <summary>
 M
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.memberTypes.Property">
 <summary>
 P
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.memberTypes.Event">
 <summary>
 E
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.XmlDoc.Serialization.Doc">
 <summary>
 .NET assembly generated XML comments documents file.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails">
 <summary>
 Parsing product assembly meta data
 </summary>
 <remarks>
 http://www.c-sharpcorner.com/uploadfile/ravesoft/access-assemblyinfo-file-and-get-product-informations/
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.#ctor">
 <summary>
 获取当前的应用程序的描述信息
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.CompanyName">
 <summary>
 Get the name of the system provider name from the assembly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.ProductVersion">
 <summary>
 Get System version from the assembly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.ProductName">
 <summary>
 Get the name of the System from the assembly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.CopyRightsDetail">
 <summary>
 Get the copyRights details from the assembly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.ProductTitle">
 <summary>
 Get the Product tile from the assembly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.ApplicationDetails.ProductDescription">
 <summary>
 Get the description of the product from the assembly
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo">
 <summary>
 Provides detailed information about the host operating system.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.ProgramBits">
 <summary>
 Determines if the current application is 32 or 64-bit.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.ProcessorBits">
 <summary>
 Determines if the current processor is 32 or 64-bit.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.Edition">
 <summary>
 Gets the edition of the operating system running on this computer.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.null">
 <summary>
 Linux/MAC
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows3_1">
 <summary>
 Windows 3.1
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsCE">
 <summary>
 Windows CE
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows95OSR2">
 <summary>
 Windows 95 OSR2
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows95">
 <summary>
 Windows 95
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows98SecondEdition">
 <summary>
 Windows 98 Second Edition
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows98">
 <summary>
 Windows 98
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsMe">
 <summary>
 Windows Me
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsNT3_51">
 <summary>
 Windows NT 3.51
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsNT4_0">
 <summary>
 Windows NT 4.0
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsNT4_0Server">
 <summary>
 Windows NT 4.0 Server
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows2000">
 <summary>
 Windows 2000
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsXP">
 <summary>
 Windows XP
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsServer2003">
 <summary>
 Windows Server 2003
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsVista">
 <summary>
 Windows Vista
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsServer2008">
 <summary>
 Windows Server 2008
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows7">
 <summary>
 Windows 7
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsServer2008R2">
 <summary>
 Windows Server 2008 R2
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.Windows8">
 <summary>
 Windows 8
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsNameList.WindowsServer2012">
 <summary>
 Windows Server 2012
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.WindowsName">
 <summary>
 Gets the name of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.ServicePack">
 <summary>
 Gets the service pack information of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.BuildVersion">
 <summary>
 Gets the build version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.VersionString">
 <summary>
 Gets the full version string of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.Version">
 <summary>
 Gets the full version of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.MajorVersion">
 <summary>
 Gets the major version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.MinorVersion">
 <summary>
 Gets the minor version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.OSVersionInfo.RevisionVersion">
 <summary>
 Gets the revision version number of the operating system running on this computer.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.Resources">
 <summary>
 Represents a resource manager that provides convenient access to culture-specific
 resources at run time.Security Note: Calling methods in this class with untrusted
 data is a security risk. Call the methods in the class only with trusted data.
 For more information, see Untrusted Data Security Risks.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.Resources.FileName">
 <summary>
 The file path of the resources satellite assembly.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.Resources.Resources">
 <summary>
 <see cref="T:System.Resources.ResourceManager"/> object in the satellite assembly.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetObject(System.String)">
 <summary>
 Returns the value of the specified non-string resource.
 </summary>
 <param name="name">The name of the resource to get.</param>
 <returns>The value of the resource localized for the caller's current culture settings.
 If an appropriate resource set exists but name cannot be found, the method returns
 null.</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetObject(System.String,System.Globalization.CultureInfo)">
 <summary>
 Gets the value of the specified non-string resource localized for the specified
 culture.
 </summary>
 <param name="name">The name of the resource to get.</param>
 <param name="culture">The culture for which the resource is localized. If the resource is not localized
 for this culture, the resource manager uses fallback rules to locate an appropriate
 resource.If this value is null, the System.Globalization.CultureInfo object is
 obtained by using the System.Globalization.CultureInfo.CurrentUICulture property.</param>
 <returns>The value of the resource, localized for the specified culture. If an appropriate
 resource set exists but name cannot be found, the method returns null.</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetStream(System.String)">
 <summary>
 Returns an unmanaged memory stream object from the specified resource.
 </summary>
 <param name="name">The name of a resource.</param>
 <returns>An unmanaged memory stream object that represents a resource .</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetStream(System.String,System.Globalization.CultureInfo)">
 <summary>
 Returns an unmanaged memory stream object from the specified resource, using
 the specified culture.
 </summary>
 <param name="name">The name of a resource.</param>
 <param name="culture">An object that specifies the culture to use for the resource lookup. If culture
 is null, the culture for the current thread is used.</param>
 <returns>An unmanaged memory stream object that represents a resource.</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetString(System.String)">
 <summary>
 Returns the value of the specified string resource.
 </summary>
 <param name="name">The name of the resource to retrieve.</param>
 <returns>The value of the resource localized for the caller's current UI culture, or null
 if name cannot be found in a resource set.</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.GetString(System.String,System.Globalization.CultureInfo)">
 <summary>
 Returns the value of the string resource localized for the specified culture.
 </summary>
 <param name="name">The name of the resource to retrieve.</param>
 <param name="culture">An object that represents the culture for which the resource is localized.</param>
 <returns>The value of the resource localized for the specified culture, or null if name
 cannot be found in a resource set.</returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.#ctor(System.Reflection.Assembly)">
 <summary>
 默认是<see cref="P:Microsoft.VisualBasic.App.HOME"/>/Resources/assmFile
 </summary>
 <param name="assm"></param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.#ctor(System.Type,System.Reflection.Assembly)">
 <summary>
 
 </summary>
 <param name="my">null</param>
 <param name="assm"></param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Resources.LoadMy">
 <summary>
 从自身的程序集之中加载数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.Resources.MyResource">
 <summary>
 Returns the cached ResourceManager instance used by this class.
 </summary>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.Globalization.StringResources`1.Default">
 <summary>
 从属性或者域上面解析出来的默认的语言值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Globalization.LanguageAttribute.#ctor(System.Int32,System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="Language">The language of the target object.</param>
 <param name="Context"></param>
 <param name="langEnum">This type define should be a enum type.</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.Globalization.LanguageHelper`1">
 <summary>
 
 </summary>
 <typeparam name="TLanguage">必须是枚举类型</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.SoftwareToolkits.Globalization.LanguageHelper`1.Text(`0,System.String)">
 <summary>
 Get the string that store as specific language.
 (获取指定语言的字符串)
 </summary>
 <param name="Language">字符串的语言</param>
 <value></value>
 <param name="res">请使用 NameOf 操作符来获取</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Globalization.LanguageHelper`1.#ctor(System.Type)">
 <summary>
 解析出所有属性，域上面的语言定义
 </summary>
 <param name="type">必须是模块类型或者属性或者域是共享类型的</param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.Globalization.LanguageHelper`1.__init(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
 <summary>
 
 </summary>
 <param name="members"></param>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller">
 <summary>
 Ngen.exe (Native Image Generator)
 
 The Native Image Generator (Ngen.exe) is a tool that improves the performance of managed applications. 
 Ngen.exe creates native images, which are files containing compiled processor-specific machine code, 
 and installs them into the native image cache on the local computer. The runtime can use native images 
 from the cache instead of using the just-in-time (JIT) compiler to compile the original assembly.
 
 Changes To Ngen.exe In the .NET Framework 4
 Ngen.exe now compiles assemblies With full trust, And code access security (CAS) policy Is no longer evaluated.
 Native images that are generated With Ngen.exe can no longer be loaded into applications that are running In Partial trust.
 
 Changes To Ngen.exe In the .NET Framework version 2.0:
 Installing an assembly also installs its dependencies, simplifying the syntax Of Ngen.exe.
 Native images can now be Shared across application domains.
 A New Action, update, re - creates images that have been invalidated.
 Actions can be deferred For execution by a service that uses idle time On the computer To generate And install images.
 Some causes Of image invalidation have been eliminated.
 </summary>
 <remarks>
 1.7 Native代码产生器: NGen.exe
 
 随.NET Framework发布的NGen.exe工具可以将IL代码编译成native代码, 当应用程序安装在用户的机器上时. 因为代码是在安装的时候编译的, CLR的JIT编译器不需要在运行时刻编译IL代码
 这能提高应用程序的性能. NGen.exe工具在下面两个场合很有趣:
 
 提高了应用程序的启动速度 运行NGen.exe能提高启动速度, 因为代码已经编译成native代码, 所以在运行时就不需要编译了
 减少应用程序的工作集 如果你认为一个程序集会被同时载入到多个进程/ Appdomain, 在这个程序集上运行NGen.exe能减少应用程序的工作集, 其原因是NGen.exe工具将IL编译成native代码,
 然后将输出保存到单独的文件中, 这个文件能同时被内存映射(memory - mapping)到多个进程地址空间中, 允许代码共享, 每个进程 / AppDomain不必为自己拷贝一份代码
 
 当一个安装程序调用NGen.exe对一个应用程序或程序集进行编译时, 那个应用程序的所有程序集或者一个特定的程序集会把其IL代码编译成native代码, 一个新的只包含native代码而不含有IL的程序集文件会被NGen.exe创建.
 这个新的文件被放到名字类似于 C: /Windows/Assembly/NativeImages_v2.0.50727_32的文件夹下面, 这个文件家名字包含了CLR的版本和native代码是否是为x86(32位版本的Windows), x64, 
 或者Itaninum(64位版本的Windows)编译的信息.
 
 现在, 当CLR载入一个程序集文件时, CLR查看对应的NGen native文件是否存在, 如果没发现native文件, CLR JIT对IL代码像通常那样进行编译.
 然而, 如果对应的native文件存在, CLR将使用native文件中的编译好的代码, 文件中的函数就不需要在运行时刻编译了.
 
 在表面上, 这听起来非常好, 听上去就像如果你得到了托管代码的全部优点(垃圾回收, 代码验证, 类型安全, 等等)而不牺牲托管代码的性能(JIT编译), 
 但是实际情况并不总是那么美好, NGen'd文件有几个潜在的问题:
 
 没有知识产权保护 很多人以为可以发布NGen文件而不用发布包含原始IL代码的文件, 从而使他们的知识产权更加保密
 不幸的是, 这并不可行, 在运行时刻, CLR需要访问程序集的metadata(为某些函数, 例如反射和串行化函数), 这需要发布包含IL和metadata的程序集.
 此外, 如果由于某种原因, CLR不能使用NGen文件(如下面所描述的), 那么CLR会回到JIT编译, 对程序集的IL代码进行编译, 因此IL代码必须存在.
 
 NGen文件可能会过时 当CLR载入NGen文件时, 它会比较以前编译的代码和当前的执行环境的很多特征, 如果任何特征不匹配, NGen文件就不能被使用, JIT编译器进程就要使用. 这是必须被匹配的部分特征列表.
 
   程序集模块的版本ID(MVID)
   被引用的程序集的版本ID
   处理器类型
   CLR版本
   Build类型(release, debug, optimized debug, profiling, 等等)
 
 所有链接时的安全性要求都必须在运行时刻被满足才能允许载入.
 
 注意有可能以升级的方式运行NGen.exe, 这告诉工具对以前曾经被执行NGen'd的所有的程序集上运行NGen.exe. 当终端用户安装.NET Framework的一个新service pack, 
 那么service pack的安装程序将会在更新模式下自动运行NGen.exe, 使得NGen文件保持和CLR的版本一致.
 
 较差的载入时性能(重定位/绑定): 程序集文件是标准的Windows PE文件, 每个文件包含着一个优先使用的基地址. 很多Windows开发者对围绕基地址和重定位的问题很熟悉, 
 关于这个主题的更多信息, 可以参考我的书 programming Applications for Microsoft Windows, 4th Edition. 当JIT编译代码时, 不必关心这些问题, 因为正确的内存地址引用会在运行时计算出来.
 
 然而, NGen的程序集文件的一些内存地址引用是静态计算的, 当Windows加载一个NGen文件时, 它检查文件是否被载入到优先的基地址上, 如果文件没有载入到优先的基地址, 
 Windows会重新定位文件, 修改所有内存地址引用. 这是极其耗时的, 因为Windows必须载入整个文件, 并修改文件中的很多字节. 此外, 这个页面文件对应的代码不能跨进程边界共享.
 
 因此如果你打算NGen程序集文件, 你应该为你的程序集文件选择好的基地址(通过csc.exe的 / baseaddress命令行开关).当你NGen一个程序集文件时, NGen文件将被赋予一个基地址, 
 这需要使用一个基于托管程序集基地址的算法. 不幸的是, 微软从没有一个良好的指导来帮助开发者如何赋予基地址. 在64位版本的Windows上, 这还不太会成为问题, 因为地址空间是很充足的, 
 但是对于一个32位的地址空间, 为每一个程序集选择一个好的基地址几乎是不可能的, 除非你精确地知道什么东西会被载入到进程, 知道那个程序集的大小不会超过后一个版本.
 
 较差的执行时性能 当编译代码时, NGen对执行环境做出的假设不会比JIT编译器的多, 这会造成NGen.exe产生较差的代码, 例如, NGen不能优化一些CPU指令, 对静态字段的访问需要简介的操作,
 因为静态字段实际的地址需要在运行时刻才能知道.NGen到处插入代码来调用类的构造函数, 因为它不知道代码执行的次序, 不知道类的构造憾事是否已经被调用了(见第8章, 类的构造函数).
 一些NGen应用程序会比JIT编译的代码慢大约5%, 因此, 如果你打算使用NGen来提高应用程序的性能, 你应该对比NGen’d和非NGen’d版本的应用程序, 确定NGen’d版本在实际执行时并不慢. 
 对于一些应用程序, 减小的工作集大小会提高性能, 因此NGen总体上还是会取胜.
 
 因为上面列出的所有问题, 当考虑使用NGen.exe时, 你应该非常小心.对于服务器端的应用程序来说, NGen.exe的用处很小甚至没有意义, 因为只有第一个客户需求经历了性能上的下降, 
 后面的客户需求都是高速运行的.此外, 对于大多数服务器应用程序, 只需要代码的一个实例, 因此没有工作集方面的利益.
 
 对于客户端应用程序, NGen.exe可能对于提高启动速度或者减小工作集有帮助, 如果程序集被多个应用程序同时使用.甚至没有多个应用程序使用一个程序集, NGen一个程序集也会提高工作集.
 此外, 如果NGen.exe被用于所有的客户端应用程序的程序集, 那么CLR就根本不需要载入JIT编译器, 从而更进一步地降低了工作集.
 当然, 如果只有一个程序集不是NGen'd或者如果一个程序集的NGen文件不能被使用, JIT编译器就会被载入, 应用程序的工作集将会增加.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Scenarios.Debug">
 <summary>
 Generate native images that can be used under a debugger.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Scenarios.Profile">
 <summary>
 Generate native images that can be used under a profiler.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Scenarios.NoDependencies">
 <summary>
 Generate the minimum number Of native images required by the specified scenario options.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.PriorityLevels.Immediately">
 <summary>
 1 Native images are generated And installed immediately, without waiting For idle time.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.PriorityLevels.Waiting">
 <summary>
 2 Native images are generated And installed without waiting For idle time, but after all priority 1 actions (And their dependencies) have completed.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.PriorityLevels.Idle">
 <summary>
 3 Native images are installed When the native image service detects that the computer Is idle. See Native Image Service.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Install(System.String,Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Scenarios,System.String,System.Boolean,Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.PriorityLevels)">
 <summary>
 Generate native images for an assembly and its dependencies and install the images in the native image cache.
 </summary>
 <param name="assemblyName">
 The full display name of the assembly. For example, "myAssembly, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0038abc9deabfle5".
 Only one assembly can be specified per Ngen.exe command line.
 
 * Note You can supply a Partial assembly name, such As myAssembly, For the display And uninstall actions.
 
 The explicit path of the assembly. You can specify a full or relative path.
 If you specify a file name without a path, the assembly must be located In the current directory.
 Only one assembly can be specified per Ngen.exe command line.
 </param>
 <param name="scenarios"></param>
 <param name="ExeConfig">exePath, Use the configuration of the specified executable assembly.
 Ngen.exe needs to make the same decisions as the loader when binding to dependencies. When a shared component Is loaded at run time, 
 using the Load method, the application's configuration file determines the dependencies that are loaded for the shared component — 
 for example, the version of a dependency that is loaded. The /ExeConfig switch gives Ngen.exe guidance on which dependencies would be loaded at run time.</param>
 <param name="AppBase">directoryPath, When locating dependencies, use the specified directory as the application base.</param>
 <param name="queue">If /queue is specified, the action is queued for the native image service. The default priority is 3. See the Priority Levels table.</param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Uninstall(System.String,Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Scenarios,System.String,System.Boolean)">
 <summary>
 Delete the native images of an assembly and its dependencies from the native image cache.
 To uninstall a single image And its dependencies, use the same command-line arguments that were used to install the image.
 
 Note In the .NET Framework 4, the action uninstall * Is no longer supported. 
 </summary>
 <param name="assemblyName">
 The full display name of the assembly. For example, "myAssembly, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0038abc9deabfle5".
 Only one assembly can be specified per Ngen.exe command line.
 
 * Note You can supply a Partial assembly name, such As myAssembly, For the display And uninstall actions.
 
 The explicit path of the assembly. You can specify a full or relative path.
 If you specify a file name without a path, the assembly must be located In the current directory.
 Only one assembly can be specified per Ngen.exe command line.
 </param>
 <param name="scenarios"></param>
 <param name="ExeConfig">exePath, Use the configuration of the specified executable assembly.
 Ngen.exe needs to make the same decisions as the loader when binding to dependencies. When a shared component Is loaded at run time, 
 using the Load method, the application's configuration file determines the dependencies that are loaded for the shared component — 
 for example, the version of a dependency that is loaded. The /ExeConfig switch gives Ngen.exe guidance on which dependencies would be loaded at run time.</param>
 <param name="AppBase">directoryPath, When locating dependencies, use the specified directory as the application base.</param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Update(System.Boolean)">
 <summary>
 Update native images that have become invalid.
 If /queue Is specified, the updates are queued For the native image service. Updates are always scheduled at priority 3, so they run When the computer Is idle.
 </summary>
 <param name="queue"></param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Display(System.String)">
 <summary>
 Display the state of the native images for an assembly and its dependencies.
 If no argument Is supplied, everything In the native image cache Is displayed.
 </summary>
 <param name="assemblyName"></param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.ExecuteQueuedItems(Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.PriorityLevels)">
 <summary>
 Execute queued compilation jobs.
 If a priority Is specified, compilation jobs With greater Or equal priority are executed. 
 If no priority Is specified, all queued compilation jobs are executed.
 </summary>
 <param name="queue"></param>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Queue(Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.QueueActions)">
 <summary>
 Pause the native image service, allow the paused service to continue, or query the status of the service.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.QueueActions.pause">
 <summary>
 Pause the native image service
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.QueueActions.Continue">
 <summary>
 allow the paused service to continue
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.QueueActions.status">
 <summary>
 query the status of the service.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.NgenInstaller.Install">
 <summary>
 将当前目录下的所有的.NET程序都进行安装
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.SoftwareToolkits.ChangeLog">
 <summary>
 Tools for generate the program change log document.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.ChangeLog.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="Path">ChangeLog的文件路径</param>
 <param name="ApplyOn">目标程序的主程序的文件路径</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.ChangeLog.AppendChangeInformation(System.Collections.Generic.IEnumerable{System.String},System.Version,System.String)">
 <summary>
 
 </summary>
 <param name="Changes"></param>
 <param name="version">假若为空的话，会自动的根据上一次版本的号码叠加1</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SoftwareToolkits.ToolkitAPI.RegisterCOMDll(System.String)">
 <summary>
 Register a .NET dll file as a COM component.(将某一个.NET语言所编写的DLL文件注册为COM组件)
 </summary>
 <param name="COM_Dll"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Win32.GetLastErrorAPI">
 <summary>
 Wrapper for the returns value of api <see cref="M:Microsoft.VisualBasic.Win32.GetLastErrorAPI.GetLastError"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Win32.GetLastErrorAPI.GetLastError">
 <summary>
 针对之前调用的api函数，用这个函数取得扩展错误信息（在vb里使用：在vb中，用Err对象的GetLastError属性获取GetLastError的值。
 这样做是必要的，因为在api调用返回以及vb调用继续执行期间，vb有时会重设GetLastError的值）
 
 GetLastError返回的值通过在api函数中调用SetLastError或SetLastErrorEx设置。函数
 并无必要设置上一次错误信息，所以即使一次GetLastError调用返回的是零值，也不能
 担保函数已成功执行。只有在函数调用返回一个错误结果时，这个函数指出的错误结果
 才是有效的。通常，只有在函数返回一个错误结果，而且已知函数会设置GetLastError
 变量的前提下，才应访问GetLastError；这时能保证获得有效的结果。SetLastError函
 数主要在对api函数进行模拟的dll函数中使用。
 </summary>
 <returns></returns>
 <remarks>
 GetLastError返回的值通过在api函数中调用SetLastError或SetLastErrorEx设置。函数并无必要设置上一次错误信息，
 所以即使一次GetLastError调用返回的是零值，也不能担保函数已成功执行。只有在函数调用返回一个错误结果时，
 这个函数指出的错误结果才是有效的。通常，只有在函数返回一个错误结果，而且已知函数会设置GetLastError变量的前提下，
 才应访问GetLastError；这时能保证获得有效的结果。SetLastError函数主要在对api函数进行模拟的dll函数中使用，
 所以对vb应用程序来说是没有意义的
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Win32.GetLastErrorAPI.LastErrors">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Win32.GetLastErrorAPI.GetLastError"/>的返回值的含义：
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Win32.GetLastErrorAPI.LastErrors.Success">
 <summary>
 (0)-操作成功完成。
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Win32.TaskManager">
 <summary>
 Windows的任务管理器的接口
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Win32.TaskManager.CPU_Usages">
 <summary>
 Using this property you can display the CPU usage (over all CPU usage like you would find on the task manager)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.TaskManager.ProcessUsageDetails">
 <summary>
 类似于任务管理器的函数：Memory, CPU, ProcessName, PID, CommandLine
 </summary>
 <returns>Memory, CPU</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Win32.TaskManager.ProcessUsage">
 <summary>
 获取CPU的使用率
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Win32.PriorityClass.GetCurrentProcess">
 <summary>
 当前进程句柄  
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Win32.PriorityClass.IDLE_PRIORITY_CLASS">
 <summary>
 新进程应该有非常低的优先级——只有在系统空闲的时候才能运行。基本值是4  
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Win32.PriorityClass.HIGH_PRIORITY_CLASS">
 <summary>
 新进程有非常高的优先级，它优先于大多数应用程序。基本值是13。注意尽量避免采用这个优先级  
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Win32.PriorityClass.NORMAL_PRIORITY_CLASS">
 <summary>
 标准优先级。如进程位于前台，则基本值是9；如在后台，则优先值是7  
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Win32.PriorityClass.PriorityClass(System.Int32)">
 <summary>
 
 </summary>
 <param name="priority"><see cref="F:Microsoft.VisualBasic.Win32.PriorityClass.IDLE_PRIORITY_CLASS"/>, <see cref="F:Microsoft.VisualBasic.Win32.PriorityClass.HIGH_PRIORITY_CLASS"/>, <see cref="F:Microsoft.VisualBasic.Win32.PriorityClass.NORMAL_PRIORITY_CLASS"/></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Win32.Win32File">
 <summary>
 .NET 2.0 Workaround for PathTooLongException
 </summary>
 <remarks>
 http://www.codeproject.com/Articles/22013/NET-Workaround-for-PathTooLongException
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Win32.Win32File.ERROR_ALREADY_EXISTS">
 <summary>
 Error
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Win32.Win32File.GetMode(System.IO.FileMode)">
 <summary>
 Converts the filemode constant to win32 constant
 </summary>
 <param name="mode"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.Win32File.GetAccess(System.IO.FileAccess)">
 <summary>
 Converts the FileAccess constant to win32 constant
 </summary>
 <param name="access"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.Win32File.GetShare(System.IO.FileShare)">
 <summary>
 Converts the FileShare constant to win32 constant
 </summary>
 <param name="share"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Win32.Win32File.OpenRead(System.String)">
 <summary>
 Open readonly file mode open(String, FileMode.Open, FileAccess.Read, FileShare.Read)
 </summary>
 <param name="filepath"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Win32.Win32File.OpenWrite(System.String)">
 <summary>
 open writable open(String, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None).
 </summary>
 <param name="filepath"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Win32.WindowsServices">
 <summary>
 Windows event logger services &amp; installer services.
 (这个模块主要的功能是日志服务，包括在安装阶段对日志记录的创建以及自定义url协议的创建等，
 请注意，这个模块之中的大部分的功能都需要你的应用程序是在管理员权限之下运行的)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Win32.WindowsServices.ServicesLogs">
 <summary>
 Windows system logging services interface, you can viewing the application log events from Event Viewer:
 Explorer >> Manage >> Event Viewer >> Applications and Services Logs >> &lt;Your_Product>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Win32.WindowsServices.Initialized">
 <summary>
 Does component <see cref="P:Microsoft.VisualBasic.Win32.WindowsServices.ServicesLogs"/> have been initialized?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.WindowsServices.Initialize">
 <summary>
 You should execute the log category entry creates job under the administrators privileges!
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.WindowsServices.Initialize(System.String)">
 <summary>
 You should execute the log category entry creates job under the administrators privileges!
 </summary>
 <param name="ServicesName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.WindowsServices.Initialize(System.String,System.String)">
 <summary>
 You should execute the log category entry creates job under the administrators privileges!
 </summary>
 <param name="ServicesName"></param>
 <param name="Product">This value is usually the property value of <see cref="P:Microsoft.VisualBasic.App.AssemblyName"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.WindowsServices.LogsInstaller(System.String,System.String[])">
 <summary>
 You should execute the log category entry creates job under the administrators privileges!
 </summary>
 <param name="ServicesName"></param>
 <param name="Products">This value is usually the property value of <see cref="P:Microsoft.VisualBasic.App.AssemblyName"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Win32.WindowsServices.RegisterURLProtocol(System.String,System.String,System.String)">
 <summary>
 (**** Please notice, that the application has To have admin privileges To be able To write the needed stuff into registry. ****)
 
 Everyone knows HTTP-URLs. Windows Shell also enables to define own URL protocols. 
 Some programs (like Visual Studio Help ms-help:// ... or Steam steam:// ...) take advantage of this feature. 
 By creating some registry entries one is able to set up a self-made URL protocol. 
 This allows to access your applications by URL (originating from every software).
 
 Please notice, that the application has To have admin privileges To be able To write the needed stuff into registry. 
 You can test your application very easy by opening Windows Explorer And typing "yoururlprotocol://testdata" 
 into the path/address field.
 
 Registers an user defined URL protocol for the usage with
 the Windows Shell, the Internet Explorer and Office.
 
 Example for an URL of an user defined URL protocol:
 
   rainbird://RemoteControl/OpenFridge/GetBeer
 </summary>
 <param name="protocolName">
 Name of the protocol (e.g. "rainbird" for "rainbird://...")
 </param>
 <param name="applicationPath">
 Complete file system path to the EXE file, which processes the URL being called (the complete URL is handed over as a Command Line Parameter).
 </param>
 <param name="description">
 Description (e.g. "URL:Rainbird Custom URL")
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.VistaSecurity.IsAdmin">
 <summary>
 Checks if the process is elevated
 </summary>
 <returns>If is elevated</returns>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.VistaSecurity.AddShieldToButton(System.Windows.Forms.Button)">
 <summary>
 Add a shield icon to a button
 </summary>
 <param name="b">The button</param>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.VistaSecurity.RestartElevated">
 <summary>
 Restart the current process with administrator credentials.(以管理员的身份重启本应用程序)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.MockForm.#ctor(System.String)">
 <summary>
 Construct mock from <see cref="M:Microsoft.VisualBasic.Windows.Forms.MockForm.FindWindow(System.String@,System.String@)"/>
 </summary>
 <param name="found"></param>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.MockTerminal.__init">
 <summary>
 Init by win32 API
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.MockTerminal.__cmd">
 <summary>
 Start a new cmd.exe instance for the terminal mock
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Windows.Forms.SingleInstanceFormEntry`1">
 <summary>
 只打开一个窗体，当窗体已经打开的时候，就会忽略当前的这一次单击事件，反之没有窗体被打开的时候就会打开新的窗体
 </summary>
 <typeparam name="TForm"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.SingleInstanceFormEntry`1.#ctor(System.Boolean)">
 <summary>
 不做任何位置的设置操作
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Windows.Forms.SingleInstanceFormEntry`1.__getDefaultPos(System.Windows.Forms.UserControl,System.Windows.Forms.Form)">
 <summary>
 默认位置是控件的中间
 </summary>
 <param name="Control"></param>
 <param name="Form"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.App">
 <summary>
 Provides information about, and means to manipulate, the current environment Application information collection.
 (More easily runtime environment information provider on <see cref="F:System.PlatformID.Unix"/>/LINUX platform for visualbasic program.)
 </summary>

</member>
<member name="P:Microsoft.VisualBasic.App.Desktop">
 <summary>
 Gets a path name pointing to the Desktop directory.
 </summary>
 <returns>The path to the Desktop directory.</returns>
</member>
<member name="P:Microsoft.VisualBasic.App.PID">
 <summary>
 Get the <see cref="T:System.Diagnostics.Process"/> id(PID) of the current program process.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.App.Process">
 <summary>
 Gets a new <see cref="T:System.Diagnostics.Process"/> component and associates it with the currently active process.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.CommandLine">
 <summary>
 Gets the command-line arguments for this <see cref="T:System.Diagnostics.Process"/>.
 </summary>
 <returns>Gets the command-line arguments for this process.</returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Command">
 <summary>
 Returns the argument portion of the <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> used to start Visual Basic or
 an executable program developed with Visual Basic. The My feature provides greater
 productivity and performance than the <see cref="M:Microsoft.VisualBasic.Interaction.Command"/> function. For more information,
 see <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs"/>.
 </summary>
 <returns>Gets the command-line arguments for this process.</returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ExecutablePath">
 <summary>
 The file path of the current running program executable file.(本应用程序的可执行文件的文件路径)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.AssemblyName">
 <summary>
 Gets the name, without the extension, of the assembly file for the application.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.HOME">
 <summary>
 The program directory of the current running program.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.userHOME">
 <summary>
 Getting the path of the home directory
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.CurrentDirectory">
 <summary>
 The currrent working directory of this application.(应用程序的当前的工作目录)
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.App._preDIR">
 <summary>
 -
 Linux里面的前一个文件夹
 </summary>
 <remarks>
 假设你之前好不容易进入了一个很深的目录，然后不小心敲了个 cd /，是不是快气晕了啊，不用着急，通过下面的指令可以轻松的回到前一个指令：

      cd -
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.App.StartupDirectory">
 <summary>
 Gets the path for the executable file that started the application, not including the executable name.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ProductProgramData">
 <summary>
 The repository root of the product application program data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ProductSharedDIR">
 <summary>
 The shared program data directory for a group of app which have the same product series name.
 (同一產品程序集所共享的數據文件夾)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetProductSharedDIR(System.Type)">
 <summary>
 使用<see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>的位置会变化的，则使用本函数则会使用获取当前的模块的文件夹，即使其不是exe程序而是一个dll文件
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.StartTime">
 <summary>
 The time tag of the application started.(应用程序的启动的时间)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.ElapsedMilliseconds">
 <summary>
 The distance of time that this application running from start and to current time.
 (当前距离应用程序启动所逝去的时间)
 </summary>
 <returns></returns>

</member>
<member name="P:Microsoft.VisualBasic.App.LocalData">
 <summary>
 The local data dir of the application in the %user%/&lt;CurrentUser>/Local/Product/App
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.LocalDataTemp">
 <summary>
 The temp directory in the application local data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.SysTemp">
 <summary>
 The directory path of the system temp data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.__sysTEMP">
 <summary>
 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)"/>(<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName"/>)
 当临时文件夹被删除掉了的时候，会出现崩溃。。。。所以弃用改用读取环境变量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.AppSystemTemp">
 <summary>
 Application temp data directory in the system temp root: %<see cref="P:Microsoft.VisualBasic.App.SysTemp"/>%/<see cref="P:Microsoft.VisualBasic.App.AssemblyName"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Version">
 <summary>
 Gets the product version associated with this application.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String)">
 <summary>
 Simply log application exception data into a log file which saves at location: %<see cref="P:Microsoft.VisualBasic.App.LocalData"/>%/.logs/err/.
 (简单日志记录，函数返回空值)
 </summary>
 <param name="ex"></param>
 <param name="Trace">调用函数的位置，这个参数一般为空，编译器会自动生成Trace位点参数</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.TraceBugs(System.Exception,System.String)">
 <summary>
 Function returns the file path of the application log file.
 (函数返回的是日志文件的文件路径)
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.__getTEMP">
 <summary>
 由于可能会运行多个使用本模块的进程，单独考哈希来作为表示会产生冲突，所以这里使用应用程序的启动时间戳以及当前的哈希值来生成唯一标示
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.LogErrDIR">
 <summary>
 Error default log fie location from function <see cref="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String)"/>.(存放自动存储的错误日志的文件夹)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String,System.String)">
 <summary>
 Simply log application exception data into a log file which saves at a user defined location parameter: <paramref name="FileName"/>.
 (简单日志记录)
 </summary>
 <param name="ex"></param>
 <param name="Trace"></param>
 <param name="FileName"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.BugsFormatter(System.Exception,System.String)">
 <summary>
 Generates the formatted error log file content.(生成简单的日志板块的内容)
 </summary>
 <param name="ex"></param>
 <param name="Trace"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.String,System.String)">
 <summary>
 This is the custom message of the exception, not extract from the function <see cref="M:System.Exception.ToString"/>
 </summary>
 <param name="exMsg">This is the custom message of the exception, not extract from the function <see cref="M:System.Exception.ToString"/></param>
 <param name="Trace"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ExceptionLogFile">
 <summary>
 <see cref="P:Microsoft.VisualBasic.App.LocalData"/>/error.log
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.Exit(System.Int32)">
 <summary>
  Terminates this <see cref="T:System.Diagnostics.Process"/> and gives the underlying operating system the specified exit code.
  (这个方法还会终止本应用程序里面的自动GC线程)
 </summary>
 <param name="state">Exit code to be given to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,System.String)">
 <summary>
 Running the <see cref="T:System.String"/> as cli command line and the specific type define as a <see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter"/>.
 (请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.__ExecuteNotFound,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.__ExecuteNotFound,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.__ExecuteFile,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.__ExecuteFile,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.__ExecuteFile,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.__ExecuteFile,Microsoft.VisualBasic.CommandLine.__ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.CLICode(System.Boolean,System.Int32)">
 <summary>
 IF the flag is True, that means cli API execute successfully, function returns ZERO, or a negative integer(Default -100) for failures.
 </summary>
 <param name="b"></param>
 <param name="Failed"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetTempFile">
 <summary>
 Creates a uniquely named zero-byte temporary file on disk and returns the full
 path of that file.
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.GetAppSysTempFile(System.String,System.String)">
 <summary>
 Get temp file name in app system temp directory.
 </summary>
 <param name="ext"></param>
 <param name="sessionID"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.GenerateTemp(System.String,System.String)">
 <summary>

 </summary>
 <param name="sysTemp">临时文件路径</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.GetProductSharedTemp">
 <summary>
 Gets a temp file name which is located at directory <see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>.
 (获取位于共享文件夹<see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>里面的临时文件)
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.SelfFolk(System.String)">
 <summary>
 Self call this program itself for batch parallel task calculation.
 (调用自身程序，这个通常是应用于批量的数据的计算任务的实现)
 </summary>
 <param name="CLI"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.SelfFolks(System.Collections.Generic.IEnumerable{System.String},System.Int32)">
 <summary>
 Folk this program itself for the large amount data batch processing.
 </summary>
 <param name="CLI"></param>
 <param name="parallel">小于等于零表示非并行化，单线程任务</param>
 <returns>返回任务的执行的总时长</returns>

</member>
<member name="F:Microsoft.VisualBasic.App.__GCThread">
 <summary>
 自动垃圾回收线程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.__completeCLI(System.Int32)">
 <summary>
 自动停止GC当前程序的线程
 </summary>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.StartGC(System.Boolean)">
 <summary>
 Start the automatic garbage collection threads.
 (这条线程只会自动清理*.tmp临时文件，因为假若不清理临时文件的话，有时候临时文件比较多的时候，会严重影响性能，甚至无法运行应用程序框架里面的IO重定向操作)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.__GCThreadInvoke">
 <summary>
 自动垃圾回收线程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.StopGC">
 <summary>
 Stop the automatic garbage collection threads.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.RunAsAdmin">
 <summary>
 Restart the current process with administrator credentials.(以管理员的身份重启本应用程序)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.Icon(System.String)">
 <summary>
 设置所编译的应用程序的图标
 </summary>
 <param name="iconPath"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.GenerateCode(System.CodeDom.CodeNamespace,System.String)">
 <summary>
 Generate the source code from the CodeDOM object model.(根据对象模型生成源代码以方便调试程序)
 </summary>
 <param name="NameSpace"></param>
 <param name="CodeStyle">VisualBasic, C#</param>
 <returns></returns>
 <remarks>
 You can easily convert the source code between VisualBasic and C# using this function just by makes change in statement: 
 CodeDomProvider.GetCompilerInfo("VisualBasic").CreateProvider().GenerateCodeFromNamespace([NameSpace], sWriter, Options)
 Modify the VisualBasic in to C#
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.Compile(System.CodeDom.CodeNamespace,System.String[],System.String,System.String)">
 <summary>
 Compile the codedom object model into a binary assembly module file.(将CodeDOM对象模型编译为二进制应用程序文件)
 </summary>
 <param name="ObjectModel">CodeDom dynamic code object model.(目标动态代码的对象模型)</param>
 <param name="Reference">Reference assemby file path collection.(用户代码的引用DLL文件列表)</param>
 <param name="DotNETReferenceAssembliesDir">.NET Framework SDK</param>
 <param name="CodeStyle">VisualBasic, C#</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.Compile(System.CodeDom.CodeNamespace,System.String[],System.String,System.CodeDom.Compiler.CompilerParameters,System.String)">
 <summary>
 Compile the codedom object model into a binary assembly module file.(将CodeDOM对象模型编译为二进制应用程序文件)
 </summary>
 <param name="ObjectModel">CodeDom dynamic code object model.(目标动态代码的对象模型)</param>
 <param name="Reference">Reference assemby file path collection.(用户代码的引用DLL文件列表)</param>
 <param name="DotNETReferenceAssembliesDir">.NET Framework SDK</param>
 <param name="CodeStyle">VisualBasic, C#</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.Compile(System.CodeDom.CodeCompileUnit,System.String[],System.String,System.String)">
 <summary>
 Compile the codedom object model into a binary assembly module file.(将CodeDOM对象模型编译为二进制应用程序文件)
 </summary>
 <param name="ObjectModel">CodeDom dynamic code object model.(目标动态代码的对象模型)</param>
 <param name="Reference">Reference assemby file path collection.(用户代码的引用DLL文件列表)</param>
 <param name="DotNETReferenceAssembliesDir">.NET Framework SDK</param>
 <param name="CodeStyle">VisualBasic, C#</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.ExecutableProfile">
 <summary>
 .exe的编译配置文件
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.DllProfile">
 <summary>
 .Dll的编译配置文件
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.Compile(System.CodeDom.CodeCompileUnit,System.String[],System.String,System.CodeDom.Compiler.CompilerParameters,System.String)">
 <summary>
 Compile the codedom object model into a binary assembly module file.(将CodeDOM对象模型编译为二进制应用程序文件)
 </summary>
 <param name="ObjectModel">CodeDom dynamic code object model.(目标动态代码的对象模型)</param>
 <param name="Reference">Reference assemby file path collection.(用户代码的引用DLL文件列表)</param>
 <param name="DotNETReferenceAssembliesDir">.NET Framework SDK</param>
 <param name="CodeStyle">VisualBasic, C#</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExtension.DotNETFramework">
 <summary>
 基本的引用集合
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.EntryPoint">
 <summary>
 Public Shared Function Main(Argvs As String()) As Integer
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.DeclareFunc(System.String,System.Collections.Generic.Dictionary{System.String,System.Type},System.Type,System.CodeDom.MemberAttributes)">
 <summary>
 声明一个函数
 </summary>
 <param name="name"></param>
 <param name="args"></param>
 <param name="returns"></param>
 <param name="control"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.FieldRef(System.String)">
 <summary>
 Reference of Me.Field
 </summary>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.New(System.Type,System.CodeDom.CodeExpression[])">
 <summary>
 Class object instance constructor
 </summary>
 <param name="Type"></param>
 <param name="parameters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.New``1(System.Object[])">
 <summary>
 Class object instance constructor.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="parameters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.LocalsInit(System.String,System.Type,System.CodeDom.CodeExpression)">
 <summary>
 声明一个局部变量
 </summary>
 <param name="Name"></param>
 <param name="Type"></param>
 <param name="initExpression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.LocalsInit(System.String,System.Type,System.Object)">
 <summary>
 Declare a local variable.
 </summary>
 <param name="Name"></param>
 <param name="Type"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.Call(System.Type,System.String,System.Object[])">
 <summary>
 Call a statics function from a specific type with a known function name
 </summary>
 <param name="type"></param>
 <param name="Name"></param>
 <param name="parametersValue"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.Return(System.CodeDom.CodeExpression)">
 <summary>
 Returns value in a function body
 </summary>
 <param name="expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.Reference(System.Type,System.String)">
 <summary>
 Reference to a statics field in the specific target type
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.Reference(System.CodeDom.CodeExpression,System.String)">
 <summary>
 Reference to a instance field in the specific object instance. 
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.Value(System.Object)">
 <summary>
 Variable value initializer
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.LocalVariable(System.String)">
 <summary>
 Reference to a local variable in a function body.(引用局部变量)
 </summary>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.GetValue(System.CodeDom.CodeExpression,System.Int32)">
 <summary>
 Gets the element value in a array object.
 </summary>
 <param name="Array"></param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.CodeDOMExpressions.GetType(System.Type)">
 <summary>
 System.Type.GetType(TypeName)
 </summary>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.VBC.CreateParameters(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 Construct of the vbc.exe compiler parameters.
 </summary>
 <param name="ref"></param>
 <param name="SDK"></param>
 <param name="dll"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.VBC.CompileCode(System.String,System.String,System.String@)">
 <summary>
 
 </summary>
 <param name="code">VisualBasic源代码</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CodeDOM_VBC.VBC.CompileCode(System.String,System.CodeDom.Compiler.CompilerParameters,System.String@)">
 <summary>
 
 </summary>
 <param name="code">VisualBasic源代码</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ControlsExtension">
 <summary>
 Two Extension methods which expose the ExtendedProps class through the label's Tag object is all you need.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ExtendedProps">
 <summary>
 An Almost Extension Property
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ListExtensions">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Boolean)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ToList``1(System.Linq.ParallelQuery{``0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.List`1"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.KeyValuePairExtensions.ToDictionary``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/>`2 from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>`1
 according to a specified key selector function.
 </summary>
 <typeparam name="T">Unique identifier provider</typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.KeyValuePairExtensions.Add``2(Microsoft.VisualBasic.List{Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject{``0,``1}}@,``0,``1)">
 <summary>
 Adds an object to the end of the List`1.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="list"></param>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Midv``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="start">0 base</param>
 <param name="length"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Split``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="delimiter">和字符串的Split函数一样，这里作为delimiter的元素都不会出现在结果之中</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.GetIndexes``1(``0[],System.Func{``0,System.Boolean})">
 <summary>
 查找出列表之中符合条件的所有的索引编号
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="condi"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MatrixExtensions.MAT``1(System.Int32,System.Int32)">
 <summary>
 生成一个有m行n列的矩阵，但是是使用数组来表示的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="m"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MatrixExtensions.ToMatrix``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Convert the data collection into a matrix value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">The elements number in each collection should be agreed!(要求集合之中的每一列之中的数据的元素数目都相等)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.MatrixExtensions.ToVectorList``1(``0[0:,0:])">
 <summary>
 Convert the matrix data into a collection of collection data type.(将矩阵对象转换为集合的集合的类型)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="MAT"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.VBDebugger">
 <summary>
 Debugger helper module for VisualBasic Enterprises System.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.LinqProc``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 当在执行大型的数据集合的时候怀疑linq里面的某一个任务进入了死循环状态，可以使用这个方法来检查是否如此
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="TAG"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.VBDebugger.Mute">
 <summary>
 Disable the debugger information outputs on the console if this <see cref="P:Microsoft.VisualBasic.VBDebugger.Mute"/> property is set to True, 
 and enable the output if this property is set to False. 
 NOTE: this debugger option property can be overrides by the debugger parameter from the CLI parameter named '--echo'
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.__DEBUG_ECHO(System.String,System.Int32)">
 <summary>
 Output the full debug information while the project is debugging in debug mode.
 (向标准终端和调试终端输出一些带有时间戳的调试信息)
 </summary>
 <param name="MSG">The message fro output to the debugger console, this function will add a time stamp automaticly To the leading position Of the message.</param>
 <param name="Indent"></param>
 <returns>其实这个函数是不会返回任何东西的，只是因为为了Linq调试输出的需要，所以在这里是返回Nothing的</returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.PrintException``1(``0,System.String)">
 <summary>
 The function will print the exception details information on the standard <see cref="T:System.Console"/>, <see cref="T:System.Diagnostics.Debug"/> console, and system <see cref="T:System.Diagnostics.Trace"/> console.
 (分别在标准终端，调试终端，系统调试终端之中打印出错误信息，请注意，函数会直接返回False可以用于指定调用者函数的执行状态，这个函数仅仅是在终端上面打印出错误，不会保存为日志文件)
 </summary>
 <typeparam name="ex"></typeparam>
 <param name="exception"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.PrintException(System.String,System.String)">
 <summary>
 可以使用这个方法<see cref="M:System.Reflection.MethodBase.GetCurrentMethod"/>.<see cref="M:Microsoft.VisualBasic.EmitReflection.GetFullName(System.Reflection.MethodBase,System.Boolean)"/>获取得到<paramref name="memberName"/>所需要的参数信息
 </summary>
 <param name="msg"></param>
 <param name="memberName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Warning(System.String,System.String)">
 <summary>
 Display the wraning level(YELLOW color) message on the console.
 </summary>
 <param name="msg"></param>
 <param name="calls"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.Boolean,System.String,Microsoft.VisualBasic.Logging.MSG_TYPES,System.String)">
 <summary>
 If <paramref name="test"/> boolean value is False, then the assertion test failure. If the test is failure the specific message will be output on the console.
 </summary>
 <param name="test"></param>
 <param name="fails"></param>
 <param name="level"></param>
 <param name="calls"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.String,Microsoft.VisualBasic.Logging.MSG_TYPES,System.String)">
 <summary>
 If the <paramref name="test"/> message is not null or empty string, then the console will output the message.
 </summary>
 <param name="test"></param>
 <param name="level"></param>
 <param name="calls"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.Boolean,System.String,System.String)">
 <summary>
 If <paramref name="test"/> is false(means this assertion test failure), then throw exception.
 </summary>
 <param name="test"></param>
 <param name="msg"></param>
</member>
<member name="T:Microsoft.VisualBasic.VBDebugger.VisualBasicAppException">
 <summary>
 VisualBasic application exception wrapper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.VisualBasicAppException.#ctor(System.Exception,System.String)">
 <summary>
 <see cref="T:System.Exception"/> inner wrapper
 </summary>
 <param name="ex">The exception details</param>
 <param name="calls">Method name where occurs this exception.</param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.__DEBUG_ECHO(System.Text.StringBuilder,System.Int32)">
 <summary>
 Output the full debug information while the project is debugging in debug mode.
 (向标准终端和调试终端输出一些带有时间戳的调试信息)
 </summary>
 <param name="MSG">The message fro output to the debugger console, this function will add a time stamp automaticly To the leading position Of the message.</param>
 <param name="Indent"></param>

</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.this(System.String)">
 <summary>
 Returns the current function name.
 </summary>
 <param name="caller">
 The caller function name, do not assign any value to this parameter! Just leave it blank.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Echo(System.String)">
 <summary>
 Alias for <see cref="M:System.Console.Write(System.Boolean)"/>
 </summary>
 <param name="s"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Echo(System.Char)">
 <summary>
 Alias for <see cref="M:System.Console.Write(System.Boolean)"/>
 </summary>
 <param name="c"></param>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.ReadBinary(System.String)">
 <summary>
 <see cref="M:System.IO.File.ReadAllBytes(System.String)"/>, if the file is not exists on the filesystem, then a empty array will be return.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushAllLines``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Text.Encoding)">
 <summary>
 Write all object into a text file by using its <see cref="T:System.Object"/> method.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="SaveTo"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushStream(System.Collections.Generic.IEnumerable{System.Byte},System.String)">
 <summary>
 Save the binary data into the filesystem.(保存二进制数据包值文件系统)
 </summary>
 <param name="buf">The binary bytes data of the target package's data.(目标二进制数据)</param>
 <param name="path">The saved file path of the target binary data chunk.(目标二进制数据包所要进行保存的文件名路径)</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="T:Microsoft.VisualBasic.PartitionedStream">
 <summary>
 只是针对文本文件的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PartitionedStream.#ctor(System.String,System.Int32,System.Text.Encoding)">
 <summary>
 依照换行符来进行分区
 </summary>
 <param name="path"></param>
 <param name="blockSize"></param>
 <param name="encoding"></param>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.IterateAllLines(System.String)">
 <summary>
 通过具有缓存的流对象读取文本数据，使用迭代器来读取文件之中的所有的行，大文件推荐使用这个方法进行读取操作
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadFirstLine(System.String)">
 <summary>
 Read the first line of the text in the file.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadAllText(System.String,System.Text.Encoding)">
 <summary>
 这个函数只建议读取小文本文件的时候使用
 </summary>
 <param name="FilePath"></param>
 <param name="Encoding">Default value is UTF8</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadAllLines(System.String,System.Text.Encoding)">
 <summary>
 这个函数只建议读取小文本文件的时候使用
 </summary>
 <param name="path"></param>
 <param name="Encoding">Default value is UTF8</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.String,System.String,System.Text.Encoding)">
 <summary>
 Write the text file data into a file which was specific by the <paramref name="path"></paramref> value,
 this function not append the new data onto the target file.
 (将目标文本字符串写入到一个指定路径的文件之中，但是不会在文件末尾追加新的数据)
 </summary>
 <param name="path"></param>
 <param name="text"></param>
 <param name="encoding">这个函数会自动处理文本的编码的</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.Xml.Linq.XElement,System.String,System.Text.Encoding)">
 <summary>
 Save the inner text value of a xml element
 </summary>
 <param name="value"></param>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.IsTextFile(System.String,System.Int32)">
 <summary>
 Determined that the target file is a text file or binary file?
 (判断是否是文本文件)
 </summary>
 <param name="FilePath">文件全路径名称</param>
 <returns>是返回True，不是返回False</returns>
 <param name="chunkSize">文件检查的长度，假若在这个长度内都没有超过null的阈值数，则认为该文件为文本文件，默认区域长度为4KB</param>
 <remarks>2012年12月5日</remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.Collections.Generic.IEnumerable{System.String},System.String,System.Text.Encoding)">
 <summary>
 将目标字符串数据全部写入到文件之中，当所写入的文件位置之上没有父文件夹存在的时候，会自动创建文件夹
 </summary>
 <param name="array"></param>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.SafeLoadXml``1(System.String,Microsoft.VisualBasic.TextEncodings.Encodings,System.Func{System.String,System.String})">
 <summary>
 这个函数主要是用作于Linq里面的Select语句拓展的，这个函数永远也不会报错，只会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadXml``1(System.String,System.Text.Encoding,System.Boolean,System.Func{System.String,System.String})">
 <summary>
 Load class object from the exists Xml document.(从文件之中加载XML之中的数据至一个对象类型之中)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="XmlFile">The path of the xml document.(XML文件的文件路径)</param>
 <param name="ThrowEx">
 If the deserialization operation have throw a exception, then this function should process this error automatically or just throw it?
 (当反序列化出错的时候是否抛出错误？假若不抛出错误，则会返回空值)
 </param>
 <param name="preprocess">
 The preprocessing on the xml document text, you can doing the text replacement or some trim operation from here.(Xml文件的预处理操作)
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadXml(System.String,System.Type,System.Text.Encoding,System.Boolean,System.Func{System.String,System.String})">
 <summary>
 从文件之中加载XML之中的数据至一个对象类型之中
 </summary>
 <param name="XmlFile">XML文件的文件路径</param>
 <param name="ThrowEx">当反序列化出错的时候是否抛出错误？假若不抛出错误，则会返回空值</param>
 <param name="preprocess">Xml文件的预处理操作</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.GetXml``1(``0,System.Boolean,Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 Serialization the target object type into a XML document.(将一个类对象序列化为XML文档)
 </summary>
 <typeparam name="T">The type of the target object data should be a class object.(目标对象类型必须为一个Class)</typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.SaveAsXml``1(``0,System.String,System.Boolean,System.Text.Encoding,System.String)">
 <summary>
 Save the object as the XML document.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <param name="saveXml"></param>
 <param name="throwEx"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.CreateObjectFromXml``1(System.String,System.Boolean)">
 <summary>
 Generate a specific type object from a xml document stream.(使用一个XML文本内容创建一个XML映射对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Xml">This parameter value is the document text of the xml file, not the file path of the xml file.(是Xml文件的文件内容而非文件路径)</param>
 <param name="ThrowEx">Should this program throw the exception when the xml deserialization error happens?
 if False then this function will returns a null value instead of throw exception.
 (在进行Xml反序列化的时候是否抛出错误，默认抛出错误，否则返回一个空对象)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.CreateObjectFromXmlFragment``1(System.String)">
 <summary>
 使用一个XML文本内容的一个片段创建一个XML映射对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Xml">是Xml文件的文件内容而非文件路径</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Correlations.SW(System.Double[],System.Double[])">
 <summary>
 假若所有的元素都是0-1之间的话，结果除以2可以得到相似度
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Correlations.TINY">
 <summary>
 will regularize the unusual case of complete correlation
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Correlations.GetPearson(System.Double[],System.Double[],System.Double@,System.Double@,System.Double@)">
 <summary>

 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="prob"></param>
 <param name="prob2"></param>
 <param name="z"></param>
 <returns></returns>
 <remarks>
 checked by Excel
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Correlations.ICorrelation">
 <summary>
 相关性的计算分析函数
 </summary>
 <param name="X"></param>
 <param name="Y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Correlations.Spearman(System.Double[],System.Double[])">
 <summary>
 This method should not be used in cases where the data set is truncated; that is,
 when the Spearman correlation coefficient is desired for the top X records
 (whether by pre-change rank or post-change rank, or both), the user should use the
 Pearson correlation coefficient formula given above.
 (斯皮尔曼相关性)
 </summary>
 <param name="X"></param>
 <param name="Y"></param>
 <returns></returns>
 <remarks>
 https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient
 checked!
 </remarks>

</member>
<member name="T:Microsoft.VisualBasic.Correlations.spcc">
 <summary>
 计算所需要的临时变量类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Correlations.spcc.rank">
 <summary>
 排序之后得到的位置
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Correlations.spcc.data">
 <summary>
 原始数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Correlations.spcc.__spccInner.i">
 <summary>
 在序列之中原有的位置
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Ranks.Ranking`1.Max">
 <summary>
 The sort direction
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Ranks.Ranking`1.Weight">
 <summary>
 默认不加权重
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Ranks.Best``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Ranks.Ranking{``0}})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="Evaluate"></param>
 <returns>Ranks值最小的是认为最好的</returns>
</member>
<member name="T:Microsoft.VisualBasic.RandomExtensions">
 <summary>
 Some extension methods for <see cref="T:System.Random"/> for creating a few more kinds of random stuff.
 </summary>
 <remarks>Imports from https://github.com/rvs76/superbest-random.git </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.NextGaussian(System.Random,System.Double,System.Double)">
 <summary>
 Generates normally distributed numbers. Each operation makes two Gaussians for the price of one, and apparently they can be cached or something for better performance, but who cares.
 </summary>
 <param name="r"></param>
 <param name = "mu">Mean of the distribution</param>
 <param name = "sigma">Standard deviation</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.NextTriangular(System.Random,System.Double,System.Double,System.Double)">
 <summary>
 Generates values from a triangular distribution.
 </summary>
 <remarks>
 See http://en.wikipedia.org/wiki/Triangular_distribution for a description of the triangular probability distribution and the algorithm for generating one.
 </remarks>
 <param name="r"></param>
 <param name = "a">Minimum</param>
 <param name = "b">Maximum</param>
 <param name = "c">Mode (most frequent value)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.NextBoolean(System.Random)">
 <summary>
 Equally likely to return true or false. Uses <see cref="M:System.Random.Next"/>.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.Shuffle``1(System.Random,Microsoft.VisualBasic.List{``0}@)">
 <summary>
 Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
 </summary>
 <param name="r"></param>
 <param name = "list"></param>
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.Shuffle(System.Random,System.Collections.IList@)">
 <summary>
 Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
 </summary>
 <param name="r"></param>
 <param name = "list"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)">
 <summary>
 Returns n unique random numbers in the range [1, n], inclusive. 
 This is equivalent to getting the first n numbers of some random permutation of the sequential numbers from 1 to max. 
 Runs in O(k^2) time.
 </summary>
 <param name="rand"></param>
 <param name="n">Maximum number possible.</param>
 <param name="k">How many numbers to return.</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ScaleMaps.TrimRanges(System.Double[],System.Double,System.Double)">
 <summary>
 Trims the data ranges, 
 if n in <paramref name="Dbl"/> vector is less than <paramref name="min"/>, then set n = min;
 else if n is greater than <paramref name="max"/>, then set n value to max, 
 else do nothing.
 </summary>
 <param name="Dbl"></param>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ScaleMaps.GenerateMapping(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
 <summary>
 如果每一个数值之间都是相同的大小，则返回原始数据，因为最大值与最小值的差为0，无法进行映射的创建（会出现除0的错误）
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>为了要保持顺序，不能够使用并行拓展</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ScaleMaps.GenerateMapping(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
 <summary>
 如果每一个数值之间都是相同的大小，则返回原始数据，因为最大值与最小值的差为0，无法进行映射的创建（会出现除0的错误）
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>为了要保持顺序，不能够使用并行拓展</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ScaleMaps.Scale(System.Collections.Generic.IEnumerable{System.Double},System.Boolean,System.Boolean)">
 <summary>
 Function centers and/or scales the columns of a numeric matrix.
 </summary>
 <param name="data">numeric matrix</param>
 <param name="center">either a logical value or a numeric vector of length equal to the number of columns of x</param>
 <param name="isScale">either a logical value or a numeric vector of length equal to the number of columns of x</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CloneExtensions">
 <summary>
 Some extension for copy a collection object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CloneExtensions.Clone``2(System.Collections.Generic.IDictionary{``0,``1})">
 <summary>
 Creates a new dictionary
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="hash"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Current">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Pointer"/> -> its current value
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Length">
 <summary>
 Memory block size
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Value(System.Int32)">
 <summary>
 相对于当前的指针的位置而言的
 </summary>
 <param name="p">相对于当前的位置的offset偏移量</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Raw">
 <summary>
 Raw memory of this pointer
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.EndRead">
 <summary>
 Is read to end?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Pointer">
 <summary>
 Current read position
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_LessThan(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 前移<paramref name="offset"/>个单位，然后返回值，这个和Peek的作用一样，不会改变指针位置
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_GreaterThan(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 后移<paramref name="offset"/>个单位，然后返回值，这个和Peek的作用一样，不会改变指针位置
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.MoveNext">
 <summary>
 Pointer move to next and then returns is <see cref="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.EndRead"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_UnaryPlus(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0})">
 <summary>
 Pointer move to next and then returns the previous value
 </summary>
 <param name="ptr"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1">
 <summary>
 内存指针
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>只不过这个对象是封装了写内存操作的</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Scan0">
 <summary>
 第一个位置
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.#ctor(System.IntPtr,System.Int32,Microsoft.VisualBasic.Emit.Marshal.UnsafeCopys{`0},Microsoft.VisualBasic.Emit.Marshal.UnsafeWrite{`0})">
 <summary>
 
 </summary>
 <param name="p"></param>
 <param name="chunkSize"></param>
 <param name="unsafeCopys">
 Public Sub UnsafeCopys(Of <typeparamref name="T"/>)(source As <see cref="T:System.IntPtr"/>, destination As <typeparamref name="T"/>(), startIndex As <see cref="T:System.Int32"/>, length As <see cref="T:System.Int32"/>)
 </param>
 <param name="unsafeWrite">
 Public Sub UnsafeWrite(Of <typeparamref name="T"/>)(destination As <typeparamref name="T"/>(), startIndex As <see cref="T:System.Int32"/>, source As <see cref="T:System.IntPtr"/>, length As <see cref="T:System.Int32"/>)
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.#ctor(`0[]@,System.IntPtr)">
 <summary>
 方便进行数组操作的
 </summary>
 <param name="raw"></param>
 <param name="p"></param>
</member>
<member name="F:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.__writeMemory">
 <summary>
 Public Delegate Sub UnsafeWrite(Of T)(destination As T(), startIndex As Integer, source As System.IntPtr, length As Integer)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Write">
 <summary>
 Unsafe write memory
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.Byte">
 <summary>
 Represents a pointer to an 8-bit unsigned integer array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Byte.#ctor(System.IntPtr,System.Int32)">
 <summary>
 Represents a pointer to an 8-bit unsigned integer array.
 </summary>
 <param name="p">The start address location of the array in the memory</param>
 <param name="chunkSize">array length</param>
</member>
<member name="T:Microsoft.VisualBasic.SecurityString.Md5HashProvider">
 <summary>
 并行化的需求
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5hashLong(System.Byte[])">
 <summary>
 <see cref="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])"/> -> <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.Byte[])"/>
 </summary>
 <param name="input"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetMd5Hash(System.String)">
 <summary>
 Calculate md5 hash value for the input string.
 </summary>
 <param name="input"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetHashCode(System.String)">
 <summary>
 Gets the hashcode of the input string. (<paramref name="input"/> => <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetMd5Hash(System.Byte[])"/> => <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.String)"/>)
 </summary>
 <param name="input">任意字符串</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetHashCode(System.Collections.Generic.IEnumerable{System.Byte})">
 <summary>
 Gets the hashcode of the input string.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.String)">
 <summary>
 Gets the hashcode of the md5 string.
 </summary>
 <param name="md5">计算所得到的MD5哈希值</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.Byte[])">
 <summary>
 CityHash algorithm for convert the md5 hash value as a <see cref="T:System.Int64"/> value.
 </summary>
 <param name="bytes">
 this input value should compute from <see cref="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5Bytes(System.Byte[])"/>
 </param>
 <returns></returns>
 <remarks>
 http://stackoverflow.com/questions/9661227/convert-md5-to-long
 
 The very best solution I found (based on my needs... mix of speed and good hash function) is Google's CityHash. 
 The input can be any byte array including an MD5 result and the output is an unsigned 64-bit long.

 CityHash has a very good but Not perfect hash distribution, And Is very fast.

 I ported CityHash from C++ To C# In half an hour. A Java port should be straightforward too.

 Just XORing the bits doesn't give as good a distribution (though admittedly that will be very fast).

 I'm not familiar enough with Java to tell you exactly how to populate a long from a byte array 
 (there could be a good helper I'm not familiar with, or I could get some details of arithmetic 
 in Java wrong). 
 Essentially, though, you'll want to do something like this:

 Long a = md5[0] * 256 * md5[1] + 256 * 256 * md5[2] + 256 * 256 * 256 * md5[3];
 Long b = md5[4] * 256 * md5[5] + 256 * 256 * md5[6] + 256 * 256 * 256 * md5[7];
 Long result = a ^ b;
 
 Note I have made no attempt To deal With endianness. If you just care about a consistent hash value, 
 though, endianness should Not matter.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.StringToByteArray(System.String)">
 <summary>
 由于md5是大小写无关的，故而在这里都会自动的被转换为小写形式，所以调用这个函数的时候不需要在额外的转换了
 </summary>
 <param name="hex"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.VerifyMd5Hash(System.String,System.String)">
 <summary>
 Verify a hash against a string. 
 </summary>
 <param name="input"></param>
 <param name="comparedHash"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.VerifyFile(System.String,System.String)">
 <summary>
 校验两个文件的哈希值是否一致
 </summary>
 <param name="query"></param>
 <param name="subject"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetFileHashString(System.String)">
 <summary>
 Get the md5 hash calculation value for a specific file.(获取文件对象的哈希值，请注意，当文件不存在或者文件的长度为零的时候，会返回空字符串)
 </summary>
 <param name="PathUri">The file path of the target file to be calculated.</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.SaltValue(System.String)">
 <summary>
 SHA256 8 bits salt value for the private key.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SecurityString.SHA256">
 <summary>
 Derives a SHA256 key from a password using an extension of the PBKDF1 algorithm.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="password"></param>
 <param name="saltValue">8 Bytes</param>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.DecryptString(System.String)">
 <summary>
 字符串的解密方法
 </summary>
 <param name="cipherText"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.EncryptData(System.String)">
 <summary>
 Encrypt the plain text string.
 </summary>
 <param name="plainText"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SecurityString.SHA256.CertificateSigned">
 <summary>
 The previous key of the sha256 encryption will be expired after the rebuild of this module,
 so that this method is not working on the statics data storage job.
 (在本模块进行重新编译之后，原有的密匙将会失效，故这个属性不适合于静态存储加密使用)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.GetDynamicsCertification``1">
 <summary>
 双重动态数据签名
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.GetDynamicsCertification(System.Type)">
 <summary>
 双重动态数据签名
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.TripleDES.#ctor(System.Byte[],System.Byte[])">
 <summary>
 
 </summary>
 <param name="key">24byte</param>
 <param name="iv">8byte</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Parser">
 <summary>
 Simple type parser
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseInteger(System.String)">
 <summary>
 <see cref="T:System.Int32"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseLong(System.String)">
 <summary>
 <see cref="T:System.Int64"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseDouble(System.String)">
 <summary>
 <see cref="T:System.Double"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseSingle(System.String)">
 <summary>
 <see cref="T:System.Single"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseBoolean(System.String)">
 <summary>
 <see cref="T:System.Boolean"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parser.ParseDate(System.String)">
 <summary>
 <see cref="T:System.DateTime"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.HtmlParser.TableParser">
 <summary>
 The string parser for the table html text block
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.HtmlParser.TableParser.GetTablesHTML(System.String)">
 <summary>
 Parsing the html text betweens the tag &lt;table>&lt;/table> by using regex expression.
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.HtmlParser.TableParser.GetRowsHTML(System.String)">
 <summary>
 Parsing the html text betweens the tag &lt;tr>&lt;/tr> by using regex expression.
 </summary>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.HtmlParser.TableParser.GetColumnsHTML(System.String)">
 <summary>
 The td tag is trimmed in this function.(请注意，在本函数之中，&lt;td>标签是被去除掉了的)
 </summary>
 <param name="row"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.WorkFlow.FolkProc``2(System.String,System.String,``0,System.Func{``0,System.Byte[]},System.Func{System.Byte[],``1})">
 <summary>
 创建出一个子进程，然后按照命令行参数<paramref name="CLI"/>执行制定的命令，同时通过内存映射传递复杂参数，最后结束后通过内存映射传递回数据
 主要是通过内存映射减少数据IO的时间，加快计算流程
 </summary>
 <typeparam name="TIn"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="exe"></param>
 <param name="CLI"></param>
 <param name="[in]"></param>
 <param name="writer"></param>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.API.WriteData(System.String,Microsoft.VisualBasic.Net.Protocols.RawStream,System.Int32)">
 <summary>
 生成的映射位置为:  &lt;var>:&lt;ChunkSize>
 </summary>
 <param name="var"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.API.TryGetValue(System.String)">
 <summary>
 
 </summary>
 <param name="var">$var or var</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.API.TryGetValue``1(System.String)">
 <summary>
 不存在的话会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.API.IsRef(System.String)">
 <summary>
 
 </summary>
 <param name="addr">$var:size</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.Pipeline.PipeStream">
 <summary>
 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.Pipeline.Pipeline">
 <summary>
 exec cmd /var $&lt;piplineName>, this can be using in the CLI programming for passing the variables between the program more efficient
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.Pipeline.GetValue``1(System.String)">
 <summary>
 假若变量不存在，则返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.Pipeline.Pipeline.__allocated(System.Int64,Microsoft.VisualBasic.Net.Protocols.RequestStream,System.Net.IPEndPoint)">
 <summary>
 在写数据之前需要先使用这个方法进行内存区块的创建
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.MapStream.MSWriter">
 <summary>
 
 </summary>
 <remarks>
 mmfServer的主要功能是创建并维护一个内存映射文件
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MapStream.MSWriter.#ctor(System.String,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <remarks>对象实例会首先尝试以服务器的角色建立连接，当不成功的时候会以客户端的形式建立连接</remarks>
</member>
<member name="P:Microsoft.VisualBasic.MMFProtocol.MapStream.MMFStream.udtBadge">
 <summary>
 Stamp; Update Badge
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.MMFProtocol.MapStream.MMFStream.byteData">
 <summary>
 内存映射文件中所存储的将要进行进程间交换的数据
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.MMFProtocol.MapStream.MSIOReader._udtBadge">
 <summary>
 内存映射文件的更新标识符
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MapStream.MSIOReader.#ctor(System.String,Microsoft.VisualBasic.MMFProtocol.DataArrival,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="callback"></param>
 <param name="ChunkSize">内存映射文件的数据块的预分配大小</param>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MapStream.MSIOReader.ReadBadge">
 <summary>
 由于考虑到可能会传递很大的数据块，所以在这里检测数据更新的话只读取头部的8个字节的数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.DataArrival">
 <summary>
 客户端接受到的数据需要经过反序列化解码方能读取
 </summary>
 <param name="data"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.ReadNewMessage">
 <summary>
 
 </summary>
 <param name="message">UTF8 string</param>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.MMFSocket">
 <summary>
 MMFProtocol socket object for the inter-process communication on the localhost, this can be using for the data exchange between two process.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.#ctor(System.String,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="chunkSize">默认的区块大小为100KB，这个对于一般的小文本传输已经足够了</param>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.#ctor(System.String,Microsoft.VisualBasic.MMFProtocol.DataArrival)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="dataArrivals">
 Public Delegate Sub <see cref="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.__dataArrival(System.Byte[])"/>(byteData As <see cref="T:System.Byte"/>())
 会优先于事件<see cref="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.__dataArrival(System.Byte[])"></see>的发生</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.ReadData">
 <summary>
 直接从映射文件之中读取数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.MMFSocket.SendMessage(System.String)">
 <summary>
 
 </summary>
 <param name="s"><see cref="P:System.Text.Encoding.UTF8"/></param>
</member>
<member name="T:Microsoft.VisualBasic.MMFProtocol.ProcessLock">
 <summary>
 进程排斥锁
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.MMFProtocol.ProcessLock._ProcessLock">
 <summary>
 进程排斥锁
 </summary>
 <remarks>
 程序中采用一个进程排斥锁是由于待日后Mono运行时环境在Linux平台中的WinForm GTK成熟后，向Linux平台迁移，
 由于Visual Baisc/C#所编写的应用程序需要保持单个进程，则需要启用应用程序框架，而很多情况下为了优化的需求应用程序
 无法使用应用程序框架，为了实现一次编译到处运行的目的，程序的代码不会再平台间进行修改，
 由于Linux平台之上不能使用Win32API来保持单进程，为了保持程序对Windows/Linux/MAC三大操作系统的兼容性，故而在这里使用了一个进程排斥锁
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.MMFProtocol.ProcessLock.f_ProcessLock">
 <summary>
 进程锁的排斥情况
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.MMFProtocol.ProcessLock.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="strHost">进程排斥锁的锁名</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.MMFProtocol.ProcessLock.Locked">
 <summary>
 返回当前的进程是否被加锁
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.MarshalExtensions">
 <summary>
 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.MarshalExtensions.MarshalAs``1(System.IntPtr,System.Int32)">
 <summary>
 
 </summary>
 <typeparam name="T">Integer, Char, Short, Long, Single, Byte, IntPtr, Double</typeparam>
 <param name="p"></param>
 <returns></returns>
 <remarks>
 Public Shared Sub Copy(source As IntPtr, destination() As Integer, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Char, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Short, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Long, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Single, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Byte, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As IntPtr, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Double, startIndex As Integer, length As Integer)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.MarshalExtensions.MarshalAs``1(``0[]@,System.IntPtr)">
 <summary>
 方便进行数组操作的一个函数
 </summary>
 <typeparam name="T"></typeparam>
 <param name="raw"></param>
 <param name="p"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.EmitReflection">
 <summary>
 Some common used reflection operation extension at here.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.RunApp(System.String,System.String,System.Boolean)">
 <summary>
 Run external [.NET] Program from RAM Memory
 </summary>
 <param name="app"></param>
 <param name="CLI"></param>
 <param name="cs">Going to running a c# program?</param>
 <remarks>
 http://www.codeproject.com/Tips/1108105/Run-external-NET-Program-from-RAM-Memory
 
 Run external app directly from RAM. You can load the specific file into a ``Byte[]`` Array 
 with a ``StreamReader()`` or even download it from WEB via a direct link provided. 
 If you loaded the file from disk, you can delete it if you want after it has been loaded 
 by a ``StreamReader()``.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsNumericType(System.Object)">
 <summary>
 Determines whether the specified value is of numeric type.
 </summary>
 <param name="o">The object to check.</param>
 <returns>
 true if o is a numeric type; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.API(System.Type,System.String,System.Boolean)">
 <summary>

 </summary>
 <param name="type"></param>
 <param name="[nameOf]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetTypeElement(System.Type,System.Boolean)">
 <summary>
 得到集合类型的对象之中的元素类型
 </summary>
 <param name="type"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetVersion(System.String)">
 <summary>

 </summary>
 <param name="Product">.NET EXE/DLL assembly path</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.ModuleVersion(System.Type)">
 <summary>
 Gets the <see cref="T:System.Reflection.AssemblyFileVersionAttribute"/> value from the type defined assembly.
 </summary>
 <param name="type"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetVersion(System.Reflection.Assembly)">
 <summary>

 </summary>
 <param name="assm">.NET EXE/DLL assembly</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Get``2(System.Collections.Generic.ICollection{``0},System.String,System.Boolean)">
 <summary>
 出错会返回空集合
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TProperty"></typeparam>
 <param name="collection"></param>
 <param name="Name">使用System.NameOf()操作符来获取</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsInheritsFrom(System.Type,System.Type)">
 <summary>
 Is a inherits from b
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="b">基本类型</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Description``1">
 <summary>
 如果有<see cref="T:System.ComponentModel.DescriptionAttribute"/>标记，则会返回该标记的字符串数据，假若没有则只会返回类型的名称
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Description(System.Type)">
 <summary>
 如果有<see cref="T:System.ComponentModel.DescriptionAttribute"/>标记，则会返回该标记的字符串数据，假若没有则只会返回类型的名称
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetReadWriteProperties(System.Type)">
 <summary>
 Gets all of the can read and write access property from a type define.
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetValue(System.Type,System.Object,System.String)">
 <summary>
 只对属性有效，出错会返回空值
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetValue``1(System.Type,System.Object,System.String)">
 <summary>
 只对属性有效，出错会返回空值
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Collection2GenericIEnumerable(System.Type,System.Boolean)">
 <summary>
 Try convert the type specific collection data type into a generic enumerable collection data type.(尝试将目标集合类型转换为通用的枚举集合类型)
 </summary>
 <param name="Type">The type specific collection data type.(特定类型的集合对象类型，当然也可以是泛型类型)</param>
 <returns>If the target data type is not a collection data type then the original data type will be returns and the function displays a warning message.</returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetDelegateInvokeEntryPoint(System.Object)">
 <summary>
 Get the method reflection entry point for a anonymous lambda expression.(当函数返回Nothing的时候说明目标对象不是一个函数指针)
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.NamespaceEntry(System.Type)">
 <summary>
 Get the scripting namespace value from <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.Namespace"/>
 </summary>
 <param name="__nsType"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetFullName(System.Reflection.MethodBase,System.Boolean)">
 <summary>
 Gets the full name of a method reflection meta data.
 </summary>
 <param name="method"></param>
 <param name="IncludeAssembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetAttribute``1(System.Reflection.MemberInfo)">
 <summary>
 Get the specific type of custom attribute from a property.
 If the target custom attribute is not declared on the target, then this function returns nothing.
 (从一个属性对象中获取特定的自定义属性对象)
 </summary>
 <typeparam name="T">The type of the custom attribute.(自定义属性的类型)</typeparam>
 <param name="Property">Target property object.(目标属性对象)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetAttribute``1(System.Reflection.PropertyInfo)">
 <summary>
 Get the specific type of custom attribute from a property.
 (从一个属性对象中获取特定的自定义属性对象，找不到的话，就会返回空值)
 </summary>
 <typeparam name="T">The type of the custom attribute.(自定义属性的类型)</typeparam>
 <param name="Property">Target property object.(目标属性对象)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.CreateObject``1(System.Object[],System.Boolean,System.String)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="args">构造函数里面的参数信息</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.DistResult.DistEdits">
 <summary>
 How doest the <see cref="P:Microsoft.VisualBasic.DistResult.Hypotheses"/> evolve from <see cref="P:Microsoft.VisualBasic.DistResult.Reference"/>.(这个结果描述了subject是如何变化成为Query的)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.DistResult.Score">
 <summary>
 可以简单地使用这个数值来表述所比较的两个对象之间的相似度
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.DistResult.MatchSimilarity">
 <summary>
 m+ scores
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.DistResult.NumMatches">
 <summary>
 比对上的对象的数目
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DistResult.Visualize">
 <summary>
 Output HTML result for visualization
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSeparator(System.String,System.Char)">
 <summary>
 Split text with a separator char
 </summary>
 <param name="text">The text.</param>
 <param name="sep">The separator.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSeparatorFromRight(System.String,System.Char)">
 <summary>
 Split text with a separator char
 </summary>
 <param name="text">The text.</param>
 <param name="sep">The separator.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSpaces(System.String)">
 <summary>
 Splits the text with spaces.
 </summary>
 <param name="text">The text.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitIntoLines(System.String)">
 <summary>
 Splits the text into lines.
 </summary>
 <param name="text">The text.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.AddWithDelim(System.String,System.String,System.String)">
 <summary>
 Concats two strings with a delimiter.
 </summary>
 <param name="s1">string 1</param>
 <param name="delim">delimiter</param>
 <param name="s2">string 2</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.String,System.String,System.String)">
 <summary>
 Contacts the with delim.
 </summary>
 <param name="str1">The STR1.</param>
 <param name="delim">The delim.</param>
 <param name="str2">The STR2.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipEmpty(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contact with delim, delim is used after the first not Empty item
 </summary>
 <param name="items"></param>
 <param name="delim"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipNull(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contact with delim, delim is used after the first not null item
 </summary>
 <param name="items"></param>
 <param name="delim"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipSome(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
 <summary>
 Contacts the items with delim skip some.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="skip">The skip.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <param name="endValue">The end value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <param name="endValue">The end value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetHeader(System.String,System.Int32)">
 <summary>
 Gets the header.
 </summary>
 <param name="text">The text.</param>
 <param name="length">The length.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetSubStringBetween(System.String,System.Char,System.Char)">
 <summary>
 Get the sub string between 'ket' and 'bra'.
 </summary>
 <param name="text"></param>
 <param name="bra"></param>
 <param name="ket"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetLastSubStringBetween(System.String,System.Char,System.Char)">
 <summary>
 Get the sub string between 'ket' and 'bra'.
 </summary>
 <param name="text"></param>
 <param name="bra"></param>
 <param name="ket"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.StartWithUpperCase(System.String)">
 <summary>
 Starts with upper case.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.UpperCaseFirstChar(System.String)">
 <summary>
 Uppers the case of the first char.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.LowerCaseFirstChar(System.String)">
 <summary>
 Lowers the case of the first char.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetWords(System.String)">
 <summary>
 split text into words by space and newline chars, multiple spaces are treated as a single space.
 </summary>
 <param name="text"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextEncodings.Assertion(System.Text.Encoding)">
 <summary>
 Default value or user specific?
 </summary>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.TextEncodings.Encodings">
 <summary>
 The text document encodings constant for text file read and write
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.TextEncodings.Encodings.Default">
 <summary>
 <see cref="P:System.Text.Encoding.Default"/>: Gets an encoding for the operating system's current ANSI code page.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.TextEncodings.Encodings.GB2312">
 <summary>
 Text encoding for simplify Chinese.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.TextEncodings.GetEncodings(Microsoft.VisualBasic.TextEncodings.Encodings)">
 <summary>
 Get text file save encodings instance
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextEncodings.TransEncoding(System.String,Microsoft.VisualBasic.TextEncodings.Encodings,System.Text.Encoding)">
 <summary>
 有时候有些软件对文本的编码是有要求的，则可以使用这个函数进行文本编码的转换
 例如R程序默认是读取ASCII，而。NET的默认编码是UTF8，则可以使用这个函数将目标文本文件转换为ASCII编码的文本文件
 </summary>
 <param name="path"></param>
 <param name="encoding"></param>
 <param name="from"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Base64Codec">
 <summary>
 Tools API for encoded the image into a base64 string.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Base64Codec.GetImage(System.String,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Function to Get Image from Base64 Encoded String
 </summary>
 <param name="Base64String"></param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Base64Codec.__getImageFromBase64(System.String,System.Drawing.Imaging.ImageFormat)">
 <summary>
 Function to Get Image from Base64 Encoded String
 </summary>
 <param name="Base64String"></param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Base64Codec.ToBase64String(System.Drawing.Image,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Convert the Image from Input to Base64 Encoded String
 </summary>
 <param name="ImageInput"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.StringHelpers">
 <summary>
 The extensions module for facilities the string operations.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.RepeatString(System.String,System.Int32)">
 <summary>
 this is to emulate what's evailable in PHP
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetTagValue(System.String,System.String)">
 <summary>
 tagName{<paramref name="delimiter"/>}value
 </summary>
 <param name="s"></param>
 <param name="delimiter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TextEquals(System.String,System.String)">
 <summary>
 Shortcuts for method <see cref="T:System.String"/>(s1, s2, <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>)
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.RegexICSng">
 <summary>
 <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase"/> + <see cref="F:System.Text.RegularExpressions.RegexOptions.Singleline"/> 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.RegexICMul">
 <summary>
 <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase"/> + <see cref="F:System.Text.RegularExpressions.RegexOptions.Multiline"/> 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.IsBlank(System.String)">
 <summary>
 <paramref name="s"/> Is Nothing, <see cref="T:System.String"/>, <see cref="T:System.String"/>
 </summary>
 <param name="s">The input test string</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.RemoveLast(System.Text.StringBuilder)">
 <summary>
 Call <see cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)"/>(<see cref="P:System.Text.StringBuilder.Length"/> - 1, 1) for removes the last character in the string sequence.
 </summary>
 <param name="s"></param>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Reverse(System.Text.StringBuilder@)">
 <summary>
 Returns a reversed version of String s.
 </summary>
 <param name="sb"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Reverse(System.String)">
 <summary>
 Returns a reversed version of String s.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.StringHelpers.NonStrictCompares">
 <summary>
 String compares with ignored chars' case.(忽略大小写为非严格的比较)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Parts(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="s"></param>
 <param name="len"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.REGEX_EMAIL">
 <summary>
 Regex expression for parsing E-Mail URL
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.REGEX_URL">
 <summary>
 Regex exprression for parsing the http/ftp URL
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Count(System.String,System.Char)">
 <summary>
 Counts the specific char that appeared in the input string.
 (计数在字符串之中所出现的指定的字符的出现的次数)
 </summary>
 <param name="str"></param>
 <param name="ch"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetString(System.String,System.Char)">
 <summary>
 获取""或者其他字符所包围的字符串的值
 </summary>
 <param name="s"></param>
 <param name="wrapper"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Intersection(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}})">
 <summary>
 求交集
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Intersection(System.String[][])">
 <summary>
 求交集
 </summary>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Searches the specified input string for the first occurrence of the specified regular expression.
 </summary>
 <param name="input">The string to search for a match.</param>
 <param name="pattern">The regular expression pattern to match.</param>
 <param name="options"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.CountTokens(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 Count the string value numbers.(请注意，这个函数是倒序排序的)
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringSplit(System.String,System.String,System.Boolean)">
 <summary>
 This method is used to replace most calls to the Java String.split method.
 </summary>
 <param name="source"></param>
 <param name="regexDelimiter"></param>
 <param name="trimTrailingEmptyStrings"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Split(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 String collection tokens by a certain delimiter string element.
 </summary>
 <param name="source"></param>
 <param name="delimiter">
 Using String.Equals function to determined this delimiter 
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Located(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 String compares using <see cref="M:System.Object.Equals(System.Object,System.Object)"/>, if the target value could not be located, then -1 will be return from this function.
 </summary>
 <param name="collection"></param>
 <param name="Text"></param>
 <param name="caseSensitive"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Lookup(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 Search the string by keyword in a string collection. Unlike search function <see cref="M:Microsoft.VisualBasic.StringHelpers.Located(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)"/>
 using function <see cref="T:System.String"/> function to search string, this function using <see cref="M:Microsoft.VisualBasic.Strings.InStr(System.String,System.String,Microsoft.VisualBasic.CompareMethod)"/>
 to search the keyword.
 </summary>
 <param name="source"></param>
 <param name="keyword"></param>
 <param name="caseSensitive"></param>
 <returns>返回第一个找到关键词的行数，没有找到则返回-1</returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.EqualsAny(System.String,System.String[])">
 <summary>
 判断目标字符串是否与字符串参数数组之中的任意一个字符串相等，大小写不敏感，假若没有相等的字符串，则会返回空字符串，假若找到了相等的字符串，则会返回该字符串
 </summary>
 <param name="source"></param>
 <param name="compareTo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.InStrAny(System.String,System.String[])">
 <summary>
 查找到任意一个既返回位置，大小写不敏感，假若查找不到，则返回-1值，判断是否查找成功，可以使用 &lt;0 来完成，
 因为是通过InStr来完成的，所以查找成功的时候，最小的值是1，即字符串序列的第一个位置，也是元素0位置
 </summary>
 <param name="source"></param>
 <param name="find"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.lTokens(System.String,System.Boolean)">
 <summary>
 Line tokens. ==> Parsing the text into lines by using <see cref="F:Microsoft.VisualBasic.Constants.vbCr"/>, <see cref="F:Microsoft.VisualBasic.Constants.vbLf"/>.
 (函数对文本进行分行操作，由于在Windows(<see cref="F:Microsoft.VisualBasic.Constants.vbCrLf"/>)和
 Linux(<see cref="F:Microsoft.VisualBasic.Constants.vbCr"/>, <see cref="F:Microsoft.VisualBasic.Constants.vbLf"/>)平台上面所生成的文本文件的换行符有差异，
 所以可以使用这个函数来进行统一的分行操作)
 </summary>
 <param name="__text"></param>
 <returns></returns>
 <param name="trim">
 Set <see cref="F:System.Boolean.FalseString"/> to avoid a reader bug in the csv data reader <see cref="T:Microsoft.VisualBasic.ComponentModel.BufferedStream"/>
 </param>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.IsNullOrEmpty(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 判断这个字符串集合是否为空集合，函数会首先按照常规的集合为空进行判断，然后假若不为空的话，假若只含有一个元素并且该唯一的元素的值为空字符串，则也认为这个字符串集合为空集合
 </summary>
 <param name="values"></param>
 <param name="strict">FALSE 为非严谨，只进行常规判断，TRUE 为严谨模式，会假若不为空的话，假若只含有一个元素并且该唯一的元素的值为空字符串，则也认为这个字符串集合为空集合</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.LevenshteinDistance">
 <summary>
 Levenshtein Edit Distance Algorithm for measure string distance
 </summary>
 <remarks>
 http://www.codeproject.com/Tips/697588/Levenshtein-Edit-Distance-Algorithm
 </remarks>

</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.__createTable(System.Int32[],System.Int32[],System.Double)">
 <summary>
 Creates distance table for data visualization
 </summary>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.CreateTable``1(``0[],``0[],System.Double,Microsoft.VisualBasic.LevenshteinDistance.Equals{``0})">
 <summary>
 用于泛型的序列相似度比较
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <param name="equals">泛型化的元素等价性的比较方法</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.ComputeDistance``1(``0[],``0[],Microsoft.VisualBasic.LevenshteinDistance.Equals{``0},System.Double)">
 <summary>
 泛型序列的相似度的比较计算方法，这个函数返回的是距离
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="equals"></param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.ComputeDistance``1(``0[],``0[],Microsoft.VisualBasic.LevenshteinDistance.Equals{``0},Microsoft.VisualBasic.LevenshteinDistance.ToChar{``0},System.Double)">
 <summary>
 泛型序列的相似度的比较计算方法，这个会返回所有的数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="equals"></param>
 <param name="asChar">这个只是用于进行显示输出的</param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.__computeRoute(System.String,Microsoft.VisualBasic.DistResult,System.Int32,System.Int32,System.Double[0:,0:])">
 <summary>
 计算lev编辑的变化路径
 </summary>
 <param name="hypotheses"></param>
 <param name="result"></param>
 <param name="i"></param>
 <param name="j"></param>
 <param name="distTable"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LevenshteinDistance.ComputeDistance(System.String,System.String,System.Double)">
 <summary>
 The edit distance between two strings is defined as the minimum number of
 edit operations required to transform one string into another.
 </summary>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.ISupportLoggingClient.WriteLog">
 <summary>
 Save the log file into the filesystem.(保存日志数据到文件系统之中)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Logging.LogReader">
 <summary>
 分析服务器的问题原因所需要的日志分析工具
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogEntry.ToString">
 <summary>
 生成日志文档之中的一行记录数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Logging.MSG_TYPES">
 <summary>
 The types enumeration of the log file message.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Logging.MSG_TYPES.INF">
 <summary>
 The normal information message.[WHITE]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Logging.MSG_TYPES.ERR">
 <summary>
 The program error information message.[RED]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Logging.MSG_TYPES.WRN">
 <summary>
 Warnning message from the program.[YELLOW]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Logging.MSG_TYPES.DEBUG">
 <summary>
 The program debug information message.[BLUE]
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Logging.EventLog">
 <summary>
 Provides interaction with Windows event logs.(这个日志入口点对象的创建应该调用于安装程序的模块之中，并且以管理员权限执行)
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="Product">Source</param>
 <param name="Services"></param>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.Collections.Generic.IEnumerable{System.String},System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.Collections.Generic.IEnumerable{System.String},System.String,System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.Collections.Generic.IEnumerable{System.String},System.Reflection.MethodBase,System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.WriteEntry(System.String,System.Reflection.MethodBase,System.Diagnostics.EventLogEntryType,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="EventType">An <see cref="T:System.Diagnostics.EventLogEntryType"/> value that indicates the event type.</param>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.LogException(System.Exception,System.String,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
 <param name="Trace">可以不需要进行额外的处理，编译器会自动在这个参数填充调用栈的位置</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.LogException(System.Exception,System.Reflection.MethodBase,System.Int32)">
 <summary>
 Writes a localized entry to the event log.
 </summary>
 <param name="category">A resource identifier that corresponds to a string defined in the category resource file of the event source, or zero to specify no category for the event.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Logging.EventLog.ToString">
 <summary>
 $"{<see cref="P:Microsoft.VisualBasic.Logging.EventLog.Services"/>}//{<see cref="P:Microsoft.VisualBasic.Logging.EventLog.Product"/>}"
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Logging.LogFile">
 <summary>
 日志文件记录模块.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.SuppressError">
 <summary>
 Indicated that write the <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.ERR">Error type</see> message to the console screen, this 
 property will override the WriteToScreen parameter in function <see cref="M:Microsoft.VisualBasic.Logging.LogFile.WriteLine(System.String)"></see> when the 
 message type is <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.ERR">Error type</see>.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.SuppressWarns">
 <summary>
 Indicated that write the <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.WRN">Warn type</see> message to the console screen, this 
 property will override the WriteToScreen parameter in function <see cref="M:Microsoft.VisualBasic.Logging.LogFile.WriteLine(System.String)"></see> when the 
 message type is <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.WRN">Warn type</see>.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.ColorfulOutput">
 <summary>
 是否采用彩色的输出，默认为关闭：
 <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.INF">一般的消息</see> - 白色; 
 <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.WRN">警告级别的消息</see> - 黄色; 
 <see cref="F:Microsoft.VisualBasic.Logging.MSG_TYPES.ERR">错误级别的消息</see> - 红色
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.FileName">
 <summary>
 没有路径名称和拓展名，仅包含有单独的文件名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.NowTimeNormalizedString">
 <summary>
 将时间字符串里面的":"符号去除之后，剩余的字符串可以用于作为路径来使用
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.WriteLine(System.String,System.String,Microsoft.VisualBasic.Logging.MSG_TYPES,System.Boolean)">
 <summary>
 向日志文件之中写入数据
 </summary>
 <param name="Msg"></param>
 <param name="[Object]"></param>
 <param name="Type"></param>
 <param name="WriteToScreen"></param>
</member>
<member name="P:Microsoft.VisualBasic.Logging.LogFile.Mute">
 <summary>
 当这个设置为真之后，终端就不会再有任何的输出了
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.#ctor(System.String,System.Boolean,System.Int32)">
 <summary>
 
 </summary>
 <param name="Path">This logfile will saved to.</param>
 <remarks></remarks>
 <param name="bufferSize">当日志的记录数目达到这个数目的时候就会将日志数据写入到文件之中</param>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.SaveLog(System.Boolean)">
 <summary>
 在进行保存的时候会清空内存之中的现有日志数据
 </summary>
 <param name="appendToLogFile">Append this log data into the target log file if the file is exists on the filesystem, default option is override the exists file.</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.WriteLine(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="s"></param>
 <param name="args">{[Object] As String, Optional Type As MsgType = MsgType.INF, Optional WriteToScreen As Boolean = True}</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.Save(System.String,System.Text.Encoding)">
 <summary>
 日志文件在保存的时候默认是追加的方式
 </summary>
 <param name="FilePath"></param>
 <param name="Encoding"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Logging.LogFile.SystemInfo">
 <summary>
 给出用于调试的系统的信息摘要
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.StatisticsMathExtensions.CPOLLicense">
 <summary>
 http://www.codeproject.com/Articles/42492/Using-LINQ-to-Calculate-Basic-Statistics
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.GZip">
 <summary>
 Creating Zip Files Easily in .NET 4.5
 Tim Corey, 11 May 2012
 http://www.codeproject.com/Articles/381661/Creating-Zip-Files-Easily-in-NET
 </summary>
 <remarks></remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.GZip.Overwrite">
 <summary>
 Used to specify what our overwrite policy
 is for files we are extracting.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.GZip.ArchiveAction">
 <summary>
 Used to identify what we will do if we are
 trying to create a zip file and it already
 exists.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.GZip.ImprovedExtractToDirectory(System.String,System.String,Microsoft.VisualBasic.GZip.Overwrite)">
 <summary>
 Unzips the specified file to the given folder in a safe
 manner.  This plans for missing paths and existing files
 and handles them gracefully.
 </summary>
 <param name="sourceArchiveFileName">
 The name of the zip file to be extracted
 </param>
 <param name="destinationDirectoryName">
 The directory to extract the zip file to
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is IfNewer.
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.GZip.ImprovedExtractToFile(System.IO.Compression.ZipArchiveEntry,System.String,Microsoft.VisualBasic.GZip.Overwrite)">
 <summary>
 Safely extracts a single file from a zip file
 </summary>
 <param name="file__1">
 The zip entry we are pulling the file from
 </param>
 <param name="destinationPath">
 The root of where the file is going
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is Overwrite.IfNewer.
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.GZip.AddToArchive(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.VisualBasic.GZip.ArchiveAction,Microsoft.VisualBasic.GZip.Overwrite,System.IO.Compression.CompressionLevel)">
 <summary>
 Allows you to add files to an archive, whether the archive
 already exists or not
 </summary>
 <param name="archiveFullName">
 The name of the archive to you want to add your files to
 </param>
 <param name="files">
 A set of file names that are to be added
 </param>
 <param name="action">
 Specifies how we are going to handle an existing archive
 </param>
 <param name="compression">
 Specifies what type of compression to use - defaults to Optimal
 </param>
 
</member>
<member name="T:Microsoft.VisualBasic.LargeTextFile">
 <summary>
 Wrapper for the file operations.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Peeks(System.String,System.Int32)">
 <summary>
 当一个文件非常大以致无法使用任何现有的文本编辑器查看的时候，可以使用本方法查看其中的一部分数据 
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Tails(System.String,System.Int32)">
 <summary>
 尝试查看大文件的尾部的数据
 </summary>
 <param name="path"></param>
 <param name="length">字符的数目</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ProgramPathSearchTool">
 <summary>
 Search the path from a specific keyword.(通过关键词来推测路径)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.MkDIR(System.String)">
 <summary>
 Make directory
 </summary>
 <param name="DIR"></param>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.ToFileURL(System.String)">
 <summary>
 Gets the URL type file path.(获取URL类型的文件路径)
 </summary>
 <param name="Path"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.ProgramPathSearchTool.ILLEGAL_PATH_CHARACTERS_ENUMERATION">
 <summary>
 枚举所有非法的路径字符
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.NormalizePathString(System.String,System.Boolean)">
 <summary>
 将目标字符串之中的非法的字符替换为"_"符号以成为正确的文件名字符串
 </summary>
 <param name="str"></param>
 <param name="OnlyASCII">当本参数为真的时候，仅26个字母，0-9数字和下划线_以及小数点可以被保留下来</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.Long2Short(System.String,System.String)">
 <summary>
 假设文件名过长发生在文件名和最后一个文件夹的路径之上
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 System.IO.PathTooLongException: The specified path, file name, or both are too long.
 The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.PathIllegal(System.String)">
 <summary>
 File path illegal?
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.FileLength(System.String)">
 <summary>
 Gets the file length, if the path is not exists, then returns -1.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.FileExists(System.String)">
 <summary>
 Check if the target file object is exists on your file system or not.(这个函数也会自动检查目标<paramref name="path"/>参数是否为空)
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.DirectoryExists(System.String)">
 <summary>
 Determine that the target directory is exists on the file system or not?(判断文件夹是否存在)
 </summary>
 <param name="DIR"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.FileOpened(System.String)">
 <summary>
 Check if the file is opened by other code?(检测文件是否已经被其他程序打开使用之中)
 </summary>
 <param name="FileName">目标文件</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.BaseName(System.String)">
 <summary>
 Gets the name of the target file or directory, if the target is a file, then the name without the extension name.
 (获取目标文件夹的名称或者文件的不包含拓展名的名称)
 </summary>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.GetBaseName(System.String)">
 <summary>
 <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.String)"/> shortcuts extension.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.ParentDirName(System.String)">
 <summary>
 Gets the name of the file's parent directory, returns value is a name, not path.
 (获取目标文件的父文件夹的文件夹名称，是名称而非路径)
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.ParentPath(System.String,System.Boolean)">
 <summary>
 这个函数是返回文件夹的路径而非名称，这个函数不依赖于系统的底层API，因为系统的底层API对于过长的文件名会出错
 </summary>
 <param name="file"></param>
 <returns></returns>
 <remarks>这个函数不依赖于系统的底层API，因为系统的底层API对于过长的文件名会出错</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.GetFile(System.String,System.String,System.String[])">
 <summary>

 </summary>
 <param name="DIR"></param>
 <param name="keyword"></param>
 <param name="ext">元素的排布是有顺序的</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.LoadSourceEntryList(System.String,System.String[],System.Boolean)">
 <summary>
 [<see cref="F:Microsoft.VisualBasic.FileIO.SearchOption.SearchAllSubDirectories"/>，这个函数会扫描目标文件夹下面的所有文件。]
 请注意，本方法是不能够产生具有相同的主文件名的数据的。假若目标GBK是使用本模块之中的方法保存或者导出来的，
 则可以使用本方法生成Entry列表；（在返回的结果之中，KEY为文件名，没有拓展名，VALUE为文件的路径）
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.LoadSourceEntryList(System.String,System.String[])">
 <summary>
 可以使用本方法生成Entry列表；（在返回的结果之中，KEY为文件名，没有拓展名，VALUE为文件的路径）
 请注意，这个函数会搜索目标文件夹下面的所有的文件夹的
 </summary>
 <param name="source"></param>
 <param name="ext">文件类型的拓展名称</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.LoadEntryList(System.String,System.String[])">
 <summary>
 允许有重复的数据
 </summary>
 <param name="DIR"></param>
 <param name="exts"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.SourceCopy(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 将不同来源<paramref name="source"></paramref>的文件复制到目标文件夹<paramref name="copyto"></paramref>之中
 </summary>
 <param name="source"></param>
 <param name="copyto"></param>
 <returns>返回失败的文件列表</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.SearchProgram(System.String,System.String)">
 <summary>
 Invoke the search session for the program file using a specific keyword string value.(使用某个关键词来搜索目标应用程序)
 </summary>
 <param name="DIR"></param>
 <param name="Keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.SearchScriptFile(System.String,System.String,System.String)">
 <summary>

 </summary>
 <param name="DIR"></param>
 <param name="Keyword"></param>
 <param name="withExtension">脚本文件的文件拓展名</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.SearchDirectory(System.String,System.String)">
 <summary>

 </summary>
 <param name="SpecificDrive">所制定进行搜索的驱动器，假若希望搜索整个硬盘，请留空字符串</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.BranchRule(System.String,System.String)">
 <summary>
 商标搜索规则
 </summary>
 <param name="ProgramFiles"></param>
 <param name="Keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.RelativePath(System.String)">
 <summary>
 获取相对于本应用程序的目标文件的相对路径(请注意，所生成的相对路径之中的字符串最后是没有文件夹的分隔符\或者/的)
 </summary>
 <param name="path"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.RelativePath(System.String,System.String)">
 <summary>
 Gets the relative path of file system object <paramref name="pcTo"/> reference to the directory path <paramref name="pcFrom"/>.
 (请注意，所生成的相对路径之中的字符串最后是没有文件夹的分隔符\或者/的)
 </summary>
 <param name="pcFrom">生成相对路径的参考文件夹</param>
 <param name="pcTo">所需要生成相对路径的目标文件系统对象的绝对路径或者相对路径</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.GetFullPath(System.String)">
 <summary>
 Gets the full path of the specific file.(为了兼容Linux，这个函数会自动替换路径之中的\为/符号)
 </summary>
 <param name="file"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.GetDirectoryFullPath(System.String)">
 <summary>
 Gets the full path of the specific directory.
 </summary>
 <param name="dir"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.TrimFileExt(System.String)">
 <summary>
 Removes the file extension name from the file path.(去除掉文件的拓展名)
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.TrimDIR(System.String)">
 <summary>
 Removes the last \ and / character in a directory path string.
 (使用这个函数修剪文件夹路径之中的最后一个分隔符，以方便生成文件名)
 </summary>
 <param name="DIR"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.GetJustFileName(System.String)">
 <summary>
 只有文件名称，没有拓展名
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ProgramPathSearchTool.SafeCopyTo(System.String,System.String)">
 <summary>
 进行安全的复制，出现错误不会导致应用程序崩溃，大文件不推荐使用这个函数进行复制
 </summary>
 <param name="source"></param>
 <param name="copyTo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MemoryDump.__dumpInvoke(System.Object,System.Int32)">
 <summary>
 Create memory dump for a class object instance
 </summary>
 <param name="obj"></param>
 <param name="DumpLevel"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.WebServiceUtils">
 <summary>
 The extension module for web services works.
 </summary>

</member>
<member name="P:Microsoft.VisualBasic.WebServiceUtils.Protocols">
 <summary>
 Web protocols enumeration
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.isURL(System.String)">
 <summary>
 Determine that is this uri string is a network location?
 (判断这个uri字符串是否是一个网络位置)
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildReqparm(System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 Build the request parameters for the HTTP POST
 </summary>
 <param name="dict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildReqparm(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
 <summary>
 Build the request parameters for the HTTP POST
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.Get_href(System.String)">
 <summary>
 Gets the link text in the html fragement text.
 </summary>
 <param name="html">A string that contains the url string pattern like: href="url_text"</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.ImageSource(System.String)">
 <summary>
 Parsing image source url from the img html tag.
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.TrimHTMLTag(System.String)">
 <summary>
 Removes the html tags from the text string.
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.IsSocketPortOccupied(System.Exception)">
 <summary>
 Only one usage of each socket address (protocol/network address/port) Is normally permitted
 </summary>
 <param name="ex"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GenerateDictionary(System.String[],System.Boolean)">
 <summary>
 Create a parameter dictionary from the request parameter tokens.
 (请注意，字典的key默认为转换为小写的形式)
 </summary>
 <param name="tokens">
 元素的个数必须要大于1，因为从url里面解析出来的元素之中第一个元素是url本身，则不再对url做字典解析
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.requestParser(System.String,System.Boolean)">
 <summary>
 不像<see cref="M:Microsoft.VisualBasic.WebServiceUtils.postRequestParser(System.String,System.Boolean)"/>函数，这个函数不会替换掉转义字符，并且所有的Key都已经被默认转换为小写形式的了
 </summary>
 <param name="argvs"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildArgvs(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean)">
 <summary>

 </summary>
 <param name="hash"></param>
 <param name="escaping">是否进行对value部分的字符串数据进行转义</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.UrlPathEncode(System.String)">
 <summary>
 编码整个URL
 </summary>
 <param name="s"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.postRequestParser(System.String,System.Boolean)">
 <summary>
 假若你的数据之中包含有SHA256的加密数据，则非常不推荐使用这个函数进行解析。因为请注意，这个函数会替换掉一些转义字符的，所以会造成一些非常隐蔽的BUG
 </summary>
 <param name="data">转义的时候大小写无关</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.CopyStream(System.IO.Stream)">
 <summary>
 Download stream data from the http response.
 </summary>
 <param name="stream">
 Create from <see cref="M:Microsoft.VisualBasic.WebServiceUtils.GetRequestRaw(System.String,System.Boolean,System.String)"/>
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetRequest(System.String,System.Boolean,System.String)">
 <summary>
 GET http request
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetRequestRaw(System.String,System.Boolean,System.String)">
 <summary>
 
 </summary>
 <param name="url"></param>
 <param name="https"></param>
 <param name="userAgent">
 
 fix a bug for github API:
 
 Protocol violation using Github api
 
 You need to set UserAgent like this:
 webRequest.UserAgent = "YourAppName"
 Otherwise it will give The server committed a protocol violation. Section=ResponseStatusLine Error.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.TrimResponseTail(System.String)">
 <summary>
 有些时候后面可能会存在多余的vbCrLf，则使用这个函数去除
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetValue(System.String)">
 <summary>
 获取两个尖括号之间的内容
 </summary>
 <param name="html"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GET(System.String,System.UInt32,System.Boolean)">
 <summary>
 Get the html page content from a website request or a html file on the local filesystem.(同时支持http位置或者本地文件)
 </summary>
 <param name="url">web http request url or a file path handle</param>
 <param name="RequestTimeOut">发生错误的时候的重试的次数</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.DownloadFile(System.String,System.String)">
 <summary>
 download the file from <paramref name="strUrl"></paramref> to <paramref name="save">local file</paramref>.
 </summary>
 <param name="strUrl"></param>
 <param name="save">The file path of the file saved</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetDownload(System.String,System.String)">
 <summary>
 使用GET方法下载文件
 </summary>
 <param name="url"></param>
 <param name="savePath"></param>
 <returns></returns>

</member>
<member name="F:Microsoft.VisualBasic.WebServiceUtils.MicrosoftDNS">
 <summary>
 Microsoft DNS Server
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetMyIPAddress">
 <summary>
 获取我的公网IP地址，假若没有连接互联网的话则会返回局域网IP地址
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.Max(System.Int32,System.Int32,System.Int32)">
 <summary>
 return the maximum of a, b and c </summary>
 <param name="a"> </param>
 <param name="b"> </param>
 <param name="c">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.Hypot(System.Double,System.Double)">
 <summary>
  sqrt(a^2 + b^2) without under/overflow.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.Pow2(System.Int32)">
 <summary>
 Calculates power of 2.
 </summary>
 
 <param name="power">Power to raise in.</param>
 
 <returns>Returns specified power of 2 in the case if power is in the range of
 [0, 30]. Otherwise returns 0.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.Log2(System.Int32)">
 <summary>
 Get base of binary logarithm.
 </summary>
 
 <param name="x">Source integer number.</param>
 
 <returns>Power of the number (base of binary logarithm).</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.IsPowerOf2(System.Int32)">
 <summary>
 Checks if the specified integer is power of 2.
 </summary>
 
 <param name="x">Integer number to check.</param>
 
 <returns>Returns <b>true</b> if the specified number is power of 2.
 Otherwise returns <b>false</b>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.Sum(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Logical true values are regarded as one, false values as zero. For historical reasons, NULL is accepted and treated as if it were integer(0).
 </summary>
 <param name="bc"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.STD(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.STD(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.STD(System.Collections.Generic.IEnumerable{System.Int64})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.STD(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.EuclideanDistance(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 多位坐标的欧几里得距离
 </summary>
 <param name="Vector"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.EuclideanDistance(System.Byte[],System.Byte[])">
 <summary>
 
 </summary>
 <param name="a">Point A</param>
 <param name="b">Point B</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.EuclideanDistance(System.Double[],System.Double[])">
 <summary>
 
 </summary>
 <param name="a">Point A</param>
 <param name="b">Point B</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.PI(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Continues multiply operations.(连续乘法)
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.RMS(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Root mean square.(均方根)
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VBMathExtensions.PoissonPDF(System.Int32,System.Double)">
 <summary>
 Returns the PDF value at x for the specified Poisson distribution.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Extensions">
 <summary>
 Common extension methods library for convenient the programming job.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Time(System.Action)">
 <summary>
 性能测试工具，函数之中会自动输出整个任务所经历的处理时长
 </summary>
 <param name="work">需要测试性能的工作对象</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Wait(System.Func{System.Boolean})">
 <summary>
 假若条件判断<paramref name="handle"/>不为真的话，函数会一直阻塞线程，直到条件判断<paramref name="handle"/>为真
 </summary>
 <param name="handle"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Wait(Microsoft.VisualBasic.Extensions.WaitHandle)">
 <summary>
 假若条件判断<paramref name="handle"/>不为真的话，函数会一直阻塞线程，直到条件判断<paramref name="handle"/>为真
 </summary>
 <param name="handle"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Add``1(``0[]@,``0)">
 <summary>
 Dynamics add a element into the target array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Add``1(``0[]@,``0[])">
 <summary>
 会自动跳过空集合，这个方法是安全的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Add``1(Microsoft.VisualBasic.List{``0}@,``0[])">
 <summary>
 Adds the elements of the specified collection to the end of the List`1.
 (会自动跳过空集合，这个方法是安全的)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="value">The collection whose elements should be added to the end of the List`1.</param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Get``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0)">
 <summary>
 假若下标越界的话会返回默认值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="index"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Get``1(``0[],System.Int32,``0)">
 <summary>
 This is a safely method for gets the value in a array, if the index was outside of the boundary, then the default value will be return.
 (假若下标越界的话会返回默认值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="index"></param>
 <param name="[default]">Default value for return when the array object is nothing or index outside of the boundary.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.If``1(System.Boolean,``0,``0)">
 <summary>
 Function test the Boolean expression and then decided returns which part of the value.
 (这个函数主要是用于Delegate函数指针类型或者Lambda表达式的)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="expr"><see cref="T:System.Boolean"/> Expression</param>
 <param name="[True]">value returns this parameter if the value of the expression is True</param>
 <param name="[False]">value returns this parameter if the value of the expression is False</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Constrain``2(System.Collections.Generic.IEnumerable{``1})">
 <summary>
 基类集合与继承类的集合约束
 </summary>
 <typeparam name="T">继承类向基类进行约束</typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToBoolean(System.Int64)">
 <summary>
 0 -> False
 1 -> True
 </summary>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CopyTypeDef``2(System.Collections.Generic.Dictionary{``0,``1})">
 <summary>

 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source">仅仅是起到类型复制的作用</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CopyTypeDef``1(Microsoft.VisualBasic.List{``0})">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="IList">仅仅是起到类型复制的作用</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
 <summary>
 假若不存在目标键名，则返回空值，默认值为空值
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="hash"></param>
 <param name="Index"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CliPath(System.String)">
 <summary>
 If the path string value is already wrappered by quot, then this function will returns the original string (DO_NOTHING).
 (假若命令行之中的文件名参数之中含有空格的话，则可能会造成错误，需要添加一个双引号来消除歧义)
 </summary>
 <param name="Path"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.CliToken(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Extensions.CliPath(System.String)"/>函数为了保持对Linux系统的兼容性会自动替换\为/符号，这个函数则不会执行这个替换
 </summary>
 <param name="Token"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.NormalizeXMLString(System.String)">
 <summary>
 对Xml文件之中的特殊字符进行转义处理
 </summary>
 <param name="str"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.GetAnonymousTypeList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 You can using this method to create a empty list for the specific type of anonymous type object.
 (使用这个方法获取得到匿名类型的列表数据集合对象)
 </summary>
 <typeparam name="TAnonymousType"></typeparam>
 <param name="typedef">The temp object which was created anonymous.
 (匿名对象的集合，这个是用来复制匿名类型的，虽然没有引用这个参数，但是却可以直接通过拓展来得到匿名类型生成列表对象)
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimVBCrLf(System.String)">
 <summary>
 Removes VbCr and VbLf
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Extensions.NIL">
 <summary>
 Chr(0): NULL char
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.DateToString(System.DateTime)">
 <summary>
 Format the datetime value in the format of yy/mm/dd hh:min
 </summary>
 <param name="dat"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Data partitioning function.
 (将目标集合之中的数据按照<paramref name="parTokens"></paramref>参数分配到子集合之中，
 这个函数之中不能够使用并行化Linq拓展，以保证元素之间的相互原有的顺序)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="parTokens">每一个子集合之中的元素的数目</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Performance the partitioning operation on the input sequence.
 (请注意，这个函数只适用于数量较少的序列。对所输入的序列进行分区操作，<paramref name="parTokens"/>函数参数是每一个分区里面的元素的数量)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="parTokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Join``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Merge two type specific collection.(函数会忽略掉空的集合，函数会构建一个新的集合，原有的集合不受影响)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.JoinBy(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 This is a safe function: if the source string collection is nothing, then whistle function will returns a empty string instead of throw exception. 
 (<see cref="T:System.String"/>，这是一个安全的函数，当数组为空的时候回返回空字符串)
 </summary>
 <param name="tokens"></param>
 <param name="delimiter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.JoinBy(System.Collections.Generic.IEnumerable{System.Int32},System.String)">
 <summary>
 <see cref="T:System.String"/>，这是一个安全的函数，当数组为空的时候回返回空字符串
 </summary>
 <param name="values"></param>
 <param name="delimiter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Invoke(System.Diagnostics.Process)">
 <summary>
 本方法会执行外部命令并等待其执行完毕，函数返回状态值
 </summary>
 <param name="Process"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.RandomDouble">
 <summary>
 Gets a random number in the region of [0,1]. (获取一个[0,1]区间之中的随机数，请注意：因为为了尽量做到随机化，这个函数会不断的初始化随机种子，
 故而性能较低，不可以在大量重复调用，或者在批量调用的时候请使用并行化拓展的LINQ)
 </summary>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.RunDriver(Microsoft.VisualBasic.ComponentModel.DataSourceModel.IObjectModel_Driver)">
 <summary>
 非线程的方式启动，当前线程会被阻塞在这里直到运行完毕
 </summary>
 <param name="driver"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.DriverRun(Microsoft.VisualBasic.ComponentModel.DataSourceModel.IObjectModel_Driver)">
 <summary>
 Run the driver in a new thread, NOTE: from this extension function calls, then run thread is already be started, 
 so that no needs of calling the method <see cref="M:System.Threading.Thread.Start"/> again.
 (使用线程的方式启动，在函数调用之后，线程是已经启动了的，所以不需要再次调用<see cref="M:System.Threading.Thread.Start"/>方法了)
 </summary>
 <param name="driver">The object which is implements the interface <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IObjectModel_Driver"/></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.GetElementCounts``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the element counts in the target data collection, if the collection object is nothing or empty
 then this function will returns ZERO, others returns Collection.Count.(返回一个数据集合之中的元素的数目，
 假若这个集合是空值或者空的，则返回0，其他情况则返回Count拓展函数的结果)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Collection"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Free``1(``0@)">
 <summary>
 Free this variable pointer in the memory.(销毁本对象类型在内存之中的指针)
 </summary>
 <typeparam name="T">假若该对象类型实现了<see cref="T:System.IDisposable"></see>接口，则函数还会在销毁前调用该接口的销毁函数</typeparam>
 <param name="obj"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Pause(System.String)">
 <summary>
 Pause the console program.
 </summary>
 <param name="Prompted"></param>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.RegexParseDouble(System.String)">
 <summary>
 Parsing a real number from the expression text by using the regex expression <see cref="F:Microsoft.VisualBasic.Extensions.RegexFloat"/>.
 (使用正则表达式解析目标字符串对象之中的一个实数)
 </summary>
 <param name="s"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.Offset(System.Int32[]@,System.Int32)">
 <summary>
 All of the number value in the target array offset a integer value.
 </summary>
 <param name="array"></param>
 <param name="intOffset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Offset(System.Int64[]@,System.Int32)">
 <summary>
 All of the number value in the target array offset a integer value.
 </summary>
 <param name="array"></param>
 <param name="intOffset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ParseDateTime(System.String)">
 <summary>
 Parsing the dat value from the expression text, if any exception happend, a null date value will returned.
 (空字符串会返回空的日期)
 </summary>
 <param name="s"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.InvokeSet``1(``0@,``0)">
 <summary>
 Value assignment to the target variable.(将<paramref name="value"/>参数里面的值赋值给<paramref name="var"/>参数然后返回<paramref name="value"/>)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <param name="value"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 (与函数<see cref="M:Microsoft.VisualBasic.Extensions.InvokeSet``1(``0@,``0)"/>)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="CopyTo"><paramref name="source"/> ==> <paramref name="CopyTo"/> target.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ModifyValue``1(System.Reflection.PropertyInfo,``0,System.Func{System.Object,System.Object})">
 <summary>
 Modify target object property value using a <paramref name="valueModifier">specific value provider</paramref> and then return original instance object.
 (修改目标对象的属性之后返回目标对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.FlushMemory">
 <summary>
 Rabbish collection to free the junk memory.(垃圾回收)
 </summary>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.InsertOrUpdate``1(System.Collections.Generic.Dictionary{System.String,``0}@,``0)">
 <summary>
 Insert data or update the exists data in the dictionary, if the target object with <see cref="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable.Identifier"/> 
 is not exists in the dictionary, then will be insert, else the old value will be replaced with the parameter 
 value <paramref name="item"/>.
 (向字典对象之中更新或者插入新的数据，假若目标字典对象之中已经存在了一个数据的话，则会将原有的数据覆盖，并返回原来的数据)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dict"></param>
 <param name="item"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Remove``1(System.Collections.Generic.Dictionary{System.String,``0}@,``0)">
 <summary>
 Remove target object from dictionary.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dict"></param>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.IsNullOrEmpty(System.Text.StringBuilder)">
 <summary>
 The <see cref="T:System.Text.StringBuilder"/> object its content is nothing?
 </summary>
 <param name="sBuilder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixToVector``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Merge the target array collection into one collection.(将目标数组的集合合并为一个数组)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixToList``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Empty list will be skip and ignored.(这是一个安全的方法，空集合会被自动跳过，并且这个函数总是返回一个集合不会返回空值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixToUltraLargeVector``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>
 Merge the target array collection into one collection.
 (将目标数组的集合合并为一个数组，这个方法是提供给超大的集合的，即元素的数目非常的多的，即超过了<see cref="T:System.Int32"></see>的上限值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.AddRange``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Add a linked list of a collection of specific type of data.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixTranspose``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>
 矩阵转置： 将矩阵之中的元素进行行列位置的互换
 </summary>
 <typeparam name="T">矩阵之中的元素类型</typeparam>
 <param name="MAT">为了方便理解和使用，矩阵使用数组的数组来表示的</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixTransposeIgnoredDimensionAgreement``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>
 将矩阵之中的元素进行行列位置的互换，请注意，假若长度不一致的话，会按照最短的元素来转置，故而使用本函数可能会造成一些信息的丢失
 </summary>
 <typeparam name="T"></typeparam>
 <param name="MAT"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.SplitMV(System.String,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="DIR">The source directory.</param>
 <param name="moveTo"></param>
 <param name="Split"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Is_NA_UHandle(System.Double)">
 <summary>
 The target parameter <paramref name="n"/> value is NaN or not a real number or not?
 (判断目标实数是否为一个无穷数或者非计算的数字，产生的原因主要来自于除0运算结果或者达到了
 <see cref="T:System.Double"></see>的上限或者下限)
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.FuzzyMatching(System.String,System.String,System.Boolean)">
 <summary>
 Fuzzy match two string, this is useful for the text query or searching.
 </summary>
 <param name="Query"></param>
 <param name="Subject"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Extensions.BooleanValues">
 <summary>
 Convert the string value into the boolean value, this is useful to the text format configuration file into data model.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.getBoolean(System.String)">
 <summary>
 Convert the string value into the boolean value, this is useful to the text format configuration file into data model.
 (请注意，空值字符串为False)
 </summary>
 <param name="str"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.GetItem``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 这个是一个安全的方法，假若下标越界或者目标数据源为空的话，则会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.StdError(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 求取该数据集的标准差
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.Extensions.Scan0">
 <summary>
 The first element in a collection.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Description(System.Enum)">
 <summary>
 Get the description data from a enum type value, if the target have no <see cref="T:System.ComponentModel.DescriptionAttribute"></see> attribute data
 then function will return the string value from the ToString() function.
 </summary>
 <param name="value"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Enums``1">
 <summary>
 Enumerate all of the enum values in the specific <see cref="T:System.Enum"/> type data.(只允许枚举类型，其他的都返回空集合)
 </summary>
 <typeparam name="T">泛型类型约束只允许枚举类型，其他的都返回空集合</typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CheckDuplicated``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 函数只返回有重复的数据
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tag"></typeparam>
 <param name="source"></param>
 <param name="getKey"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveDuplicates``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 移除重复的对象，这个函数是根据对象所生成的标签来完成的
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tag"></typeparam>
 <param name="source"></param>
 <param name="getKey">得到对象的标签</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimNull``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Remove all of the null object in the target object collection.
 (这个是一个安全的方法，假若目标集合是空值，则函数会返回一个空的集合)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimNull(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Remove all of the null object in the target object collection
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Randomize``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Return a collection with randomize element position in <paramref name="source">the original collection</paramref>.
 (从原有序序列中获取一个随机元素的序列)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.GetItem``1(System.Collections.Generic.IEnumerable{``0},System.String,System.StringComparison)">
 <summary>
 Get a specific item value from the target collction data using its UniqueID property，
 (请注意，请尽量不要使用本方法，因为这个方法的效率有些低，对于获取<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.sIdEnumerable">
 </see>类型的集合之中的某一个对象，请尽量先转换为字典对象，在使用该字典对象进行查找以提高代码效率，使用本方法的优点是可以选择忽略<paramref name="UniqueId">
 </paramref>参数之中的大小写，以及对集合之中的存在相同的Key的这种情况的容忍)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="UniqueId"></param>
 <param name="IgnoreCase"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CopyTo``1(``0,``0@)">
 <summary>
 Copy the value in <paramref name="value"></paramref> into target variable <paramref name="target"></paramref> and then return the target variable.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value"></param>
 <param name="target"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Move(System.Int64@,System.Int32)">
 <summary>
 变量<paramref name="p"/>移动距离<paramref name="d"/>然后返回其移动之前的值
 </summary>
 <param name="p"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Move(System.Int32@,System.Int32)">
 <summary>
 变量<paramref name="p"/>移动距离<paramref name="d"/>然后返回其移动之前的值
 </summary>
 <param name="p"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Move(System.Double@,System.Int32)">
 <summary>
 变量<paramref name="p"/>移动距离<paramref name="d"/>然后返回其移动之前的值
 </summary>
 <param name="p"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TakeRandomly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 随机的在目标集合中选取指定数目的子集合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Collection"></param>
 <param name="Counts">当目标数目大于或者等于目标集合的数目的时候，则返回目标集合</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToStringArray``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Convert target object type collection into a string array using the Object.ToString() interface function.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Collection"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Union(System.String[],System.String[])">
 <summary>
 Get a sub set of the string data which is contains in both collection <paramref name="strArray1"></paramref> and <paramref name="strArray2"></paramref>
 </summary>
 <param name="strArray1"></param>
 <param name="strArray2"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.SwapWith``1(``0@,``0@)">
 <summary>
 Swap the value in the two variables.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj1"></param>
 <param name="obj2"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.SwapItem``1(Microsoft.VisualBasic.List{``0}@,``0,``0)">
 <summary>
 Swap the two item position in the target <paramref name="List">list</paramref>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="List"></param>
 <param name="obj_1"></param>
 <param name="obj_2"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimA(System.String,System.String)">
 <summary>
 Replace the <see cref="F:Microsoft.VisualBasic.Constants.vbCrLf"/> with the specific string.
 </summary>
 <param name="strText"></param>
 <param name="VbCRLF_Replace"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.AddHandle``1(System.Collections.Generic.IEnumerable{``0}@,System.Int32)">
 <summary>
 为列表中的对象添加对象句柄值
 </summary>
 <param name="source"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MoveNext(System.Int32@)">
 <summary>
 <paramref name="p"></paramref> plus one and then return its previous value. (p++)
 </summary>
 <param name="p"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Sequence``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Gets the subscript index of a generic collection.(获取某一个集合的下标的集合)
 </summary>
 <typeparam name="T">集合中的元素为任意类型的</typeparam>
 <param name="source">目标集合对象</param>
 <returns>A integer array of subscript index of the target generic collection.</returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.Takes``1(System.Collections.Generic.IEnumerable{``0},System.Int32[],System.Int32,System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="indexs">所要获取的目标对象的下表的集合</param>
 <param name="reversedSelect">是否为反向选择</param>
 <param name="OffSet">当进行反选的时候，本参数将不会起作用</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.__reversedTakeSelected``1(System.Collections.Generic.IEnumerable{``0},System.Int32[])">
 <summary>
 反选，即将所有不出现在<paramref name="indexs"></paramref>之中的元素都选取出来
 </summary>
 <typeparam name="T"></typeparam>
 <param name="coll"></param>
 <param name="indexs"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Boolean)">
 <summary>
 将目标键值对对象的集合转换为一个字典对象
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source"></param>
 <param name="remoteDuplicates">当这个参数为False的时候，出现重复的键名会抛出错误，当为True的时候，有重复的键名存在的话，可能会丢失一部分的数据</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 This object collection is a null object or contains zero count items.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.IsNullOrEmpty``1(``0[])">
 <summary>
 This object array is a null object or contains zero count items.(判断某一个对象数组是否为空)
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.LoadTextDoc``1(System.String,System.Text.Encoding,System.Func{System.String,System.Text.Encoding,``0},System.Boolean)">
 <summary>
 默认是加载Xml文件的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="file"></param>
 <param name="encoding"></param>
 <param name="parser">default is Xml parser</param>
 <param name="ThrowEx"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.GetLength``1(``0[])">
 <summary>
 0 for null object
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Shell(System.String)">
 <summary>
 执行一个命令行语句，并返回一个IO重定向对象，以获取被执行的目标命令的标准输出
 </summary>
 <param name="CLI"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.π(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 获取一个实数集合中所有元素的积
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.FillBlank(System.Drawing.Image@,System.Drawing.Brush)">
 <summary>
 Fill the newly created image data with the specific color brush
 </summary>
 <param name="Image"></param>
 <param name="FilledColor"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Removes``1(Microsoft.VisualBasic.List{``0}@,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Remove all of the element in the <paramref name="collection"></paramref> from target <paramref name="List">list</paramref>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="List"></param>
 <param name="collection"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveLast``1(Microsoft.VisualBasic.List{``0}@)">
 <summary>
 Removes the last element in the List object.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.CPOL">
<summary>
  Looks up a localized string similar to ?&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Code Project Open License (CPOL)&lt;/title&gt;
&lt;Style&gt;
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H1,H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H1 { font-size: 14pt;color:black }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: &quot;Courier New&quot;, Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: &quot;Courier New&quot;, Courier, mono; }
.SpacedList li [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.gpl">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.license">
<summary>
  Looks up a localized string similar to This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Pu [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.List_of_MIME_types___Internet_Media_Types_">
<summary>
  Looks up a localized string similar to Name	MIME Type / Internet Media Type	File Extension	More Details
3D Crossword Plugin	application/vnd.hzn-3d-crossword	.x3d	IANA: 3D Crossword Plugin
3GP	video/3gpp	.3gp	Wikipedia: 3GP
3GP2	video/3gpp2	.3g2	Wikipedia: 3G2
3GPP MSEQ File	application/vnd.mseq	.mseq	IANA: 3GPP MSEQ File
3M Post It Notes	application/vnd.3m.post-it-notes	.pwn	IANA: 3M Post It Notes
3rd Generation Partnership Project - Pic Large	application/vnd.3gpp.pic-bw-large	.plb	3GPP
3rd Generation Partnership Project - Pic Small	application/ [rest of string was truncated]&quot;;.
</summary>
</member>
</members>
</doc>
