#Region "Microsoft.VisualBasic::b4e44d1fedcf3ed2c0b77c9148d6fa81, RNA-Seq\Rockhopper\Java\Math_lib\Lowess.vb"

    ' Author:
    ' 
    '       asuka (amethyst.asuka@gcmodeller.org)
    '       xie (genetics@smrucc.org)
    '       xieguigang (xie.guigang@live.com)
    ' 
    ' Copyright (c) 2018 GPL3 Licensed
    ' 
    ' 
    ' GNU GENERAL PUBLIC LICENSE (GPL3)
    ' 
    ' 
    ' This program is free software: you can redistribute it and/or modify
    ' it under the terms of the GNU General Public License as published by
    ' the Free Software Foundation, either version 3 of the License, or
    ' (at your option) any later version.
    ' 
    ' This program is distributed in the hope that it will be useful,
    ' but WITHOUT ANY WARRANTY; without even the implied warranty of
    ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ' GNU General Public License for more details.
    ' 
    ' You should have received a copy of the GNU General Public License
    ' along with this program. If not, see <http://www.gnu.org/licenses/>.



    ' /********************************************************************************/

    ' Summaries:

    ' Module Lowess
    ' 
    '     Function: (+2 Overloads) lowess, process, (+2 Overloads) product, sum
    ' 
    '     Sub: cube, Main, (+2 Overloads) oneMinus, print
    ' 
    ' /********************************************************************************/

#End Region

Imports Microsoft.VisualBasic.CommandLine.Reflection
Imports Microsoft.VisualBasic.Scripting.MetaData
Imports Microsoft.VisualBasic

'
' * Copyright 2013 Brian Tjaden
' *
' * This file is part of Rockhopper.
' *
' * Rockhopper is free software: you can redistribute it and/or modify
' * it under the terms of the GNU General Public License as published by
' * the Free Software Foundation, either version 3 of the License, or
' * any later version.
' *
' * Rockhopper is distributed in the hope that it will be useful,
' * but WITHOUT ANY WARRANTY; without even the implied warranty of
' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' * GNU General Public License for more details.
' *
' * You should have received a copy of the GNU General Public License
' * (in the file gpl.txt) along with Rockhopper.  
' * If not, see <http://www.gnu.org/licenses/>.
' 


<PackageNamespace("Lowess",
                  Description:=" * Copyright 2013 Brian Tjaden
 *
 * This file is part of Rockhopper.
 *
 * Rockhopper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * Rockhopper is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * (in the file gpl.txt) along with Rockhopper.  
 * If not, see <http://www.gnu.org/licenses/>.",
                  Publisher:="Copyright 2013 Brian Tjaden",
                  Cites:="<li>McClure, R., et al. (2013). ""<strong>Computational analysis of bacterial RNA-Seq data.</strong>"" Nucleic Acids Res 41(14): e140.
<p>Recent advances in high-throughput RNA sequencing (RNA-seq) have enabled tremendous leaps forward in our understanding of bacterial transcriptomes. However, computational methods for analysis of bacterial transcriptome data have not kept pace with the large and growing data sets generated by RNA-seq technology. Here, we present new algorithms, specific to bacterial gene structures and transcriptomes, for analysis of RNA-seq data. The algorithms are implemented in an open source software system called Rockhopper that supports various stages of bacterial RNA-seq data analysis, including aligning sequencing reads to a genome, constructing transcriptome maps, quantifying transcript abundance, testing for differential gene expression, determining operon structures and visualizing results. We demonstrate the performance of Rockhopper using 2.1 billion sequenced reads from 75 RNA-seq experiments conducted with Escherichia coli, Neisseria gonorrhoeae, Salmonella enterica, Streptococcus pyogenes and Xenorhabdus nematophila. We find that the transcriptome maps generated by our algorithms are highly accurate when compared with focused experimental data from E. coli and N. gonorrhoeae, and we validate our system's ability to identify novel small RNAs, operons and transcription start sites. Our results suggest that Rockhopper can be used for efficient and accurate analysis of bacterial RNA-seq data, and that it can aid with elucidation of bacterial transcriptomes.</li>")>
Public Module Lowess

    ''' <summary>
    ''' Lowess smoother. Robust locally weighted regression.
    ''' The lowess function fits a nonparametric regression curve to a 
    ''' scatterplot. x and y must be of equal length. Returns the
    ''' estimatad smooth values of y.
    ''' </summary>
    ''' 
    <ExportAPI("lowess", Info:="Lowess smoother. Robust locally weighted regression.
The lowess function fits a nonparametric regression curve to a scatterplot. x and y must be of equal length. Returns the estimatad smooth values of y.")>
    Public Function lowess(x As List(Of Long), y As List(Of Long)) As List(Of Long)
        Return lowess(x, y, 0.1, 1)
        ' Default parameters
    End Function

    ''' <summary>
    ''' Lowess smoother. Robust locally weighted regression.
    ''' The lowess function fits a nonparametric regression curve to a 
    ''' scatterplot. x and y must be of equal length. Returns the
    ''' estimatad smooth values of y.
    ''' 
    ''' A larger smoothing span results in a smoother curve.
    ''' The number of iterations can be increased to improve robustness
    ''' at a cost to running time.
    ''' </summary>
    ''' 
    <ExportAPI("lowess", Info:="Lowess smoother. Robust locally weighted regression.
The lowess function fits a nonparametric regression curve to a scatterplot. x and y must be of equal length. Returns the estimatad smooth values of y.
     
A larger smoothing span results in a smoother curve. The number of iterations can be increased to improve robustness at a cost to running time.")>
    Public Function lowess(x As List(Of Long), y As List(Of Long), smoothingSpan As Double, iterations As Integer) As List(Of Long)
        If x.Count <> y.Count Then
            Output("Error - cannot compute lowess of two matrices with differing sizes." & vbLf)
            Return New List(Of Long)()
        End If

        ' Create lists of nonzero elements
        Dim X1 As New List(Of Long)()
        Dim Y1 As New List(Of Long)()
        Dim X1_sorted As New List(Of Long)()
        For i As Integer = 0 To x.Count - 1
            If x(i) > 0 Then
                X1.Add(x(i))
                Y1.Add(y(i))
                X1_sorted.Add(x(i))
            End If
        Next

        Dim j As Integer = 0

        ' "process" method creates a 2D array based on the size of X1.
        ' If X1 is too large, then we run out of memory and crash.
        ' Here we attempt to limit the size of the dimensions, i.e., the X1 array.
        Dim power As Integer = 0
        Dim threshold As Integer = 0
        While (X1.Count >= 10000) AndAlso (Oracle.Java.System.Runtime.Runtime.maxMemory() < 1300000000) AndAlso (power < 31)
            threshold = CInt(Math.Truncate(Math.Pow(2, power)))
            X1.Clear()
            Y1.Clear()
            X1_sorted.Clear()
            For i As Integer = 0 To x.Count - 1
                If x(i) > threshold Then
                    X1.Add(x(i))
                    Y1.Add(y(i))
                    X1_sorted.Add(x(i))
                End If
            Next
            power += 1
        End While

        ' Sort X1 in reverse order
        Collections.Sort(X1_sorted)
        X1_sorted.Reverse()

        Dim h As New List(Of Long)()
        Dim dist As New List(Of Long)()
        For i As Integer = 0 To X1.Count - 1
            Dim p As Long = X1(i)
            dist.Clear()
            Dim fraction As Double = (X1_sorted.Count - X1_sorted.IndexOf(p)) / CDbl(X1_sorted.Count)
            Dim r As Integer = CInt(Math.Truncate(Math.Ceiling(Math.Min(2.0 * fraction, 0.4) * X1.Count)))
            For j = 0 To X1.Count - 1
                dist.Add(Math.Abs(CLng(p) - CLng(X1(j))))
            Next
            Collections.Sort(dist)
            If r < dist.Count Then
                h.Add(dist(r))
            Else
                h.Add(dist(dist.Count - 1))
            End If
        Next

        Dim w As Double()() = process(X1, h)
        cube(w)
        oneMinus(w)
        cube(w)

        Dim yest As Double() = New Double(X1.Count - 1) {}
        Dim delta As Double() = New Double(X1.Count - 1) {}

        For z As Integer = 0 To iterations - 1
            For i As Integer = 0 To X1.Count - 1
                Dim weights As New List(Of Double)()
                For j = 0 To w.Length - 1
                    weights.Add(w(j)(i))
                Next
                Dim b1 As Double = sum(product(weights, Y1))
                Dim b2 As Double = sum(product(product(weights, Y1), X1))
                Dim A1 As Double = sum(weights)
                Dim A2 As Double = sum(product(weights, X1))
                Dim A3 As Double = A2
                Dim A4 As Double = sum(product(product(weights, X1), X1))
                Dim b As Double()() = {New Double() {b1}, New Double() {b2}}
                Dim A As Double()() = {New Double() {A1, A2}, New Double() {A3, A4}}
                Dim b_Matrix As New Java.Matrix(b)
                Dim A_Matrix As New Java.Matrix(A)
                Dim beta As Double()() = A_Matrix.solve(b_Matrix).array
                ' Linear algebra solver
                yest(i) = beta(0)(0) + (beta(1)(0) * X1(i))
            Next
            Dim residuals As Double() = New Double(Y1.Count - 1) {}
            Dim residuals_absValue As New List(Of Double)()
            For i As Integer = 0 To Y1.Count - 1
                residuals(i) = Y1(i) - yest(i)
                residuals_absValue.Add(Math.Abs(CDbl(Y1(i) - yest(i))))
            Next
            Dim s As Double = 1.0
            If residuals.Length > 0 Then
                s = Java.Misc.select_Double(residuals_absValue, 1 + (residuals.Length \ 2))
            End If

            For i As Integer = 0 To delta.Length - 1
                delta(i) = residuals(i) / (6.0 * s)
                If delta(i) < -1 Then
                    delta(i) = -1.0
                End If
                If delta(i) > 1 Then
                    delta(i) = 1.0
                End If
            Next
            oneMinus(product(delta, delta))
            delta = product(delta, delta)
        Next

        Dim minPositive As Double = Double.MaxValue
        For i As Integer = 0 To yest.Length - 1
            If yest(i) > threshold Then
                If yest(i) < minPositive Then
                    minPositive = yest(i)
                End If
            End If
        Next

        Dim yest_Long As New List(Of Long)()
        j = 0
        For i As Integer = 0 To x.Count - 1
            If x(i) <= threshold Then
                yest_Long.Add(CLng(Math.Truncate(minPositive)))
            Else
                yest_Long.Add(CLng(Math.Truncate(yest(j))))
                j += 1
            End If
        Next
        Return yest_Long
    End Function

    ''' <summary>
    '''**********************************************
    ''' **********   PRIVATE STATIC METHODS   **********
    ''' </summary>

    ''' <summary>
    ''' clip(abs(([x]-transpose([x]))/h),0.0,1.0)
    ''' </summary>
    Private Function process(x As List(Of Long), h As List(Of Long)) As Double()()
        'ORIGINAL LINE: double[][] w = new double[x.Count][x.Count];
        'JAVA TO C# CONVERTER NOTE: The following call to the 'RectangularArrays' helper class reproduces the rectangular array initialization that is automatic in Java:
        Dim w As Double()() = ReturnRectangularDoubleArray(x.Count, x.Count)
        For i As Integer = 0 To x.Count - 1
            For j As Integer = 0 To x.Count - 1
                Dim value As Double = Math.Abs(CDbl(CDbl(x(i) - x(j)) / h(i)))
                If value < 0.0 Then
                    value = 0.0
                End If
                If value > 1.0 Then
                    value = 1.0
                End If
                w(j)(i) = value
            Next
        Next
        Return w
    End Function

    ''' <summary>
    ''' Cube every element in a 2D array.
    ''' </summary>
    Private Sub cube(w As Double()())
        For i As Integer = 0 To w.Length - 1
            For j As Integer = 0 To w(0).Length - 1
                w(i)(j) = w(i)(j) * w(i)(j) * w(i)(j)
            Next
        Next
    End Sub

    ''' <summary>
    ''' w = 1 - w
    ''' </summary>
    Private Sub oneMinus(w As Double()())
        For i As Integer = 0 To w.Length - 1
            For j As Integer = 0 To w(0).Length - 1
                w(i)(j) = 1.0 - w(i)(j)
            Next
        Next
    End Sub

    ''' <summary>
    ''' w = 1 - w
    ''' </summary>
    Private Sub oneMinus(w As Double())
        For i As Integer = 0 To w.Length - 1
            w(i) = 1.0 - w(i)
        Next
    End Sub

    ''' <summary>
    ''' Return a new ArrayList where each element is the product of the corresponding
    ''' elements in the two specified ArrayLists.
    ''' </summary>
    Private Function product(x As List(Of Double), y As List(Of Long)) As List(Of Double)
        Dim result As New List(Of Double)()
        For i As Integer = 0 To x.Count - 1
            result.Add(x(i) * y(i))
        Next
        Return result
    End Function

    ''' <summary>
    ''' Returns a new array where each element is the product of the corresponding
    ''' elements in the two specified arrays.
    ''' </summary>
    Private Function product(x As Double(), y As Double()) As Double()
        Dim result As Double() = New Double(x.Length - 1) {}
        For i As Integer = 0 To x.Length - 1
            result(i) = x(i) * y(i)
        Next
        Return result
    End Function

    ''' <summary>
    ''' Returns the sum of all elements in an ArrayList.
    ''' </summary>
    Private Function sum(x As List(Of Double)) As Double
        Dim _sum As Double = 0.0
        For i As Integer = 0 To x.Count - 1
            _sum += x(i)
        Next
        Return _sum
    End Function

    ''' <summary>
    ''' Output to Stdout a 2D array.
    ''' </summary>
    Private Sub print(w As Double()())
        Output(vbLf)
        For i As Integer = 0 To w.Length - 1
            For j As Integer = 0 To w(0).Length - 1
                Output(vbTab & w(i)(j))
            Next
            Output(vbLf)
        Next
        Output(vbLf)
    End Sub



    ''' <summary>
    '''***********************************
    ''' **********   MAIN METHOD   **********
    ''' </summary>
    ''' <summary>
    ''' The main method is used to test the methods of this class.
    ''' </summary>
    Private Sub Main(args As String())
        Dim a As New List(Of Long)()
        a.Add(CLng(1))
        a.Add(CLng(2))
        a.Add(CLng(5))
        a.Add(CLng(8))
        a.Add(CLng(7))
        a.Add(CLng(3))
        a.Add(CLng(20))
        a.Add(CLng(13))
        a.Add(CLng(10))
        Dim b As New List(Of Long)()
        b.Add(CLng(4))
        b.Add(CLng(9))
        b.Add(CLng(6))
        b.Add(CLng(0))
        b.Add(CLng(1))
        b.Add(CLng(5))
        b.Add(CLng(15))
        b.Add(CLng(11))
        b.Add(CLng(18))
        Console.WriteLine(vbLf & Convert.ToString(lowess(a, b)) & vbLf)


    End Sub

End Module
