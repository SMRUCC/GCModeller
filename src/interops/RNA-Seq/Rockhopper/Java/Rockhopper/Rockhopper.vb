#Region "Microsoft.VisualBasic::571955bc2a840f7091c54f4e89efe703, RNA-Seq\Rockhopper\Java\Rockhopper\Rockhopper.vb"

    ' Author:
    ' 
    '       asuka (amethyst.asuka@gcmodeller.org)
    '       xie (genetics@smrucc.org)
    '       xieguigang (xie.guigang@live.com)
    ' 
    ' Copyright (c) 2018 GPL3 Licensed
    ' 
    ' 
    ' GNU GENERAL PUBLIC LICENSE (GPL3)
    ' 
    ' 
    ' This program is free software: you can redistribute it and/or modify
    ' it under the terms of the GNU General Public License as published by
    ' the Free Software Foundation, either version 3 of the License, or
    ' (at your option) any later version.
    ' 
    ' This program is distributed in the hope that it will be useful,
    ' but WITHOUT ANY WARRANTY; without even the implied warranty of
    ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ' GNU General Public License for more details.
    ' 
    ' You should have received a copy of the GNU General Public License
    ' along with this program. If not, see <http://www.gnu.org/licenses/>.



    ' /********************************************************************************/

    ' Summaries:

    '     Class Rockhopper
    ' 
    '         Properties: genomes
    ' 
    '         Constructor: (+1 Overloads) Sub New
    ' 
    '         Function: getNumOfDifferentiallyExpressedGenes
    ' 
    '         Sub: computeDifferentialExpression, computeGeneExpression, identifySimilarConditions, runRockhopper
    ' 
    ' 
    ' /********************************************************************************/

#End Region

Imports System.Collections.Generic

'
' * Copyright 2013 Brian Tjaden
' *
' * This file is part of Rockhopper.
' *
' * Rockhopper is free software: you can redistribute it and/or modify
' * it under the terms of the GNU General Public License as published by
' * the Free Software Foundation, either version 3 of the License, or
' * any later version.
' *
' * Rockhopper is distributed in the hope that it will be useful,
' * but WITHOUT ANY WARRANTY; without even the implied warranty of
' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' * GNU General Public License for more details.
' *
' * You should have received a copy of the GNU General Public License
' * (in the file gpl.txt) along with Rockhopper.  
' * If not, see <http://www.gnu.org/licenses/>.
' 

Namespace Java

    ''' <summary>
    ''' The Rockhopper application reads in RNA-seq data, aligns the
    ''' sequencing reads to a genome, and then analyzes the data to
    ''' identify the expression of genes in each condition, differential
    ''' gene expression between conditions, transcript boundaries, and
    ''' operons. Rockhopper can also assemble transcripts de novo
    ''' without a reference genome.
    ''' </summary>
    ''' <remarks>
    ''' McClure, R., et al. (2013). "Computational analysis of bacterial RNA-Seq data." Nucleic Acids Res 41(14): e140.
    ''' 
    '''	Recent advances In high-throughput RNA sequencing (RNA-seq) have enabled tremendous leaps forward In our understanding Of bacterial transcriptomes. 
    ''' However, computational methods For analysis Of bacterial transcriptome data have Not kept pace With the large And growing data sets generated by 
    ''' RNA-seq technology. Here, we present New algorithms, specific To bacterial gene structures And transcriptomes, For analysis Of RNA-seq data. 
    ''' The algorithms are implemented In an open source software system called Rockhopper that supports various stages Of bacterial RNA-seq data analysis, 
    ''' including aligning sequencing reads To a genome, constructing transcriptome maps, quantifying transcript abundance, testing For differential gene 
    ''' expression, determining operon structures And visualizing results. We demonstrate the performance Of Rockhopper Using 2.1 billion sequenced reads 
    ''' from 75 RNA-seq experiments conducted With Escherichia coli, Neisseria gonorrhoeae, Salmonella enterica, Streptococcus pyogenes And Xenorhabdus 
    ''' nematophila. We find that the transcriptome maps generated by our algorithms are highly accurate When compared With focused experimental data from 
    ''' E. coli And N. gonorrhoeae, And we validate our system's ability to identify novel small RNAs, operons and transcription start sites. Our results 
    ''' suggest that Rockhopper can be used for efficient and accurate analysis of bacterial RNA-seq data, and that it can aid with elucidation of bacterial 
    ''' transcriptomes.
    ''' </remarks>
    Public Class Rockhopper

        ''' <summary>
        '''******************************************
        ''' **********   INSTANCE VARIABLES   **********
        ''' </summary>

        Private _genomes As New List(Of Genome)()
        Private transcripts As New List(Of Transcripts)()
        Private conditions As List(Of Condition)
        ' RNA-seq data for each condition


        ''' <summary>
        '''************************************
        ''' **********   CONSTRUCTORS   **********
        ''' </summary>

        ''' <summary>
        ''' Constructs a new Rockhopper object.
        ''' </summary>
        Public Sub New()

            stagesProcessed = 0
            If isDeNovo Then
                ' De novo assembly
                Dim a As New Assembler()
                Return
            End If

            ' Read in genome
            genomeSizes = New List(Of Integer)()
            genomeSize = 0
            For Each genome_DIR As String In genome_DIRs
                Dim genome As New Genome(genome_DIR)
                Me._genomes.Add(genome)
                genomeSizes.Add(genome.size())
                genomeSize += genome.size()
            Next

            ' Align sequencing reads to genome and compute basic expression information
            Me.conditions = New List(Of Condition)()
            Peregrine.sequenceFiles = New String(_genomes.Count - 1) {}
            Peregrine.annotationsPlus = New String(_genomes.Count - 1)() {}
            Peregrine.annotationsMinus = New String(_genomes.Count - 1)() {}
            For z As Integer = 0 To _genomes.Count - 1
                Dim genome_DIR As String = genome_DIRs(z)
                Dim dir As New Oracle.Java.IO.File(genome_DIR)
                Dim files As String() = dir.list()
                For i As Integer = 0 To files.Length - 1
                    If files(i).EndsWith(".fna") Then
                        Peregrine.sequenceFiles(z) = genome_DIR & files(i)
                        Peregrine.annotationsPlus(z) = _genomes(z).getAnnotations("+"c)
                        Peregrine.annotationsMinus(z) = _genomes(z).getAnnotations("-"c)
                    End If
                Next
            Next
            Peregrine.numSequences = _genomes.Count
            'Peregrine.outputBrowserFile = False
            output(vbLf)
            For i As Integer = 0 To conditionFiles.Count - 1
                ' For each condition
                Dim readFiles As String() = StringSplit(conditionFiles(i), ",", True)
                Dim C As New Condition()
                For j As Integer = 0 To readFiles.Length - 1
                    ' For each replicate
                    Dim parse_readFiles As String() = StringSplit(readFiles(j), "%", True)
                    If parse_readFiles.Length = 1 Then
                        ' Using single-end reads (except maybe SAM/BAM)
                        Dim file1 As String = parse_readFiles(0)
                        output("Aligning sequencing reads from file:" & vbTab & StringSplit(file1, separator(), True)(StringSplit(file1, separator(), True).Length - 1) & vbLf)
                        Peregrine.isPairedEnd = False
                        Peregrine.pairedEndFile = Nothing
                        Peregrine.readsFile = file1
                        Dim p As New Peregrine()
                        '  updateProgress()
                        C.addReplicate(New Replicate(p.getListOfCompressedFileNames(file1), file1, unstranded))
                    Else
                        ' Using paired-end reads
                        Dim file1 As String = parse_readFiles(0)
                        Dim file2 As String = parse_readFiles(1)
                        output("Aligning sequencing reads from files:" & vbLf)
                        output(vbTab & StringSplit(file1, separator(), True)(StringSplit(file1, separator(), True).Length - 1) & vbLf)
                        output(vbTab & StringSplit(file2, separator(), True)(StringSplit(file2, separator(), True).Length - 1) & vbLf)
                        Peregrine.isPairedEnd = True
                        Peregrine.readsFile = file1
                        Peregrine.pairedEndFile = file2
                        Dim p As New Peregrine()
                        '  updateProgress()
                        C.addReplicate(New Replicate(p.getListOfCompressedFileNames(file1), file1, unstranded))
                    End If
                Next
                C.setMinDiffExpressionLevel()
                conditions.Add(C)
            Next
            numConditions = conditions.Count
            computeGeneExpression()

            ' Output mapped reads to WIG files that can be loaded by genome browser
            Dim trackRange As Double = 0.0
            Dim totalReplicates As Integer = 0
            For i As Integer = 0 To conditions.Count - 1
                For j As Integer = 0 To conditions(i).numReplicates() - 1
                    trackRange += conditions(i).getReplicate(j).avgReads
                    totalReplicates += 1
                Next
            Next
            trackRange = (2 * trackRange) / totalReplicates
            ' Range for display in genome browser
            For i As Integer = 0 To conditionFiles.Count - 1
                ' For each condition
                Dim readFiles As String() = StringSplit(conditionFiles(i), ",", True)
                For j As Integer = 0 To readFiles.Length - 1
                    ' For each replicate
                    Dim r As Replicate = conditions(i).getReplicate(j)
                    Dim multiplier As Double = 100000.0 / CDbl(r.upperQuartile)
                    For z As Integer = 0 To _genomes.Count - 1
                        Dim coordinates_plus As Integer() = New Integer(genomeSizes(z) - 1) {}
                        Dim coordinates_minus As Integer() = New Integer(genomeSizes(z) - 1) {}
                        For k As Integer = 0 To genomeSizes(z) - 1
                            coordinates_plus(k) = CInt(Math.Truncate(multiplier * r.getReads(z, k, "+"c)))
                            coordinates_minus(k) = CInt(Math.Truncate(multiplier * r.getReads(z, k, "-"c)))
                        Next
                        Peregrine.outputBrowserFile(StringSplit(readFiles(j), "%", True)(0), Peregrine.sequenceFiles(z), output_DIR, browser_DIR, r.getCompressedFileName(z), coordinates_plus,
                        coordinates_minus, CInt(Math.Truncate(trackRange)))
                    Next
                Next
            Next
            Peregrine.releaseMemory()

            output("Analyzing transcripts..." & vbLf)

            ' Compute transcript boundaries
            If computeTranscripts Then
                For z As Integer = 0 To _genomes.Count - 1
                    Dim genome As Genome = _genomes(z)
                    If genome.numGenes() > 0 Then
                        Dim t As New Transcripts(z, genome, conditions, unstranded)
                        t.identifyUTRs()
                        t.identifyRNAs()
                        transcripts.Add(t)
                    End If
                Next
            End If

            ' Compute gene differential expression
            If computeExpression Then
                Gene.setLowessVariances(_genomes, conditions)
                ' Compute lowess variance for each gene
                For Each genome As Genome In _genomes
                    If genome.numGenes() > 0 Then
                        computeDifferentialExpression(genome)
                    End If
                Next
                ' Compute q-values, Benjamini-Hochberg correction
                Gene.correctPvalues(_genomes, conditions)
            End If

            For z As Integer = 0 To _genomes.Count - 1
                runRockhopper(z)
            Next
            output(vbLf & "Summary of results written to file:" & vbTab & output_DIR & summaryFile & vbLf)
            For z As Integer = 0 To _genomes.Count - 1
                output("Expression of transcripts written to file:" & vbTab & output_DIR & _genomes(z).iD & "_" & expressionFile & vbLf)
                If computeOperons Then
                    'output("Pairs of operon genes written to file:\t" + output_DIR + genome.getID() + "_" + operonGenePairFile + "\n");
                    output("Operons written to file:" & vbTab & vbTab & output_DIR & _genomes(z).iD & "_" & operonMergedFile & vbLf)
                End If
            Next
            output(vbLf & "FINISHED." & vbLf & vbLf)
            summaryWriter.close()
            'updateProgress()
        End Sub



        ''' <summary>
        '''***********************************************
        ''' **********   PUBLIC INSTANCE METHODS   **********
        ''' </summary>

        Public Overridable Sub runRockhopper(z As Integer)
            Dim genome As Genome = _genomes(z)

            output(vbLf)
            output("************************************************************" & vbLf)
            output(genome.name & vbLf)
            output("************************************************************" & vbLf)
            output(vbLf)

            ' Compute transcript boundaries
            If computeTranscripts AndAlso (genome.numGenes() > 0) Then
                Dim t As Transcripts = transcripts(z)
                output("Computing transcript boundaries..." & vbLf)
                output(vbTab & "Number of 5'UTRs:" & vbTab & vbTab & vbTab & t.num5UTRs & vbLf)
                output(vbTab & "Number of 3'UTRs:" & vbTab & vbTab & vbTab & t.num3UTRs & vbLf)
                output(vbTab & "Number of predicted RNAs:" & vbTab & vbTab & vbTab & (t.numSenseRNAs + t.numAntisenseRNAs) & vbLf)
                If Not unstranded Then
                    output(vbTab & "Number of predicted RNAs (not antisense):" & vbTab & vbTab & t.numSenseRNAs & vbLf)
                    output(vbTab & "Number of predicted RNAs (antisense):" & vbTab & vbTab & t.numAntisenseRNAs & vbLf)
                End If
                output(vbLf)
                outputUTRsForBrowser(output_DIR & browser_DIR & genome.iD & "_UTRs.wig", genome.formalGenomeName, genome.genes, genome.size())
                outputRNAsForBrowser(output_DIR & browser_DIR & genome.iD & "_ncRNAs.wig", genome.formalGenomeName, genome.genes, genome.size())
            End If

            ' Compute gene differential expression
            If computeExpression AndAlso (genome.numGenes() > 0) Then
                output("Computing differential gene expression..." & vbLf)
                output(vbTab & "Number of differentially expressed protein coding genes:" & vbTab & getNumOfDifferentiallyExpressedGenes(genome, 0.01) & vbLf & vbLf)
                outputDifferentiallyExpressedGenesForBrowser(output_DIR & browser_DIR & genome.iD & "_diffExpressedGenes.wig", genome.formalGenomeName, genome.genes, genome.size())
            End If

            ' Output transcript file
            Try
                Dim writer As New PrintWriter(New Oracle.Java.IO.File(output_DIR & genome.iD & "_" & expressionFile))
                writer.println(genome.genesToString(conditions, labels))
                writer.close()
            Catch e As FileNotFoundException
                output(vbLf & "Error - could not open file " & genome.iD & "_" & expressionFile & vbLf & vbLf)
            End Try

            ' Compute operons
            If computeOperons AndAlso (genome.numGenes() > 0) Then
                output("Computing likely operons..." & vbLf)
                Dim ops As New Operons(genome.codingGenes, genome.genes)
                output(vbTab & "Number of gene-pairs predicted to be part of the same operon:" & vbTab & ops.getNumOperonGenePairs(genome.codingGenes) & vbLf)
                'ops.outputGenePairOperons(output_DIR + genome.getID() + "_" + operonGenePairFile, genome.getCodingGenes());
                Dim numMergedOperons As Integer = ops.outputMergedOperons(output_DIR & genome.iD & "_" & operonMergedFile, output_DIR & browser_DIR & genome.iD & "_operons.wig", genome.formalGenomeName, genome.codingGenes, genome.size())
                output(vbTab & "Number of predicted multi-gene operons:" & vbTab & vbTab & numMergedOperons & vbLf & vbLf)
            End If
        End Sub

        ''' <summary>
        ''' Returns a list of Genome objects.
        ''' </summary>
        Public Overridable ReadOnly Property genomes() As List(Of Genome)
            Get
                Return _genomes
            End Get
        End Property

        ''' <summary>
        '''************************************************
        ''' **********   PRIVATE INSTANCE METHODS   **********
        ''' </summary>

        ''' <summary>
        ''' For each gene, compute its raw read counts, normalized read
        ''' counts, mean, variance, and RPKM.
        ''' </summary>
        Private Sub computeGeneExpression()
            Dim totalReplicates As Integer = 0
            Dim sumUpperQuartile As Long = 0
            For j As Integer = 0 To conditions.Count - 1
                For k As Integer = 0 To conditions(j).numReplicates() - 1
                    Dim r As Replicate = conditions(j).getReplicate(k)
                    r.minExpression = transcriptSensitivity
                    Dim currentGeneReads As New List(Of Long)()
                    ' For normalization
                    Dim zeroCountGenes As Integer = 0
                    ' For normalization, keep track of genes with zero reads
                    Dim totalGenes As Integer = 0
                    For z As Integer = 0 To _genomes.Count - 1
                        Dim genome As Genome = _genomes(z)
                        For i As Integer = 0 To genome.numGenes() - 1
                            Dim g As Gene = genome.getGene(i)

                            Dim readsForGene As Long = r.getReadsInRange(z, g.minCoordinate, g.maxCoordinate, g.strand)
                            If unstranded Then
                                ' Strand ambiguous. Count reads on both strands.
                                readsForGene = r.getReadsInRange(z, g.minCoordinate, g.maxCoordinate, "+"c) + r.getReadsInRange(z, g.minCoordinate, g.maxCoordinate, "-"c)
                            End If
                            g.setRawCount(j, k, readsForGene)
                            ' Set raw counts for gene
                            If r.avgLengthReads = 0 Then
                                g.setRawCount_reads(j, k, 0)
                            Else
                                g.setRawCount_reads(j, k, readsForGene \ r.avgLengthReads)
                            End If
                            currentGeneReads.Add(readsForGene)
                            ' Populate list for normalization
                            If readsForGene = 0 Then
                                ' Genes with zero reads for normalization
                                zeroCountGenes += 1
                            End If
                        Next
                        totalGenes += genome.numGenes()
                    Next
                    Dim upperQuartile As Long = Misc.select_Long(currentGeneReads, CInt(Math.Truncate(zeroCountGenes + 0.75 * (totalGenes - zeroCountGenes))))
                    r.upperQuartile = upperQuartile
                    sumUpperQuartile += upperQuartile
                    totalReplicates += 1
                Next
            Next
            Condition.avgUpperQuartile = sumUpperQuartile \ totalReplicates

            ' Set normalized read counts for each gene
            For j As Integer = 0 To conditions.Count - 1
                For k As Integer = 0 To conditions(j).numReplicates() - 1
                    For z As Integer = 0 To _genomes.Count - 1
                        Dim genome As Genome = _genomes(z)
                        For i As Integer = 0 To genome.numGenes() - 1
                            ' Set normalized counts
                            genome.getGene(i).setNormalizedCount(j, k, 100000.0, conditions(j).getReplicate(k).upperQuartile)
                        Next
                    Next
                Next
            Next

            ' Compute mean and RPKM for each gene in each condition
            For z As Integer = 0 To _genomes.Count - 1
                Dim genome As Genome = _genomes(z)
                For i As Integer = 0 To genome.numGenes() - 1
                    genome.getGene(i).computeExpression(conditions)
                Next
            Next

            identifySimilarConditions()
            ' We require means to identify similar conditions
            ' Compute variance for each gene in each condition
            For z As Integer = 0 To _genomes.Count - 1
                Dim genome As Genome = _genomes(z)
                For i As Integer = 0 To genome.numGenes() - 1
                    genome.getGene(i).computeVariance(conditions)
                Next
            Next
        End Sub

        Private Sub computeDifferentialExpression(genome As Genome)
            ' Compute differential expression for each gene in pairs of conditions
            For i As Integer = 0 To genome.numGenes() - 1
                genome.getGene(i).computeDifferentialExpression()
            Next
        End Sub

        ''' <summary>
        ''' Returns the number of significantly differentially expressed
        ''' protein-coding genes.
        ''' The significance threshold is specified by the parameter.
        ''' </summary>
        Private Function getNumOfDifferentiallyExpressedGenes(genome As Genome, significance As Double) As Integer
            Dim numDiffExpressedGenes As Integer = 0
            For i As Integer = 0 To genome.numGenes() - 1
                If genome.getGene(i).isDifferntiallyExpressedORF(significance) Then
                    numDiffExpressedGenes += 1
                End If
            Next
            Return numDiffExpressedGenes
        End Function

        ''' <summary>
        ''' For each condition, determines the other condition that is most similar,
        ''' i.e., its "partner". If there are no replicate experiments then the
        ''' partner of each condition is used as a surrogate replicate.
        ''' Similarity between two conditions is measured by the Pearson correlation 
        ''' coefficient of normalized gene expression.
        ''' This method sets the "partner" of each condition.
        ''' </summary>
        Private Sub identifySimilarConditions()
            If conditions.Count = 1 Then
                ' Special case. Only 1 condition. It partners itself.
                conditions(0).partner = 0
                Return
            End If

            'ORIGINAL LINE: double[][] correlationMatrix = new double[conditions.Count][conditions.Count];
            'JAVA TO C# CONVERTER NOTE: The following call to the 'RectangularArrays' helper class reproduces the rectangular array initialization that is automatic in Java:
            Dim correlationMatrix As Double()() = ReturnRectangularDoubleArray(conditions.Count, conditions.Count)
            For i As Integer = 0 To conditions.Count - 1
                For j As Integer = 0 To conditions.Count - 1
                    Dim e1 As New List(Of Long)()
                    ' Gene expression values 1
                    Dim e2 As New List(Of Long)()
                    ' Gene expression values 2
                    For Each genome As Genome In _genomes
                        For k As Integer = 0 To genome.numGenes() - 1
                            Dim geneLength As Integer = genome.getGene(k).maxCoordinate - genome.getGene(k).minCoordinate + 1
                            e1.Add(genome.getGene(k).getMean(i) \ geneLength)
                            e2.Add(genome.getGene(k).getMean(j) \ geneLength)
                        Next
                    Next
                    correlationMatrix(i)(j) = Misc.correlation(e1, e2)
                Next
            Next

            ' Determine partner for each condition
            Dim partner As Integer = -1
            For i As Integer = 0 To conditions.Count - 1
                If i = 0 Then
                    partner = 1
                Else
                    partner = 0
                End If
                For j As Integer = 0 To conditions.Count - 1
                    If (i <> j) AndAlso (correlationMatrix(i)(j) > correlationMatrix(i)(partner)) Then
                        partner = j
                    End If
                Next
                conditions(i).partner = partner
            Next
        End Sub

    End Class
End Namespace
