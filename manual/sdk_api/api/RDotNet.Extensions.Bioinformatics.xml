<?xml version="1.0"?>
<doc>
<assembly>
<name>
RDotNET.Extensions.Bioinformatics
</name>
</assembly>
<members>
<member name="T:RDotNET.Extensions.Bioinformatics.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.My.Resources.Resources.sparcc">
<summary>
  Looks up a localized string similar to require(gtools)


## NB
##------------------------------
## count matrix x should be samples on the rows and OTUs on the colums,
## assuming dim(x) -&gt; samples by OTUs

sparcc &lt;- function(x, max.iter=20, th=0.1, exiter=10){
  xdim &lt;- dim(x)
  Vlist &lt;- matrix(NA,nrow=xdim[2],ncol=max.iter)
  Corlist &lt;- array(,dim=c(max.iter, xdim[2], xdim[2]))
  Covlist &lt;- array(,dim=c(max.iter, xdim[2], xdim[2]))

  ## Cycle max.iter times for variability in variance estimation
  for (i in 1:max.iter){
    cat(&quot;Iteration: %d [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.adegenet.API.df2genind(Microsoft.VisualBasic.Data.csv.DocumentStream.File,System.String,System.String,System.String[],System.String[],System.String,System.String,System.Int32,System.String,System.String,System.String)">
 <summary>
 Convert a ``data.frame`` of allele data to a <see cref="T:RDotNET.Extensions.Bioinformatics.adegenet.genind"/> object.
 
 The function ``df2genind`` converts a ``data.frame`` (or a matrix) into a ``genind`` object. The ``data.frame`` must meet the following requirements:
 
 - genotypes are in row (one row per genotype)
 - markers/loci are in columns
 - each element Is a string of characters coding alleles, ideally separated by a character string (argument sep); if no separator Is used, the number of characters coding alleles must be indicated (argument ncode).
 
 (这个函数在这里所返回来的是<see cref="T:RDotNET.Extensions.Bioinformatics.adegenet.genind"/>对象在R之中的变量的名称)
 </summary>
 <param name="X">a matrix or a data.frame containing allelle data only (see decription)</param>
 <param name="sep">a character string separating alleles. See details.</param>
 <param name="ncode">an optional integer giving the number of characters used for coding one genotype at one locus. If not provided, this is determined from data.</param>
 <param name="indNames">an optional character vector giving the individuals names; if NULL, taken from rownames of X.</param>
 <param name="locNames">an optional character vector giving the markers names; if NULL, taken from colnames of X.</param>
 <param name="pop">an optional factor giving the population of each individual.</param>
 <param name="NAchar">a vector of character strings which are to be treated as NA</param>
 <param name="ploidy">an integer indicating the degree of ploidy of the genotypes.</param>
 <param name="type">a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' markers (e.g. AFLP, RAPD).</param>
 <param name="strata">an optional data frame that defines population stratifications for your samples. This is especially useful if you have a hierarchical or factorial sampling design.</param>
 <param name="hierarchy">a hierarchical formula that explicitely defines hierarchical levels in your strata. see hierarchy for details.</param>
 <returns>an object of the class genind for df2genind; a matrix of biallelic genotypes for genind2df</returns>
 <remarks>
 See genind2df to convert genind objects back to such a data.frame.

 === Details for the sep argument ===
 this character Is directly used In reguar expressions Like gsub, And thus require some characters To be 
 preceeded by Double backslashes. For instance, "/" works but "|" must be coded As "\|".
 
 #### Examples

 ```R
 ## simple example
 df &lt;- data.frame(locusA=c("11","11","12","32"),
 locusB=c(NA,"34","55","15"),locusC=c("22","22","21","22"))
 row.names(df) &lt;- .genlab("genotype",4)
 df

 obj &lt;- df2genind(df, ploidy=2, ncode=1)
 obj
 obj@tab

 ## converting a genind as data.frame
 genind2df(obj)
 genind2df(obj, sep="/")
 ```
 </remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.adegenet.genind">
 <summary>
 ###### adegenet formal class (S4) for individual genotypes
 
 The S4 class genind is used to store individual genotypes.
 It contains several components described In the 'slots' section).
 The summary Of a genind Object invisibly returns a list Of component. 
 The Function .valid.genind Is For internal use. The Function genind 
 creates a genind Object from a valid table Of alleles corresponding 
 To the @tab slot. Note that As In other S4 classes, slots are accessed 
 Using @ instead Of \$.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.tab">
 <summary>
 matrix integers containing genotypes data for individuals (in rows) for 
 all alleles (in columns). 
 The table differs depending on the @type slot:
 
 + ``codom``: values are numbers of alleles, summing up to the individuals' ploidies.
 + ``PA``: values are presence/absence of alleles.
 
 In all cases, rows And columns are given generic names.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.locFac">
 <summary>
 locus factor for the columns of tab
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.locNAll">
 <summary>
 integer vector giving the number of alleles per locus
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.allNames">
 <summary>
 list having one component per locus, each containing a character vector of alleles names
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.ploidy">
 <summary>
 an integer indicating the degree of ploidy of the genotypes. Beware: 2 is not an integer, but as.integer(2) is.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.type">
 <summary>
 a character string indicating the type of marker: ``codom`` stands for ``codominant`` 
 (e.g. microstallites, allozymes); ``PA`` stands for ``presence/absence`` (e.g. AFLP).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.call">
 <summary>
 the matched call
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.strata">
 <summary>
 (optional) data frame giving levels of population stratification for each individual
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.hierarchy">
 <summary>
 (optional) a hierarchical formula defining the hierarchical levels in the @@strata slot.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.pop">
 <summary>
 (optional) factor giving the population of each individual
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.adegenet.genind.other">
 <summary>
 (optional) a list containing other information
 </summary>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.adegenet.genind.nancycats">
 <summary>
 ###### Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France)
 
 This data set gives the genotypes of 237 cats (Felis catus L.) for 9 microsatellites markers. 
 The individuals are divided into 17 colonies whose spatial coordinates are also provided.
 </summary>
 <returns></returns>
 <remarks>
 nancycats is a genind object with spatial coordinates of the colonies as a supplementary components (@xy).
 
 Dominique Pontier (UMR CNRS 5558, University Lyon1, France)
 
 > Devillard, S.; Jombart, T. &amp; Pontier, D. Disentangling spatial and genetic structure of stray cat (Felis catus L.) colonies in urban habitat using: not all colonies are equal. submitted to Molecular Ecology
 </remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.setArc">
 <summary>
 The set.arc function operates in the following way:
 
 If there Is no arc between from And To, the arc from -> To Is added.
 If there Is an undirected arc between from And To, its direction Is Set To from -> To.
 If the arc To -> from Is present, it Is reversed.
 If the arc from -> To Is present, no action Is taken.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.dropArc">
 <summary>
 The drop.arc function operates in the following way:

 If there Is no arc between from And To, no action Is taken.
 If there Is a directed Or an undirected arc between from And To, it Is dropped regardless Of its direction.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.reverseArc">
 <summary>
 The reverse.arc function operates in the following way:

 If there Is no arc between from And To, it returns an Error.
 If there Is an undirected arc between from And To, it returns an Error.
 If the arc To -> from Is present, it Is reversed.
 If the arc from -> To Is present, it Is reversed.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.setEdge">
 <summary>
 The set.edge function operates in the following way:

 If there Is no arc between from And To, the undirected arc from - To Is added.
 If there Is an undirected arc between from And To, no action Is taken.
 If either the arc from -> To Or the arc To -> from are present, they are replaced With the undirected arc from - To.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.dropEdge">
 <summary>
 The drop.edge function operates in the following way:

 If there Is no undirected arc between from And To, no action Is taken.
 If there Is an undirected arc between from And To, it Is removed.
 If there Is a directed arc between from And To, no action Is taken.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFit">
 <summary>
 Fit the parameters of a Bayesian network conditional on its structure.
 
 bn.fit fits the parameters of a Bayesian network given its structure and a data set; bn.net returns the structure underlying a fitted Bayesian network.
 An in-place replacement method Is available to change the parameters of each node in a bn.fit object; see the examples for discrete, continuous And hybrid networks below. For a discrete node (class bn.fit.dnode Or bn.fit.onode), the New parameters must be in a table object. For a Gaussian node (class bn.fit.gnode), the New parameters can be defined either by an lm, glm Or pensim object (the latter Is from the penalized package) Or in a list with elements named coef, sd And optionally fitted And resid. For a conditional Gaussian node (class bn.fit.cgnode), the New parameters can be defined by a list with elements named coef, sd And optionally fitted, resid And configs. In both cases coef should contain the New regression coefficients, sd the standard deviation of the residuals, fitted the fitted values And resid the residuals. configs should contain the configurations if the discrete parents of the conditional Gaussian node, stored as a factor.
 </summary>
 <remarks>
 bn.fit returns an object of class bn.fit, bn.net an object of class bn. See bn class and bn.fit class for details.
 </remarks>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFit.x">
 <summary>
 an object of class bn (for bn.fit and custom.fit) or an object of class bn.fit (for bn.net).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFit.data">
 <summary>
 a data frame containing the variables In the model.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFit.method">
 <summary>
 a character string, either mle for Maximum Likelihood parameter estimation or bayes for Bayesian parameter estimation (currently implemented only for discrete data).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFit.debug">
 <summary>
 a boolean value. If TRUE a lot of debugging output is printed; otherwise the function is completely silent.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.customFit">
 <summary>
 custom.fit takes a set of user-specified distributions and their parameters and uses them to build a bn.fit object. 
 Its purpose is to specify a Bayesian network (complete with the parameters, not only the structure) using knowledge from experts in the field instead of learning it from a data set. 
 The distributions must be passed to the function in a list, with elements named after the nodes of the network structure x. 
 Each element of the list must be in one of the formats described above for in-place replacement.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.customFit.x">
 <summary>
 an object of class bn (for bn.fit and custom.fit) or an object of class bn.fit (for bn.net).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.customFit.dist">
 <summary>
 a named list, with element for each node of x. See below.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.customFit.ordinal">
 <summary>
 a vector Of character strings, the labels Of the discrete nodes which should be saved As ordinal random variables (bn.fit.onode) instead Of unordered factors (bn.fit.dnode).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnNet.x">
 <summary>
 an object of class bn (for bn.fit and custom.fit) or an object of class bn.fit (for bn.net).
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnNet.debug">
 <summary>
 a boolean value. If TRUE a lot of debugging output is printed; otherwise the function is completely silent.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitPlot">
 <summary>
 Plot fitted Bayesian networks
 Plot functions for the bn.fit, bn.fit.dnode and bn.fit.gnode classes, based on the lattice package.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitPlot.fitted">
 <summary>
 an object of class bn.fit, bn.fit.dnode Or bn.fit.gnode.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitPlot.xlab">
 <summary>
 the label of the x axis, of the y axis, and the plot title.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitPlot.ylab">
 <summary>
 the label of the x axis, of the y axis, and the plot title.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitPlot.main">
 <summary>
 the label of the x axis, of the y axis, and the plot title.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitQqplot">
 <summary>
 bn.fit.qqplot draws a quantile-quantile plot of the residuals.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitHistogram">
 <summary>
 bn.fit.histogram draws a histogram of the residuals, using either absolute or relative frequencies.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitHistogram.density">
 <summary>
 a boolean value. If TRUE the histogram is plotted using relative frequencies, and the matching normal density is added to the plot.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitxyplot">
 <summary>
 bn.fit.xyplot plots the residuals versus the fitted values.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.bnFitBarchart">
 <summary>
 bn.fit.barchart and bn.fit.dotplot plot the probabilities in the conditional probability table associated with each node.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.declares.bnlearn.alarm">
 <summary>
 The alarm data set contains the following 37 variables:
 
 CVP (central venous pressure): a three-level factor With levels LOW, NORMAL And HIGH.
 PCWP (pulmonary capillary wedge pressure): a three-level factor With levels LOW, NORMAL And HIGH.
 HIST (history): a two-level factor With levels True And False.
 TPR (total peripheral resistance): a three-level factor With levels LOW, NORMAL And HIGH.
 BP (blood pressure): a three-level factor With levels LOW, NORMAL And HIGH.
 CO (cardiac output): a three-level factor With levels LOW, NORMAL And HIGH.
 HRBP (heart rate / blood pressure): a three-level factor With levels LOW, NORMAL And HIGH.
 HREK (heart rate measured by an EKG monitor): a three-level factor With levels LOW, NORMAL And HIGH.
 HRSA (heart rate / oxygen saturation): a three-level factor With levels LOW, NORMAL And HIGH.
 PAP (pulmonary artery pressure): a three-level factor With levels LOW, NORMAL And HIGH.
 SAO2 (arterial oxygen saturation): a three-level factor With levels LOW, NORMAL And HIGH.
 FIO2 (fraction of inspired oxygen): a two-level factor With levels LOW And NORMAL.
 PRSS (breathing pressure): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 ECO2 (expelled CO2): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 MINV (minimum volume): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 MVS (minimum volume set): a three-level factor With levels LOW, NORMAL And HIGH.
 HYP (hypovolemia): a two-level factor With levels True And False.
 LVF (left ventricular failure): a two-level factor With levels True And False.
 APL (anaphylaxis): a two-level factor With levels True And False.
 ANES (insufficient anesthesia/analgesia): a two-level factor With levels True And False.
 PMB (pulmonary embolus): a two-level factor With levels True And False.
 INT (intubation): a three-level factor With levels NORMAL, ESOPHAGEAL And ONESIDED.
 KINK (kinked tube): a two-level factor With levels True And False.
 DISC (disconnection): a two-level factor With levels True And False.
 LVV (left ventricular end-diastolic volume): a three-level factor With levels LOW, NORMAL And HIGH.
 STKV (stroke volume): a three-level factor With levels LOW, NORMAL And HIGH.
 CCHL (catecholamine): a two-level factor With levels NORMAL And HIGH.
 ERLO (error low output): a two-level factor With levels True And False.
 HR (heart rate): a three-level factor With levels LOW, NORMAL And HIGH.
 ERCA (electrocauter): a two-level factor With levels True And False.
 SHNT (shunt): a two-level factor With levels NORMAL And HIGH.
 PVS (pulmonary venous oxygen saturation): a three-level factor With levels LOW, NORMAL And HIGH.
 ACO2 (arterial CO2): a three-level factor With levels LOW, NORMAL And HIGH.
 VALV (pulmonary alveoli ventilation): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 VLNG (lung ventilation): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 VTUB (ventilation tube): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 VMCH (ventilation machine): a four-level factor With levels ZERO, LOW, NORMAL And HIGH.
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.declares.bnlearn.alarm.RScript">
 <summary>
 The ALARM ("A Logical Alarm Reduction Mechanism") is a Bayesian network designed to provide an alarm message system for patient monitoring.
 </summary>
 <returns></returns>
 <remarks>这个是一个数据集而非一个函数来的</remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.deSolve.API">
 <summary>
 Example:
 
 ```R
 ## =======================================================================
 ## Example2: Substrate-Producer-Consumer Lotka-Volterra model
 ## =======================================================================

 ## Note:
 ## Function sigimp passed as an argument (input) to model
 ##   (see also lsoda And rk examples)

 SPCmod &lt;- function(t, x, parms, input)  {
   With (as.list(c(parms, x)), {
     import &lt;- input(t)
     dS &lt;- import - b*S*P + g*C    # substrate
     dP &lt;- c*S*P  - d*C*P          # producer
     dC &lt;- e*P*C  - f*C            # consumer
     res &lt;- c(dS, dP, dC)
     list(res)
   })
 }

 ## The parameters 
 parms &lt;- c(b = 0.001, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

 ## vector of timesteps
 times &lt;- seq(0, 200, length = 101)

 ## external signal with rectangle impulse
 signal &lt;- data.frame(times = times, import = rep(0, length(times)))

 signal$import[signal$times >= 10 &amp; signal$times &lt;= 11] &lt;- 0.2
 sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)

 ## Start values for steady state
 xstart &lt;- c(S = 1, P = 1, C = 1)

 ## Solve model
 out &lt;- ode(y = xstart, times = times,
               func = SPCmod, parms = parms, input = sigimp)

 ## Default plot method
 plot(out)

 ## User specified plotting
 mf &lt;- par(mfrow = c(1, 2))
 matplot(out[,1], out[,2:4], type = "l", xlab = "time", ylab = "state")
 legend("topright", col = 1:3, lty = 1:3, legend = c("S", "P", "C"))
 plot(out[,"P"], out[,"C"], type = "l", lwd = 2, xlab = "producer",
      ylab = "consumer")
 par(mfrow = mf)
 ```
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.deSolve.API.ode(System.String,System.String,System.String,System.String,System.String,System.String[])">
 <summary>
 General Solver for Ordinary Differential Equations
 Solves a system of ordinary differential equations; a wrapper around the implemented ODE solvers
 </summary>
 <param name="y">the initial (state) values for the ODE system, a vector. If y has a name attribute, the names will be used to label the output matrix</param>
 <param name="times">time sequence for which output is wanted; the first value of times must be the initial time.</param>
 <param name="func">either an R-function that computes the values of the derivatives in the ODE system (the model definition) at time t, or a character string giving the name of a compiled function in a dynamically loaded shared library.
 If func Is an R-Function, it must be defined As: func &lt;- function(t, y, parms,...). t Is the current time point in the integration, y Is the current estimate of the variables in the ODE system. If the initial values y has a names attribute, the names will be available inside func. parms Is a vector Or list of parameters; ... (optional) are any other arguments passed to the function.
 The return value of func should be a list, whose first element Is a vector containing the derivatives of y with respect to time, And whose next elements are global values that are required at each point in times. The derivatives must be specified in the same order as the state variables y.
 If func Is a String, Then dllname must give the name Of the Shared library (without extension) which must be loaded before ode Is called. See package vignette "compiledCode" For more details.</param>
 <param name="parms">parameters passed to func.</param>
 <param name="method">the integrator to use, either a function that performs integration, or a list of class rkMethod, or a string ("lsoda", "lsode", "lsodes","lsodar","vode", "daspk", "euler", "rk4", "ode23", "ode45", "radau", "bdf", "bdf_d", "adams", "impAdams" or "impAdams_d" ,"iteration"). Options "bdf", "bdf_d", "adams", "impAdams" or "impAdams_d" are the backward differentiation formula, the BDF with diagonal representation of the Jacobian, the (explicit) Adams and the implicit Adams method, and the implicit Adams method with diagonal representation of the Jacobian respectively (see details). The default integrator used is lsoda.
 Method "iteration" Is special in that here the function func should return the New value of the state variables rather than the rate of change. This can be used for individual based models, for difference equations, Or in those cases where the integration Is performed within func). See last example.</param>
 <param name="additionals">additional arguments passed to the integrator or to the methods.</param>
 <returns>
 A matrix of class deSolve with up to as many rows as elements in times and as many columns as elements in y plus the number of "global" values 
 returned in the second element of the return from func, plus an additional column (the first) for the time value. There will be one row for each 
 element in times unless the integrator returns with an unrecoverable error. If y has a names attribute, it will be used to label the columns of 
 the output value.</returns>
 <remarks>
 This is simply a wrapper around the various ode solvers.
 See package vignette For information about specifying the model In compiled code.
 See the selected integrator For the additional options.
 The Default integrator used Is lsoda.
 The option method = "bdf" provdes a handle to the backward differentiation formula (it Is equal to using method = "lsode"). It Is best suited to solve stiff (systems of) equations.
 The option method = "bdf_d" selects the backward differentiation formula that uses Jacobi-Newton iteration (neglecting the off-diagonal elements of the Jacobian (it Is equal to using method = "lsode", mf = 23). It Is best suited to solve stiff (systems of) equations.
 method = "adams" triggers the Adams method that uses functional iteration (no Jacobian used); (equal to method = "lsode", mf = 10. It Is often the best choice for solving non-stiff (systems of) equations. Note when functional iteration Is used, the method Is often said to be explicit, although it Is in fact implicit.
 method = "impAdams" selects the implicit Adams method that uses Newton- Raphson iteration (equal to method = "lsode", mf = 12.
 method = "impAdams_d" selects the implicit Adams method that uses Jacobi- Newton iteration, i.e. neglecting all off-diagonal elements (equal to method = "lsode", mf = 13.
 For very stiff systems, method = "daspk" may outperform method = "bdf".
 
 ###### Example
 
 ```R
 a &lt;- -8/3 ; b &lt;- -10; c &lt;- 28
 yini &lt;- c(X = 1, Y = 1, Z = 1)
 Lorenz &lt;- function (t, y, parms) {
    with(as.list(y), {
       dX &lt;- a * X + Y * Z
       dY &lt;- b * (Y - Z)
       dZ &lt;- -X * Y + c * Y - Z
       list(c(dX, dY, dZ))
    })
 }
 times &lt;- seq(from = 0, to = 100, by = 0.01)
 out &lt;- ode(y = yini, times = times, func = Lorenz, parms = NULL)
 plot(out, lwd = 2)
 plot(out[,"X"], out[,"Y"], type = "l", xlab = "X",
      ylab = "Y", main = "butterfly")
 ```
 </remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.genetics.API.genotype(System.String,System.String,System.String,System.String,System.Boolean,System.String,System.Boolean,System.String,System.String)">
 <summary>
 ``genotype`` creates a genotype object.
 </summary>
 <param name="a1">vector(s) or matrix containing two alleles for each individual. See details, below</param>
 <param name="a2">vector(s) or matrix containing two alleles for each individual. See details, below</param>
 <param name="alleles">names (and order if reorder="yes") of possible alleles</param>
 <param name="sep">character separator or column number used to divide alleles when a1 is a vector of strings where each string holds both alleles. See below for details</param>
 <param name="removeSpaces">logical indicating whether spaces and tabs will be removed from a1 and a2 before processing</param>
 <param name="reorder">how should alleles within an individual be reordered. If reorder="no", use the order specified by the alleles parameter. If reorder="freq" or reorder="yes", sort alleles within each individual by observed frequency. If reorder="ascii", reorder alleles in ASCII order (alphabetical, with all upper case before lower case). The default value for genotype is "freq". The default value for haplotype is "no".</param>
 <param name="allowPartialmissing">logical indicating whether one allele is permitted to be missing. When set to FALSE both alleles are set to NA when either is missing.</param>
 <param name="locus">object of class locus, gene, or marker, holding information about the source of this genotype.</param>
 <param name="genotypeOrder">character, vector of genotype/haplotype names so that further functions can sort genotypes/haplotypes in wanted order</param>
 <returns>
 The genotype class extends "factor" and haplotype extends genotype. Both classes have the following attributes:
 
 + levels	
     character vector Of possible genotype/haplotype values stored coded by paste( allele1, "/", allele2, sep="").
 + allele.names	
     character vector Of possible alleles. For a SNP, these might be c("A","T"). For a variable length dinucleotyde repeat this might be c("136","138","140","148").
 + allele.map	
     matrix encoding how the factor levels correspond To alleles. See the source code To allele.genotype() For how To extract allele values Using this matrix. Better yet, just use allele.genotype().
 + genotypeOrder	
     character, genotype/haplotype names in defined order that can used for sorting in various functions. Note that this slot stores both ordered And unordered genotypes i.e. "A/B" And "B/A".
 </returns>
 <remarks>
 Genotype objects hold information on which gene or marker alleles were observed for different individuals. For each individual, two alleles are recorded.
 The genotype Class considers the stored alleles To be unordered, i.e., "C/T" Is equivalent To "T/C". The haplotype Class considers the order Of the alleles To be significant so that "C/T" Is distinct from "T/C".
 When calling genotype Or haplotype
 If only a1 Is provided And Is a character vector, it Is assumed that Each element encodes both alleles. In this Case, If sep Is a character String, a1 Is assumed To be coded As ``Allele1&lt;sep>Allele2``. 
 If sep Is a numeric value, it Is assumed that character locations 1:sep contain allele 1 And that remaining locations contain allele 2.
 If a1 Is a matrix, it Is assumed that column 1 contains allele 1 And column 2 contains allele 2.
 If a1 And a2 are both provided, Each Is assumed To contain one allele value so that the genotype For an individual Is obtained by paste(a1,a2,sep="/").
 If remove.spaces Is True, (the Default) any whitespace contained In a1 And a2 Is removed When the genotypes are created. If whitespace Is used As the separator, (eg "C C", "C T", ...), be sure To Set remove.spaces To False.
 When the alleles are explicitly specified using the alleles argument, all potential alleles Not present in the list will be converted to NA.
 NOTE: genotype assumes that the order Of the alleles Is Not important (E.G., "A/C" == "C/A"). Use Class haplotype If order Is significant.
 If genotypeOrder = NULL(the Default setting), Then expectedGenotypes Is used To Get standard sorting order. Only unique values In genotypeOrder are used, which In turns means that the first occurrence prevails. When genotypeOrder Is given some genotype names, but Not all that appear In the data, the rest (those In the data And possible combinations based On allele variants) Is automatically added at the End Of genotypeOrder. This puts "missing" genotype names at the End Of sort order. This feature Is especially useful When there are a lot Of allele variants And especially In haplotypes. See examples.
 </remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.genetics.API.dataframe(Microsoft.VisualBasic.Data.csv.DocumentStream.File)">
 <summary>
 将``SNP``数据转换为``LDheatmap {LDheatmap}``绘图所需要的genotype数据
 </summary>
 <param name="df"></param>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.hierfstat.API.pairwise_fst(System.String,System.String,System.String)">
 <summary>
 Wrapper for fst estimator from hierfstat package (from adegenet)
 
 ```R
 pairwise.fst(x, pop = NULL, res.type = c("dist", "matrix"))
 ```
 
 The function fstat is a wrapper for varcomp.glob of the package hierfstat. For Fst, Fis and Fit, an alternative is offered by 
 Fst from the pagas package (see example).
 Let A And B be two populations of population sizes n_A And n_B, with expected heterozygosity (averaged over loci) Hs(A) And Hs(B), 
 respectively. We denote Ht the expected heterozygosity of a population pooling A And B. Then, the pairwise Fst between A And B 
 Is computed as
 
 ```
 Fst(A,B) = \frac{(Ht - (n_A Hs(A) + n_B Hs(B))/(n_A + n_B) )}{Ht} 
 ```
 </summary>
 <param name="x">an object of class genind.(其实在这里是R对象的变量名称)</param>
 <param name="pop">a factor giving the 'population' of each individual. If NULL, pop is seeked from pop(x). Note that the term population refers in fact to any grouping of individuals'.</param>
 <param name="resType">the type of result to be returned: a dist object, or a symmetric matrix</param>
 <returns>A vector, a matrix, or a dist object containing F statistics.</returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.LDheatmap.API.LDheatmap(System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Double,System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.String,System.Boolean,System.String@)">
 <summary>
 ``LDheatmap()`` is used to produce a graphical display, as a heat map, of pairwise linkage disequilibrium (LD) measurements for SNPs. 
 The heat map is a false color image in the upper-left diagonal of a square plot. Optionally, a line parallel to the diagonal of the 
 image indicating the physical or genetic map positions of the SNPs may be added, along with text reporting the total length of the 
 genomic region considered.
 </summary>
 <param name="gdat">SNP data: a data frame of genotype objects, a square matrix of pairwise linkage disequilibrium measurements or an object of class "LDheatmap" (the returned object of this function).</param>
 <param name="geneticDistances">A numeric vector of map locations of the SNPs, in the same order as SNPs listed in gdat, in terms of genetic or physical distances. Physical distances should be in bases, genetic distances should be in centiMorgans (cM). When gdat is not an object of class LDheatmap, the default is a vector that represents equi-spaced markers, 1kb (1000 bases) apart. When gdat is an object of class LDheatmap, the genetic.distances argument is taken to be the genetic.distances list item of gdat.</param>
 <param name="distances">A character string to specify whether the provided map locations are in physical or genetic distances. If distances="physical" (default), the text describing the total length of the region will be “Physical Length:XXkb” where XX is the length of the region in kilobases. If distances="genetic", the text will be “Genetic Map Length:YYcM” where YY is the length of the region in centiMorgans. If gdat is an object of class LDheatmap, distances is taken from gdat.</param>
 <param name="LDmeasure">A character string specifying the measure of LD - either allelic correlation r^2 or Lewontin's |D'|; default = "r" for r^2; type "D'" for |D'|. This argument is ignored when the user has already supplied calculated LD measurements through gdat (i.e., when gdat is a matrix of pairwise LD measurements or an object of class "LDheatmap").</param>
 <param name="title">A character string for the main title of the plot. Default is “Pairwise LD”.</param>
 <param name="addMap">If TRUE (default), a diagonal line indicating the physical or genetic map positions of the SNPs will be added to the plot, along with text indicating the total length of the genetic region.</param>
 <param name="addKey">If TRUE (default) the color legend is drawn.</param>
 <param name="geneMapLocation">A numeric value specifying the position of the line parallel to the diagonal of the matrix; the larger the value, the farther it lies from the matrix diagonal. Ignored when add.map=FALSE.</param>
 <param name="geneMapLabelX">A numeric value specifying the x-coordinate of the text indicating the total length of the genomic region being considered. Ignored when add.map=FALSE.</param>
 <param name="geneMapLabelY">A numeric value specifying the y-coordinate of the text indicating the total length of the genomic region being considered. Ignored when add.map=FALSE.</param>
 <param name="SNPname">A vector of character string(s) of SNP name(s) to be labelled. Should match the names of SNPs in the provided object gdat, otherwise nothing is done.</param>
 <param name="color">A range of colors to be used for drawing the heat map. Default is grey.colors(20).</param>
 <param name="newpage">If TRUE (default), the heat map will be drawn on a new page.</param>
 <param name="name">A character string specifying the name of the LDheatmap graphical object (grob) to be produced.</param>
 <param name="vpname">A character string specifying the name of the viewport where the heat map is going to be drawn.</param>
 <param name="pop">If TRUE, the viewport where the heat map is drawn is popped (i.e. removed) from the viewport tree after drawing. Default=FALSE.</param>
 <param name="flip">If TRUE, the LDheatmap plot is flipped below a horizontal line, in the style of Haploview. Default is FALSE.</param>
 <param name="text">If TRUE, the LD measurements are printed on each cell.</param>
 <returns>For gdat, any square matrix with values between 0 and 1 inclusive can be passed, and the values above the diagonal will be plotted. In the display of LD, SNPs appear in the order supplied by the user as the horizontal and vertical coordinates are increased and one moves along the off-diagonal line, from the bottom-left to the top-right corner. To achieve this, the conventions of the image() function have been adopted, in which horizontal coordinates correspond to the rows of the matrix and vertical coordinates correspond to columns, and vertical coordinates are indexed in increasing order from bottom to top.
 For the argument color, an appropriate color palette for quantitative data Is recommended, as outlined in the help page of the brewer.pal() function of the RColorBrewer package.
 See the package vignette LDheatmap For more examples And details Of the implementation. Examples Of adding “tracks” Of genomic annotation above a flipped heatmap are In the package vignette addTracks.
 </returns>
 <remarks>The produced heat map can be modified in two ways. First, it is possible to edit interactively the grob components of the heat map, by using the function grid.edit; the function will not work if there is no open graphical device showing the heat map. Alternatively, the user can use the function editGrob and work with the grob LDheatmapGrob returned by LDheatmap. See Examples for usage.
 LDheatmap() uses Grid, which does Not respond to par() settings. Hence modifying par() settings of mfrow And mfcol will Not work with LDheatmap(). The Examples section shows how to display multiple heat maps on one plot without the use of par().
 </remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.pheatmap.API">
 <summary>
 A function to draw clustered heatmaps.
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.pheatmap.API.pheatmap(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.String[])">
 <summary>
 A function to draw clustered heatmaps where one has better control over some graphical parameters such as cell size, etc. 
 </summary>
 <param name="mat">numeric matrix of the values to be plotted.</param>
 <param name="color">vector of colors used in heatmap.</param>
 <param name="kmeans_k">the number of kmeans clusters to make, if we want to agggregate the rows before drawing heatmap. If NA then the rows are not aggregated.</param>
 <param name="breaks">a sequence of numbers that covers the range of values in mat and is one element longer than color vector. Used for mapping values to colors. Useful, if needed to map certain values to certain colors, to certain values. If value is NA then the breaks are calculated automatically.</param>
 <param name="border_color">color of cell borders on heatmap, use NA if no border should be drawn.</param>
 <param name="cellwidth"></param>
 <param name="cellheight"></param>
 <param name="scale"></param>
 <param name="cluster_rows"></param>
 <param name="cluster_cols"></param>
 <param name="clustering_distance_rows"></param>
 <param name="clustering_distance_cols"></param>
 <param name="clustering_method"></param>
 <param name="clustering_callback"></param>
 <param name="cutree_rows"></param>
 <param name="cutree_cols"></param>
 <param name="treeheight_row"></param>
 <param name="treeheight_col"></param>
 <param name="legend"></param>
 <param name="legend_breaks"></param>
 <param name="legend_labels"></param>
 <param name="annotation_row"></param>
 <param name="annotation_col"></param>
 <param name="annotation"></param>
 <param name="annotation_colors"></param>
 <param name="annotation_legend"></param>
 <param name="annotation_names_row"></param>
 <param name="annotation_names_col"></param>
 <param name="drop_levels"></param>
 <param name="show_rownames"></param>
 <param name="show_colnames"></param>
 <param name="main"></param>
 <param name="fontsize"></param>
 <param name="fontsize_row"></param>
 <param name="fontsize_col"></param>
 <param name="display_numbers"></param>
 <param name="number_format"></param>
 <param name="number_color"></param>
 <param name="fontsize_number"></param>
 <param name="gaps_row"></param>
 <param name="gaps_col"></param>
 <param name="labels_row"></param>
 <param name="labels_col"></param>
 <param name="filename"></param>
 <param name="width"></param>
 <param name="height"></param>
 <param name="silent"></param>
 <param name="additionals">graphical parameters for the text used in plot. Parameters passed to grid.text, see gpar.</param>
 <returns>
 Invisibly a list of components 

 + tree_row the clustering of rows as hclust object 
 + tree_col the clustering of columns as hclust object 
 + kmeans the kmeans clustering of rows if parameter kmeans_k was specified 
 </returns>
 <remarks>
 The function also allows to aggregate the rows using kmeans clustering. 
 This is advisable if number of rows is so big that R cannot handle their 
 hierarchical clustering anymore, roughly more than 1000. Instead of 
 showing all the rows separately one can cluster the rows in advance and 
 show only the cluster centers. The number of clusters can be tuned with 
 parameter kmeans_k. 
 </remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.plot3D.plot3D">
 <summary>
 Plots arrows, segments, points, lines, polygons, rectangles and boxes in a 3D perspective plot or in 2D.
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.igraph.make_lattice">
 <summary>
 make_lattice is a flexible function, it can create lattices of arbitrary dimensions, periodic or unperiodic ones. It has two forms. 
 In the first form you only supply dimvector, but not length and dim. In the second form you omit dimvector and supply length and dim.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.dimvector">
 <summary>
 A vector giving the size of the lattice in each dimension.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.length">
 <summary>
 Integer constant, for regular lattices, the size of the lattice in each dimension.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.dim">
 <summary>
 Integer constant, the dimension of the lattice.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.nei">
 <summary>
 The distance within which (inclusive) the neighbors on the lattice will be connected. This parameter is not used right now.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.directed">
 <summary>
 Whether to create a directed lattice.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.mutual">
 <summary>
 Logical, if TRUE directed lattices will be mutually connected.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_lattice.circular">
 <summary>
 Logical, if TRUE the lattice or ring will be circular.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.igraph.lattice">
 <summary>
 Create a lattice graph
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.igraph.graph_from_edgelist">
 <summary>
 graph_from_edgelist creates a graph from an edge list. Its argument is a two-column matrix, each row defines one edge.
 If it is a numeric matrix then its elements are interpreted as vertex ids.
 If it is a character matrix then it is interpreted as symbolic vertex names and a vertex id will be assigned to each name, and also a name vertex attribute will be added.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.graph_from_edgelist.el">
 <summary>
 The edge list, a two column matrix, character or numeric.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.graph_from_edgelist.directed">
 <summary>
 Whether to create a directed graph.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.igraph.from_edgelist">
 <summary>
 Create a graph from an edge list matrix
 </summary>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.igraph.make_empty_graph">
 <summary>
 A graph with no edges
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_empty_graph.n">
 <summary>
 Number of vertices.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.igraph.make_empty_graph.directed">
 <summary>
 Whether to create a directed graph.
 </summary>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.polysat.API.BuilMatrix(System.Double[],System.String[])">
 <summary>
 Build a Csv File for the result of API <see cref="M:RDotNET.Extensions.Bioinformatics.polysat.API.calcFst(System.String,System.String,System.String)"/>
 </summary>
 <param name="list"></param>
 <param name="pops"></param>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.polysat.API.calcFst(System.String,System.String,System.String)">
 <summary>
 **Calculate Wright's Pairwise FST**
 
 Given a data frame of allele frequencies and population sizes, calcFst calculates a matrix of pairwise Fst values.
 calcFst works by calculating HS and HT for each locus for each pair of populations, then averaging HS and HT across loci. FST is then calculated for each pair of populations as (HT-HS)/HT.
 H values(expected heterozygosities for populations And combined populations) are calculated As one minus the sum Of all squared allele frequencies at a locus. To calculte HT, allele frequencies between two populations are averaged before the calculation. To calculate HS, H values are averaged after the calculation. In both cases, the averages are weighted by the relative sizes Of the two populations (As indicated by freqs$Genomes).
 </summary>
 <param name="freqs">A data frame of allele frequencies and population sizes such as that produced by simpleFreq or deSilvaFreq. Each population is in one row, and a column called Genomes contains the relative size of each population. All other columns contain allele frequencies. The names of these columns are the locus name and allele name, separated by a period.</param>
 <param name="pops">A character vector. Populations to analyze, which should be a subset of row.names(freqs).</param>
 <param name="loci">A character vector indicating which loci to analyze. These should be a subset of the locus names as used in the column names of freqs.</param>
 <returns>A square matrix containing FST values. The rows and columns of the matrix are both named by population.</returns>
 <remarks>
 ###### Examples
 
 ```R
 # create a data set (typically done by reading files)
 mygenotypes &lt;- New("genambig", samples = paste("ind", 16, sep=""), loci = c("loc1", "loc2"))
 Genotypes(mygenotypes, loci = "loc1") &lt;- list(c(206), c(208,210), c(204,206,210),
                                                  c(196,198,202,208), c(196,200), c(198,200,202,204))
 Genotypes(mygenotypes, loci = "loc2") &lt;- list(c(130,134), c(138,140), c(130,136,140),
                                                  c(138), c(136,140), c(130,132,136))
 PopInfo(mygenotypes)  &lt;- c(1,1,1,2,2,2)
 Ploidies(mygenotypes) &lt;- c(2,2,4,4,2,4)
 
 # calculate allele frequencies
 myfreq &lt;- simpleFreq(mygenotypes)
 
 myfreq
 
 #      Genomes loc1.196 loc1.198 loc1.200 loc1.202  loc1.204  loc1.206 loc1.208  loc1.210  loc2.130  loc2.132 loc2.134  loc2.136 loc2.138  loc2.140
 # Pop1       8      0.0      0.0      0.0      0.0 0.1666667 0.4166667    0.125 0.2916667 0.2916667 0.0000000    0.125 0.1666667    0.125 0.2916667
 # Pop2      10      0.2      0.2      0.2      0.2 0.1000000 0.0000000    0.100 0.0000000 0.1333333 0.1333333    0.000 0.2333333    0.400 0.1000000
 
 # calculate pairwise FST
 myfst &lt;- calcFst(myfreq)
 
 # examine the results
 myfst
 
 #            Pop1       Pop2
 # Pop1 0.00000000 0.08870835
 # Pop2 0.08870835 0.00000000
 ```
 </remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.polysat.API.myfreq">
 <summary>
 Example data for analysis API <see cref="M:RDotNET.Extensions.Bioinformatics.polysat.API.calcFst(System.String,System.String,System.String)"/>
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.sparcc.API">
 <summary>
 R package computes correlation for relative abundances
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.sparcc.API.#cctor">
 <summary>
 装载计算脚本
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.sparcc.API.sparcc(System.String,System.Int32,System.Double,System.Double)">
 <summary>
 count matrix x should be samples on the rows and OTUs on the colums,
 
 ```R
 assuming dim(x) -> samples by OTUs
 ```
 </summary>
 <param name="x">The data file path</param>
 <param name="maxIter"></param>
 <param name="th"></param>
 <param name="exiter"></param>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn">
 <summary>
Creates a Venn diagram with four sets.
 </summary>
 <remarks>
 The function defaults to placing the ellipses so that area1 corresponds to lower left,
 area2 corresponds to lower right, area3 corresponds to middle left and area4 corresponds
 to middle right. Refer to the example below to see how the 31 partial areas are ordered.
 Arguments with length of 15 (label.col, cex, fontface, fontfamily) will follow the order
 in the example.

 Value

 Returns an Object Of Class gList containing the grid objects that make up the diagram.
 Also displays the diagram In a graphical device unless specified With ind = False.
 Grid:grid.draw can be used to draw the gList object in a graphical device.
 </remarks>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.area1">
 <summary>
 The size of the first set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.area2">
 <summary>
 The size of the second set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.area3">
 <summary>
 The size of the third set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.area4">
 <summary>
 The size of the fourth set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n12">
 <summary>
 The size of the intersection between the first and the second set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n13">
 <summary>
 The size of the intersection between the first and the third set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n14">
 <summary>
 The size of the intersection between the first and the fourth set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n23">
 <summary>
 The size of the intersection between the second and the third set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n24">
 <summary>
 The size of the intersection between the second and the fourth set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n34">
 <summary>
 The size of the intersection between the third and the fourth set
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n123">
 <summary>
 The size of the intersection between the first, second and third sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n124">
 <summary>
 The size of the intersection between the first, second and fourth sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n134">
 <summary>
 The size of the intersection between the first, third and fourth sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n234">
 <summary>
 The size of the intersection between the second, third and fourth sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.n1234">
 <summary>
 The size of the intersection between all four sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.category">
 <summary>
 A vector (length 4) of strings giving the category names of the sets
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.lwd">
 <summary>
 A vector (length 4) of numbers giving the line width of the circles' circumferences
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.lty">
 <summary>
 A vector (length 4) giving the dash pattern of the circles' circumferences
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.col">
 <summary>
 A vector (length 4) giving the colours of the circles' circumferences
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.fill">
 <summary>
 A vector (length 4) giving the colours of the circles' areas
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.alpha">
 <summary>
 A vector (length 4) giving the alpha transparency of the circles' areas
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.labelCol">
 <summary>
 A vector (length 15) giving the colours of the areas' labels
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.cex">
 <summary>
 A vector (length 15) giving the size of the areas' labels
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.fontface">
 <summary>
 A vector (length 15) giving the fontface of the areas' labels
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.fontfamily">
 <summary>
 A vector (length 15) giving the fontfamily of the areas' labels
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catPos">
 <summary>
 A vector (length 4) giving the positions (in degrees) of the category names along the circles,
 with 0 (default) at 12 o'clock
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catDist">
 <summary>
 A vector (length 4) giving the distances (in npc units) of the category names from the edges
 of the circles (can be negative)
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catCol">
 <summary>
 A vector (length 4) giving the size of the category names
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catCex">
 <summary>
 A vector (length 4) giving the colours of the category names
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catFontface">
 <summary>
 A vector (length 4) giving the fontface of the category names
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catFontfamily">
 <summary>
 A vector (length 4) giving the fontfamily of the category names
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.catJust">
 <summary>
 List of 4 vectors of length 2 indicating horizontal and vertical justification of each category name
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.rotationDegree">
 <summary>
 Number of degrees to rotate the entire diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.rotationCentre">
 <summary>
 A vector (length 2) indicating (x,y) of the rotation centre
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.ind">
 <summary>
 Boolean indicating whether the function is to automatically draw the diagram before returning
 the gList object or not
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.cexProp">
 <summary>
 A function or string used to rescale areas
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.printMode">
 <summary>
 Can be either 'raw' or 'percent'. This is the format that the numbers will be printed in.
 Can pass in a vector with the second element being printed under the first
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.sigdigs">
 <summary>
 If one of the elements in print.mode is 'percent', then this is how many significant digits will be kept
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.directArea">
 <summary>
 If this is equal to true, then the vector passed into area.vector will be directly assigned
 to the areas of the corresponding regions. Only use this if you know which positions in the
 vector correspond to which regions in the diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.drawQuadVenn.areaVector">
 <summary>
 An argument to be used when direct.area is true. These are the areas of the corresponding
 regions in the Venn Diagram
 </summary>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.Extensions.ParseName(System.Collections.Generic.IEnumerable{System.String},System.Int32)">
 <summary>
 尝试着从一个字符串集合中猜测出可能的名称
 </summary>
 <param name="source">基因号列表</param>
 <returns>猜测出基因号的物种前缀，例如XC_1184 -> XC_</returns>
 <remarks></remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.RModelAPI.Generate(Microsoft.VisualBasic.Data.csv.DocumentStream.File)">
 <summary>
 从一个Excel逗号分割符文件之中生成一个文氏图的数据模型
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.RModelAPI.VectorMapper(System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.String[]})">
 <summary>
 从实际的对象映射到venn图里面的实体标记
 </summary>
 <returns>为了保证一一对应的映射关系，这个函数里面不再使用并行化拓展</returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.RModelAPI.VectorMapper``1(``0)">
 <summary>
 从实际的对象映射到venn图里面的实体标记
 </summary>
 <param name="entities">字符串矩阵</param>
 <returns>为了保证一一对应的映射关系，这个函数里面不再使用并行化拓展</returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.Partition">
 <summary>
 A partition in the venn diagram.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.Partition.Name">
 <summary>
 The name of this partition
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.Partition.Color">
 <summary>
 The color string of the partition
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.Partition.Vector">
 <summary>
 使用数字来表示成员的一个向量
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram">
 <summary>
 The data model of the venn diagram.(文氏图的数据模型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.plot">
 <summary>
 The venn.diagram plot API in R language
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.Title">
 <summary>
 The title of the diagram.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.saveTiff">
 <summary>
 vennDiagram tiff file saved path.(所生成的文氏图的保存文件名)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.partitions">
 <summary>
 Partitions on the venn diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.categoryNames">
 <summary>
 The partition names
 </summary>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.RandomColors">
 <summary>
 Assign random colors to the venn diagram partitions
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.op_Addition(RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram,System.Collections.Generic.IEnumerable{System.String[]})">
 <summary>
 Applying the diagram options
 </summary>
 <param name="venn"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.VennDiagram.ModelAPI.VennDiagram.__R_script">
 <summary>
 Convert the data model as the R script for venn diagram drawing.(将本数据模型对象转换为R脚本)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.makeTruthTable">
 <summary>
 Makes a truth table of the inputs.
 
 A data frame with length(x) logical vector columns and 2 ^ length(x) rows.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.makeTruthTable.x">
 <summary>
 A short vector.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.getVennPartitions">
 <summary>
 Partitions a list into Venn regions.
 
 If force.unique is FALSE, then there are two supported methods of grouping categories with duplicated elements in common. 
 If hierarchical is FALSE, then any common elements are gathered into a pool. So if x &lt;- list(a = c(1,1,2,2,3,3), b=c(1,2,3,4,4,5), c=c(1,4)) then (b intersect c)/(a) would contain three 4's. Since the 4's are pooled, (b)/(a union c) contains no 4's. 
 If hierachical is TRUE, then (b intersect c)/(a) would contain one 4.Then (b)/(a union c) cotains one 4.
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.getVennPartitions.x">
 <summary>
 A list of vectors.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.getVennPartitions.forceUnique">
 <summary>
 A logical value. Should only unique values be considered?
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.getVennPartitions.keepElements">
 <summary>
 A logical value. Should the elements in each region be returned?
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.getVennPartitions.hierarchical">
 <summary>
 A logical value. Changed the way overlapping elements are treated if force.unique is TRUE.
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot">
 <summary>
 This function takes a list and creates a publication-quality TIFF Venn Diagram
 </summary>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.x">
 <summary>
 A list of vectors (e.g., integers, chars), with each component corresponding to a separate circle in the Venn diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.filename">
 <summary>
 Filename for image output, Or if NULL returns the grid object itself
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.height">
 <summary>
 Integer giving the height Of the output figure In units
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.width">
 <summary>
 Integer giving the width of the output figure in units
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.resolution">
 <summary>
 Resolution of the final figure in DPI
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.imagetype">
 <summary>
 Specification of the image format (e.g. tiff, png or svg)
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.units">
 <summary>
 Size-units to use for the final figure
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.compression">
 <summary>
 What compression algorithm should be applied to the final tiff
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.na">
 <summary>
 Missing value handling method: "none", "stop", "remove"
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.main">
 <summary>
 Character giving the main title of the diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.sub">
 <summary>
 Character giving the subtitle of the diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainPos">
 <summary>
 Vector of length 2 indicating (x,y) of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainFontface">
 <summary>
 Character giving the fontface (font style) of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainFontfamily">
 <summary>
 Character giving the fontfamily (font type) of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainCol">
 <summary>
 Character giving the colour of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainCex">
 <summary>
 Number giving the cex (font size) of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.mainJust">
 <summary>
 Vector of length 2 indicating horizontal and vertical justification of the main title
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subPos">
 <summary>
 Vector of length 2 indicating (x,y) of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subFontface">
 <summary>
 Character giving the fontface (font style) of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subFontfamily">
 <summary>
 Character giving the fontfamily (font type) of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subCol">
 <summary>
 Character Colour of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subCex">
 <summary>
 Number giving the cex (font size) of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.subJust">
 <summary>
 Vector of length 2 indicating horizontal and vertical justification of the subtitle
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.categoryNames">
 <summary>
 Allow specification of category names using plotmath syntax
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.forceUnique">
 <summary>
 Logical specifying whether to use only unique elements in each item of the input list or use all elements. Defaults to FALSE
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.printMode">
 <summary>
 Can be either 'raw' or 'percent'. This is the format that the numbers will be printed in. Can pass in a vector with the second element being printed under the first
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.sigdigs">
 <summary>
 If one of the elements in print.mode is 'percent', then this is how many significant digits will be kept
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.directArea">
 <summary>
 If this is equal to true, then the vector passed into area.vector will be directly assigned to the areas of the corresponding regions. Only use this if you know which positions in the vector correspond to which regions in the diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.areaVector">
 <summary>
 An argument to be used when direct.area is true. These are the areas of the corresponding regions in the Venn Diagram
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.hyperTest">
 <summary>
 If there are only two categories in the venn diagram and total.population is not NULL, then perform the hypergeometric test and add it to the sub title.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.totalPopulation">
 <summary>
 An argument to be used when hyper.test is true. This is the total population size
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.VennDiagram.vennDiagramPlot.fill">
 <summary>
 The partition fill color
 </summary>
 <returns></returns>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.bnlearn.BnlearnInference">
 <summary>
 使用已经建立好的计算模型，利用bnlearn包进行推测
 </summary>
 <remarks></remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.bnlearn.BnlearnInference.__R_script">
 <summary>
 cpquery返回一个数值，以证据evidence为条件下事件event的条件概率
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.bnlearn.BnlearnModelling`1.createNetwork(`0[])">
 <summary>
 创建一个空网络，并构建好初始的网络结构
 </summary>
 <param name="NetworkData"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:RDotNET.Extensions.Bioinformatics.bnlearn.bnlearn">
 <summary>
 ```R
 require(bnlearn)
 ```
 </summary>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.bnlearn.ConditionalProbability.TryParse(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="strData"></param>
 <returns></returns>
 <remarks>  
 list(node = "B", parents = "A", children = "E", prob = c(0.855072463768116, 0.0257944422284271, 0.119133094003457, 0.44468791500664, 0.221181938911023, 0.334130146082337, 0.11535895382973, 0.0949426207632773, 0.789698425406992))
 </remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.bnlearn.NetworkParameters.#ctor(System.String)">
 <summary>
 贝叶斯网络对象的变量名
 </summary>
 <param name="ObjectName"></param>
 <remarks></remarks>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.bnlearn.NetworkParameters.GetNetworkParameters(System.Int32)">
 <summary>
 Get Bayesian network parameters
 </summary>
 <returns></returns>
 <remarks>
 </remarks>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.rowNameMaps">
 <summary>
 Column name of the row factor in the csv file that represents the row name. Default is the first column.
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.dataset">
 <summary>
 Csv文件的文件路径
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.image">
 <summary>
 tiff文件的输出路径
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.output">
 <summary>
 在执行完了脚本之后调用本方法才能够得到结果，否则返回空值
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.locusId">
 <summary>
 第一列所表示的基因号
 </summary>
 <returns></returns>
</member>
<member name="P:RDotNET.Extensions.Bioinformatics.Heatmap.samples">
 <summary>
 第一行所表示的样本编号
 </summary>
 <returns></returns>
</member>
<member name="M:RDotNET.Extensions.Bioinformatics.Heatmap.__R_script">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 http://joseph.yy.blog.163.com/blog/static/50973959201285102114376/
 </remarks>
</member>
</members>
</doc>
